<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <title>PBR demo</title>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <meta name="apple-mobile-web-app-capable" content="yes" />

  <!-- <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@200;400&display=swap" rel="stylesheet"> -->

  <script src="Stats.js"></script>

  <style>

    * {
      box-sizing: border-box;

      -webkit-touch-callout: none; /* iOS Safari */
        -webkit-user-select: none; /* Safari */
          -khtml-user-select: none; /* Konqueror HTML */
            -moz-user-select: none; /* Old versions of Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
                user-select: none; /* Non-prefixed version, currently
                                      supported by Chrome, Edge, Opera and Firefox */
    }

    :root {
      font-family: 'Oswald', sans-serif;
    }

    body {
      background: white;
      margin: 0;
      overflow: hidden;
    }

    .hidden {
      display: none !important;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
    }

    .pauseOverlay {
      position: absolute;
      inset: 0;
      backdrop-filter: blur(10px);
      pointer-events: none;
      z-index: 10;

      display: flex;
      justify-content: center;
      align-items: center;

      color: white;
    }

    .pauseOverlay .menu {
      display: flex;
      flex-direction: column;
      align-items: center;

      width: 200px;
    }

    .pauseOverlay .menu > button {
      width: 100%;
      pointer-events: all;
      outline: none;
      border: none;
      background: white;

      font-weight: bold;
      font-size: 1em;
      padding: 0.5em;

      margin-bottom: 10px;
    }

    .pauseOverlay .menu > button:focus {
      /* outline: 3px solid black; */
      background: darkgray;
    }
    .pauseOverlay .menu > button:active {
      /* outline: 3px solid black; */
      background: rgb(56, 142, 241);
      color: white;
    }

  </style>
</head>
<body>
  <div class="pauseOverlay hidden">
    <div class="menu">
      <h2>Paused</h2>
      <button>Settings</button>
      <button>Reset car</button>
      <button>Resume</button>
    </div>
  </div>

  <script src="./gameCanvas-5.0.js"></script>
  <script  type="module">

    import Renderer, { Scene, GameObject, Transform, Camera, FindMaterials } from "./engine/renderer.mjs";
    import OrbitCamera from "./engine/orbitCamera.mjs";
    import FlyCamera from "./engine/flyCamera.mjs";
    import Vector from "./engine/vector.mjs";
    import Matrix from "./engine/matrix.mjs";
    import Quaternion from "./engine/quaternion.mjs";
    import GLDebugger from "./engine/GLDebugger.mjs";
    import Terrain from "./engine/terrain.mjs";
    import { LerpCurve } from "./engine/curves.mjs";
    import { lerp, mapValue, clamp, loadImage, getImagePixelData } from "./engine/helper.mjs";
    import { getTriangleNormal } from "./engine/algebra.mjs";
    import Perlin from "./engine/perlin.mjs";
    import { NewMaterial } from "./engine/material.mjs";

    import * as roadSource from "./assets/shaders/custom/road.glsl.mjs";
    import { PhysicsEngine, MeshCollider, Rigidbody } from "./engine/physics.mjs";
    import { Car, Wing } from "./car.js";

    document.addEventListener("DOMContentLoaded", function () {
      var physicsEngine;

      var stats = new Stats();
      document.body.appendChild(stats.dom);

      var ui = new GameCanvas({publicMethods: false});
      ui.canvas.classList.add("ingameUICanvas");
      ui.canvas.style.zIndex = 2;

      var renderer;
      var scene;
      var camera;
      var snowCamera;

      var paused = false;

      var pauseOverlay = document.querySelector(".pauseOverlay");

      (async function() {
        renderer = new Renderer({
          renderScale: 1,
          debug: true,
          renderpipeline: 0
        });
        renderer.canvas.style.position = "fixed";

        scene = new Scene();
        scene.environmentIntensity = 1.5;
        scene.sunIntensity = Vector.fill(3);
        // scene.sunDirection = Vector.normalize(new Vector(-5, 2, -5));
        // scene.smoothSkybox = true;
        renderer.add(scene);

        await scene.loadEnvironment({
          // hdr: "./assets/hdri/wide_street_01_1k.hdr",
          hdrFolder: "./assets/hdri/snowy_field_1k",
          res: 512
        });

        window.Debug = new GLDebugger(scene);

        physicsEngine = new PhysicsEngine(scene, {
          octreeLevels: 5,
          multipleTimestepsPerFrame: false
        });

        var snowRenderTexture = new renderer.RenderTexture(512, 512, {
          clearFlags: renderer.gl.DEPTH_BUFFER_BIT,
        });
        snowCamera = new Camera({
          type: Camera.Type.Orthographic,
          renderTexture: snowRenderTexture,
          layer: 0b10,
          size: 50,
          near: 0.1,
          far: 100,
        });
        snowCamera.transform.matrix = Matrix.lookAt(new Vector(0, 40, 0), Vector.zero(), new Vector(0, 0, -1));

        // camera = new OrbitCamera(renderer, {near: 0.1, far: 5000, fov: 20});
        // camera.distance = 4;
        camera = new FlyCamera(renderer, {position: new Vector(0, 0, 5), near: 0.1, far: 10000, fov: 35});
        camera.sprintSpeed = 250;

        // camera = new Camera({near: 0.1, far: 100, fov: 35});
        // camera.transform.position = new Vector(0, 0, 7);

        // // var mapPath = "./assets/models/brickPlane.glb";
        // var colliderPath = "./assets/models/kajamanCollider.glb";
        // var mapPath = "./assets/models/kajaman.glb";

        // var map = await renderer.loadGLTF(mapPath);
        // map.transform.position.y -= 5;
        // // map.transform.rotation = Quaternion.euler(0, 0, 0.3);
        // // map.transform.scale = Vector.fill(20);
        // scene.add(renderer.BatchGameObject(map));

        // var collider = await renderer.loadGLTF(colliderPath, { loadMaterials: false, loadNormals: false, loadTangents: false });
        // collider.transform.set(map.transform);
        // physicsEngine.addMeshCollider(collider);
        // physicsEngine.setupMeshCollider();

        var roadProgram = new renderer.ProgramContainer(await renderer.createProgram(roadSource.webgl2.vertex, roadSource.webgl2.fragment));

        var car = new Car(scene, physicsEngine, {
          drivetrain: "RWD",
          torque: 800,
          gearChangeTime: 0.15,

          friction: 1.2,
          forwardFriction: 1,
          sidewaysFriction: 1.05,

          maxSteerAngle: 40,
          steerVelocity: 100,

          suspensionForce: 90_000,
          suspensionDamping: 3000,
          suspensionTravel: 0.1,
          rideHeightOffset: 0.08,

          controlScheme: Car.ControlScheme.Controller,
          activateAutoCountersteer: true,

          ABS: true,
          differential: Car.ENUMS.DIFFERENTIAL.LSD,

          wings: [
            new Wing(new Vector(0, 0.5, -2.3), 0.4),
            new Wing(new Vector(0, -0.4, 2.2), 0.42),
          ]
        });
        car.resetPosition = new Vector(0, 15, 0);
        await car.setup("./assets/models/aventador.glb");
        // await car.setup("./assets/models/ford_ranger_police.glb");
        // await car.setup("./assets/models/PH_orange.glb");
        // await car.setup("./assets/models/toyota_ae86.glb");
        // await car.setup("./assets/models/audi_rs6.glb");
        // await car.setup("./cargame/porsche.glb");


        
        // var car = new Car(scene, physicsEngine, {
        //   drivetrain: "RWD",
        //   friction: 1,
        //   forwardFriction: 1,
        //   sidewaysFriction: 1.05,
        //   maxSteerAngle: 40 * 1.2,
        //   torque: 400 * 2.5,

        //   suspensionForce: 90_000,
        //   suspensionDamping: 3000,
        //   suspensionTravel: 0.1,
        //   rideHeightOffset: 0.08,

        //   controlScheme: Car.ControlScheme.Controller,
        //   activateAutoCountersteer: true,

        //   ABS: false,
        //   differential: Car.ENUMS.DIFFERENTIAL.LSD,
        // });
        // await car.setup("./assets/models/volvov70.glb");
        // car.rb.COMOffset.y -= 0.2;
        // // await car.setup("./assets/models/toyota_ae86.glb");



        // var car = new Car(scene, physicsEngine, {
        //   mass: 1900,

        //   drivetrain: "RWD",
        //   differentialRatio: 7,

        //   friction: 1,//0.5,
        //   forwardFriction: 1,
        //   sidewaysFriction: 1,
        //   maxSteerAngle: 40,
        //   torque: 500,

        //   suspensionForce: 45_000,
        //   suspensionDamping: 4000,
        //   suspensionTravel: 0.3,
        //   rideHeightOffset: 0.3,
        //   antiRoll: 15_000,

        //   controlScheme: Car.ControlScheme.Controller,
        //   activateAutoCountersteer: true,

        //   ABS: true,
        // });
        // await car.setup("./assets/models/ford_ranger_police.glb");


        // car.camera.followDistance = 4
        // car.camera.followHeight = 0.25;//0.3;
        // car.camera.pitch = 0.1;

        // car.getWheel("fr").sidewaysFriction = 1.3;
        // car.getWheel("fl").sidewaysFriction = 1.3;

        // car.rb.COMOffset.z += 0.3;
        // car.rb.velocity.z = -30;
        
        car.wheels.map(w => {
          w.model.setLayer(0b10, true);
        });

        document.addEventListener("keydown", function(e) {
          if (e.keyCode == 27) {
            paused = !paused;
            handlePauseChange();
          }
        });

        document.addEventListener('visibilitychange', function() {
          paused = document.hidden;
          handlePauseChange();
        }, false);

        function handlePauseChange() {
          if (paused) {
            car.freeze();
            pauseOverlay.classList.remove("hidden");
            pauseOverlay.querySelectorAll("button")[0].focus();
          }
          else {
            car.unfreeze();
            pauseOverlay.classList.add("hidden");
          }
        }

        var terrain = new Terrain(scene);

        var maxHeight = 400;
        var imageRes = 1024;
        const imageData = getImagePixelData(await loadImage("./assets/textures/terrainHeightmap.png"), imageRes, imageRes);

        function getHeightFromImage(u, v) {
          u = clamp(u, 0, imageRes - 1);
          v = clamp(v, 0, imageRes - 1);

          var indexOffset = (u + v * imageRes) * 4;
          var remappedHeight = imageData[indexOffset + 0] + imageData[indexOffset + 1] / 255;
          var height = remappedHeight * maxHeight / 255;

          return height;
        }

        function bilinear(u, v, f) {
          var fu = Math.floor(u);
          var fv = Math.floor(v);

          var a = f(fu, fv);
          var b = f(fu + 1, fv);
          var c = f(fu, fv + 1);
          var d = f(fu + 1, fv + 1);

          var e = lerp(a, b, u % 1);
          var f = lerp(c, d, u % 1);
          var g = lerp(e, f, v % 1);

          return g;
        }

        terrain.getHeight = (i, j) => {
          var u = mapValue(i, -500, 500, 0, imageRes - 1);
          var v = mapValue(j, -500, 500, 0, imageRes - 1);

          return bilinear(u, v, getHeightFromImage);
        }

        terrain.chunkRes = 21//101;
        // terrain.chunkUpdatesPerFrame = 100;
        // terrain.quadtree.placeTransform(camera.camera.transform);
        await terrain.loadMaterials();
        // terrain.terrainMat.setUniform("maxHeight", 0.3);
        // terrain.terrainMat.setUniform("cameraSize", 50);
        // terrain.terrainMat.setUniform("heightmap", snowRenderTexture.colorTexture);

        initSnow();
        await initTrees();

        var controlPoints = JSON.parse('[{"x":238.9905803198908,"y":11.010891524613218,"z":0},{"x":248.35707929750777,"y":12.723226116925797,"z":180.44198024083917},{"x":86.43430472565373,"y":2.3016814664524694,"z":266.0174367013337},{"x":-68.42980023211553,"y":0.19100462446428695,"z":210.60526962657337},{"x":-291.0143147923255,"y":11.280076252913517,"z":211.43427595496414},{"x":-367.37847338756524,"y":44.89847560608845,"z":4.4990887150972286e-14},{"x":-244.37662920532279,"y":21.023621965313925,"z":-177.55001396826387},{"x":-88.49153796618087,"y":6.502505256081859,"z":-272.34894957783365},{"x":75.79755225098485,"y":0.26559658178005546,"z":-233.28087872103728},{"x":209.2681935881474,"y":11.838977337235947,"z":-152.04224240064795}]');
        var crCurve = new CatmullRomCurve(controlPoints, 0.5);
        initRoad(crCurve);

        var mainCamera = car.mainCamera;
        // var mainCamera = camera.camera;
        // var mainCamera = camera;

        renderer.on("renderloop", function(frameTime, totalTime) {
          camera.update?.(frameTime);

          // terrain.update(mainCamera.transform);
          terrain.update();
          

          physicsEngine.update();
          if (car) {
            car.update(frameTime);
          }

          scene.update(frameTime);
          renderer.render(mainCamera, [ snowCamera ]);

          ui.clearScreen();
          car.renderUI(ui);

          stats.update();
        });

        window.renderer = renderer;
        window.scene = scene;
        window.physicsEngine = physicsEngine;
        window.camera = camera;
        window.terrain = terrain;
        window.car = car;

        function generateTerrainHeightmap(imageRes = 256, maxHeight = 400) {
          var terrainBounds = 500;

          var controlPoints = [];
          for (var i = 0; i < Math.PI * 2; i += Math.PI * 2 / 10) {
            var r = 300 + (Math.random() - 0.5) * 200;

            var controlPoint = new Vector(
              r * Math.cos(i),
              0,
              r * Math.sin(i)
            );
            controlPoint.y = terrain.getHeightBeforeCurve(controlPoint.x, controlPoint.z);

            controlPoints.push(controlPoint);
          }

          var crCurve = new CatmullRomCurve(controlPoints, 0.5);

          var perlin = new Perlin();

          var canvas = document.createElement("canvas");
          canvas.width = canvas.height = imageRes;
          var ctx = canvas.getContext("2d");
          const imageData = ctx.createImageData(imageRes, imageRes);

          for (var u = 0; u < imageRes; u++) {
            for (var v = 0; v < imageRes; v++) {
              var x = mapValue(u, 0, imageRes - 1, -terrainBounds, terrainBounds);
              var z = mapValue(v, 0, imageRes - 1, -terrainBounds, terrainBounds);
              var height = getHeight(x, z);

              if (height < 0 || height > maxHeight) {
                console.warn("Height outside range!", height);
              }

              height = clamp(height, 0, maxHeight);

              var h = height / maxHeight * 255;
              var r = Math.floor(h);
              var g = (h % 1) * 255;

              var indexOffset = (u + v * imageRes) * 4;
              imageData.data[indexOffset + 0] = r;
              imageData.data[indexOffset + 1] = g;
              imageData.data[indexOffset + 2] = 0;
              imageData.data[indexOffset + 3] = 255;
            }
          }

          ctx.putImageData(imageData, 0, 0);
          return canvas;

          function LayeredNoise(x, y, octaves = 4) {
            var noise = 0;
            var frequency = 1;
            var factor = 1;

            var persistance = 0.4;
            var roughness = 3;

            for (var i = 0; i < octaves; i++) {
              noise += perlin.noise(x * frequency + i * 0.72354, y * frequency + i * 0.72354) * factor;
              factor *= persistance;
              frequency *= roughness;
            }

            return noise;
          }

          function getHeight(i, j) {
            var power = 1.5;
            var noiseLayers = 2;
            var noiseScale = 0.001;
            var height = 100;

            var heightFalloff = 1;//1 - clamp((Vector.length(new Vector(i, j)) - 400) * 0.005, 0, 1);
            var elevation = Math.pow(Math.abs(LayeredNoise(i * noiseScale, j * noiseScale, noiseLayers)), power) * height * heightFalloff;

            var w = 15;
            var d = crCurve.distanceSqrToPoint(new Vector(i, 0, j));
            if (!d.point) {
              console.log(d);
            }

            return lerp(d.point?.y ?? 0, elevation, clamp(
              (d.distance - w * w) / 2500,
              0, 1
            ));

            return elevation;
          }
        }

        function initRoad(crCurve) {
          var road = new GameObject("Road");
          road.transform.position.y = 0.22;
          var roadMaterial = renderer.CreateLitMaterial({
            albedo: [0.3, 0.3, 0.3, 1],
            albedoTexture: renderer.loadTexture("./assets/textures/asphalt_01_1k/asphalt_01_diff_1k.jpg", { ...renderer.getSRGBFormats() }),
            normalTexture: renderer.loadTexture("./assets/textures/asphalt_01_1k/asphalt_01_nor_gl_1k.png"),
          }, roadProgram);
          // roadMaterial.setUniform("albedo", [1, 1, 1, 1]);
          // roadMaterial.setUniform("albedoTexture", renderer.loadTexture("./assets/textures/checkerboard2.png"));

          var distanceAlongPath = 0;

          var indices = [];
          var vertices = [];
          var uvs = [];

          var width = 12;
          var step = 0.0005;
          for (var t = 0; t <= 1; t += step) {
            var center = crCurve.getPoint(t);

            var diff = Vector.subtract(
              crCurve.getPoint((t + step) % 1),
              center
            );
            var tangent = Vector.normalize(diff);

            var normal = Quaternion.QxV(Quaternion.angleAxis(Math.PI / 2, tangent), Vector.up());
            
            var edge = Vector.multiply(normal, width / 2);
            var margin = Vector.multiply(normal, width / 2 * 1.6);

            var e1 = Vector.add(center, edge);
            var m1 = Vector.add(center, margin);
            m1.y -= width * 0.1;
            var e2 = Vector.subtract(center, edge);
            var m2 = Vector.subtract(center, margin);
            m2.y -= width * 0.1;

            vertices.push(m1.x, m1.y, m1.z);
            vertices.push(e1.x, e1.y, e1.z);
            vertices.push(e1.x, e1.y, e1.z);
            vertices.push(e2.x, e2.y, e2.z);
            vertices.push(e2.x, e2.y, e2.z);
            vertices.push(m2.x, m2.y, m2.z);

            var v = distanceAlongPath / width;
            uvs.push(-0.5, v);
            uvs.push(0, v);
            uvs.push(0, v);
            uvs.push(1, v);
            uvs.push(1, v);
            uvs.push(3.5, v);

            distanceAlongPath += Vector.length(diff);
          }

          for (var i = 0; i < vertices.length / 3 * 3; i += 6) {
            var w = vertices.length / 3;
            indices.push(
              (i + 0) % w,
              (i + 6) % w,
              (i + 1) % w,

              (i + 1) % w,
              (i + 6) % w,
              (i + 7) % w,

              (i + 2) % w,
              (i + 8) % w,
              (i + 3) % w,

              (i + 3) % w,
              (i + 8) % w,
              (i + 9) % w,

              (i + 4) % w,
              (i + 10) % w,
              (i + 5) % w,

              (i + 5) % w,
              (i + 10) % w,
              (i + 11) % w,
            );
          }

          var roadMeshData = new renderer.MeshData({
            indices: {
              bufferData: new Uint32Array(indices),
              target: renderer.gl.ELEMENT_ARRAY_BUFFER
            },
            position: {
              bufferData: new Float32Array(vertices),
              size: 3
            },
            uv: {
              bufferData: new Float32Array(uvs),
              size: 2
            }
          });
          roadMeshData.recalculateNormals();
          roadMeshData.recalculateTangents();

          road.meshRenderer = new renderer.MeshRenderer(roadMaterial, roadMeshData);
          // road.addComponent(new MeshCollider());
          scene.add(road);

          physicsEngine.addMeshCollider(road);
          physicsEngine.setupMeshCollider();
        }

        async function initTrees() {
          var tree = scene.add(await renderer.loadGLTF("./assets/models/treePbr.glb"));
          tree.children[0].meshRenderer = tree.children[0].meshRenderer.getInstanceMeshRenderer();

          for (var i = 0; i < 100; i++) {
            var pos = new Vector((Math.random() - 0.5) * 100, 0, (Math.random() - 0.5) * 100);
            pos.y = terrain.getHeight(pos.x, pos.z);
            
            tree.children[0].meshRenderer.addInstance(Matrix.transform([
              ["translate", pos],
              ["scale", Vector.fill(0.8 + Math.random() * 0.4)],
              ["ry", Math.random() * Math.PI * 2]
            ]));
          }
        }

        function initSnow() {
          var snow = new GameObject("Snow");
          var snowParticles = new renderer.ParticleSystem(5000);
          
          var m = new NewMaterial(renderer.programContainers.particle);
          m.setUniform("albedoTexture", renderer.loadTexture("./assets/textures/snowParticle32x32.png"));
          snowParticles.material = m;

          snowParticles.alphaCurve = new LerpCurve();
          snowParticles.alphaCurve.addStage(0, 0);
          snowParticles.alphaCurve.addStage(0.15, 1);
          snowParticles.alphaCurve.addStage(0.9, 1);
          snowParticles.alphaCurve.addStage(1, 0);

          snowParticles.emitHealth = 9;
          snowParticles.orientation = "faceCamera";
          snowParticles.startSize = dst => Vector.fill(0.05 + Math.random() * 0.07, dst);

          snowParticles.emitPosition = dst => {
            return Vector.add(mainCamera.transform.position, new Vector((Math.random() - 0.5) * 50, 10, (Math.random() - 0.5) * 50), dst);
          }
          snowParticles.emitVelocity = dst => {
            return new Vector(0, -4, 0, dst);
          }

          snow.addComponent(snowParticles);
          scene.add(snow);

          setInterval(_ => {
            snowParticles.emit(5);
          }, 20);
        }


        function CatmullRomCurve(points, alpha = 0.5) {
          this.alpha = alpha;
          this.points = points;
          var segments = [];

          for (var i = 0; i < points.length; i++) {
            segments.push(new CatmullRomSegment(
              points[(i + 0) % points.length],
              points[(i + 1) % points.length],
              points[(i + 2) % points.length],
              points[(i + 3) % points.length],
              this.alpha
            ));
          }

          this.distanceToPoint = function(p) {
            var d = this.distanceSqrToPoint(p);
            return {
              distance: Math.sqrt(d.distance),
              point: d.point,
            };
          }

          this.distanceSqrToPoint = function(p) {
            var closestDistance = Infinity;
            var closestPoint;

            for (var segment of segments) {
              var d = segment.distanceSqrToPoint(p);
              if (d.distance < closestDistance) {
                closestDistance = d.distance;
                closestPoint = d.point;
              }
            }

            return {
              distance: closestDistance,
              point: closestPoint,
            };
          }

          this.getPoint = function(t) {
            var segment = Math.floor(t * segments.length);
            return segments[segment].getPoint((t * segments.length) % 1);
          }
        }

        function CatmullRomSegment(p0, p1, p2, p3, alpha = 0.5) {
          this.p0 = p0;
          this.p1 = p1;
          this.p2 = p2;
          this.p3 = p3;
          this.alpha = alpha;

          this.distanceToPoint = function(p) {
            var d = this.distanceSqrToPoint(p);
            return {
              distance: Math.sqrt(d.distance),
              point: d.point
            };
          }

          this.distanceSqrToPoint = function(p) {
            var closestDistance = Infinity;
            var closestPoint;

            var projP = Vector.copy(p);
            projP.y = 0;

            var d;
            var step = 0.5;
            var start = 0;
            var end = 1;
            while (step >= 0.005) {
              d = this._getClosestDistanceInRange(projP, start, end, step);
              start = d.t - step;
              end = d.t + step;
              step /= 2;
            }

            return {
              distance: d.distance,
              point: d.point,
              t: d.t,
            };
          }

          this._getClosestDistanceInRange = function(projP, start, end, step) {
            var closestDistance = Infinity;
            var closestPoint;
            var closestT;

            start = Math.max(0, start);
            end = Math.min(1, end);

            for (var t = start; t <= end; t += step) {
              var curvePoint = this.getPoint(t);

              var d = Vector.distanceSqr(projP, new Vector(curvePoint.x, 0, curvePoint.z));
              if (d < closestDistance) {
                closestDistance = d;
                closestPoint = curvePoint;
                closestT = t;
              }
            }

            return {
              distance: closestDistance,
              point: closestPoint,
              t: closestT,
            };
          }

          this.getPoint = function(t) {
            var k0 = 0;
            var k1 = GetKnotInterval(this.p0, this.p1);
            var k2 = GetKnotInterval(this.p1, this.p2) + k1;
            var k3 = GetKnotInterval(this.p2, this.p3) + k2;

            var u = lerp(k1, k2, t);
            var A1 = Remap(k0, k1, this.p0, this.p1, u);
            var A2 = Remap(k1, k2, this.p1, this.p2, u);
            var A3 = Remap(k2, k3, this.p2, this.p3, u);
            var B1 = Remap(k0, k2, A1, A2, u);
            var B2 = Remap(k1, k3, A2, A3, u);

            return Remap(k1, k2, B1, B2, u);
          }

          function Remap(a, b, c, d, u) {
            return Vector.lerp(c, d, (u - a) / (b - a));
          }

          function GetKnotInterval(a, b) {
            return Math.pow(Vector.distanceSqr(a, b), alpha / 2);
          }
        }

      })();
    });

  </script>
</body>
</html>