/*! For license information please see bundle.js.LICENSE.txt */
(()=>{"use strict";var e,t,n,r,i={220:(e,t,n)=>{n.a(e,(async(e,t)=>{try{var r=n(744),i=n(582),o=n(973),a=n(367),s=n(472);const e=new i.ZP({renderpipeline:0,path:"./"}),l=window.scene=e.add(new i.xs);await l.loadEnvironment({hdrFolder:"./assets/hdri/kloofendal_48d_partly_cloudy_puresky_1k_precomputed"});const c=new o.Z(e,{fov:30,near:.1,far:1e3});c.rotation=new a.Z(-.6,0,0);const u=c.camera,h=new e.CustomProgram(r),f=await e.loadTextureAsync("./perlin.png"),d=()=>{x.length=0;for(let t=g.shells-1;t>=0;t--){const n=l.add(e.CreatePlane());n.transform.scale=a.Z.fill(g.area);const r=n.meshRenderer.materials[0];r.programContainer=h,r.doubleSided=!0,x[t]=n}v()},m=()=>{for(let e=0;e<x.length;e++)x[e].delete();d()},v=()=>{for(let e=0;e<x.length;e++){const t=x[e].meshRenderer.materials[0];t.setUniform("height",g.height/g.area),t.setUniform("heightBias",g.heightBias),t.setUniform("shells",g.shells),t.setUniform("shellIndex",e),t.setUniform("baseColor",g.baseColor),t.setUniform("density",g.density*g.area),t.setUniform("simplexNoiseTexture",g.simplexNoiseTexture),t.setUniform("swayStrength",g.swayStrength),t.setUniform("swayDensity",g.swayDensity*g.area),t.setUniform("windSpeed",g.windSpeed),t.setUniform("thickness",g.thickness)}},p=()=>{for(let e=0;e<x.length;e++)x[e].transform.scale=a.Z.fill(g.area);v()},g={area:2,shells:64,height:1,heightBias:.3,baseColor:[.1,1,.25,1],density:30,thickness:2.5,simplexNoiseTexture:f,swayStrength:10,swayDensity:.1,windSpeed:.015},x=[],b=new s.ZP;b.add(g,"area",1,100).onChange(p),b.add(g,"shells",4,256,1).onChange(m),b.add(g,"height",0,3).onChange(v),b.add(g,"heightBias",.01,1).onChange(v),b.addColor(g,"baseColor").onChange(v),b.add(g,"density",1,100).onChange(v),b.add(g,"thickness",0,10).onChange(v),b.add(g,"swayStrength",0,50).onChange(v),b.add(g,"swayDensity",0,1).onChange(v),b.add(g,"windSpeed",0,.1).onChange(v),d(),e.on("renderloop",(t=>{e.update(t),e.render(u)})),t()}catch(e){t(e)}}),1)},283:(e,t,n)=>{n.d(t,{AO:()=>r,XS:()=>o,tM:()=>i});var r="\n#version 300 es\nprecision highp float;\nprecision mediump int;\n",i="\n#version 300 es\n\nin vec2 position;\n\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n",o="\nuniform float environmentMinLight;\n\n// const int levels = 2;\n\n// vec4 projectedTexcoords[levels];\n// uniform float biases[levels];\n// uniform sampler2D projectedTextures[levels];\n// uniform mat4 textureMatrices[levels];\n\nuniform int shadowQuality;\nconst bool blurShadows = true;\nconst int shadowSamples = 8 * 2;\nconst float shadowSampleRadius = 3.;\n\nfloat shadowDarkness = 0.;\nconst float shadowKernalSize = 2.;\n// mat3 shadowKernel = mat3(\n//   1, 2, 1,\n//   2, 4, 2,\n//   1, 2, 1\n// );\nvec2 poissonDisk[16] = vec2[]( \n  vec2( -0.94201624, -0.39906216 ), \n  vec2( 0.94558609, -0.76890725 ), \n  vec2( -0.094184101, -0.92938870 ), \n  vec2( 0.34495938, 0.29387760 ), \n  vec2( -0.91588581, 0.45771432 ), \n  vec2( -0.81544232, -0.87912464 ), \n  vec2( -0.38277543, 0.27676845 ), \n  vec2( 0.97484398, 0.75648379 ), \n  vec2( 0.44323325, -0.97511554 ), \n  vec2( 0.53742981, -0.47373420 ), \n  vec2( -0.26496911, -0.41893023 ), \n  vec2( 0.79197514, 0.19090188 ), \n  vec2( -0.24188840, 0.99706507 ), \n  vec2( -0.81409955, 0.91437590 ), \n  vec2( 0.19984126, 0.78641367 ), \n  vec2( 0.14383161, -0.14100790 ) \n);\n\nbool inRange(vec3 projCoord) {\n  return projCoord.x >= 0.0 &&\n         projCoord.x <= 1.0 &&\n         projCoord.y >= 0.0 &&\n         projCoord.y <= 1.0 &&\n         projCoord.z <  1.0;\n}\n\nfloat fadeOutShadow(float visibility, vec3 proj) {\n  return mix(visibility, 1., clamp(pow(length(proj.xy - vec2(0.5, 0.5)) * 2., 5.), 0., 1.));\n}\n\nfloat fadeToNextShadowMap(float v1, float v2, vec3 proj) {\n  return mix(v1, v2, clamp(pow(length(proj.xy - vec2(0.5, 0.5)) * 2., 30.), 0., 1.));\n}\n\n// float random(vec3 seed, int i){\n//   vec4 seed4 = vec4(seed,i);\n//   float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));\n//   return fract(sin(dot_product) * 43758.5453);\n// }\n\nvec2 hash( vec2 p ) { // replace this by something better\n  p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n  return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat getBias(float bias, float cosTheta) {\n  bias = -bias * (cosTheta > 0. ? 1. : 0.);\n  bias = bias * tan(acos(cosTheta));\n  bias = clamp(bias, 0.0, 0.1);\n\n  return bias;\n}\n\nfloat getShadowAmount(vec3 worldPosition, float cosTheta) {\n  // for (int i = 0; i < levels; i++) {\n  //   projectedTexcoords[i] = textureMatrices[i] * vec4(worldPosition, 1);\n  // }\n\n  if (shadowQuality == 0) {\n    return 1.;\n  }\n\n  if (shadowQuality == 1) {\n    vec3 proj = projectedTexcoords[0].xyz / projectedTexcoords[0].w;\n    bool inside = inRange(proj);\n    \n    if (inside) {\n      // float bias = 0.005*tan(acos(cosTheta)); // cosTheta is dot( n,l ), clamped between 0 and 1\n      // bias = clamp(bias, 0.0, 0.01);\n\n      float projectedDepth = texture(projectedTextures[0], proj.xy).r;\n      float currentDepth = proj.z + biases[0];\n      return (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n    }\n    \n    proj = projectedTexcoords[1].xyz / projectedTexcoords[1].w;\n    inside = inRange(proj);\n\n    if (inside) {\n      float currentDepth = proj.z + biases[1];\n      float projectedDepth = texture(projectedTextures[1], proj.xy).r;\n      return (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n    }\n\n    return 1.;\n  }\n\n  vec2 shadowStepSize = vec2(1) / vec2(textureSize(projectedTextures[0], 0));\n\n  if (shadowQuality >= 2) {\n    vec4 ShadowCoord = projectedTexcoords[0];\n    vec3 proj = ShadowCoord.xyz / ShadowCoord.w;\n\n    float bias = -biases[0];//getBias(biases[0], cosTheta);\n\n    float currentDepth = proj.z - bias;\n    bool inside = inRange(proj);\n\n    if (inside) {\n      float outShadow = 0.;\n\n      if (blurShadows) {\n        float visibility = 1.;\n        for (int i = 0; i < shadowSamples; i++) {\n          // int index = int(16.0*random(gl_FragCoord.xyy + float(i) * vec3(1, 0.4, -0.5), i))%16;\n          // int index = int(16.0*random(floor(worldPosition.xyz*500.0), i))%16;\n          \n          // if (texture(projectedTextures[0], proj.xy + poissonDisk[index] * shadowStepSize * 4.).r < currentDepth) {\n          //   visibility -= 1. / 64.;\n          // }\n\n          if (texture(projectedTextures[0], proj.xy + hash(worldPosition.xz + worldPosition.zy + float(i) * vec2(1, -.9)) * shadowStepSize * shadowSampleRadius).r < currentDepth) {\n            visibility -= 1. / float(shadowSamples);\n          }\n\n          // visibility -= 0.01*(1.0-textureProj(projectedTextures[0], vec3(ShadowCoord.xy + poissonDisk[index]/700.0, (ShadowCoord.z-bias * 3.) / ShadowCoord.w)).r);\n        }\n\n        outShadow =  visibility;\n      }\n      else {\n        float sum = 0.0;\n        for (float j = -shadowKernalSize / 2. + 0.5; j <= shadowKernalSize / 2. - 0.5; j++) {\n          for (float k = -shadowKernalSize / 2. + 0.5; k <= shadowKernalSize / 2. - 0.5; k++) {\n            // float projectedDepth = texture(projectedTextures[0], proj.xy + shadowStepSize * hash(vec2(j, k) / 1000.)).r;\n            float projectedDepth = texture(projectedTextures[0], proj.xy + shadowStepSize * vec2(j, k)).r;\n\n            sum += 1. - step(projectedDepth, currentDepth);//(projectedDepth <= currentDepth ? shadowDarkness : 1.);// * shadowKernel[j + 1][k + 1];\n          }\n        }\n\n        outShadow = sum / float(shadowKernalSize * shadowKernalSize);\n      }\n\n      // bruh double calc\n      vec3 projNext = projectedTexcoords[1].xyz / projectedTexcoords[1].w;\n\n      float bias = getBias(biases[1], cosTheta);\n\n      float depthNext = projNext.z - bias;\n      float projectedDepthNext = texture(projectedTextures[1], projNext.xy).r;\n      float nextVis = (projectedDepthNext <= depthNext ? shadowDarkness : 1.);\n      return fadeToNextShadowMap(outShadow, nextVis, proj);\n    }\n\n    proj = projectedTexcoords[1].xyz / projectedTexcoords[1].w;\n    inside = inRange(proj);\n\n    if (inside) {\n      float bias = getBias(biases[1], cosTheta);\n      currentDepth = proj.z - bias;\n      \n      if (shadowQuality == 2) {\n        float projectedDepth = texture(projectedTextures[1], proj.xy).r;\n        return fadeOutShadow((projectedDepth <= currentDepth ? shadowDarkness : 1.), proj);\n      }\n\n      if (shadowQuality == 3) {\n        float sum = 0.0;\n        for (float j = -shadowKernalSize / 2. + 0.5; j <= shadowKernalSize / 2. - 0.5; j++) {\n          for (float k = -shadowKernalSize / 2. + 0.5; k <= shadowKernalSize / 2. - 0.5; k++) {\n            float projectedDepth = texture(projectedTextures[1], proj.xy + shadowStepSize * vec2(j, k)).r;\n            sum += (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n          }\n        }\n\n        return fadeOutShadow(sum / 16., proj);\n      }\n    }\n\n    return 1.;\n  }\n\n  return 1.;\n}\n"},453:(e,t,n)=>{n.r(t),n.d(t,{fogBase:()=>l,litAttributesAndUniforms:()=>a,litBase:()=>s,motionBlurMain:()=>c,shaderBase:()=>o,trimStrings:()=>i,webgl1:()=>w,webgl2:()=>y});var r=n(283);function i(e){for(var t in e){var n=e[t];"object"==typeof n?i(n):"string"==typeof n&&(e[t]=e[t].trim())}}var o="\n#version 300 es\nprecision highp float;\nprecision mediump int;\n",a="\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\n// Attributes\nin vec3 vPosition;\nin vec3 vNormal;\nin vec4 vTangent; // in vec3 vTangent;\nin vec3 vColor;\nin vec2 vUV;\nin mat3 vTBN;\n\n// Motion blur\nin vec4 clipSpace;\nin vec4 prevClipSpace;\n//#in\n\n// Material properties\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform sampler2D normalTexture;\nuniform bool useNormalTexture;\nuniform sampler2D metallicRoughnessTexture;\nuniform bool useMetallicRoughnessTexture;\nuniform sampler2D emissiveTexture;\nuniform bool useEmissiveTexture;\nuniform sampler2D occlusionTexture;\nuniform bool useOcclusionTexture;\n\nuniform vec4 albedo;\nuniform bool useVertexColor;\nuniform float metallic;\nuniform float roughness;\nuniform vec3 emissiveFactor;\nfloat ao = 1.;\nuniform bool opaque;\nuniform float alphaCutoff;\nuniform float normalStrength;\nuniform bool doNoTiling;\n\n// bruh make shared uniform into uniform block\n// Light info\nstruct LightInfo {\n  int type;\n  vec3 position;\n  vec3 direction;\n  float angle;\n  vec3 color;\n};\nconst int maxLights = 16;\nuniform LightInfo lights[maxLights];\nuniform int nrLights;\nuniform vec3 sunDirection;\nuniform vec3 sunIntensity;\n\n// Environment\nuniform vec3 ambientColor;\nuniform float environmentIntensity;\nuniform samplerCube u_diffuseIBL;\nuniform samplerCube u_specularIBL;\nuniform sampler2D u_splitSum;\n\n// Shadows\nconst int levels = 2;\nin vec4 projectedTexcoords[levels];\n// uniform float biases[levels];\nuniform sampler2D projectedTextures[levels];\n\n// uniform mat4 inverseViewMatrix;\nuniform mat4 modelMatrix;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n",s=`\nconst float PI = 3.141592;\n\n// No tiling\nvec4 hash4( vec2 p ) {\n  return fract(sin(vec4(1.0+dot(p,vec2(37.0,17.0)), \n                        2.0+dot(p,vec2(11.0,47.0)),\n                        3.0+dot(p,vec2(41.0,29.0)),\n                        4.0+dot(p,vec2(23.0,31.0))))*103.0);\n}\n\nvec3 textureNoTile( sampler2D samp, in vec2 uv, float v ) {\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n\t\n    // derivatives (for correct mipmapping)\n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n    \n\tvec3 va = vec3(0.0);\n\tfloat w1 = 0.0;\n    float w2 = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec4 o = hash4( p + g );\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n        float w = exp(-5.0*d );\n        vec3 c = textureGrad( samp, uv + v*o.zw, ddx, ddy ).xyz;\n\t\tva += w*c;\n\t\tw1 += w;\n        w2 += w*w;\n    }\n    \n    // normal averaging --\x3e lowers contrasts\n    return va/w1;\n\n    // contrast preserving average\n    float mean = 0.3;// textureGrad( samp, uv, ddx*16.0, ddy*16.0 ).x;\n    vec3 res = mean + (va-w1*mean)/sqrt(w2);\n    return mix( va/w1, res, v );\n}\n\nvec2 noiseHash( vec2 p ) { // replace this by something better\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n  const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n  const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n  vec2  a = p - i + (i.x+i.y)*K2;\n  float m = step(a.y,a.x); \n  vec2  o = vec2(m,1.0-m);\n  vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n  vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,noiseHash(i+0.0)), dot(b,noiseHash(i+o)), dot(c,noiseHash(i+1.0)));\n  return (dot( n, vec3(70.0) ) + 1.) / 2.;\n}\n\nconst int OCTAVES = 4;\nfloat LayeredNoise(vec2 p) {\n  float _noise = 0.;\n  float frequency = 1.;\n  float factor = 1.;\n\n  float persistance = 0.45;\n  float roughness = 3.;\n\n  for (int i = 0; i < OCTAVES; i++) {\n    _noise += noise(p * frequency + float(i) * 0.72354) * factor;\n    factor *= persistance;\n    frequency *= roughness;\n  }\n\n  return _noise;\n}\n\n// Texture sampling\nvec4 sampleTexture(sampler2D samp, vec2 uv) {\n  if (doNoTiling) {\n    return vec4(textureNoTile(samp, uv, 1.), 1);\n  }\n  else {\n    return texture(samp, uv);\n  }\n}\n\n//Normal map\nvec3 setNormalStrength(vec3 normal, float strength) {\n  return vec3(normal.xy * strength, mix(1., normal.z, clamp(strength, 0., 1.)));\n}\n\n// vec3 sampleNormalTexture(sampler2D texture, vec2 uv) {\n//   return sampleTexture(texture, uv).rgb * 2. - 1.\n// }\n\n${r.XS}\n\n// PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  // return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0); // trying this\n  return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n} \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n  float a      = roughness*roughness;\n  float a2     = a*a;\n  float NdotH  = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH*NdotH;\n\n  float num   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n\n  return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r*r) / 8.0;\n\n  float num   = 1.;//NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 F0 = vec3(scalarF0);\n  F0 = mix(F0, albedo, metallic);\n  vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.), F0, roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - metallic;\t  \n    \n  vec3 irradiance = texture(u_diffuseIBL, N).rgb;\n  vec3 diffuse  = irradiance * albedo;\n    \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureLod(u_specularIBL, R, roughness * MAX_REFLECTION_LOD).rgb;\n\n  vec2 uv = vec2(max(dot(N, V), 0.), roughness);\n  uv.y = 1. - uv.y;\n  vec2 envBRDF = texture(u_splitSum, uv).rg;\n\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n  vec3 ambient = (kD * diffuse + specular) * environmentIntensity;\n\n  return ambient;\n}\n\nvec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 L = normalize(lightDir);  \n  vec3 H = normalize(V + L);\n\n  vec3 radiance = lightColor;\n  float NdotL = max(dot(N, L), 0.0);\n\n  vec3 F0 = vec3(scalarF0); \n  F0 = mix(F0, albedo, metallic);\n  vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n\n  // Specular\n  float NDF = DistributionGGX(N, H, roughness);\n  vec3 specular = vec3(0);\n\n  // if (dot(N, V) <= 0.01) {\n  //   float G2 = GeometrySchlickGGX(max(dot(N, L), 0.0), roughness);\n  //   float r1 = (roughness + 1.);\n  //   vec3 numerator = 2. * F * NDF * G2;\n  //   float denominator = max(dot(N, L), 0.0) * r1 * r1 + 0.001;\n  //   specular = numerator / denominator;\n  // }\n  // else {\n    float G = GeometrySmith(N, V, L, roughness);     \n    vec3 numerator = NDF * G * F;\n    // float denominator = 4.0 * max(dot(N, H), 0.0) * max(dot(N, L), 0.0) + 0.001; // incorrect (almost no highlights) but no back-facing normal artifacts\n    float denominator = 4.0;// * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;\n    specular = numerator / denominator;\n  // }\n\n  // Diffuse\n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n  kD *= 1.0 - metallic;\n\n  // Combine\n  vec3 finalColor = (kD * albedo / PI + specular) * radiance * NdotL;\n\n  return finalColor;\n}\n\nvec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0;// * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec3 Spotlight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 dir, float angle, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 currentDir = normalize(worldPos - lightPos);\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n\n  float sharpness = 5.;\n  attenuation *= clamp((dot(currentDir, dir) - cos(angle)) * sharpness, 0., 1.);\n\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0;// * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);\n\n  // if (dot(N, V) <= 0.01) {\n  //   float G2 = GeometrySchlickGGX(max(dot(N, L), 0.0), roughness);\n  //   float r1 = (roughness + 1.);\n  //   vec3 numerator = 2. * F * NDF * G2;\n  //   float denominator = max(dot(N, L), 0.0) * r1 * r1 + 0.001;\n  //   specular = numerator / denominator;\n  // }\n  \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec4 lit(vec4 _albedo, float _alphaCutoff, vec3 _emission, vec3 _tangentNormal, float _metallic, float _roughness, float _ao) {\n  _roughness = clamp(_roughness, 0.01, 0.99);\n  \n  if (_albedo.a <= _alphaCutoff) {\n    discard;\n  }\n\n  if (opaque) {\n    _albedo.a = 1.;\n  }\n\n  // vec3 N = normalize(mat3(modelMatrix) * vNormal);\n  vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n\n  vec3 N;\n  if (vTangent.xyz != vec3(0)) { //if (vTangent != vec3(0)) {\n    N = normalize(vTBN * _tangentNormal);\n  }\n  else {\n    N = normalize(mat3(modelMatrix) * vNormal);\n  }\n\n  if (!gl_FrontFacing) {\n    N *= -1.;\n  }\n\n  vec3 R = reflect(-V, N);\n\n  vec3 L = normalize(sunDirection.xyz);\n  vec3 H = normalize(V + L);\n\n  // return vec4(vec3(dot(N, V) < 0. ? 1. : 0.), 1);\n  // return vec4(vec3(dot(N, H) < 0. ? 1. : 0.), 1);\n  // return vec4(vec3(dot(N, L) < 0. ? 1. : 0.), 1);\n  // return vec4(vec3(dot(H, V) < 0. ? 1. : 0.), 1);\n\n  float f0 = 0.04;\n\n  float shadowAmount = getShadowAmount(vPosition, dot(sunDirection.xyz, N));\n  // float environmentMinLight = 0.25;\n\n  vec3 col = vec3(0);\n\n  // Ambient\n  col += ambientColor;\n\n  // Environment\n  col += IBL(N, V, R, _albedo.rgb, _metallic, _roughness, f0) * _ao * (environmentMinLight + shadowAmount * (1. - environmentMinLight));\n  \n  // Directional sun light\n  if (sunIntensity.xyz != vec3(0)) {\n    col += DirectionalLight(vPosition, N, V, sunDirection.xyz, sunIntensity.xyz, _albedo.rgb, _metallic, _roughness, f0) * _ao * shadowAmount;\n  }\n\n  // Lights\n  for (int i = 0; i < int(nrLights); i++) {\n    LightInfo light = lights[i];\n    if (light.type == 0) {\n      col += PositionalLight(vPosition, N, V, light.position, light.color, _albedo.rgb, _metallic, _roughness, f0);\n    }\n    else if (light.type == 1) {\n      col += Spotlight(vPosition, N, V, light.position, light.direction, light.angle, light.color, _albedo.rgb, _metallic, _roughness, f0);\n    }\n    else if (light.type == 2) {\n      col += DirectionalLight(vPosition, N, V, light.direction, light.color, _albedo.rgb, _metallic, _roughness, f0);\n    }\n  }\n\n  // Emission\n  col += _emission;\n\n  return vec4(col, _albedo.a);\n}\n`,l="\n#define USEFOG\n\nuniform vec4 fogColor;// = vec4(0.23, 0.24, 0.26, 1);\nuniform float fogDensity;// = 0.0035;\n\nvec4 applyFog(vec4 color) {\n  float distance = length(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n  float fogAmount = exp(-pow(distance * fogDensity, 2.));\n  \n  return mix(fogColor, color, fogAmount);\n}\n",c="\nvec3 NDCPos = (clipSpace / clipSpace.w).xyz;\nvec3 PrevNDCPos = (prevClipSpace / prevClipSpace.w).xyz;\nmotionVector = (NDCPos - PrevNDCPos).xy * 0.5 + 0.5;\n",u="\n// Motion blur\nout vec4 clipSpace;\nout vec4 prevClipSpace;\nuniform mat4 prevViewMatrix;\nuniform mat4 prevModelMatrix;\n",h="\n// Motion blur\nvec4 prevCs = projectionMatrix * prevViewMatrix * prevModelMatrix * vec4(position, 1.0);\nprevClipSpace = prevCs;\nclipSpace = gl_Position;\n",f=`\n${o}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent; // in vec3 tangent;\nin vec3 color;\nin vec2 uv;\n//#in\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec4 vTangent; // out vec3 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\n//#out\n\nconst int levels = 2;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n// uniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n//Shadows\nuniform mat4 textureMatrices[levels];\nout vec4 projectedTexcoords[levels];\n\n${u}\n\nvoid main() {\n  //#main\n\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(vNormal, vTangent.xyz) * vTangent.w, 0.0))); // bruh According to comment on stackoverflow (https://blender.stackexchange.com/questions/220756/why-does-blender-output-vec4-tangents-for-gltf), tangents are vec4 and .w is used for bitangent sign (who could have known... :(\n  vec3 _N = normalize(vec3(modelMatrix * vec4(vNormal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  for (int i = 0; i < levels; i++) {\n    projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  }\n\n  vPosition = vec3(worldPosition);\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n\n  ${h}\n}\n`,d=`\n${o}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent; //in vec3 tangent;\nin vec3 color;\nin vec2 uv;\nin mat4 modelMatrix;\nin float ditherAmount;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec4 vTangent; //out vec3 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat4 vModelMatrix;\nout mat3 vTBN;\nout float vDitherAmount;\n\nconst int levels = 2;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n//Shadows\nuniform mat4 textureMatrices[levels];\nout vec4 projectedTexcoords[levels];\n\n${u}\n\nvoid main() {\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n  vModelMatrix = modelMatrix;\n  vDitherAmount = ditherAmount;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(vNormal, vTangent.xyz) * vTangent.w, 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * vec4(vNormal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  for (int i = 0; i < levels; i++) {\n    projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  }\n\n  vPosition = vec3(worldPosition);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n\n  ${h}\n}\n`,m=`\n${o}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent;\nin vec3 color;\nin vec2 uv;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec4 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\nout mat4 vSkin;\n\nconst int levels = 2;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n// uniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n//Skinning\nin vec4 weights;\nin vec4 joints;\n\nuniform sampler2D u_jointTexture;\nuniform float u_numJoints;\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.)\n#define ROW1_U ((0.5 + 1.0) / 4.)\n#define ROW2_U ((0.5 + 2.0) / 4.)\n#define ROW3_U ((0.5 + 3.0) / 4.)\n \nmat4 getBoneMatrix(float jointNdx) {\n  float v = (jointNdx + 0.5) / u_numJoints;\n  return mat4(\n    texture(u_jointTexture, vec2(ROW0_U, v)),\n    texture(u_jointTexture, vec2(ROW1_U, v)),\n    texture(u_jointTexture, vec2(ROW2_U, v)),\n    texture(u_jointTexture, vec2(ROW3_U, v))\n  );\n}\n\n//Shadows\nuniform mat4 textureMatrices[levels];\nout vec4 projectedTexcoords[levels];\n\n${u}\n\nvoid main() {\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vNormal = normal;\n  // vNormal = mat3(inverse(modelMatrix * skinMatrix)) * normal;\n  // vNormal = mat3(world * inverse(modelMatrix)) * normal;\n\n  mat4 skinMatrix = getBoneMatrix(joints[0]) * weights[0] +\n                    getBoneMatrix(joints[1]) * weights[1] +\n                    getBoneMatrix(joints[2]) * weights[2] +\n                    getBoneMatrix(joints[3]) * weights[3];\n  \n  mat4 world = modelMatrix * skinMatrix;\n  // mat4 world = skinMatrix * modelMatrix;\n  // mat4 world = modelMatrix;\n\n  mat4 TBNWorld = modelMatrix * skinMatrix * modelMatrix;\n  // vec3 _T = normalize(vec3(TBNWorld * vec4(tangent, 0.0)));\n  // vec3 _B = normalize(vec3(TBNWorld * vec4(cross(normal, tangent), 0.0)));\n  // vec3 _N = normalize(vec3(TBNWorld * vec4(normal, 0.0)));\n  vec3 _T = normalize(vec3(TBNWorld * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(TBNWorld * vec4(cross(normal, vTangent.xyz) * vTangent.w, 0.0))); // bruh According to comment on stackoverflow (https://blender.stackexchange.com/questions/220756/why-does-blender-output-vec4-tangents-for-gltf), tangents are vec4 and .w is used for bitangent sign (who could have known... :(\n  vec3 _N = normalize(vec3(TBNWorld * vec4(normal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = world * vec4(position, 1.0);\n  for (int i = 0; i < levels; i++) {\n    projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  }\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n  vPosition = worldPosition.xyz;\n\n  vSkin = skinMatrix;\n\n  // Motion blur\n  vec4 prevCs = projectionMatrix * prevViewMatrix * prevModelMatrix * skinMatrix * vec4(position, 1.0);\n  prevClipSpace = prevCs;\n  clipSpace = gl_Position;\n}\n`,v=f;v=(v=(v=v.replace("//#in","in float alpha;")).replace("//#out","out float vAlpha;")).replace("//#main","vAlpha = alpha;");var p=`\n${o}\n\n${a}\n\n${s}\n\n${l}\n\nuniform float ditherAmount;\nuniform sampler2D ditherTexture;\n\nvoid main() {\n  ${c}\n\n  // Dither\n  float dither = texture(ditherTexture, gl_FragCoord.xy / 8.).r;\n  float d = 1. - ditherAmount;\n  if (d + (d < 0. ? dither : -dither) < 0.) {\n    discard;\n  }\n  \n  // fragColor = vec4(1, 0, 0, 1);\n  // return;\n\n  // fragColor = vec4(vNormal, 1);\n  // return;\n\n  vec4 currentAlbedo = useTexture ? sampleTexture(albedoTexture, vUV) : vec4(1);\n  currentAlbedo *= albedo;\n  if (useVertexColor) {\n    currentAlbedo.xyz *= vec3(1) - vColor;\n  }\n  //#currentAlbedo\n\n  // if (doNoTiling) {\n  //   currentAlbedo.rgb *= mix(vec3(1.0), vec3(0.4, 0.7, 0.4), clamp(LayeredNoise(vUV / 40.), 0., 1.));\n  // }\n\n  // fragColor = currentAlbedo + vec4(emissiveFactor, 0.);\n  // return;\n\n  vec3 _emission = emissiveFactor;\n  if (useEmissiveTexture) {\n    _emission *= sampleTexture(emissiveTexture, vUV).rgb;\n  }\n\n  float _ao = ao;\n  if (useOcclusionTexture) {\n    _ao *= sampleTexture(occlusionTexture, vUV).r;\n  }\n\n  float _metallic = metallic;\n  float _roughness = roughness;\n  if (useMetallicRoughnessTexture) {\n    vec4 ts = sampleTexture(metallicRoughnessTexture, vUV);\n    _metallic *= ts.b;\n    _roughness *= ts.g;\n  }\n\n  vec3 _tangentNormal = vec3(0, 0, 1);\n  if (useNormalTexture) {\n    _tangentNormal = sampleTexture(normalTexture, vUV).rgb;\n    \n    // Accoring to GLTF NormalTangentTest, it's correct to flip none of the channels here! Update: yup, should not flip anything here\n    // _tangentNormal.r = 1. - _tangentNormal.r;\n    // _tangentNormal.g = 1. - _tangentNormal.g; // Convert from DirectX to OpenGL normal map format (remove this line if the normal map looks inverted)\n\n    // _tangentNormal.rg = _tangentNormal.gr;\n\n    _tangentNormal = _tangentNormal * 2. - 1.;\n    _tangentNormal = setNormalStrength(_tangentNormal, normalStrength);\n  }\n\n  // fragColor = vec4(_tangentNormal, 1);\n  // return;\n\n  vec4 litColor = lit(currentAlbedo, alphaCutoff, _emission, _tangentNormal, _metallic, _roughness, _ao);\n \n  #ifdef USEFOG\n    litColor = applyFog(litColor);\n  #endif\n\n  fragColor = litColor;\n}\n`,g=p;g=(g=(g=(g=(g=g.replace(/modelMatrix/g,"vModelMatrix")).replace(/uniform mat4 vModelMatrix/g,"in mat4 vModelMatrix")).replace(/uniform float ditherAmount/g,"in float vDitherAmount")).replace(/ditherAmount/g,"vDitherAmount")).replace("motionVector = (NDCPos - PrevNDCPos).xy * 0.5 + 0.5;","motionVector = vec2(0.5);");var x=p,b=p;b=(b=b.replace("//#in","in float vAlpha;")).replace("//#currentAlbedo","currentAlbedo *= vec4(1, 1, 1, vAlpha);");var T="\n// lit - vertex.glsl\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 tangent;\nattribute vec3 color;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vTangent;\nvarying vec3 vColor;\nvarying vec2 vUV;\nvarying mat3 vTBN;\n\n//Shadows\nconst int levels = 2;\nuniform mat4 textureMatrices[levels];\n// varying vec4 projectedTexcoords[levels];\n\nvoid main() {\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(vNormal, vTangent), 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * vec4(vNormal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  // for (int i = 0; i < levels; i++) {\n  //   projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  // }\n\n  vPosition = vec3(worldPosition);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",E="\n#extension GL_EXT_shader_texture_lod : enable\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n\n#ifndef GL_EXT_shader_texture_lod\nvec4 textureCubeLodEXT(samplerCube t, vec3 n, float lod) {\n  return textureCube(t, n);\n}\n#endif\n\nconst float PI = 3.141592;\n\n// Attributes\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vTangent;\nvarying vec3 vColor;\nvarying vec2 vUV;\nvarying mat3 vTBN;\n\nuniform mat4 inverseViewMatrix;\nuniform mat4 modelMatrix;\n\n// Material properties\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform sampler2D normalTexture;\nuniform bool useNormalTexture;\nuniform sampler2D metallicRoughnessTexture;\nuniform bool useMetallicRoughnessTexture;\nuniform sampler2D emissiveTexture;\nuniform bool useEmissiveTexture;\nuniform sampler2D occlusionTexture;\nuniform bool useOcclusionTexture;\n\nuniform vec4 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform vec3 emissiveFactor;\nfloat ao = 1.;\nuniform bool opaque;\nuniform float alphaCutoff;\nuniform float normalStrength;\nuniform bool doNoTiling;\n\n// bruh make shared uniform into uniform block\n// Light info\nstruct LightInfo {\n  int type;\n  vec3 position;\n  vec3 direction;\n  float angle;\n  vec3 color;\n};\nconst int maxLights = 8;\nuniform LightInfo lights[maxLights];\nuniform int nrLights;\nuniform vec3 sunDirection;\nuniform vec3 sunIntensity;\n\n// Environment\nuniform float environmentIntensity;\nuniform samplerCube u_diffuseIBL;\nuniform samplerCube u_specularIBL;\nuniform sampler2D u_splitSum;\n\n// Shadows\nfloat shadowDarkness = 0.;\nvec2 shadowStepSize = 1. / vec2(1024);\nconst int shadowKernalSize = 3;\nmat3 shadowKernel = mat3(\n  1, 2, 1,\n  2, 4, 2,\n  1, 2, 1\n);\n\nconst int levels = 2;\n// in vec4 projectedTexcoords[levels];\nuniform float biases[levels];\nuniform sampler2D projectedTextures[levels];\n\n// Debug\nuniform sampler2D unsued2D;\nuniform samplerCube unsued3D;\n\n// No tiling\nvec4 hash4(vec2 p);\nvec2 hash(vec2 p);\n\n// Texture sampling\nvec4 sampleTexture(sampler2D samp, vec2 uv);\n\n//Normal map\nvec3 setNormalStrength(vec3 normal, float strength);\n\n// Shadow functions\nbool inRange(vec3 projCoord);\nfloat getShadowAmount();\n\n// PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0);\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness);\nfloat DistributionGGX(vec3 N, vec3 H, float roughness);\nfloat GeometrySchlickGGX(float NdotV, float roughness);\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness);\nvec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0);\nvec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0);\nvec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0);\nvec3 Spotlight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 dir, float angle, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0);\nvec4 lit(vec4 _albedo, float _alphaCutoff, vec3 _emission, vec3 _tangentNormal, float _metallic, float _roughness, float _ao);\n\nvoid main() {\n  vec4 currentAlbedo = useTexture ? sampleTexture(albedoTexture, vUV) : vec4(1);\n  currentAlbedo *= albedo;\n  currentAlbedo *= vec4(vec3(1) - vColor, 1);\n\n  vec3 _emission = emissiveFactor;\n  if (useEmissiveTexture) {\n    _emission *= sampleTexture(emissiveTexture, vUV).rgb;\n  }\n\n  float _ao = ao;\n  if (useOcclusionTexture) {\n    _ao *= sampleTexture(occlusionTexture, vUV).r;\n  }\n\n  float _metallic = metallic;\n  float _roughness = roughness;\n  if (useMetallicRoughnessTexture) {\n    vec3 ts = sampleTexture(metallicRoughnessTexture, vUV).rgb;\n    _metallic *= ts.b;\n    _roughness *= ts.g;\n  }\n\n  vec3 _tangentNormal = vec3(0, 0, 1);\n  if (useNormalTexture) {\n    _tangentNormal = sampleTexture(normalTexture, vUV).rgb * 2. - 1.;\n\n    if (normalStrength != 0.) {\n    _tangentNormal = setNormalStrength(_tangentNormal, normalStrength);\n    }\n  }\n\n  gl_FragColor = lit(currentAlbedo, alphaCutoff, _emission, _tangentNormal, _metallic, _roughness, _ao);\n}\n\n// Texture sampling\nvec4 sampleTexture(sampler2D samp, vec2 uv) {\n  return texture2D(samp, uv);\n}\n\n//Normal map\nvec3 setNormalStrength(vec3 normal, float strength) {\n  return vec3(normal.xy * strength, mix(1., normal.z, clamp(strength, 0., 1.)));\n}\n\n// Shadow functions\nbool inRange(vec3 projCoord) {\n  return projCoord.x >= 0.0 &&\n      projCoord.x <= 1.0 &&\n      projCoord.y >= 0.0 &&\n      projCoord.y <= 1.0;\n}\n\nfloat getShadowAmount() {\n  return 1.;\n}\n\n// PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n} \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n  float a      = roughness*roughness;\n  float a2     = a*a;\n  float NdotH  = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH*NdotH;\n\n  float num   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n\n  return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r*r) / 8.0;\n\n  float num   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 F0 = vec3(scalarF0); \n  F0 = mix(F0, albedo, metallic);\n  vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.), F0, roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - metallic;\t  \n    \n  vec3 irradiance = textureCube(u_diffuseIBL, N).rgb;\n  vec3 diffuse  = irradiance * albedo;\n\n    \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureCubeLodEXT(u_specularIBL, R, roughness * MAX_REFLECTION_LOD).rgb;   \n  \n  // vec2 envBRDF = texture2D(u_splitSum, vec2(max(dot(N, V), 0.), roughness)).rg;\n\n  vec2 uv = vec2(max(dot(N, V), 0.), roughness);\n  uv.y = 1. - uv.y;\n  vec2 envBRDF = texture2D(u_splitSum, uv).rg;\n  \n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n  vec3 ambient = (kD * diffuse + specular) * ao;\n\n  return ambient;\n}\n\nvec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 L = normalize(lightDir);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec3 Spotlight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 dir, float angle, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 currentDir = normalize(worldPos - lightPos);\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n\n  float sharpness = 5.;\n  attenuation *= clamp((dot(currentDir, dir) - cos(angle)) * sharpness, 0., 1.);\n\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec4 lit(vec4 _albedo, float _alphaCutoff, vec3 _emission, vec3 _tangentNormal, float _metallic, float _roughness, float _ao) {\n  _roughness = clamp(_roughness, 0.01, 0.99);\n\n  if (_albedo.a <= _alphaCutoff) {\n    discard;\n  }\n\n  if (opaque) {\n    _albedo.a = 1.;\n  }\n\n  // vec3 N = normalize(mat3(modelMatrix) * vNormal);\n  vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n\n  vec3 N = normalize(vTBN * _tangentNormal);\n  if (!gl_FrontFacing) {\n    N *= -1.;\n  }\n\n  vec3 R = reflect(-V, N);\n\n  float f0 = 0.04;\n\n  vec3 col = vec3(0);\n  col += IBL(N, V, R, _albedo.rgb, _metallic, _roughness, f0) * _ao * environmentIntensity;\n  \n  if (sunIntensity != vec3(0)) {\n    col += DirectionalLight(vPosition, N, V, sunDirection, sunIntensity, _albedo.rgb, _metallic, _roughness, f0) * _ao * getShadowAmount();\n  }\n\n  for (int i = 0; i < maxLights; i++) {\n    if (i < nrLights) {\n      LightInfo light = lights[i];\n      if (light.type == 0) {\n        col += PositionalLight(vPosition, N, V, light.position, light.color, _albedo.rgb, _metallic, _roughness, f0);\n      }\n      else if (light.type == 1) {\n        col += Spotlight(vPosition, N, V, light.position, light.direction, light.angle, light.color, _albedo.rgb, _metallic, _roughness, f0);\n      }\n    }\n  }\n\n  // if (nrLights >= 1) {\n  //   const int i = 0;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 2) {\n  //   const int i = 1;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 3) {\n  //   const int i = 2;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 4) {\n  //   const int i = 3;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 5) {\n  //   const int i = 4;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 6) {\n  //   const int i = 5;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 7) {\n  //   const int i = 6;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 8) {\n  //   const int i = 7;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n\n  col += _emission;\n\n  return vec4(col, _albedo.a);\n}\n\n\n\n\n\n\n\n\n// #extension GL_EXT_shader_texture_lod : enable\n// precision highp float;\n\n// #ifndef GL_EXT_shader_texture_lod\n// vec4 textureCubeLodEXT(samplerCube t, vec3 n, float lod) {\n//   return textureCube(t, n);\n// }\n// #endif\n\n// varying vec3 vPosition;\n// varying vec3 vNormal;\n// varying vec3 vTangent;\n// varying vec3 vColor;\n// varying vec2 vUV;\n// varying mat3 vTBN;\n\n// uniform sampler2D albedoTexture;\n// uniform bool useTexture;\n// uniform sampler2D normalTexture;\n// uniform bool useNormalTexture;\n// uniform sampler2D metallicRoughnessTexture;\n// uniform bool useMetallicRoughnessTexture;\n// uniform sampler2D emissiveTexture;\n// uniform bool useEmissiveTexture;\n// uniform sampler2D occlusionTexture;\n// uniform bool useOcclusionTexture;\n\n// uniform mat4 inverseViewMatrix;\n// uniform mat4 modelMatrix;\n\n// uniform samplerCube u_diffuseIBL;\n// uniform samplerCube u_specularIBL;\n// uniform sampler2D u_splitSum;\n\n// uniform vec3 sunDirection;\n// uniform vec3 sunIntensity;\n\n// float shadowDarkness = 0.;\n\n// uniform vec4 albedo;\n// uniform float metallic;\n// uniform float roughness;\n// uniform vec3 emissiveFactor;\n// float ao = 1.;\n\n// uniform bool opaque;\n// uniform float alphaCutoff;\n\n// uniform bool doNoTiling;\n\n// const float PI = 3.141592;\n\n// vec2 hash( vec2 p ) // replace this by something better\n// {\n// \tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n// \treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n// }\n\n// float noise( in vec2 p )\n// {\n//   const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n//   const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n// \tvec2  i = floor( p + (p.x+p.y)*K1 );\n//   vec2  a = p - i + (i.x+i.y)*K2;\n//   float m = step(a.y,a.x); \n//   vec2  o = vec2(m,1.0-m);\n//   vec2  b = a - o + K2;\n// \tvec2  c = a - 1.0 + 2.0*K2;\n//   vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n// \tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n//   return (dot( n, vec3(70.0) ) + 1.) / 2.;\n// }\n\n// // Texture sampling\n// vec4 sampleTexture(sampler2D samp, vec2 uv) {\n//   return texture2D(samp, uv);\n// }\n\n// //Shadows\n// vec2 shadowStepSize = 1. / vec2(1024);\n// const int shadowKernalSize = 3;\n// mat3 shadowKernel = mat3(\n//   1, 2, 1,\n//   2, 4, 2,\n//   1, 2, 1\n// );\n\n// const int levels = 2;\n// uniform float biases[levels];\n// uniform sampler2D projectedTextures[levels];\n// // varying vec4 projectedTexcoords[levels];\n\n// bool inRange(vec3 projCoord) {\n//   return projCoord.x >= 0.0 &&\n//       projCoord.x <= 1.0 &&\n//       projCoord.y >= 0.0 &&\n//       projCoord.y <= 1.0;\n// }\n\n// float getShadowAmount() {\n//   // vec3 proj = projectedTexcoords[0].xyz / projectedTexcoords[0].w;\n//   // float currentDepth = proj.z + biases[0];\n//   // float projectedDepth = texture2D(projectedTextures[0], proj.xy).r;\n//   // bool inside = inRange(proj);\n  \n//   // if (inside) {\n//   //   return (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n//   // }\n  \n//   // proj = projectedTexcoords[1].xyz / projectedTexcoords[1].w;\n//   // currentDepth = proj.z + biases[1];\n//   // projectedDepth = texture2D(projectedTextures[1], proj.xy).r;\n//   // inside = inRange(proj);\n\n//   // if (inside) {\n//   //   return (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n//   // }\n\n//   return 1.;\n// }\n\n// // PBR\n// vec3 fresnelSchlick(float cosTheta, vec3 F0) {\n//   return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n// }\n\n// vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n//   return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n// } \n\n// float DistributionGGX(vec3 N, vec3 H, float roughness) {\n//   float a      = roughness*roughness;\n//   float a2     = a*a;\n//   float NdotH  = max(dot(N, H), 0.0);\n//   float NdotH2 = NdotH*NdotH;\n\n//   float num   = a2;\n//   float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n//   denom = PI * denom * denom;\n\n//   return num / denom;\n// }\n\n// float GeometrySchlickGGX(float NdotV, float roughness) {\n//   float r = (roughness + 1.0);\n//   float k = (r*r) / 8.0;\n\n//   float num   = NdotV;\n//   float denom = NdotV * (1.0 - k) + k;\n\n//   return num / denom;\n// }\n\n// float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n//   float NdotV = max(dot(N, V), 0.0);\n//   float NdotL = max(dot(N, L), 0.0);\n//   float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n//   float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n//   return ggx1 * ggx2;\n// }\n\n// vec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0) {\n//   vec3 F0 = vec3(scalarF0); \n//   F0 = mix(F0, albedo, metallic);\n//   vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.), F0, roughness);\n\n//   vec3 kS = F;\n//   vec3 kD = 1.0 - kS;\n//   kD *= 1.0 - metallic;\n    \n//   vec3 irradiance = textureCube(u_diffuseIBL, N).rgb;\n//   vec3 diffuse  = irradiance * albedo;\n    \n//   const float MAX_REFLECTION_LOD = 4.0;\n//   vec3 prefilteredColor = textureCubeLodEXT(u_specularIBL, R, roughness * MAX_REFLECTION_LOD).rgb;   \n//   vec2 envBRDF = texture2D(u_splitSum, vec2(max(dot(N, V), 0.), roughness)).rg;\n//   vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n//   vec3 ambient = (kD * diffuse + specular) * ao;\n\n//   return ambient;\n// }\n\n// vec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n//   vec3 L = normalize(lightDir);  \n//   vec3 H = normalize(V + L);  \n//   vec3 radiance     = lightColor;     \n//   vec3 F0 = vec3(scalarF0); \n//   F0      = mix(F0, albedo, metallic);\n//   vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n//   float NDF = DistributionGGX(N, H, roughness);       \n//   float G   = GeometrySmith(N, V, L, roughness);     \n//   vec3 nominator    = NDF * G * F;\n//   float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n//   vec3 specular     = nominator / denominator;       \n//   vec3 kS = F;\n//   vec3 kD = vec3(1.0) - kS;\n    \n//   kD *= 1.0 - metallic;     \n//   float NdotL = max(dot(N, L), 0.0);        \n//   return (kD * albedo / PI + specular) * radiance * NdotL;  \n// }\n\n// void main() {\n//   vec4 currentAlbedo = useTexture ? sampleTexture(albedoTexture, vUV) : vec4(1);\n//   currentAlbedo *= albedo;\n\n//   if (currentAlbedo.a <= alphaCutoff) {\n//     discard;\n//   }\n\n//   if (opaque) {\n//     currentAlbedo.a = 1.;\n//   }\n\n//   float _metallic = metallic;\n//   float _roughness = roughness;\n//   if (useMetallicRoughnessTexture) {\n//     vec3 ts = sampleTexture(metallicRoughnessTexture, vUV).rgb;\n//     _metallic *= ts.b;\n//     _roughness *= ts.g;\n//   }\n\n//   float _ao = ao;\n//   if (useOcclusionTexture) {\n//     _ao *= sampleTexture(occlusionTexture, vUV).r;\n//   }\n\n//   vec3 N = normalize(mat3(modelMatrix) * vNormal);\n//   vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n\n//   if (useNormalTexture && vTangent.xyz != vec3(0)) {\n//     vec3 tangentNormal = sampleTexture(normalTexture, vUV).rgb * 2. - 1.;\n//     N = normalize(vTBN * tangentNormal);\n//   }\n\n//   if (!gl_FrontFacing) {\n//     N *= -1.;\n//   }\n\n//   vec3 R = reflect(-V, N);\n\n//   float f0 = 0.04;\n\n//   vec3 col = vec3(0);\n//   col += IBL(N, V, R, currentAlbedo.rgb, _metallic, _roughness, f0) * _ao;\n//   if (sunIntensity != vec3(0)) {\n//     col += DirectionalLight(vPosition, N, V, sunDirection, sunIntensity, currentAlbedo.rgb, _metallic, _roughness, f0) * _ao * getShadowAmount();\n//   }\n\n//   if (useEmissiveTexture) {\n//     col += sampleTexture(emissiveTexture, vUV).rgb * emissiveFactor;\n//   }\n//   else {\n//     col += emissiveFactor;\n//   }\n\n//   gl_FragColor = vec4(col, currentAlbedo.a);\n//   return;\n// }\n";f=f.trim(),d=d.trim(),m=m.trim(),v=v.trim(),p=p.trim(),g=g.trim(),x=x.trim(),b=b.trim();var w={lit:{vertex:T=T.trim(),fragment:E=E.trim()}},y={lit:{vertex:f,fragment:p},litInstanced:{vertex:d,fragment:g},litSkinned:{vertex:m,fragment:x},litTrail:{vertex:v,fragment:b}}},358:(e,t,n)=>{function r(e,t){return(e%t+t)%t}function i(e,t){return(e%t+t)%t}function o(e,t,n){return Math.max(t,Math.min(n,e))}function a(e,t,n){return e*(1-n)+t*n}function s(e,t,n){return Math.abs(e-t)<1e-6?0:(n-e)/(t-e)}function l(e,t){return Math.round(e/t)*t}function c(e){return 0==(e&e-1)}function u(e){for(var t=new Uint16Array(e.length),n=0;n<t.length;n++)t[n]=d(e[n]);return t}n.d(t,{DJ:()=>x,Pn:()=>l,UR:()=>T,_v:()=>v,gA:()=>b,ii:()=>s,mB:()=>m,po:()=>g,re:()=>r,rz:()=>c,t7:()=>a,uZ:()=>o,wQ:()=>i,wo:()=>u,z:()=>p});var h,f,d=(h=new Float32Array(1),f=new Int32Array(h.buffer),function(e){h[0]=e;var t=f[0],n=t>>16&32768,r=t>>12&2047,i=t>>23&255;return i<103?n:i>142?(n|=31744,n|=(255==i?0:1)&&8388607&t):i<113?n|=((r|=2048)>>114-i)+(r>>113-i&1):(n|=i-112<<10|r>>1,n+=1&r)});function m(e){return new DataView(Uint8Array.from(e).buffer).getInt32(0,!0)}function v(e){return new Promise((t=>setTimeout(t,e)))}function p(e){return!e||0===Object.keys(e).length}function g(e){return new Promise(((t,n)=>{let r=new Image;r.addEventListener("load",(e=>t(r))),r.addEventListener("error",(()=>{n(new Error(`Failed to load image's URL: ${e}`))})),r.src=e}))}function x(e,t,n){var r=document.createElement("canvas");r.width=t??e.width,r.height=n??e.height;var i=r.getContext("2d");return i.drawImage(e,0,0),i.getImageData(0,0,r.width,r.height).data}function b(e,t="download"){var n=document.createElement("a");n.download=t+".png",n.href=e.toDataURL(),n.click()}function T(e,t="download"){var n=document.createElement("a");n.download=t+".png",n.href=e,n.click()}},775:(e,t,n)=>{n.d(t,{Z:()=>u});var r=n(271),i=n(367),o=n(358);const a=new Float32Array(16),s=new r.Z,l=new Float32Array(16);function c(e,t,n,r,i,o,a,s,l,c,u,h,f,d,m,v,p){return e[0]=t,e[1]=n,e[2]=r,e[3]=i,e[4]=o,e[5]=a,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=h,e[11]=f,e[12]=d,e[13]=m,e[14]=v,e[15]=p,e}class u{constructor(e=0,t=0,n=0,r=0,i=0,o=0,a=0,s=0,l=0,u=0,h=0,f=0,d=0,m=0,v=0,p=0){var g=new Float32Array(16);return c(g,e,t,n,r,i,o,a,s,l,u,h,f,d,m,v,p),g}static identity(e){return c(e=e||new Float32Array(16),1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),e}static set(e,t,n,r,i,o,a,s,l,u,h,f,d,m,v,p,g){return c(e,t,n,r,i,o,a,s,l,u,h,f,d,m,v,p,g)}static copy(e,t){return(t=t||new Float32Array(16)).set(e),t}static isNaN(e){return isNaN(e[0])||isNaN(e[1])||isNaN(e[2])||isNaN(e[3])||isNaN(e[4])||isNaN(e[5])||isNaN(e[6])||isNaN(e[7])||isNaN(e[8])||isNaN(e[9])||isNaN(e[10])||isNaN(e[11])||isNaN(e[12])||isNaN(e[13])||isNaN(e[14])||isNaN(e[15])}static equal(e,t,n=1e-6){return Math.abs(e[0]-t[0])<n&&Math.abs(e[1]-t[1])<n&&Math.abs(e[2]-t[2])<n&&Math.abs(e[3]-t[3])<n&&Math.abs(e[4]-t[4])<n&&Math.abs(e[5]-t[5])<n&&Math.abs(e[6]-t[6])<n&&Math.abs(e[7]-t[7])<n&&Math.abs(e[8]-t[8])<n&&Math.abs(e[9]-t[9])<n&&Math.abs(e[10]-t[10])<n&&Math.abs(e[11]-t[11])<n&&Math.abs(e[12]-t[12])<n&&Math.abs(e[13]-t[13])<n&&Math.abs(e[14]-t[14])<n&&Math.abs(e[15]-t[15])<n}static add(e,t,n){return c(n=n||new Float32Array(16),e[0]+t[0],e[1]+t[1],e[2]+t[2],e[3]+t[3],e[4]+t[4],e[5]+t[5],e[6]+t[6],e[7]+t[7],e[8]+t[8],e[9]+t[9],e[10]+t[10],e[11]+t[11],e[12]+t[12],e[13]+t[13],e[14]+t[14],e[15]+t[15]),n}static subtract(e,t,n){return c(n=n||new Float32Array(16),e[0]-t[0],e[1]-t[1],e[2]-t[2],e[3]-t[3],e[4]-t[4],e[5]-t[5],e[6]-t[6],e[7]-t[7],e[8]-t[8],e[9]-t[9],e[10]-t[10],e[11]-t[11],e[12]-t[12],e[13]-t[13],e[14]-t[14],e[15]-t[15]),n}static lerp(e,t,n,r){return c(r=r||new Float32Array(16),(0,o.t7)(e[0],t[0],n),(0,o.t7)(e[1],t[1],n),(0,o.t7)(e[2],t[2],n),(0,o.t7)(e[3],t[3],n),(0,o.t7)(e[4],t[4],n),(0,o.t7)(e[5],t[5],n),(0,o.t7)(e[6],t[6],n),(0,o.t7)(e[7],t[7],n),(0,o.t7)(e[8],t[8],n),(0,o.t7)(e[9],t[9],n),(0,o.t7)(e[10],t[10],n),(0,o.t7)(e[11],t[11],n),(0,o.t7)(e[12],t[12],n),(0,o.t7)(e[13],t[13],n),(0,o.t7)(e[14],t[14],n),(0,o.t7)(e[15],t[15],n)),r}static transpose(e,t){return c(t=t||new Float32Array(16),e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],e[3],e[7],e[11],e[15]),t}static inverse(e,t){c(a,e[5]*e[10]*e[15]-e[5]*e[11]*e[14]-e[9]*e[6]*e[15]+e[9]*e[7]*e[14]+e[13]*e[6]*e[11]-e[13]*e[7]*e[10],-e[1]*e[10]*e[15]+e[1]*e[11]*e[14]+e[9]*e[2]*e[15]-e[9]*e[3]*e[14]-e[13]*e[2]*e[11]+e[13]*e[3]*e[10],e[1]*e[6]*e[15]-e[1]*e[7]*e[14]-e[5]*e[2]*e[15]+e[5]*e[3]*e[14]+e[13]*e[2]*e[7]-e[13]*e[3]*e[6],-e[1]*e[6]*e[11]+e[1]*e[7]*e[10]+e[5]*e[2]*e[11]-e[5]*e[3]*e[10]-e[9]*e[2]*e[7]+e[9]*e[3]*e[6],-e[4]*e[10]*e[15]+e[4]*e[11]*e[14]+e[8]*e[6]*e[15]-e[8]*e[7]*e[14]-e[12]*e[6]*e[11]+e[12]*e[7]*e[10],e[0]*e[10]*e[15]-e[0]*e[11]*e[14]-e[8]*e[2]*e[15]+e[8]*e[3]*e[14]+e[12]*e[2]*e[11]-e[12]*e[3]*e[10],-e[0]*e[6]*e[15]+e[0]*e[7]*e[14]+e[4]*e[2]*e[15]-e[4]*e[3]*e[14]-e[12]*e[2]*e[7]+e[12]*e[3]*e[6],e[0]*e[6]*e[11]-e[0]*e[7]*e[10]-e[4]*e[2]*e[11]+e[4]*e[3]*e[10]+e[8]*e[2]*e[7]-e[8]*e[3]*e[6],e[4]*e[9]*e[15]-e[4]*e[11]*e[13]-e[8]*e[5]*e[15]+e[8]*e[7]*e[13]+e[12]*e[5]*e[11]-e[12]*e[7]*e[9],-e[0]*e[9]*e[15]+e[0]*e[11]*e[13]+e[8]*e[1]*e[15]-e[8]*e[3]*e[13]-e[12]*e[1]*e[11]+e[12]*e[3]*e[9],e[0]*e[5]*e[15]-e[0]*e[7]*e[13]-e[4]*e[1]*e[15]+e[4]*e[3]*e[13]+e[12]*e[1]*e[7]-e[12]*e[3]*e[5],-e[0]*e[5]*e[11]+e[0]*e[7]*e[9]+e[4]*e[1]*e[11]-e[4]*e[3]*e[9]-e[8]*e[1]*e[7]+e[8]*e[3]*e[5],-e[4]*e[9]*e[14]+e[4]*e[10]*e[13]+e[8]*e[5]*e[14]-e[8]*e[6]*e[13]-e[12]*e[5]*e[10]+e[12]*e[6]*e[9],e[0]*e[9]*e[14]-e[0]*e[10]*e[13]-e[8]*e[1]*e[14]+e[8]*e[2]*e[13]+e[12]*e[1]*e[10]-e[12]*e[2]*e[9],-e[0]*e[5]*e[14]+e[0]*e[6]*e[13]+e[4]*e[1]*e[14]-e[4]*e[2]*e[13]-e[12]*e[1]*e[6]+e[12]*e[2]*e[5],e[0]*e[5]*e[10]-e[0]*e[6]*e[9]-e[4]*e[1]*e[10]+e[4]*e[2]*e[9]+e[8]*e[1]*e[6]-e[8]*e[2]*e[5]);let n=e[0]*a[0]+e[1]*a[4]+e[2]*a[8]+e[3]*a[12];if(!n)return e;n=1/n;for(let e=0;e<16;e++)a[e]*=n;return t||(t=new Float32Array(16)),u.copy(a,t),t}static multiply(e,t,n){const r=e,i=t,o=n=n||new Float32Array(16),a=r[0],s=r[4],l=r[8],c=r[12],u=r[1],h=r[5],f=r[9],d=r[13],m=r[2],v=r[6],p=r[10],g=r[14],x=r[3],b=r[7],T=r[11],E=r[15],w=i[0],y=i[4],_=i[8],R=i[12],A=i[1],M=i[5],F=i[9],C=i[13],D=i[2],P=i[6],U=i[10],N=i[14],S=i[3],B=i[7],L=i[11],z=i[15];return o[0]=a*w+s*A+l*D+c*S,o[4]=a*y+s*M+l*P+c*B,o[8]=a*_+s*F+l*U+c*L,o[12]=a*R+s*C+l*N+c*z,o[1]=u*w+h*A+f*D+d*S,o[5]=u*y+h*M+f*P+d*B,o[9]=u*_+h*F+f*U+d*L,o[13]=u*R+h*C+f*N+d*z,o[2]=m*w+v*A+p*D+g*S,o[6]=m*y+v*M+p*P+g*B,o[10]=m*_+v*F+p*U+g*L,o[14]=m*R+v*C+p*N+g*z,o[3]=x*w+b*A+T*D+E*S,o[7]=x*y+b*M+T*P+E*B,o[11]=x*_+b*F+T*U+E*L,o[15]=x*R+b*C+T*N+E*z,n}static basis(e,t,n,r){return c(r=r||new Float32Array(16),e.x,e.y,e.z,0,t.x,t.y,t.z,0,n.x,n.y,n.z,0,0,0,0,1),r}static getForward(e,t){return(t=t||new i.Z).x=-e[8],t.y=-e[9],t.z=-e[10],i.Z.normalizeTo(t),t}static getRight(e,t){return(t=t||new i.Z).x=e[0],t.y=e[1],t.z=e[2],i.Z.normalizeTo(t),t}static getUp(e,t){return(t=t||new i.Z).x=e[4],t.y=e[5],t.z=e[6],i.Z.normalizeTo(t),t}static forward(e,t){return u.getForward(e,t)}static right(e,t){return u.getRight(e,t)}static up(e,t){return u.getUp(e,t)}static translate(e={x:0,y:0,z:0},t){return c(t=t||new Float32Array(16),1,0,0,0,0,1,0,0,0,0,1,0,e.x,e.y,e.z,1),t}static getTranslationMatrix(e,t){return c(t=t||new Float32Array(16),1,0,0,0,0,1,0,0,0,0,1,0,e[12],e[13],e[14],1),t}static getPosition(e,t){return(t=t||i.Z.zero()).x=e[12],t.y=e[13],t.z=e[14],t}static setPosition(e,t){e[12]=t.x,e[13]=t.y,e[14]=t.z}static removeTranslation(e){return e[12]=0,e[13]=0,e[14]=0,e}static setRotation(e,t){var n=i.Z.length({x:e[4],y:e[5],z:e[6]}),r=i.Z.length({x:e[0],y:e[1],z:e[2]}),o=i.Z.length({x:e[8],y:e[9],z:e[10]});e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[8]=t[8]*o,e[9]=t[9]*o,e[10]=t[10]*o}static getRotationMatrix(e,t){t=t||new Float32Array(16);const n=i.Z.lengthNonVector(e[0],e[1],e[2]),r=i.Z.lengthNonVector(e[4],e[5],e[6]),o=i.Z.lengthNonVector(e[8],e[9],e[10]);return c(t,e[0]/n,e[1]/n,e[2]/n,0,e[4]/r,e[5]/r,e[6]/r,0,e[8]/o,e[9]/o,e[10]/o,0,0,0,0,1),t}static rotateX(e,t,n){var r=new Float32Array([1,0,0,0,0,Math.cos(t),Math.sin(t),0,0,-Math.sin(t),Math.cos(t),0,0,0,0,1]);return u.multiply(e,r,n)}static rotateY(e,t,n){var r=new Float32Array([Math.cos(t),0,-Math.sin(t),0,0,1,0,0,Math.sin(t),0,Math.cos(t),0,0,0,0,1]);return u.multiply(e,r,n)}static rotateZ(e,t,n){var r=new Float32Array([Math.cos(t),Math.sin(t),0,0,-Math.sin(t),Math.cos(t),0,0,0,0,1,0,0,0,0,1]);return u.multiply(e,r,n)}static scale(e={x:1,y:1,z:1},t){return c(t=t||new Float32Array(16),e.x,0,0,0,0,e.y,0,0,0,0,e.z,0,0,0,0,1),t}static scaleWithScalar(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e[4]*=t,e[5]*=t,e[6]*=t,e[8]*=t,e[9]*=t,e[10]*=t,e}static scaleWithVector(e,t){return e[0]*=t.x,e[1]*=t.x,e[2]*=t.x,e[4]*=t.y,e[5]*=t.y,e[6]*=t.y,e[8]*=t.z,e[9]*=t.z,e[10]*=t.z,e}static setScale(e,t){var n=i.Z.length({x:e[0],y:e[1],z:e[2]})/t.x,r=i.Z.length({x:e[4],y:e[5],z:e[6]})/t.y,o=i.Z.length({x:e[8],y:e[9],z:e[10]})/t.z;e[0]/=n,e[1]/=n,e[2]/=n,e[4]/=r,e[5]/=r,e[6]/=r,e[8]/=o,e[9]/=o,e[10]/=o}static getScale(e,t){return(t=t||new i.Z).x=i.Z.lengthNonVector(e[0],e[1],e[2]),t.y=i.Z.lengthNonVector(e[4],e[5],e[6]),t.z=i.Z.lengthNonVector(e[8],e[9],e[10]),t}static getScaleMatrix(e,t){return c(t=t||new Float32Array(16),i.Z.lengthNonVector(e[0],e[1],e[2]),0,0,0,0,i.Z.lengthNonVector(e[4],e[5],e[6]),0,0,0,0,i.Z.lengthNonVector(e[8],e[9],e[10]),0,0,0,0,1),t}static applyTranslation(e,t){t=t||u.identity();const n=e.x||0,r=e.y||0,i=e.z||0;return t[12]+=t[0]*n+t[4]*r+t[8]*i,t[13]+=t[1]*n+t[5]*r+t[9]*i,t[14]+=t[2]*n+t[6]*r+t[10]*i,t[15]+=t[3]*n+t[7]*r+t[11]*i,t}static applyRotationX(e=0,t){return t=t||u.identity(),u.set(l,1,0,0,0,0,Math.cos(e),Math.sin(e),0,0,-Math.sin(e),Math.cos(e),0,0,0,0,1),u.multiply(t,l,t),t}static applyRotationY(e=0,t){return t=t||u.identity(),u.set(l,Math.cos(e),0,-Math.sin(e),0,0,1,0,0,Math.sin(e),0,Math.cos(e),0,0,0,0,1),u.multiply(t,l,t),t}static applyRotationZ(e=0,t){return t=t||u.identity(),u.set(l,Math.cos(e),Math.sin(e),0,0,-Math.sin(e),Math.cos(e),0,0,0,0,1,0,0,0,0,1),u.multiply(t,l,t),t}static applyScaleX(e,t){t[0]*=e,t[1]*=e,t[2]*=e,t[3]*=e}static applyScaleY(e,t){t[4]*=e,t[5]*=e,t[6]*=e,t[7]*=e}static applyScaleZ(e,t){t[8]*=e,t[9]*=e,t[10]*=e,t[11]*=e}static applyScale(e,t){const n=e.x??1,r=e.y??1,i=e.z??1;t[0]*=n,t[1]*=n,t[2]*=n,t[3]*=n,t[4]*=r,t[5]*=r,t[6]*=r,t[7]*=r,t[8]*=i,t[9]*=i,t[10]*=i,t[11]*=i}static transform(e=[],t){t=t||u.identity();for(var n=0;n<e.length;n++){var r=e[n];switch(r[0]){case"translate":u.applyTranslation(r[1],t);break;case"rx":u.applyRotationX(r[1],t);break;case"ry":u.applyRotationY(r[1],t);break;case"rz":u.applyRotationZ(r[1],t);break;case"sx":u.applyScaleX(r[1],t);break;case"sy":u.applyScaleY(r[1],t);break;case"sz":u.applyScaleZ(r[1],t);break;case"scale":u.applyScale(r[1],t)}}return t}static lookAt(e,t,n=i.Z.up(),r){r=r||new Float32Array(16);var o=i.Z.normalize(i.Z.subtract(e,t)),a=i.Z.normalize(i.Z.cross(n,o)),s=i.Z.cross(o,a);return c(r,a.x,a.y,a.z,0,s.x,s.y,s.z,0,o.x,o.y,o.z,0,e.x,e.y,e.z,1),r}static lookInDirection(e,t,n=i.Z.up(),r){r=r||new Float32Array(16);var o=i.Z.normalize(t),a=i.Z.cross(n,o),s=i.Z.normalizeTo(a),l=i.Z.cross(o,s);return c(r,s.x,s.y,s.z,0,l.x,l.y,l.z,0,o.x,o.y,o.z,0,e.x,e.y,e.z,1),r}static perspective(e={},t){t=t||new Float32Array(16);var n=e.fov||1.5,r=e.aspect||1,i=e.near||.1,o=e.far||100,a=Math.sin(n),s=1/(o-i),l=Math.cos(n)/a;return c(t,l/r,0,0,0,0,l,0,0,0,0,-(o+i)*s,-1,0,0,-2*i*o*s,0),t}static setPerspectiveFov(e,t,n){var r=Math.cos(n)/Math.sin(n);e[0]=r/t,e[5]=r}static orthographic(e={},t){t=t||new Float32Array(16);var n=e.top||e.size||5,r=e.bottom||-e.size||-5,i=e.left||-e.size||5,o=e.right||e.size||-5,a=e.far||100,s=e.near||1;return c(t,2/(o-i),0,0,0,0,2/(n-r),0,0,0,0,-2/(a-s),0,-(o+i)/(o-i),-(n+r)/(n-r),-(a+s)/(a-s),1),t}static transformVector(e,t,n){n=n||new i.Z;const r=t.x,o=t.y,a=t.z;return n.x=e[0]*r+e[4]*o+e[8]*a+e[12],n.y=e[1]*r+e[5]*o+e[9]*a+e[13],n.z=e[2]*r+e[6]*o+e[10]*a+e[14],n}static transformDirection(e,t,n){n=n||new i.Z;const r=u.getRotationMatrix(e);return u.transformVector(r,t,n)}static fromQuaternion(e,t){t=t||new Float32Array(16),r.Z.normalize(e,s);const n=s;return c(t,1-2*n.y*n.y-2*n.z*n.z,2*n.x*n.y-2*n.z*n.w,2*n.x*n.z+2*n.y*n.w,0,2*n.x*n.y+2*n.z*n.w,1-2*n.x*n.x-2*n.z*n.z,2*n.y*n.z-2*n.x*n.w,0,2*n.x*n.z-2*n.y*n.w,2*n.y*n.z+2*n.x*n.w,1-2*n.x*n.x-2*n.y*n.y,0,0,0,0,1),u.transpose(t,t),t}static get(e,t,n){return e[t+4*n]}static isMatrix(e){return e instanceof Float32Array&&16==e.length}static pprint(e){e=u.transpose(e),console.table([[...e.slice(0,4)],[...e.slice(4,8)],[...e.slice(8,12)],[...e.slice(12,16)]])}static logSummary(e){console.log("---Matrix summary---"),console.log("Position",u.getPosition(e)),console.log("Scale",u.getScale(e)),console.log("Rotation",r.Z.fromMatrix(e))}}},973:(e,t,n)=>{n.d(t,{Z:()=>s});var r=n(367),i=n(775),o=n(582),a=n(271);function s(e,t,n={}){if(!(e instanceof o.ZP))throw new Error("renderer is not of type 'Renderer'");var s=this;{let e=new r.Z,t=new r.Z,n=new a.Z;var l=function(){a.Z.eulerVector(v,n),s.camera.transform.rotation=n,i.Z.getForward(s.camera.transform.worldMatrix,e),r.Z.multiplyTo(e,-s.distance),r.Z.set(t,m),r.Z.addTo(t,e),s.camera.transform.position=t}}var c=n.rotate??!0,u=n.translate??!0,h=n.scale??!0,f=n.stylePointer??!0,d=5;Object.defineProperty(this,"distance",{get:function(){return d},set:function(e){d=e,l()}});var m=r.Z.zero();Object.defineProperty(this,"center",{get:function(){return m},set:function(e){m=e,l()}});var v=r.Z.zero();Object.defineProperty(this,"rotation",{get:function(){return v},set:function(e){v=e,l()}});var p=i.Z.identity();y(),this.camera=new o.V1(t),this.camera.setAspect(e.aspect),l(),f&&(e.canvas.style.cursor="grab",e.canvas.addEventListener("mousedown",(function(){e.canvas.style.cursor="grabbing"})),document.addEventListener("mouseup",(function(){e.canvas.style.cursor="grab"}))),e.canvas.addEventListener("contextmenu",(function(e){e.preventDefault()})),window.addEventListener("mousemove",(function(t){e.mouse.left&&c?(v.x+=.005*-t.movementY,v.y+=.005*-t.movementX,y()):e.mouse.right&&u&&w(t.movementX,t.movementY),l()}));var g={x:0,y:0},x=!0;e.canvas.addEventListener("touchstart",(function(e){g.x=e.touches[0].clientX,g.y=e.touches[0].clientY,x=!(e.touches.length>1),2==e.touches.length&&(g.x=(e.touches[0].clientX+e.touches[1].clientX)/2,g.y=(e.touches[0].clientY+e.touches[1].clientY)/2),l(),e.preventDefault()})),e.canvas.addEventListener("touchmove",(function(e){if(x){let t=e.touches[0].clientX-g.x,n=e.touches[0].clientY-g.y,r=.005;v.x+=-n*r,v.y+=-t*r,y(),g.x=e.touches[0].clientX,g.y=e.touches[0].clientY}if(2==e.touches.length){let t=(e.touches[0].clientX+e.touches[1].clientX)/2,n=(e.touches[0].clientY+e.touches[1].clientY)/2;w(t-g.x,n-g.y),g.x=t,g.y=n}l(),e.preventDefault()})),document.addEventListener("touchmove",(function(e){1!==e.scale&&e.preventDefault()}),{passive:!1}),e.canvas.addEventListener("wheel",(function(e){h&&(s.distance+=.001*e.deltaY*s.distance,s.distance=Math.max(0,s.distance),l(),e.preventDefault())}));var b=1;e.canvas.addEventListener("gesturestart",(function(e){b=e.scale}),!1),e.canvas.addEventListener("gesturechange",(function(e){var t=b/e.scale;b=e.scale,s.distance*=t,s.distance=Math.max(0,s.distance),l(),e.preventDefault()}),!1),e.on("resize",(function(){s.camera.setAspect(e.aspect)})),this.setCenter=function(e){m=e,l()};let T=new r.Z,E=new r.Z;function w(e,t){var n=6e-4*s.distance;E.x=-e*n,E.y=t*n,E.z=0,i.Z.transformVector(p,E,T),r.Z.addTo(m,T)}function y(){i.Z.identity(p),i.Z.applyRotationY(v.y,p),i.Z.applyRotationX(v.x,p)}}},271:(e,t,n)=>{n.d(t,{Z:()=>a});var r=n(358),i=n(775),o=n(367);class a{constructor(e=0,t=0,n=0,r=0,i){return(i=i||{x:0,y:0,z:0,w:0}).x=e,i.y=t,i.z=n,i.w=r,i}static isQuaternionIsh(e){return"object"==typeof e&&"x"in e&&"y"in e&&"z"in e&&"w"in e}static zero(){return{x:0,y:0,z:0,w:0}}static identity(e){return(e=e||new a).x=0,e.y=0,e.z=0,e.w=1,e}static copy(e){return{x:e.x,y:e.y,z:e.z,w:e.w}}static set(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}static equal(e,t,n=1e-6){return Math.abs(e.x-t.x)<n&&Math.abs(e.y-t.y)<n&&Math.abs(e.z-t.z)<n&&Math.abs(e.w-t.w)<n}static isNaN(e){return isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||isNaN(e.w)}static lengthSqr(e){return e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w}static length(e){return Math.sqrt(a.lengthSqr(e))}static normalize(e,t){t=t||new a;const n=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w);return t.x=e.x/n,t.y=e.y/n,t.z=e.z/n,t.w=e.w/n,t}static normalizeTo(e){const t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w);return e.x/=t,e.y/=t,e.z/=t,e.w/=t,e}static dot(e,t){return e.x*t.x+e.y*t.y+e.z*t.z+e.w*t.w}static add(e,t){return{x:e.x+t.x,y:e.y+t.y,z:e.z+t.z,w:e.w+t.w}}static multiply(e,t){return{x:e.x*t,y:e.y*t,z:e.z*t,w:e.w*t}}static QxQ(e,t,n){n=n||new a;const r=e.x,i=e.y,o=e.z,s=e.w,l=t.x,c=t.y,u=t.z,h=t.w;return n.x=s*l+r*h+i*u-o*c,n.y=s*c-r*u+i*h+o*l,n.z=s*u+r*c-i*l+o*h,n.w=s*h-r*l-i*c-o*u,n}static QxV(e,t,n){n=n||new o.Z;var r=t.x,i=t.y,a=t.z,s=e.x,l=e.y,c=e.z,u=e.w,h=u*r+l*a-c*i,f=u*i+c*r-s*a,d=u*a+s*i-l*r,m=-s*r-l*i-c*a;return n.x=h*u+m*-s+f*-c-d*-l,n.y=f*u+m*-l+d*-s-h*-c,n.z=d*u+m*-c+h*-l-f*-s,n}static slerp(e,t,n){var r=a.dot(e,t);if(Math.abs(1-r)<1e-5)return e;var i=r>=0?e:a.multiply(e,-1),o=Math.acos(Math.abs(r)),s=a.add(a.multiply(i,Math.sin((1-n)*o)),a.multiply(t,Math.sin(n*o)));return a.multiply(s,1/Math.sin(o))}static lerp(e,t,n){return{x:(0,r.t7)(e.x,t.x,n),y:(0,r.t7)(e.y,t.y,n),z:(0,r.t7)(e.z,t.z,n),w:(0,r.t7)(e.w,t.w,n)}}static euler(e,t,n,r){r=r||new a;const i=e,o=t,s=n,l=Math.sin(i/2)*Math.cos(o/2)*Math.cos(s/2)-Math.cos(i/2)*Math.sin(o/2)*Math.sin(s/2),c=Math.cos(i/2)*Math.sin(o/2)*Math.cos(s/2)+Math.sin(i/2)*Math.cos(o/2)*Math.sin(s/2),u=Math.cos(i/2)*Math.cos(o/2)*Math.sin(s/2)-Math.sin(i/2)*Math.sin(o/2)*Math.cos(s/2),h=Math.cos(i/2)*Math.cos(o/2)*Math.cos(s/2)+Math.sin(i/2)*Math.sin(o/2)*Math.sin(s/2);return r.x=l,r.y=c,r.z=u,r.w=h,r}static eulerVector(e,t){return a.euler(e.x,e.y,e.z,t)}static toEulerAngles(e){var[t,n,r,i]=[e.x,e.y,e.z,e.w],o=2*(i*t+n*r),a=1-2*(t*t+n*n),s=2*(i*n-r*t);s=(s=s>1?1:s)<-1?-1:s;var l=2*(i*r+t*n),c=1-2*(n*n+r*r);return[Math.atan2(o,a),Math.asin(s),Math.atan2(l,c)]}static angleAxis(e,t,n){return(n=n||new a).x=t.x*Math.sin(e/2),n.y=t.y*Math.sin(e/2),n.z=t.z*Math.sin(e/2),n.w=Math.cos(e/2),n}static fromMatrix(e,t){t=t||new a;var n=i.Z.get(e,0,0)+i.Z.get(e,1,1)+i.Z.get(e,2,2);if(n>0){let r=.5/Math.sqrt(n+1);t.x=(i.Z.get(e,2,1)-i.Z.get(e,1,2))*r,t.y=(i.Z.get(e,0,2)-i.Z.get(e,2,0))*r,t.z=(i.Z.get(e,1,0)-i.Z.get(e,0,1))*r,t.w=.25/r}else if(i.Z.get(e,0,0)>i.Z.get(e,1,1)&&i.Z.get(e,0,0)>i.Z.get(e,2,2)){let n=2*Math.sqrt(1+i.Z.get(e,0,0)-i.Z.get(e,1,1)-i.Z.get(e,2,2));t.x=.25*n,t.y=(i.Z.get(e,0,1)+i.Z.get(e,1,0))/n,t.z=(i.Z.get(e,0,2)+i.Z.get(e,2,0))/n,t.w=(i.Z.get(e,2,1)-i.Z.get(e,1,2))/n}else if(i.Z.get(e,1,1)>i.Z.get(e,2,2)){let n=2*Math.sqrt(1+i.Z.get(e,1,1)-i.Z.get(e,0,0)-i.Z.get(e,2,2));t.x=(i.Z.get(e,0,1)+i.Z.get(e,1,0))/n,t.y=.25*n,t.z=(i.Z.get(e,1,2)+i.Z.get(e,2,1))/n,t.w=(i.Z.get(e,0,2)+i.Z.get(e,2,0))/n}else{let n=2*Math.sqrt(1+i.Z.get(e,2,2)-i.Z.get(e,0,0)-i.Z.get(e,1,1));t.x=(i.Z.get(e,0,2)+i.Z.get(e,2,0))/n,t.y=(i.Z.get(e,1,2)+i.Z.get(e,2,1))/n,t.z=.25*n,t.w=(i.Z.get(e,1,0)+i.Z.get(e,0,1))/n}return t}static inverse(e,t){t=t||new a;const n=a.lengthSqr(e);return t.x=-e.x/n,t.y=-e.y/n,t.z=-e.z/n,t.w=e.w/n,t}}},582:(e,t,n)=>{n.d(t,{V1:()=>G,xs:()=>V,ZP:()=>ot});var r={};n.r(r),n.d(r,{webgl1:()=>ce,webgl2:()=>ue});var i={};n.r(i),n.d(i,{webgl2:()=>de});var o={};n.r(o),n.d(o,{webgl1:()=>ve,webgl2:()=>pe});var a={};n.r(a),n.d(a,{webgl1:()=>xe,webgl2:()=>be});var s={};n.r(s),n.d(s,{webgl1:()=>Ee,webgl2:()=>we});var l={};n.r(l),n.d(l,{webgl1:()=>_e,webgl2:()=>Re});var c={};n.r(c),n.d(c,{webgl1:()=>Me,webgl2:()=>Fe});var u={};n.r(u),n.d(u,{webgl1:()=>De,webgl2:()=>Pe});var h={};n.r(h),n.d(h,{webgl1:()=>Ne,webgl2:()=>Se});var f={};n.r(f),n.d(f,{webgl1:()=>Le,webgl2:()=>ze});const d={SHADOWS:1,OPAQUE:2,ALPHA:4,DOWNSCALED:8};var m=n(367),v=n(775),p=n(271);function g(e,t,n){var r=Math.max(e,t,n);if(r<1e-32)return[0,0,0,0];var[i,o]=function(e){const t=[e=Number(e),0];if(0!==e&&Number.isFinite(e)){const n=Math.abs(e),r=Math.log2||function(e){return Math.log(e)*Math.LOG2E};let i=Math.max(-1023,Math.floor(r(n))+1),o=n*Math.pow(2,-i);for(;o<.5;)o*=2,i--;for(;o>=1;)o*=.5,i++;e<0&&(o=-o),t[0]=o,t[1]=i}return t}(r);return r=256*i/r,[parseInt(e*r),parseInt(t*r),parseInt(n*r),parseInt(o+128)]}async function x(e){const t=await fetch(e),n=await t.arrayBuffer();console.time("Load hdr");for(var r=0,i=new Uint8Array(n),o="";!o.match(/\n\n[^\n]+\n/g);)o+=String.fromCharCode(i[r++]);var a=o.match(/FORMAT=(.*)$/m)[1];if("32-bit_rle_rgbe"!=a)return this.onerror(),console.warn("unknown format : "+a);var s=o.split(/\n/).reverse()[1].split(" "),l=parseInt(s[3]),c=parseInt(s[1]);const u=new Uint8Array(l*c*4);let h=0;const f=new Uint8Array(4*l);for(let e=0;e<c;e++){const e=i.subarray(r,r+=4);if(2!=e[0]||2!=e[1]||128&e[2]){let e=l,t=0;for(r-=4;e>0;)if(u.set(i.slice(r,r+=4),h),1==u[h]&&1==u[h+1]&&1==u[h+2]){for(u[h+3];d>0;d--)u.set(u.slice(h-4,h),h),h+=4,e--;t+=8}else e--,h+=4,t=0}else{if((e[2]<<8)+e[3]!=l)return void console.warn("HDR line mismatch ..");for(var d=0;d<4;d++){let e,t=d*l,n=(d+1)*l;for(;t<n;){let n=i[r],o=i[r+1];if(r+=2,n>128)e=n-128,f.fill(o,t,t+e),t+=e;else for(e=n-1,f[t++]=o;e-- >0;)f[t++]=i[r++]}}for(d=0;d<l;d++)u[h++]=f[d],u[h++]=f[d+l],u[h++]=f[d+2*l],u[h++]=f[d+3*l]}}return console.timeEnd("Load hdr"),{data:u,width:l,height:c}}var b=n(358);new m.Z,new m.Z,new m.Z,new m.Z,new m.Z,new m.Z,new m.Z(1,0,0),new m.Z(0,1,0),new m.Z(0,0,1),new m.Z,new m.Z;const T=new m.Z,E=new m.Z;function w(e,t){return t=t||new m.Z,m.Z.subtract(e[1],e[0],T),m.Z.subtract(e[2],e[0],E),m.Z.cross(T,E,t),m.Z.normalizeTo(t),t}const y=new m.Z;function _(e,t,n){return m.Z.dot(n,m.Z.subtract(e,t,y))}function R(){this.wrapMode=R.WrapModes.Clamp;var e=[],t=1/0,n=-1/0;this.addStage=function(r,i){e.some((e=>e.t==r))?console.warn("Time "+r+" already has a value!"):(e.push({t:r,value:i}),e.sort(((e,t)=>e.t-t.t)),t=Math.min(t,e[0].t),n=Math.max(n,e[e.length-1].t))};var r=e=>this.wrapMode==R.WrapModes.Clamp?(0,b.uZ)(e,t,n):this.wrapMode==R.WrapModes.Repeat?(0,b.wQ)(e-t,n-t)+t:(0,b.uZ)(e,t,n);this.getValue=function(t){if(0==e.length)return 0;t=r(t);for(var n=e[0],i=e[1],o=0;o<e.length;o++)t>=e[o].t&&(n=e[o],i=e[Math.min(e.length-1,o+1)]);var a=(0,b.ii)(n.t,i.t,t);return(0,b.t7)(n.value,i.value,a)}}function A(e,t){this.isEmpty=!e&&!t,this.bl=e??m.Z.zero(),this.tr=t??m.Z.zero();var n=m.Z.fill(1/0),r=m.Z.fill(-1/0);this.copy=function(e){let t=e||new A;return t.bl=m.Z.copy(this.bl),t.tr=m.Z.copy(this.tr),t.isEmpty=this.isEmpty,t},this.addPadding=function(e=0){this.bl.x-=e,this.bl.y-=e,this.bl.z-=e,this.tr.x+=e,this.tr.y+=e,this.tr.z+=e},this.extend=function(e){if(e instanceof A){var t=e;m.Z.compFunc(this.isEmpty?n:this.bl,t.bl,Math.min,this.bl),m.Z.compFunc(this.isEmpty?r:this.tr,t.tr,Math.max,this.tr)}else if(m.Z.isVectorIsh(e)){var i=e;m.Z.compFunc(this.isEmpty?n:this.bl,i,Math.min,this.bl),m.Z.compFunc(this.isEmpty?r:this.tr,i,Math.max,this.tr)}else this.addPadding(e);this.isEmpty=!1},this.pointInside=function(e){return e.x>=this.bl.x&&e.y>=this.bl.y&&e.z>=this.bl.z&&e.x<=this.tr.x&&e.y<=this.tr.y&&e.z<=this.tr.z},this.getVertices=function(){return[{x:this.bl.x,y:this.bl.y,z:this.bl.z},{x:this.tr.x,y:this.bl.y,z:this.bl.z},{x:this.tr.x,y:this.bl.y,z:this.tr.z},{x:this.bl.x,y:this.bl.y,z:this.tr.z},{x:this.bl.x,y:this.tr.y,z:this.bl.z},{x:this.tr.x,y:this.tr.y,z:this.bl.z},{x:this.tr.x,y:this.tr.y,z:this.tr.z},{x:this.bl.x,y:this.tr.y,z:this.tr.z}]},this.getEdges=function(){return[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]]};const i=new m.Z;this.getCenter=function(){return m.Z.average(this.tr,this.bl,i),m.Z.copy(i)};const o=new m.Z;this.getSize=function(){return m.Z.subtract(this.tr,this.bl,o),m.Z.copy(o)},this.translate=function(e){m.Z.addTo(this.bl,e),m.Z.addTo(this.tr,e)};const a=new m.Z;this.approxTransform=function(e){var t=this.getVertices();for(var n of(this.isEmpty=!0,m.Z.zero(this.bl),m.Z.zero(this.tr),t))v.Z.transformVector(e,n,a),this.extend(a);return this},this.isInsideFrustum=function(e){return this.isAbovePlane(e.leftPlane)&&this.isAbovePlane(e.rightPlane)&&this.isAbovePlane(e.nearPlane)&&this.isAbovePlane(e.farPlane)&&this.isAbovePlane(e.topPlane)&&this.isAbovePlane(e.bottomPlane)};const s=new m.Z;this.isAbovePlane=function(e){return m.Z.subtract(this.tr,this.bl,s),m.Z.divideTo(s,2),m.Z.average(this.tr,this.bl,i),-(s.x*Math.abs(e.normal.x)+s.y*Math.abs(e.normal.y)+s.z*Math.abs(e.normal.z))<=e.getSignedDistanceToPlane(i)}}function M(){this.events={},this.addEvent=this.on=function(e,t){if("function"!=typeof t)throw new Error("[EventHandler]: Not a function");this.events[e]?this.events[e].functions.push(t):this.events[e]={functions:[t]}},this.removeEvent=this.off=function(e,t){var n=this.events[e];if(n){var r=n.functions.indexOf(t);-1!==r&&n.functions.splice(r,1)}},this.fireEvent=function(e,...t){if(this.events[e]){for(var n of this.events[e].functions)n(...t);return!0}return!1}}R.WrapModes={Clamp:0,Repeat:1},A.bounds=function(e){for(var t=m.Z.fill(1/0),n=m.Z.fill(-1/0),r=0;r<e.length;r++){var i=e[r];t=m.Z.compFunc(t,i,Math.min),n=m.Z.compFunc(n,i,Math.max)}return new A(t,n)},new m.Z,new m.Z;const F=v.Z.identity(),C=new v.Z,D=new p.Z;function P(e,t,n,r){var i=this;this.gameObject=null,this.eventHandler=new M,this.on=this.eventHandler.on.bind(this.eventHandler),this._hasChanged={matrix:!1,worldMatrix:!1};var o=v.Z.identity(),a=v.Z.identity(),s=v.Z.identity(),l=v.Z.identity(),c=v.Z.identity(),u=t??m.Z.zero(),h=n??p.Z.identity(),f=r??m.Z.one(),d=R(u,w),g=R(h,(()=>{w()})),x=R(f,w),b=m.Z.copy(u),T=p.Z.copy(h),E=m.Z.copy(f);function w(){i.gameObject?(i.gameObject.traverse((e=>{e.transform._hasChanged.matrix=!0,e.transform._hasChanged.worldMatrix=!0})),i.gameObject.traverse((e=>{e.transform.eventHandler.fireEvent("transformChange")}))):(i._hasChanged.matrix=!0,i._hasChanged.worldMatrix=!0,i.eventHandler.fireEvent("transformChange"))}function y(){v.Z.translate(u,F),v.Z.multiply(F,l,F),v.Z.applyScale(f,F),_(F,!1)}function _(e,t=!0){v.Z.isNaN(e)?console.error("Matrix is NaN: ",e):(v.Z.copy(e,o),v.Z.getTranslationMatrix(o,s),v.Z.getRotationMatrix(o,l),v.Z.getScaleMatrix(o,c),t&&(v.Z.getPosition(o,d),p.Z.fromMatrix(o,g),v.Z.getScale(o,x),m.Z.set(b,d),p.Z.set(T,g),m.Z.set(E,x)),i.onUpdateMatrix?.(o))}function R(e,t=(()=>{})){return new Proxy(e,{set:function(e,n,r){if("x"==n||"y"==n||"z"==n||"w"==n){if(isNaN(r))return console.error("Proxy property "+n+" is NaN",e,n,r),!0;e[n]=r,t?.()}else e[n]=r;return!0},get:function(){return Reflect.get(...arguments)}})}null!=e?_(e):y(),this.set=function(e){this.matrix=e.matrix},Object.defineProperty(this,"position",{get:function(){return d},set:function(e){if(m.Z.isVectorIsh(e)){if(m.Z.equal(e,b))return;if(m.Z.isNaN(e))return void console.error("Position is NaN: ",e);d.x=e.x,d.y=e.y,d.z=e.z,m.Z.set(b,e)}else console.warn("Position is not vector",e)}}),Object.defineProperty(this,"worldPosition",{get:function(){return v.Z.getPosition(i.worldMatrix)},set:e=>{m.Z.isVectorIsh(e)?m.Z.isNaN(e)?console.error("Position is NaN: ",e):this.gameObject&&this.gameObject.parent?(v.Z.inverse(this.gameObject.parent.transform.worldMatrix,C),v.Z.transformVector(C,e,this.position)):this.position=e:console.warn("World position is not vector",e)}}),Object.defineProperty(this,"rotation",{get:function(){return g},set:function(e){if(p.Z.isQuaternionIsh(e)){if(p.Z.equal(e,T))return;if(p.Z.isNaN(e))return void console.error("Rotation is NaN: ",e);g.x=e.x,g.y=e.y,g.z=e.z,g.w=e.w,v.Z.fromQuaternion(h,l),p.Z.set(T,e)}else console.warn("Rotation is not quaternion",e)}}),Object.defineProperty(this,"worldRotation",{get:function(){return p.Z.fromMatrix(a)},set:e=>{p.Z.isQuaternionIsh(e)?p.Z.isNaN(e)?console.error("World rotation is NaN: ",e):this.gameObject&&this.gameObject.parent?(p.Z.fromMatrix(this.gameObject.parent.transform.worldMatrix,D),p.Z.inverse(D,D),p.Z.QxQ(D,e,D),this.rotation=D):this.rotation=e:console.warn("World rotation is not quaternion",e)}}),Object.defineProperty(this,"scale",{get:function(){return x},set:function(e){if(m.Z.isVectorIsh(e)){if(m.Z.equal(e,E))return;if(m.Z.isNaN(e))return void console.error("Scale is NaN: ",e);x.x=e.x,x.y=e.y,x.z=e.z,m.Z.set(E,e)}else console.warn("Scale is not vector",e)}}),Object.defineProperty(this,"matrix",{get:function(){return i._hasChanged.matrix&&(i._hasChanged.matrix=!1,y()),o},set:function(e){w(),_(e)}}),Object.defineProperty(this,"worldMatrix",{get:function(){return i._hasChanged.worldMatrix&&(i._hasChanged.worldMatrix=!1,i.gameObject&&i.gameObject.parent?v.Z.multiply(i.gameObject.parent.transform.worldMatrix,i.matrix,a):v.Z.copy(i.matrix,a)),a},set:function(e){v.Z.isNaN(e)?console.error("World matrix is NaN: ",e):(v.Z.inverse(i.gameObject.parent.transform.worldMatrix,C),v.Z.multiply(C,e,i.matrix))}}),Object.defineProperty(this,"translationMatrix",{get:function(){return s}}),Object.defineProperty(this,"rotationMatrix",{get:function(){return l},set:function(e){v.Z.isNaN(e)?console.error("Rotation matrix is NaN: ",e):(w(),p.Z.fromMatrix(e,h),v.Z.copy(e,l))}}),Object.defineProperty(this,"scaleMatrix",{get:function(){return c}}),Object.defineProperty(this,"forward",{get:function(){return v.Z.getForward(i.worldMatrix)}}),Object.defineProperty(this,"up",{get:function(){return v.Z.getUp(i.worldMatrix)}}),this.getWorldMatrix=function(e){return this.gameObject&&this.gameObject.parent&&this.gameObject.parent!=e?v.Z.multiply(this.gameObject.parent.transform.getWorldMatrix(e),this.matrix):this.matrix}}function U(e="Unnamed",t={}){var n=this;this.name=e,this.children=N(t.children,[]),this.parent=null,this.transform=new P(t.matrix,t.position,t.rotation,t.scale),this.transform.gameObject=this,this.prevModelMatrix=v.Z.copy(this.transform.worldMatrix),this.isCulled=!1;var r=null,i=!0;let o=()=>{i=!0};this.getAABB=function(){return r},this.forceAABBUpdate=function(){this.meshRenderer&&this.meshRenderer.getAABB&&(r||(r=new A),this.meshRenderer.getAABB(r),this.meshRenderer instanceof ot.MeshInstanceRenderer||r.approxTransform(this.transform.worldMatrix),i=!1)},this.transform.on("transformChange",o),this.customData={},this.layer=1,this.visible=N(t.visible,!0),this.castShadows=N(t.castShadows,!0),this.receiveShadows=N(t.receiveShadows,!0),this.disableFrustumCulling=N(t.disableFrustumCulling,!1),this.runUpdate=N(t.runUpdate,!0),this.active=N(t.active,!0),this.animationController=null;var a,s,l=[];function c(e,t,n){e.parent&&e!=t&&(n.push(e.parent.children.indexOf(e)),c(e.parent,t,n))}Object.defineProperty(this,"meshRenderer",{get:function(){return s},set:function(e){s&&s.off("updateAABB",o),(s=e)&&s.materials&&(a=new Array(s.materials.length)),s&&s.on("updateAABB",o)}}),this.meshRenderer=N(t.meshRenderer,null),this.traverse=function(e){for(var t of(e(this),this.children))t.traverse(e)},this.traverseCondition=function(e,t=(()=>!0)){for(var n of(e(this),this.children))t(n)&&n.traverseCondition(e,t)},this.setReceiveShadows=function(e,t=!1){t?this.traverse((t=>{t.receiveShadows=e})):this.receiveShadows=e},this.setLayer=function(e,t=!1){t?this.traverse((t=>{t.layer=e})):this.layer=e},this.getComponents=function(){return l},this.addComponent=function(e){return e.gameObject=this,l.push(e),e.onAdd?.(this),e},this.removeComponent=function(e){return l.splice(l.indexOf(e),1),delete e.gameObject,e},this.findComponents=function(e){return l.filter((t=>t.componentType===e))},this.getComponent=function(e){return l.find((t=>t.componentType===e))},this.copy=function(e=!0){var t=new U(this.name+(e?" (Copy)":""));for(var r of(t.layer=this.layer,t.visible=this.visible,t.castShadows=this.castShadows,t.transform.matrix=n.transform.matrix,this.meshRenderer&&(t.meshRenderer=this.meshRenderer.copy()),this.animationController&&(t.animationController=this.animationController.copy()),l))r.copy?t.addComponent(r.copy(t)):t.addComponent(r);for(var i of this.children)t.addChild(i.copy(!1));var o=this,a=t;if(a.traverse((e=>{if(e!=a&&e.meshRenderer&&e.meshRenderer.skin){var t=[];for(var n of e.meshRenderer.skin.joints){let e=n.getHierarchyPath(o);t.push(a.getChildFromHierarchyPath(e))}var r=e.meshRenderer.skin,i=new(0,r.constructor)(t,r.inverseBindMatrixData),s=r.parentNode.getHierarchyPath(o);i.parentNode=a.getChildFromHierarchyPath(s),e.meshRenderer.skin=i}})),o.animationController)for(var s=0;s<o.animationController.animations.length;s++)for(var c=o.animationController.animations[s],u=0;u<c.data.length;u++){var h=c.data[u].target.getHierarchyPath(o),f=a.getChildFromHierarchyPath(h);a.animationController.animations[s].data[u].target=f}return t},this.getChildrenWithCustomData=function(e){var t=[];return this.traverse((n=>{n.customData&&e in n.customData&&t.push(n)})),t},this.getChild=function(e,t=!1){var n;return t?(this.traverse((t=>{t.name.match(e)&&!n&&(n=t)})),n):this.children.find((t=>t.name.match(e)))},this.getChildren=function(e,t=!1,n=!0){if(t){var r=[];return this.traverse((t=>{(n&&t.name===e||!n&&-1!==t.name.indexOf(e))&&r.push(t)})),r}return this.children.every((t=>n&&t.name===e||!n&&-1!==t.name.indexOf(e)))},this.addChild=function(e){if(!(e instanceof U))throw console.error(e),new Error("Child is not GameObject");if(null==e.parent)return e.parent=this,this.children.push(e),e;throw new Error("Can't add child! Child already has parent")},this.add=this.addChild,this.addChildren=function(e){for(var t=0;t<e.length;t++)this.addChild(e[t]);return e},this.removeChild=function(e){var t=this.children.indexOf(e);-1!==t&&(e.parent=null,this.children.splice(t,1))},this.setParent=function(e){null!=this.parent&&this.parent.removeChild(this),this.parent=e,e.children.push(this)},this.delete=function(){this.parent.removeChild(this)},this.getChildFromHierarchyPath=function(e){var t=this;for(var n of e)t=t.children[n];return t},this.getHierarchyPath=function(e){var t=[];return c(this,e,t),t.reverse()},this.update=function(e){if(this.runUpdate&&this.active){for(var t of(i&&this.meshRenderer&&this.meshRenderer.getAABB&&(r||(r=new A),this.meshRenderer.getAABB(r),this.meshRenderer instanceof ot.MeshInstanceRenderer||r.approxTransform(this.transform.worldMatrix),i=!1),this.animationController&&this.animationController.update(e),this.meshRenderer?.update?.(e),l))t.update?.(e);for(var n=0;n<this.children.length;n++)this.children[n].update(e)}},this.render=function(e,t={}){if(this.visible&&this.active){var n=!!t.renderPass&&!!(d.SHADOWS&t.renderPass),r=!(t.renderPass&&d.ALPHA&t.renderPass),i=!!t.renderPass&&!!(d.DOWNSCALED&t.renderPass);if(n&&!this.castShadows)return;if((e.layer??65535)&this.layer){if(this.meshRenderer&&(!n||this.castShadows)&&!this.isCulled)if(t.materialOverride){var o=t.materialOverride;this.meshRenderer instanceof ot.MeshInstanceRenderer?o=t.materialOverrideInstanced:this.meshRenderer instanceof ot.SkinnedMeshRenderer&&(o=t.materialOverrideSkinned);for(let e=0;e<this.meshRenderer.materials.length;e++)a[e]=this.meshRenderer.materials[e].programContainer,this.meshRenderer.materials[e].programContainer=o.programContainer;this.meshRenderer.render(e,this.transform.worldMatrix,n,r,this.prevModelMatrix);for(let e=0;e<this.meshRenderer.materials.length;e++)this.meshRenderer.materials[e].programContainer=a[e]}else this.meshRenderer.render(e,this.transform.worldMatrix,n,r,this.prevModelMatrix,{downscaledPass:i,shadowQuality:this.receiveShadows?2:0});for(var s of l)s.render?.(e,this.transform.worldMatrix,n,r,this.prevModelMatrix,{downscaledPass:i})}for(var c=0;c<this.children.length;c++)this.children[c].render(e,t);n||this.isCulled||this.updatePrevModelMatrix()}},this.updatePrevModelMatrix=function(){v.Z.copy(this.transform.worldMatrix,this.prevModelMatrix)},this.getChildStructure=function(e=0,t=[]){var n=this.name;this.visible||(n+=" (Not visible)"),this.active||(n+=" (Not active)"),(this.children.length>0||this.getComponents().length>0)&&(n+="\n");var r=[];for(let e=0;e<this.getComponents().length;e++){var i=this.getComponents()[e],o=e==this.getComponents().length-1&&0==this.children.length;let n="";for(let e=0;e<t.length;e++)n+=t[e]?"   ":"|  ";n+=o?"":"";let a=n+"(COMPONENT) "+i.componentType??`No type: ${i.constructor.name}`;r.push(a)}for(let n=0;n<this.children.length;n++){var a=n==this.children.length-1,s="";for(let e=0;e<t.length;e++)s+=t[e]?"   ":"|  ";s+=a?"":"";var l=[...t];l.push(a),r.push(s+this.children[n].getChildStructure(e+1,l))}return n+=r.join("\n"),1!=e||t[t.length-1]||(n+="\n|"),n}}function N(e,t){return void 0===e?t:e}function S(e={}){this.exposure=e.exposure??0,this.gamma=e.gamma??2.2,this.tonemapping=e.tonemapping??S.TONEMAPPING.ACES,this.motionBlurStrength=e.motionBlurStrength??.2,this.saturation=e.saturation??0,this.contrast=e.contrast??0,this.vignette=e.vignette??new L,this.whiteBalance=e.whiteBalance??new B}function B(e={}){this.temperature=e.temperature??0,this.tint=e.tint??0}function L(e={}){this.amount=e.amount??.2,this.falloff=e.falloff??.3}function z(e={}){this.enabled=e.enabled??!0,this.sampleScale=e.sampleScale??1,this.threshold=e.threshold??1,this.knee=e.knee??.5,this.clamp=e.clamp??100,this.intensity=e.intensity??.05}S.TONEMAPPING={NONE:0,ACES:1,REINHARD:2};class I{constructor(e,t={}){if("object"!=typeof t||null===t||Array.isArray(t))throw new Error("Uniforms is not a dictionary (object)");if(null!==e&&!(e instanceof ot.ProgramContainer))throw new Error("Could not create material. Not a program container: "+e);this.programContainer=e,null===e&&console.warn("Program container is null"),this.name="No name",this.doubleSided=!1,this.doubleSidedShadows=!0,this.uniforms=t,this.opaque=!0}setUniform(e,t){this.programContainer&&!this.programContainer.activeUniforms[e]&&console.warn("[setUniform] Uniform does not exist on current shader-program: "+e),this.uniforms[e]=t}getUniform(e){return this.uniforms[e]}isOpaque(){return this.opaque}getUniformLocation(e){if(!this.programContainer)throw new Error("Material does not have a program container associated with it");return this.programContainer.getUniformLocation(e)}copy(){return O.call(this,I)}}class Z extends I{constructor(e,t={}){super(e,t),this.isLit=!0,this.uniforms.albedo=this.uniforms.albedo??[1,1,1,1],this.uniforms.emissiveFactor=this.uniforms.emissiveFactor??[0,0,0],this.uniforms.metallic=this.uniforms.metallic??0,this.uniforms.roughness=this.uniforms.roughness??1,this.uniforms.alphaCutoff=this.uniforms.alphaCutoff??.5,this.uniforms.doNoTiling=this.uniforms.doNoTiling??!1,this.uniforms.normalStrength=this.uniforms.normalStrength??1,this.uniforms.useVertexColor=this.uniforms.useVertexColor??!0,this.uniforms.useTexture=!!this.uniforms.albedoTexture,this.uniforms.useNormalTexture=!!this.uniforms.normalTexture,this.uniforms.useMetallicRoughnessTexture=!!this.uniforms.metallicRoughnessTexture,this.uniforms.useEmissiveTexture=!!this.uniforms.emissiveTexture,this.uniforms.useOcclusionTexture=!!this.uniforms.occlusionTexture,"opaque"in this.uniforms&&(this.opaque=!!this.uniforms.opaque,delete this.uniforms.opaque)}setUniform(e,t){super.setUniform(e,t),"albedoTexture"==e?this.uniforms.useTexture=!!t:"normalTexture"==e?this.uniforms.useNormalTexture=!!t:"metallicRoughnessTexture"==e?this.uniforms.useMetallicRoughnessTexture=!!t:"emissiveTexture"==e?this.uniforms.useEmissiveTexture=!!t:"occlusionTexture"==e&&(this.uniforms.useOcclusionTexture=!!t)}copy(){return O.call(this,Z)}}function O(e){var t={};for(var n in this.uniforms){let e=this.uniforms[n];e instanceof WebGLTexture?t[n]=e:t[n]=void 0===e?e:JSON.parse(JSON.stringify(e))}var r=new e(this.programContainer,t);return r.name=this.name,r.doubleSided=this.doubleSided,r.doubleSidedShadows=this.doubleSidedShadows,r.opaque=this.opaque,r}function V(e){this.renderer=null,this.name=e,this.root=new U("root"),this.sunDirection=m.Z.normalize({x:-.8,y:1.3,z:1.2}),this.sunIntensity=m.Z.multiply(new m.Z(1,.9,.85),5),this.skyboxAnimation=new X,this.skyboxVisible=!0,this.smoothSkybox=!1,this.environmentIntensity=1,this.environmentMinLight=.25,this.ambientColor=[0,0,0],this.skyboxFogIntensity=.8,this.fogDensity=.0035,this.fogColor=[.23,.24,.26,1],this.shadowQuality=2,this.postprocessing=new S,this.bloom=new z;var t=[];this.setupUBO=function(){var e=this.renderer.programContainers.lit.uniformBuffers.sharedPerScene;if(e){this.sharedUBO=new this.renderer.UniformBuffer(this.renderer.UBOLocationCounter++,e.blockSize);var t=this.renderer.gl;t.bindBuffer(t.UNIFORM_BUFFER,this.sharedUBO.buffer),t.bufferSubData(t.UNIFORM_BUFFER,e.offsets[3],new Float32Array([this.renderer.shadowCascades.shadowmaps[1].bias]),0),t.bufferSubData(t.UNIFORM_BUFFER,e.offsets[3]+16,new Float32Array([this.renderer.shadowCascades.shadowmaps[0].bias]),0)}},this.updateUniformBuffers=function(e,t,n){if(this.sharedUBO){var r=this.renderer.programContainers.lit.uniformBuffers.sharedPerScene,i=this.renderer.gl;i.bindBuffer(i.UNIFORM_BUFFER,this.sharedUBO.buffer),i.bufferSubData(i.UNIFORM_BUFFER,r.offsets[0],e,0),i.bufferSubData(i.UNIFORM_BUFFER,r.offsets[1],t,0),i.bufferSubData(i.UNIFORM_BUFFER,r.offsets[2],n,0)}},this.loadEnvironment=async function(e={}){if(this.renderer){this.specularCubemap=null;var t=e.res??1024;if(e.hdr)this.skyboxCubemap=await this.renderer.createCubemapFromHDR(e.hdr,t),console.warn("No prebaked diffuse map. Generating one..."),this.diffuseCubemap=await this.renderer.getDiffuseCubemap(this.skyboxCubemap);else if(e.hdrFolder){var n=e.hdrFolder;this.skyboxCubemap=await this.renderer.createCubemapFromHDR(n+"/skybox.hdr",t);try{this.diffuseCubemap=await this.renderer.createCubemapFromHDR(n+"/diffuse.hdr",32)}catch(e){console.warn("No prebaked diffuse map. Generating one..."),this.diffuseCubemap=await this.renderer.getDiffuseCubemap(this.skyboxCubemap)}try{this.renderer.version,this.specularCubemap=await this.renderer.createSpecularCubemapFromHDR(n,t)}catch(e){console.error(e),console.warn("No prebaked specular map. Generating one...")}}else if(e.cubemap)this.skyboxCubemap=e.cubemap,this.diffuseCubemap=await this.renderer.getDiffuseCubemap(this.skyboxCubemap);else{var r=new this.renderer.ProgramContainer(await this.renderer.createProgramFromFile(this.renderer.path+`assets/shaders/built-in/webgl${this.renderer.version}/procedualSkybox`)),i=new I(r,{sunDirection:m.Z.toArray(this.sunDirection)});this.skyboxCubemap=await this.renderer.createCubemapFromCube(i,t),this.diffuseCubemap=await this.renderer.getDiffuseCubemap(this.skyboxCubemap)}return this.specularCubemap||(this.specularCubemap=await this.renderer.getSpecularCubemap(this.skyboxCubemap)),this.smoothSkybox&&(this.skyboxCubemap=this.diffuseCubemap),!0}return console.error("Add scene to renderer before loading environment"),!1},this.copyEnvironment=function(e){this.skyboxCubemap=e.skyboxCubemap,this.diffuseCubemap=e.diffuseCubemap,this.specularCubemap=e.specularCubemap},this.add=function(e){return Array.isArray(e)?this.root.addChildren(e):this.root.addChild(e)},this.remove=function(e){if(Array.isArray(e))for(var t of e)this.root.removeChild(t);else this.root.removeChild(e)},this.update=function(e){this.updateLights(),this.root.update(e)},this.render=function(){this.renderer.currentBoundLitPrograms=new WeakMap,this.root.render(...arguments)},this.getLights=function(){return t},this.updateLights=function(){return t=[],this.root.traverseCondition((e=>{let n=e.getComponents();for(var r of n)"Light"==r.componentType&&t.push({type:r.type,position:v.Z.getPosition(e.transform.worldMatrix),direction:v.Z.getForward(e.transform.worldMatrix),angle:r.angle,color:r.color})}),(e=>e.active&&e.visible)),!0}}function X(e={}){this.speed=e.speed??0,this.direction=e.direction??new m.Z(1,-.3,0)}function k(){this.componentType="Light",this.gameObject=null,this.angle=Math.PI/3,this.color=[1,.5,.1],this.type=0,this.kelvinToRgb=function(e,t=1){return k.kelvinToRgb(e,t)},this.copy=function(){var e=new k;return e.angle=this.angle,e.color=Array.from(this.color),e.type=this.type,e}}function G(e={}){var t=this;this.frustum=new j,this.transform=new P(null,e.position,e.rotation),this.layer=e.layer??65535,this.renderTexture=e.renderTexture??null;var n=v.Z.identity();this.prevViewMatrix=v.Z.identity(),this.aspect=1;var r=e.fov??45,i=e.near??.3,o=e.far??100,a=e.size??20;let s=null;function l(){v.Z.inverse(t.transform.matrix,n),t.updateFrustum()}this.updateFrustum=function(){if(v.Z.getPosition(this.transform.matrix,W),v.Z.getForward(this.transform.matrix,$),v.Z.getUp(this.transform.matrix,Y),v.Z.getRight(this.transform.matrix,q),m.Z.set(K,$),m.Z.multiplyTo(K,o),this.type==G.Type.Perspective){const e=o*Math.tan(r*Math.PI/180),t=e*this.aspect;m.Z.set(this.frustum.nearPlane.position,$),m.Z.multiplyTo(this.frustum.nearPlane.position,i),m.Z.addTo(this.frustum.nearPlane.position,W),m.Z.set(this.frustum.nearPlane.normal,$),m.Z.set(this.frustum.farPlane.position,K),m.Z.addTo(this.frustum.farPlane.position,W),m.Z.set(this.frustum.farPlane.normal,$),m.Z.negateTo(this.frustum.farPlane.normal),m.Z.set(this.frustum.rightPlane.position,W),m.Z.set(Q,q),m.Z.multiplyTo(Q,t),m.Z.subtractTo(Q,K),m.Z.cross(Q,Y,this.frustum.rightPlane.normal),m.Z.set(this.frustum.leftPlane.position,W),m.Z.set(Q,q),m.Z.multiplyTo(Q,t),m.Z.addTo(Q,K),m.Z.cross(Q,Y,this.frustum.leftPlane.normal),m.Z.set(this.frustum.topPlane.position,W),m.Z.set(Q,Y),m.Z.multiplyTo(Q,e),m.Z.subtractTo(Q,K),m.Z.cross(q,Q,this.frustum.topPlane.normal),m.Z.set(this.frustum.bottomPlane.position,W),m.Z.set(Q,Y),m.Z.multiplyTo(Q,e),m.Z.addTo(Q,K),m.Z.cross(q,Q,this.frustum.bottomPlane.normal),m.Z.normalizeTo(this.frustum.rightPlane.normal),m.Z.normalizeTo(this.frustum.leftPlane.normal),m.Z.normalizeTo(this.frustum.topPlane.normal),m.Z.normalizeTo(this.frustum.bottomPlane.normal),m.Z.negateTo(this.frustum.leftPlane.normal),m.Z.negateTo(this.frustum.rightPlane.normal),m.Z.negateTo(this.frustum.topPlane.normal),m.Z.negateTo(this.frustum.bottomPlane.normal)}else this.type==G.Type.Orthographic&&(m.Z.set(this.frustum.nearPlane.position,$),m.Z.multiplyTo(this.frustum.nearPlane.position,i),m.Z.addTo(this.frustum.nearPlane.position,W),m.Z.set(this.frustum.nearPlane.normal,$),m.Z.set(this.frustum.farPlane.position,K),m.Z.addTo(this.frustum.farPlane.position,W),m.Z.set(this.frustum.farPlane.normal,$),m.Z.negateTo(this.frustum.farPlane.normal),m.Z.set(Q,q),m.Z.multiplyTo(Q,a),m.Z.addTo(Q,W),m.Z.set(this.frustum.rightPlane.position,Q),m.Z.set(this.frustum.rightPlane.normal,q),m.Z.negateTo(this.frustum.rightPlane.normal),m.Z.set(Q,q),m.Z.multiplyTo(Q,-a),m.Z.addTo(Q,W),m.Z.set(this.frustum.leftPlane.position,Q),m.Z.set(this.frustum.leftPlane.normal,q),m.Z.set(Q,Y),m.Z.multiplyTo(Q,a),m.Z.addTo(Q,W),m.Z.set(this.frustum.topPlane.position,Q),m.Z.set(this.frustum.topPlane.normal,Y),m.Z.negateTo(this.frustum.topPlane.normal),m.Z.set(Q,Y),m.Z.multiplyTo(Q,-a),m.Z.addTo(Q,W),m.Z.set(this.frustum.bottomPlane.position,Q),m.Z.set(this.frustum.bottomPlane.normal,Y))},Object.defineProperty(this,"cameraMatrix",{get:function(){return t.transform.matrix}}),Object.defineProperty(this,"inverseViewMatrix",{get:function(){return t.transform.matrix}}),Object.defineProperty(this,"viewMatrix",{get:function(){return(t.transform._hasChanged.matrix||t.transform._hasChanged.worldMatrix)&&v.Z.inverse(t.transform.matrix,n),n}}),Object.defineProperty(this,"type",{get:function(){return s},set:function(e){s=e,this.type==G.Type.Perspective?this.projectionMatrix=v.Z.perspective({fov:r*Math.PI/180,aspect:this.aspect,near:i,far:o}):this.type==G.Type.Orthographic&&(this.projectionMatrix=v.Z.orthographic({size:a,near:i,far:o})),this.updateFrustum()}}),this.setAspect=function(e){this.type==G.Type.Perspective?(this.aspect=e,v.Z.perspective({fov:r*Math.PI/180,aspect:this.aspect,near:i,far:o},this.projectionMatrix),this.updateFrustum()):console.warn("Can't set aspect ratio of orthographic camera")},this.setFOV=function(e){this.type==G.Type.Perspective?e!=r&&(r=e,v.Z.setPerspectiveFov(this.projectionMatrix,this.aspect,r*Math.PI/180),this.updateFrustum()):console.warn("Can't set FOV of orthographic camera")},this.getFOV=function(){return this.type==G.Type.Orthographic&&console.error("Orthographic camera does not use FOV"),r},this.screenToWorldRay=function(e,t){const n=e-.5,r=t-.5;if(this.type===G.Type.Orthographic){const e=new m.Z(n*a*2,-r*a*2,0),t=v.Z.transformDirection(this.transform.rotationMatrix,e);return m.Z.addTo(t,this.transform.position),{origin:t,direction:this.transform.forward}}if(this.type===G.Type.Perspective){const e=this.getFOV()*Math.PI/180,t=2*Math.tan(e),i=new m.Z(n*t*this.aspect,-r*t,-1);console.log(this.aspect);const o=v.Z.transformDirection(this.transform.rotationMatrix,i);return m.Z.normalizeTo(o),{origin:m.Z.copy(this.transform.position),direction:o}}throw new Error("Can't find ray with camera type "+this.type)},this.type=e.type??G.Type.Perspective,this.transform.onUpdateMatrix=l,l()}function j(){this.topPlane=new H,this.bottomPlane=new H,this.rightPlane=new H,this.leftPlane=new H,this.farPlane=new H,this.nearPlane=new H}function H(){this.normal=new m.Z,this.position=new m.Z,this.getSignedDistanceToPlane=function(e){return m.Z.dot(this.normal,m.Z.subtract(e,this.position,Q))}}k.kelvinToRgb=function(e,t=1){var n=[0,0,0];if((e=(0,b.uZ)(e,1e3,4e4)/100)<=66)n[0]=1,n[1]=(0,b.uZ)(.3900815787690196*Math.log(e)-.6318414437886274,0,1);else{var r=e-60;n[0]=(0,b.uZ)(1.292936186062745*Math.pow(r,-.1332047592),0,1),n[1]=(0,b.uZ)(1.129890860895294*Math.pow(r,-.0755148492),0,1)}return n[2]=e>66?1:e<=19?0:(0,b.uZ)(.543206789110196*Math.log(e-10)-1.19625408914,0,1),n[0]*=t,n[1]*=t,n[2]*=t,n},G.Type={Perspective:0,Orthographic:1};const W=new m.Z,$=new m.Z,Y=new m.Z,q=new m.Z,K=new m.Z,Q=new m.Z;function J(e=[]){this.x=0,this.y=0,this.z=0,this.blendCoords=e,this.getWeight=function(e){var t=this.blendCoords.find((t=>t.animation==e));if(t){var n=m.Z.distance(new m.Z(this.x,this.y,this.z),t.coords);return(0,b.uZ)(1-n,0,1)/this.getWeightSum()}return 0},this.getWeightSum=function(){var e=0;for(var t of this.blendCoords){var n=m.Z.distance(new m.Z(this.x,this.y,this.z),t.coords);e+=(0,b.uZ)(1-n,0,1)}return e}}function ee(e="Unnamed animation",t=[],n){if(this.name=e,this.data=t,this.speed=1,null==n)if(this.data.length>0){var r=0;for(var i of this.data){var o=i.inputBuffer[i.inputBuffer.length-1];o>r&&(r=o)}this.length=r}else this.length=4;else this.length=n;this.copy=function(){var e=[];for(var t of this.data)e.push({...t});var n=new ee(this.name+" (Copy)",e,this.length);return n.speed=this.speed,n},this.transfer=function(e,t){for(var n of this.data)n.target=t.getChild(n.target.name,!0)}}function te(e=[]){function t(e,t,n,r,i="LINEAR"){var o=e.outputBuffer[t],a=e.outputBuffer[n];if("LINEAR"==i)return m.Z.lerp(o,a,r);if("STEP"==i)return m.Z.copy(a);if("CUBICSPLINE"==i&&e.inputTangents&&e.outputTangents){var s=e.inputBuffer[t]-e.inputBuffer[n];return function(e,t,n,r,i){var o=i*i,a=o*i,s=m.Z.multiply(e,2*a-3*o+1),l=m.Z.multiply(t,a-2*o+i),c=m.Z.multiply(n,-2*a+3*o),u=m.Z.multiply(r,a-o);return m.Z.add(m.Z.add(s,l),m.Z.add(c,u))}(a,m.Z.multiply(e.inputTangents[t],s),o,m.Z.multiply(e.outputTangents[t],s),r=1-r)}return m.Z.zero()}function n(e,t,n,r,i="LINEAR"){var o=e.outputBuffer[t],a=e.outputBuffer[n];if("LINEAR"==i)return p.Z.slerp(o,a,r);if("STEP"==i)return p.Z.copy(a);if("CUBICSPLINE"==i&&e.inputTangents&&e.outputTangents){var s=e.inputBuffer[t]-e.inputBuffer[n];return function(e,t,n,r,i){var o=i*i,a=o*i,s=p.Z.multiply(e,2*a-3*o+1),l=p.Z.multiply(t,a-2*o+i),c=p.Z.multiply(n,-2*a+3*o),u=p.Z.multiply(r,a-o);return p.Z.add(p.Z.add(s,l),p.Z.add(c,u))}(a,p.Z.multiply(e.inputTangents[t],s),o,p.Z.multiply(e.outputTangents[t],s),r=1-r)}return p.Z.identity()}this.animations=e,this.speed=1,this.loop=!1,this.animationTimes=new WeakMap,this.weightsHandler=new function(){this.weights=new WeakMap,this.getWeight=function(e){var t=this.weights.get(e);return void 0!==t?t:0}},this.copy=function(){var e=new te;e.speed=this.speed,e.loop=this.loop,this.weightsHandler instanceof J&&(e.weightsHandler=new J);for(let t of this.animations){let n=t.copy();e.animationTimes.set(n,this.animationTimes.get(t)),e.animations.push(n),this.weightsHandler.weights&&e.weightsHandler.weights.set(n,this.weightsHandler.weights.get(t)??0),this.weightsHandler instanceof J&&e.weightsHandler.blendCoords.push({animation:n,coords:this.weightsHandler.blendCoords.find((e=>e.animation==t)).coords})}return e},this.update=function(e){var t=new WeakMap,n=[];for(var r of this.animations){var i=(this.animationTimes.get(r)??0)+e*this.speed*r.speed;this.loop&&(i%=r.length)<0&&(i=r.length+i),this.animationTimes.set(r,i);var o=this.weightsHandler.getWeight(r);if(o>.001&&(i<1.2*r.length||this.loop)){var a=this.getCurrentMatrices(r);for(var s of a){t.get(s.target)||(t.set(s.target,{position:[],rotation:[],scale:[],totalWeight:0}),n.push(s.target));var l=t.get(s.target),c=o;c>.001&&(s.translation&&l.position.push(m.Z.multiply(s.translation,c)),s.rotation&&l.rotation.push(p.Z.multiply(s.rotation,c)),s.scale&&l.scale.push(m.Z.multiply(s.scale,c)))}}}for(var u of n){var h=t.get(u);h.position.length>0&&(u.transform.position=h.position.reduce(((e,t)=>m.Z.add(e,t)),m.Z.zero())),h.rotation.length>0&&(u.transform.rotation=h.rotation.reduce(((e,t)=>p.Z.add(e,t)),p.Z.zero())),h.scale.length>0&&(u.transform.scale=h.scale.reduce(((e,t)=>m.Z.add(e,t)),m.Z.zero()))}},this.play=function(e){if(e instanceof ee)return this.animationTimes.set(e,0),void this.weightsHandler.weights.set(e,1);var t=e?.toLowerCase();for(var n of this.animations)null!=e&&-1==n.name.toLowerCase().indexOf(t)||(this.animationTimes.set(n,0),this.weightsHandler.weights.set(n,1))},this.getCurrentMatrices=function(e){var t=this.animationTimes.get(e)??0;return this.getStates(e,t)},this.getStates=function(e,r){for(var i=e.data,o=[],a=0;a<i.length;a++){var s=i[a],l={target:s.target},c=this.getClosestIndex(s.inputBuffer,r);"translation"==s.path?l.translation=t(s,c.indices[0],c.indices[1],c.lerpTime,s.interpolation):"rotation"==s.path?l.rotation=n(s,c.indices[0],c.indices[1],c.lerpTime,s.interpolation):"scale"==s.path&&(l.scale=t(s,c.indices[0],c.indices[1],c.lerpTime,s.interpolation)),o.push(l)}return o},this.getClosestIndex=function(e,t){for(var n=0;n<e.length;n++)if(t<e[n])return{indices:[n,Math.max(0,n-1)],lerpTime:(0,b.ii)(e[n],e[Math.max(0,n-1)],t)};return{indices:[e.length-1,e.length-1],lerpTime:0}}}var ne=n(453),re=ne.webgl2.lit.vertex,ie=`\n${ne.shaderBase}\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform vec4 albedo;\n\nuniform float alphaCutoff; // uniform alphaCutoff = 0.5;\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec3 vTangent;\nin vec3 vColor;\nin vec2 vUV;\n\nconst int levels = 2;\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n${ne.fogBase}\n\nvoid main() {\n  motionVector = vec2(0.5);\n\n  vec4 currentAlbedo = useTexture ? texture(albedoTexture, vUV) : vec4(1);\n  currentAlbedo *= albedo;\n  currentAlbedo.xyz *= vec3(1) - vColor.xyz;\n\n  if (currentAlbedo.a < alphaCutoff) {\n    discard;\n  }\n\n  #ifdef USEFOG\n    currentAlbedo = applyFog(currentAlbedo);\n  #endif\n\n  fragColor = currentAlbedo;\n}\n`,oe=`\n${ne.shaderBase}\n\nin vec3 position;\nin vec3 normal;\nin vec3 tangent;\nin vec4 color;\nin vec2 uv;\nin mat4 modelMatrix;\n\n// uniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\n\nconst int levels = 2;\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec3 vTangent;\nout vec4 vColor;\nout vec2 vUV;\n\nvoid main() {\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n  vPosition = vec3(modelMatrix * vec4(position, 1.0));\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n`,ae=`\n${ne.shaderBase}\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform vec4 albedo;\n\nuniform float alphaCutoff; // uniform alphaCutoff = 0.5;\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec3 vTangent;\nin vec4 vColor;\nin vec2 vUV;\n\nconst int levels = 2;\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n${ne.fogBase}\n\nvoid main() {\n  motionVector = vec2(0.5);\n  \n  vec4 currentAlbedo = useTexture ? texture(albedoTexture, vUV) : vec4(1);\n  currentAlbedo *= albedo;\n  currentAlbedo.xyz *= vec3(1) - vColor.xyz;\n\n  if (currentAlbedo.a < alphaCutoff) {\n    discard;\n  }\n\n  #ifdef USEFOG\n    currentAlbedo = applyFog(currentAlbedo);\n  #endif\n\n  fragColor = currentAlbedo;\n}\n`,se="\n",le="\n";re=re.trim(),ie=ie.trim(),oe=oe.trim(),ae=ae.trim();var ce={vertex:se=se.trim(),fragment:le=le.trim()},ue={unlit:{vertex:re,fragment:ie},unlitInstanced:{vertex:oe,fragment:ae}};let he="\n#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec3 tangent;\nin vec3 color;\nin vec2 uv;\nuniform mat4 modelMatrix;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec3 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat4 vModelMatrix;\nout mat3 vTBN;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  // float biases[levels];\n};\n\nvoid main() {\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n  vModelMatrix = modelMatrix;\n\n  vec3 center = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);\n  vec3 cameraRight = vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]);\n  vec3 cameraUp = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n  vec4 worldPosition = vec4(center + (cameraRight * position.x + cameraUp * position.y) * 0.5, 1);\n\n  vPosition = vec3(worldPosition); \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n",fe="\n#version 300 es\nprecision highp float;\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\nuniform sampler2D albedoTexture;\n\nin vec2 vUV;\n\nvoid main() {\n  fragColor = texture(albedoTexture, vUV);\n  motionVector = vec2(0.5);\n}\n";he=he.trim(),fe=fe.trim();let de={billboard:{vertex:he,fragment:fe}};var me={webgl1:{particle:{vertex:"\n        attribute vec3 position;\n        attribute vec3 normal;\n        attribute vec3 tangent;\n        attribute vec4 color;\n        attribute vec2 uv;\n        attribute mat4 modelMatrix;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        varying vec3 vNormal;\n        varying vec3 vTangent;\n        varying vec4 vColor;\n        varying vec2 vUV;\n\n        void main() {\n          vNormal = normal;\n          vTangent = tangent;\n          vUV = uv;\n          vColor = color;\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        uniform sampler2D albedoTexture;\n        uniform bool useTexture;\n        uniform vec4 albedo;\n\n        varying vec3 vNormal;\n        varying vec3 vTangent;\n        varying vec4 vColor;\n        varying vec2 vUV;\n\n        void main() {\n          vec4 currentAlbedo = useTexture ? texture2D(albedoTexture, vUV) : vec4(1);\n          currentAlbedo *= albedo;\n          currentAlbedo *= vColor;\n\n          gl_FragColor = currentAlbedo;\n        }\n      "}},webgl2:{particle:{vertex:"\n        #version 300 es\n\n        in vec3 position;\n        in vec3 normal;\n        in vec3 tangent;\n        in vec4 color;\n        in vec2 uv;\n        in mat4 modelMatrix;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        out vec3 vNormal;\n        out vec3 vTangent;\n        out vec4 vColor;\n        out vec2 vUV;\n\n        void main() {\n          vNormal = normal;\n          vTangent = tangent;\n          vUV = uv;\n          vColor = color;\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        layout (location = 0) out vec4 fragColor;\n        layout (location = 1) out vec2 motionVector;\n\n        uniform sampler2D albedoTexture;\n        uniform bool useTexture;\n        uniform vec4 albedo;\n\n        in vec3 vNormal;\n        in vec3 vTangent;\n        in vec4 vColor;\n        in vec2 vUV;\n\n        void main() {\n          vec4 currentAlbedo = useTexture ? texture(albedoTexture, vUV) : vec4(1);\n          currentAlbedo *= albedo;\n          currentAlbedo *= vColor;\n\n          fragColor = currentAlbedo;\n          motionVector = vec2(0.5);\n        }\n      "}}};(0,ne.trimStrings)(me);var ve=me.webgl1,pe=me.webgl2,ge={webgl1:{skybox:{vertex:"\n        attribute vec4 position;\n\n        varying vec4 vPosition;\n        \n        void main() {\n          vPosition = position;\n        \n          gl_Position = position;\n          gl_Position.z = 1.;\n        }\n      ",fragment:"\n        precision mediump float;\n\n        varying vec4 vPosition;\n        \n        uniform samplerCube skybox;\n        uniform mat4 viewDirectionProjectionInverse;\n\n        // #define USEFOG\n        const vec4 fogColor = vec4(0.23, 0.24, 0.26, 1);\n        \n        void main() {\n          vec4 t = viewDirectionProjectionInverse * vPosition;\n          vec3 col = textureCube(skybox, normalize(t.xyz / t.w)).rgb;\n        \n          #ifdef USEFOG\n            gl_FragColor = fogColor;\n          #else\n            gl_FragColor = vec4(col, 1);\n          #endif\n        }\n      "}},webgl2:{skybox:{vertex:"\n        #version 300 es\n        \n        in vec4 position;\n        \n        out vec4 vPosition;\n        \n        void main() {\n          vPosition = position;\n        \n          gl_Position = position;\n          gl_Position.z = 1.;\n        }\n      ",fragment:"\n        #version 300 es\n        precision mediump float;\n        \n        layout (location = 0) out vec4 fragColor;\n        layout (location = 1) out vec2 motionVector;\n        \n        in vec4 vPosition;\n        \n        uniform float environmentIntensity;\n        uniform samplerCube skybox;\n        uniform mat4 viewDirectionProjectionInverse;\n\n        uniform vec4 fogColor;\n        uniform float fogIntensity;\n\n        uniform float _SkyboxSpeed;\n        uniform vec3 _SkyboxDirection;\n        uniform float iTime;\n\n        vec4 flowUVW(vec3 dir, vec3 curl, float t, bool flowB) {\n          float phaseOffset = flowB ? 0.5f : 0.0f;\n          float progress = t + phaseOffset - floor(t + phaseOffset);\n          vec3 offset = curl * progress;\n\n          vec4 uvw = vec4(dir, 0.0f);\n          uvw.xz -= offset.xy;\n          uvw.w = 1. - abs(1.0f - 2.0f * progress);\n\n          return uvw;\n        }\n        \n        void main() {\n          motionVector = vec2(0.5);\n\n          vec4 proj = viewDirectionProjectionInverse * vPosition;\n          vec3 viewDir = normalize(proj.xyz / proj.w);\n\n          // vec3 col = texture(skybox, viewDir).rgb * environmentIntensity;\n\n          vec3 curl = normalize(_SkyboxDirection);\n          float t = iTime * _SkyboxSpeed;\n          vec4 uvw1 = flowUVW(viewDir, curl, t, false);\n          vec4 uvw2 = flowUVW(viewDir, curl, t, true);\n\n          vec3 sky = texture(skybox, uvw1.xyz).rgb * uvw1.w;\n          vec3 sky2 = texture(skybox, uvw2.xyz).rgb * uvw2.w;\n          vec3 col = (sky + sky2) * environmentIntensity;\n\n          // Fog\n          col = mix(col, fogColor.rgb, fogIntensity * clamp(1. - viewDir.y * 10., 0., 1.));\n\n          fragColor = vec4(col, 1);\n        }\n      "}}};(0,ne.trimStrings)(ge);var xe=ge.webgl1,be=ge.webgl2,Te={webgl2:{shadow:{vertex:"\n        attribute vec3 position;\n        attribute vec2 uv;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n        uniform mat4 modelMatrix;\n\n        varying vec2 vUV;\n\n        void main() {\n          vUV = uv;\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        varying vec2 vUV;\n\n        uniform sampler2D albedoTexture;\n        uniform bool useTexture;\n        uniform float alphaCutoff;\n\n        void main() {\n          if (useTexture && texture2D(albedoTexture, vUV).a < alphaCutoff) {\n            discard;\n          }\n\n          gl_FragColor = vec4(1, 0, 0, 1);\n        }\n      "},shadowInstanced:{vertex:"\n        attribute vec3 position;\n        attribute vec2 uv;\n        attribute mat4 modelMatrix;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        varying vec2 vUV;\n\n        void main() {\n          vUV = uv;\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n      ",fragment:null},shadowSkinned:{vertex:"\n        attribute vec3 position;\n        attribute vec2 uv;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n        uniform mat4 modelMatrix;\n\n        varying vec2 vUV;\n\n        //Skinning\n        attribute vec4 weights;\n        attribute vec4 joints;\n\n        uniform sampler2D u_jointTexture;\n        uniform float u_numJoints;\n\n        // these offsets assume the texture is 4 pixels across\n        #define ROW0_U ((0.5 + 0.0) / 4.)\n        #define ROW1_U ((0.5 + 1.0) / 4.)\n        #define ROW2_U ((0.5 + 2.0) / 4.)\n        #define ROW3_U ((0.5 + 3.0) / 4.)\n        \n        mat4 getBoneMatrix(float jointNdx) {\n          float v = (jointNdx + 0.5) / u_numJoints;\n          return mat4(\n            texture2D(u_jointTexture, vec2(ROW0_U, v)),\n            texture2D(u_jointTexture, vec2(ROW1_U, v)),\n            texture2D(u_jointTexture, vec2(ROW2_U, v)),\n            texture2D(u_jointTexture, vec2(ROW3_U, v))\n          );\n        }\n\n        void main() {\n          vUV = uv;\n\n          mat4 skinMatrix = getBoneMatrix(joints[0]) * weights[0] +\n                            getBoneMatrix(joints[1]) * weights[1] +\n                            getBoneMatrix(joints[2]) * weights[2] +\n                            getBoneMatrix(joints[3]) * weights[3];\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * skinMatrix * vec4(position, 1.0);\n        }\n      ",fragment:null}}};Te.webgl2.shadowInstanced.fragment=Te.webgl2.shadow.fragment,Te.webgl2.shadowSkinned.fragment=Te.webgl2.shadow.fragment,Te.webgl1={shadow:{vertex:Te.webgl2.shadow.vertex,fragment:Te.webgl2.shadow.fragment}},ne.trimStrings(Te);var Ee=Te.webgl1,we=Te.webgl2,ye={webgl2:{postprocessing:{vertex:"\n        #version 300 es\n\n        in vec2 position;\n\n        void main() {\n          gl_Position = vec4(position, 0.0, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        // #define DEBUG_COLOR\n        \n        out vec4 fragColor;\n\n        // uniform float iTime;\n        uniform vec2 SIZE;\n        uniform sampler2D mainTexture;\n        uniform sampler2D bloomTexture;\n        uniform sampler2D depthTexture;\n        uniform sampler2D motionBlurTexture;\n        uniform sampler2D downscaledTexture;\n        \n        uniform float bloomIntensity;\n        uniform float exposure;\n        uniform float gamma;\n        uniform float saturation;\n        uniform float contrast;\n        uniform float temperature;\n        uniform float tint;\n        uniform float vignetteFalloff;\n        uniform float vignetteAmount;\n        \n        #ifdef ENABLE_MOTIONBLUR\n        uniform float motionBlurStrength;\n        #endif\n\n        uniform sampler2D rainTexture;\n        \n        vec3 godrays(float density, float weight, float decay, float exposure, vec2 screenSpaceLightPos, vec2 uv);\n        vec3 ACESFilm(vec3 x);\n        float getHeight(vec2 uv);\n        vec3 adjustSaturation(vec3 color, float value);\n        vec3 adjustContrast(vec3 color, float value);\n\n        // White balance\n        vec3 whiteBalance(vec3 In, float Temperature, float Tint)\n        {\n          // Range ~[-1.67;1.67] works best\n          float t1 = Temperature * 10. / 6.;\n          float t2 = Tint * 10. / 6.;\n\n          // Get the CIE xy chromaticity of the reference white point.\n          // Note: 0.31271 = x value on the D65 white point\n          float x = 0.31271 - t1 * (t1 < 0. ? 0.1 : 0.05);\n          float standardIlluminantY = 2.87 * x - 3. * x * x - 0.27509507;\n          float y = standardIlluminantY + t2 * 0.05;\n\n          // Calculate the coefficients in the LMS space.\n          vec3 w1 = vec3(0.949237, 1.03542, 1.08728); // D65 white point\n\n          // CIExyToLMS\n          float Y = 1.;\n          float X = Y * x / y;\n          float Z = Y * (1. - x - y) / y;\n          float L = 0.7328 * X + 0.4296 * Y - 0.1624 * Z;\n          float M = -0.7036 * X + 1.6975 * Y + 0.0061 * Z;\n          float S = 0.0030 * X + 0.0136 * Y + 0.9834 * Z;\n          vec3 w2 = vec3(L, M, S);\n\n          vec3 balance = vec3(w1.x / w2.x, w1.y / w2.y, w1.z / w2.z);\n\n          mat3 LIN_2_LMS_MAT = mat3(\n            3.90405e-1, 5.49941e-1, 8.92632e-3,\n            7.08416e-2, 9.63172e-1, 1.35775e-3,\n            2.31082e-2, 1.28021e-1, 9.36245e-1\n          );\n\n          mat3 LMS_2_LIN_MAT = mat3(\n            2.85847e+0, -1.62879e+0, -2.48910e-2,\n            -2.10182e-1,  1.15820e+0,  3.24281e-4,\n            -4.18120e-2, -1.18169e-1,  1.06867e+0\n          );\n\n          vec3 lms = LIN_2_LMS_MAT * In;\n          lms *= balance;\n          vec3 Out = LMS_2_LIN_MAT * lms;\n\n          return Out;\n        }\n\n        // FXAA\n        #ifndef FXAA_REDUCE_MIN\n            #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n        #endif\n        #ifndef FXAA_REDUCE_MUL\n            #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n        #endif\n        #ifndef FXAA_SPAN_MAX\n            #define FXAA_SPAN_MAX     8.0\n        #endif\n\n        void texcoords(vec2 fragCoord, vec2 resolution,\n                       out vec2 v_rgbNW, out vec2 v_rgbNE,\n                       out vec2 v_rgbSW, out vec2 v_rgbSE,\n                       out vec2 v_rgbM);\n\n        vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n                  vec2 v_rgbNW, vec2 v_rgbNE, \n                  vec2 v_rgbSW, vec2 v_rgbSE, \n                  vec2 v_rgbM);\n\n        vec4 applyFXAA(sampler2D tex, vec2 fragCoord, vec2 resolution);\n\n        // DoF\n        #define MAX_BLUR 10.0\n\n        uniform float uFocusDistance;\n        uniform float uBlurCoefficient;\n        uniform float uPPM;\n        uniform vec2  uDepthRange;\n        uniform vec2 uResolution;\n        uniform vec2 uTexelOffset;\n        uniform sampler2D uDepth;\n\n        vec4 texture2D(sampler2D samp, vec2 uv) {\n          return texture(samp, uv);\n        }\n\n        // Raindrops\n\n        uniform float iTime;\n\n        #define S(x, y, z) smoothstep(x, y, z)\n        #define B(a, b, edge, t) S(a-edge, a+edge, t)*S(b+edge, b-edge, t)\n        #define sat(x) clamp(x,0.,1.)\n\n        #define streetLightCol vec3(1., .7, .3)\n        #define headLightCol vec3(.8, .8, 1.)\n        #define tailLightCol vec3(1., .1, .1)\n\n        #define HIGH_QUALITY\n        #define CAM_SHAKE 1.\n        #define LANE_BIAS .5\n        #define RAIN\n        //#define DROP_DEBUG\n\n        vec3 ro, rd;\n\n        float N(float t) {\n          return fract(sin(t*10234.324)*123423.23512);\n        }\n        vec3 N31(float p) {\n            //  3 out, 1 in... DAVE HOSKINS\n          vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n          p3 += dot(p3, p3.yzx + 19.19);\n          return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n        }\n        float N2(vec2 p)\n        {\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n          vec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n            p3 += dot(p3, p3.yzx + 19.19);\n            return fract((p3.x + p3.y) * p3.z);\n        }\n\n\n        float DistLine(vec3 ro, vec3 rd, vec3 p) {\n          return length(cross(p-ro, rd));\n        }\n        \n        vec3 ClosestPoint(vec3 ro, vec3 rd, vec3 p) {\n            // returns the closest point on ray r to point p\n            return ro + max(0., dot(p-ro, rd))*rd;\n        }\n\n        float Remap(float a, float b, float c, float d, float t) {\n          return ((t-a)/(b-a))*(d-c)+c;\n        }\n\n        float BokehMask(vec3 ro, vec3 rd, vec3 p, float size, float blur) {\n          float d = DistLine(ro, rd, p);\n            float m = S(size, size*(1.-blur), d);\n            \n            #ifdef HIGH_QUALITY\n            m *= mix(.7, 1., S(.8*size, size, d));\n            #endif\n            \n            return m;\n        }\n\n\n\n        float SawTooth(float t) {\n            return cos(t+cos(t))+sin(2.*t)*.2+sin(4.*t)*.02;\n        }\n\n        float DeltaSawTooth(float t) {\n            return 0.4*cos(2.*t)+0.08*cos(4.*t) - (1.-sin(t))*sin(t+cos(t));\n        }  \n\n        vec2 GetDrops(vec2 uv, float seed, float m) {\n            \n            float t = iTime+m*30.;\n            vec2 o = vec2(0.);\n            \n            #ifndef DROP_DEBUG\n            uv.y += t*.05;\n            #endif\n            \n            uv *= vec2(10., 2.5)*2.;\n            vec2 id = floor(uv);\n            vec3 n = N31(id.x + (id.y+seed)*546.3524);\n            vec2 bd = fract(uv);\n            \n            vec2 uv2 = bd;\n            \n            bd -= .5;\n            \n            bd.y*=4.;\n            \n            bd.x += (n.x-.5)*.6;\n            \n            t += n.z * 6.28;\n            float slide = SawTooth(t);\n            \n            float ts = 1.5;\n            vec2 trailPos = vec2(bd.x*ts, (fract(bd.y*ts*2.-t*2.)-.5)*.5);\n            \n            bd.y += slide*2.;\t\t\t\t\t\t\t\t// make drops slide down\n            \n            #ifdef HIGH_QUALITY\n            float dropShape = bd.x*bd.x;\n            dropShape *= DeltaSawTooth(t);\n            bd.y += dropShape;\t\t\t\t\t\t\t\t// change shape of drop when it is falling\n            #endif\n            \n            float d = length(bd);\t\t\t\t\t\t\t// distance to main drop\n            \n            float trailMask = S(-.2, .2, bd.y);\t\t\t\t// mask out drops that are below the main\n            trailMask *= bd.y;\t\t\t\t\t\t\t\t// fade dropsize\n            float td = length(trailPos*max(.5, trailMask));\t// distance to trail drops\n            \n            float mainDrop = S(.2, .1, d);\n            float dropTrail = S(.1, .02, td);\n            \n            dropTrail *= trailMask;\n            o = mix(bd*mainDrop, trailPos, dropTrail);\t\t// mix main drop and drop trail\n            \n            #ifdef DROP_DEBUG\n            if(uv2.x<.02 || uv2.y<.01) o = vec2(1.);\n            #endif\n            \n            return o;\n        }\n\n        vec2 rainEffect(vec2 uv) {\n          // vec3 f = normalize(lookat-ro);\n          // vec3 r = cross(vec3(0., 1., 0.), f);\n          // vec3 u = cross(f, r);\n\n          uv.x *= SIZE.x / SIZE.y;\n\n          float m = 0.;\n          float t = iTime;\n          vec2 offs = vec2(0.);\n\n          #ifdef RAIN\n          vec2 dropUv = uv;\n          \n          #ifdef HIGH_QUALITY\n          // float x = (sin(t*.1)*.5+.5)*.5;\n          // x = -x*x;\n          const float x = 0.2;\n          const float s = sin(x);\n          const float c = cos(x);\n          \n          const mat2 rot = mat2(c, -s, s, c);\n        \n          dropUv = uv*rot;\n          // dropUv.x += -sin(t*.1)*.5;\n          #endif\n          \n          offs = GetDrops(dropUv, 1., m);\n          \n          #ifndef DROP_DEBUG\n          offs += GetDrops(dropUv*1.4, 10., m);\n          #ifdef HIGH_QUALITY\n          // offs += GetDrops(dropUv*2.4, 25., m);\n          //offs += GetDrops(dropUv*3.4, 11.);\n          //offs += GetDrops(dropUv*3., 2.);\n          #endif\n          \n          // float ripple = sin(t+uv.y*3.1415*30.+uv.x*124.)*.5+.5;\n          // ripple *= .005;\n          // offs += vec2(ripple*ripple, ripple);\n          #endif\n          #endif\n\n          uv -= offs;\n          uv.x /= SIZE.x / SIZE.y;\n\n          return uv;\n        }\n        \n        void main() {\n          vec2 uv = gl_FragCoord.xy / SIZE;\n\n          #ifdef DEBUG_COLOR\n          fragColor = texture2D(mainTexture, uv);\n          return;\n          #endif\n        \n          // float stepSize = 0.02;\n          // float size = 2.; //?\n          // float s01 = getHeight(uv + vec2(-stepSize, 0));\n          // float s21 = getHeight(uv + vec2(stepSize, 0));\n          // float s10 = getHeight(uv + vec2(0, -stepSize));\n          // float s12 = getHeight(uv + vec2(0, stepSize));\n          // vec3 va = normalize(vec3(size, 0, s21 - s01));\n          // vec3 vb = normalize(vec3(0, size, s12 - s10));\n          // vec3 normal = cross(va, vb);\n        \n          // gl_FragColor = vec4(normal, 1);\n          // return;\n        \n          // Rain drops\n          // vec3 normal = texture(rainTexture, uv * 3.).rgb * 2. - 1.;\n          // float screenDistance = 0.07 * 0.5;\n          // vec2 uvOffset = normal.xy * screenDistance;\n          // uv += uvOffset;\n\n          // uv = rainEffect(uv);\n        \n          vec4 col = vec4(0);\n\n          // // DoF\n          // ivec2 fragCoord = ivec2(gl_FragCoord.xy);\n          // ivec2 resolution = ivec2(uResolution) - 1;\n\n          // // Convert to linear depth\n          // float ndc = 2.0 * texelFetch(uDepth, fragCoord, 0).r - 1.0;\n          // float depth = -(2.0 * uDepthRange.y * uDepthRange.x) / (ndc * (uDepthRange.y - uDepthRange.x) - uDepthRange.y - uDepthRange.x);\n          // float deltaDepth = abs(uFocusDistance - depth);\n          \n          // // Blur more quickly in the foreground.\n          // float xdd = depth < uFocusDistance ? abs(uFocusDistance - deltaDepth) : abs(uFocusDistance + deltaDepth);\n          // float blurRadius = min(floor(uBlurCoefficient * (deltaDepth / xdd) * uPPM), MAX_BLUR);\n          \n          // if (blurRadius > 1.0) {\n          //     float halfBlur = blurRadius * 0.5;\n\n          //     float count = 0.0;\n\n          //     // for (float i = 0.0; i <= MAX_BLUR; ++i) {\n          //     //     if (i > blurRadius) {\n          //     //         break;\n          //     //     }\n\n          //     //     // texelFetch outside texture gives vec4(0.0) (undefined in ES 3)\n          //     //     ivec2 sampleCoord = clamp(fragCoord + ivec2(((i - halfBlur) * uTexelOffset)), ivec2(0), resolution);\n          //     //     col += texelFetch(mainTexture, sampleCoord, 0);\n\n          //     //     ++count;\n          //     // }\n          //     for (float i = 0.0; i <= MAX_BLUR; ++i) {\n          //       if (i > blurRadius) {\n          //         break;\n          //       }\n\n          //       for (float j = 0.0; j <= MAX_BLUR; ++j) {\n          //         if (j > blurRadius) {\n          //           break;\n          //         }\n\n          //         // texelFetch outside texture gives vec4(0.0) (undefined in ES 3)\n          //         ivec2 sampleCoord = clamp(fragCoord + ivec2(i - halfBlur, j - halfBlur), ivec2(0), resolution);\n          //         col += texelFetch(mainTexture, sampleCoord, 0);\n          //         #ifdef ENABLE_BLOOM\n          //           vec4 bloom = texture2D(bloomTexture, vec2(sampleCoord) / vec2(resolution));\n          //           col.rgb += bloom.rgb * bloomIntensity;\n          //         #endif\n\n          //         ++count;\n          //       }\n          //     }\n\n          //     col /= count;\n          // } else {\n          //     col = texelFetch(mainTexture, fragCoord, 0);\n          // }\n\n          #ifdef ENABLE_MOTIONBLUR\n            const int nSamples = 32;\n            vec2 blurVec = motionBlurStrength * (texture2D(motionBlurTexture, uv).xy * 2. - 1.);\n            vec4 result = texture2D(mainTexture, uv);\n\n            for (int i = 1; i < nSamples; ++i) {\n              vec2 offset = blurVec * (float(i) / float(nSamples - 1) - 0.5);\n              result += texture2D(mainTexture, uv + offset);\n              // result += applyFXAA(mainTexture, (uv + offset) * SIZE, SIZE);\n            }\n            result /= float(nSamples);\n            col += result;\n          #else\n            vec4 samp = texture2D(mainTexture, uv);\n            // vec4 samp = applyFXAA(mainTexture, gl_FragCoord.xy, SIZE);\n            col += samp;\n          #endif\n\n          // Downscaled texture\n          vec4 downscaledCol = texture2D(downscaledTexture, uv);\n          col.rgb += downscaledCol.rgb;\n        \n          // Bloom\n          #ifdef ENABLE_BLOOM\n            vec4 bloom = texture2D(bloomTexture, uv);\n            col.rgb += bloom.rgb * bloomIntensity;\n          #endif\n        \n          // Godrays\n          #ifdef ENABLE_GODRAYS\n            col.rgb += godrays(1., 0.01, 0.97, 0.6, vec2(0.5, 0.5), uv);\n          #endif\n        \n          // Exposure correction\n          col.rgb = col.rgb * pow(2., exposure);\n        \n          // Tonemapping (HDR to LDR)\n          #ifdef TONEMAPPING\n            #if TONEMAPPING == 1\n              col.rgb = ACESFilm(col.rgb);\n            #elif TONEMAPPING == 2\n              col.rgb = col.rgb / (col.rgb + vec3(1.0));\n            #endif\n          #endif\n        \n          // // Gamma correction\n          // col.rgb = pow(col.rgb, vec3(1. / gamma));\n        \n          // Saturation, contrast\n          // #ifdef ENABLE_COLORGRADING\n          col.rgb = adjustSaturation(col.rgb, saturation);\n          col.rgb = adjustContrast(col.rgb, 1. + contrast);\n          // #endif\n\n          // White balance\n          col.rgb = whiteBalance(col.rgb, temperature, tint);\n\n          // Gamma correction\n          col.rgb = pow(col.rgb, vec3(1. / gamma));\n\n          // Vignette\n          float dist = distance(uv, vec2(0.5, 0.5));\n          col.rgb *= smoothstep(0.8, vignetteFalloff * 0.799, dist * (vignetteAmount + vignetteFalloff));\n        \n          fragColor = col;\n        }\n\n        vec4 applyFXAA(sampler2D tex, vec2 fragCoord, vec2 resolution) {\n          mediump vec2 v_rgbNW;\n          mediump vec2 v_rgbNE;\n          mediump vec2 v_rgbSW;\n          mediump vec2 v_rgbSE;\n          mediump vec2 v_rgbM;\n\n          //compute the texture coords\n          texcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n          \n          //compute FXAA\n          return fxaa(tex, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n        }\n\n        vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n                    vec2 v_rgbNW, vec2 v_rgbNE, \n                    vec2 v_rgbSW, vec2 v_rgbSE, \n                    vec2 v_rgbM) {\n            vec4 color;\n            mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n            vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n            vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n            vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n            vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n            vec4 texColor = texture2D(tex, v_rgbM);\n            vec3 rgbM  = texColor.xyz;\n            vec3 luma = vec3(0.299, 0.587, 0.114);\n            float lumaNW = dot(rgbNW, luma);\n            float lumaNE = dot(rgbNE, luma);\n            float lumaSW = dot(rgbSW, luma);\n            float lumaSE = dot(rgbSE, luma);\n            float lumaM  = dot(rgbM,  luma);\n            float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n            float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n            \n            mediump vec2 dir;\n            dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n            dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n            \n            float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                                  (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n            \n            float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n            dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n                      max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                      dir * rcpDirMin)) * inverseVP;\n            \n            vec3 rgbA = 0.5 * (\n                texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n            vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n            float lumaB = dot(rgbB, luma);\n            if ((lumaB < lumaMin) || (lumaB > lumaMax))\n                color = vec4(rgbA, texColor.a);\n            else\n                color = vec4(rgbB, texColor.a);\n            return color;\n        }\n\n        void texcoords(vec2 fragCoord, vec2 resolution,\n              out vec2 v_rgbNW, out vec2 v_rgbNE,\n              out vec2 v_rgbSW, out vec2 v_rgbSE,\n              out vec2 v_rgbM) {\n          vec2 inverseVP = 1.0 / resolution.xy;\n          v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n          v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n          v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n          v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n          v_rgbM = vec2(fragCoord * inverseVP);\n        }\n        \n        vec3 ACESFilm(vec3 x) {\n          float a = 2.51;\n          float b = 0.03;\n          float c = 2.43;\n          float d = 0.59;\n          float e = 0.14;\n          return clamp((x*(a*x+b))/(x*(c*x+d)+e), vec3(0.), vec3(1.));\n        }\n        \n        vec3 godrays(float density, float weight, float decay, float exposure, vec2 screenSpaceLightPos, vec2 uv) {\n          vec3 fragColor = vec3(0);\n        \n          vec2 deltaTextCoord = vec2(uv - screenSpaceLightPos.xy);\n          vec2 textCoo = uv.xy;\n          deltaTextCoord *= (1.0 /  float(100)) * density;\n          float illuminationDecay = 1.0;\n        \n          for (int i = 0; i < 100; i++){\n            textCoo -= deltaTextCoord;\n            vec3 samp = clamp(texture2D(depthTexture, textCoo).xyz, vec3(0.3), vec3(10)) - vec3(0.3);\n            samp *= illuminationDecay * weight;\n            fragColor += samp;\n            illuminationDecay *= decay;\n          }\n        \n          fragColor *= exposure;\n\n          return fragColor;\n        }\n        \n        float getHeight(vec2 uv) {\n          float y = 0.5 + 0.2 * sin(uv.x * 12.);\n          float d = abs(uv.y - y);\n          float falloff = 40.;\n          float thickness = 0.;\n          float height = 1. - clamp(d * falloff - thickness, 0., 1.);\n          return height;\n        }\n\n        vec4 sharpen(in sampler2D tex, in vec2 coords, in vec2 renderSize) {\n          float dx = 1.0 / renderSize.x;\n          float dy = 1.0 / renderSize.y;\n          vec4 sum = vec4(0.0);\n          sum += -1. * texture2D(tex, coords + vec2( -1.0 * dx , 0.0 * dy));\n          sum += -1. * texture2D(tex, coords + vec2( 0.0 * dx , -1.0 * dy));\n          sum += 5. * texture2D(tex, coords + vec2( 0.0 * dx , 0.0 * dy));\n          sum += -1. * texture2D(tex, coords + vec2( 0.0 * dx , 1.0 * dy));\n          sum += -1. * texture2D(tex, coords + vec2( 1.0 * dx , 0.0 * dy));\n          return sum;\n        }\n        \n        vec3 adjustSaturation(vec3 color, float value) {\n          // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance\n          const vec3 luminosityFactor = vec3(0.2126, 0.7152, 0.0722);\n          vec3 grayscale = vec3(dot(color, luminosityFactor));\n        \n          return mix(grayscale, color, 1.0 + value);\n        }\n\n        vec3 adjustContrast(vec3 color, float value) {\n          return 0.5 + value * (color - 0.5);\n        }\n      "}}};ye.webgl1={postprocessing:{vertex:ye.webgl2.postprocessing.vertex,fragment:ye.webgl2.postprocessing.fragment}},(0,ne.trimStrings)(ye);var _e=ye.webgl1,Re=ye.webgl2,Ae={webgl1:{bloom:{vertex:"\n        attribute vec2 position;\n\n        void main() {\n          gl_Position = vec4(position, 0.0, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        uniform vec2 screenSize;\n        uniform sampler2D mainTexture;\n        uniform vec2 mainTextureSize;\n        uniform sampler2D secondTexture;\n        uniform int stage;\n\n        #define EPSILON 1.0e-4\n\n        uniform float _SampleScale;\n        uniform float threshold;\n        uniform float knee;\n        uniform float _Clamp;\n\n        float Max3(float a, float b, float c)\n        {\n          return max(max(a, b), c);\n        }\n\n        vec4 QuadraticThreshold(vec4 color, float threshold, vec3 curve)\n        {\n            // Pixel brightness\n            float br = Max3(color.r, color.g, color.b);\n\n            // Under-threshold part: quadratic curve\n            float rq = clamp(br - curve.x, 0.0, curve.y);\n            rq = curve.z * rq * rq;\n\n            // Combine and apply the brightness response curve.\n            color *= max(rq, br - threshold) / max(br, EPSILON);\n\n            return color;\n        }\n\n        vec4 DownsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n        {\n            vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\n            vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\n            vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\n            vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\n            vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\n            vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\n            vec4 G = texture2D(tex, uv                               );\n            vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\n            vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\n            vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\n            vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\n            vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\n            vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\n\n            vec2 div = (1.0 / 4.0) * vec2(0.5, 0.125);\n\n            vec4 o = (D + E + I + J) * div.x;\n            o += (A + B + G + F) * div.y;\n            o += (B + C + H + G) * div.y;\n            o += (F + G + L + K) * div.y;\n            o += (G + H + M + L) * div.y;\n\n            return o;\n        }\n\n        // Standard box filtering\n        vec4 DownsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n        {\n            vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\n\n            vec4 s;\n            s =  (texture2D(tex, uv + d.xy));\n            s += (texture2D(tex, uv + d.zy));\n            s += (texture2D(tex, uv + d.xw));\n            s += (texture2D(tex, uv + d.zw));\n\n            return s * (1.0 / 4.0);\n        }\n\n        // 9-tap bilinear upsampler (tent filter)\n        vec4 UpsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n        {\n            vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\n\n            vec4 s;\n            s =  texture2D(tex, uv - d.xy);\n            s += texture2D(tex, uv - d.wy) * 2.0;\n            s += texture2D(tex, uv - d.zy);\n\n            s += texture2D(tex, uv + d.zw) * 2.0;\n            s += texture2D(tex, uv       ) * 4.0;\n            s += texture2D(tex, uv + d.xw) * 2.0;\n\n            s += texture2D(tex, uv + d.zy);\n            s += texture2D(tex, uv + d.wy) * 2.0;\n            s += texture2D(tex, uv + d.xy);\n\n            return s * (1.0 / 16.0);\n        }\n\n        // Standard box filtering\n        vec4 UpsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n        {\n            vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * (sampleScale * 0.5);\n\n            vec4 s;\n            s =  (texture2D(tex, uv + d.xy));\n            s += (texture2D(tex, uv + d.zy));\n            s += (texture2D(tex, uv + d.xw));\n            s += (texture2D(tex, uv + d.zw));\n\n            return s * (1.0 / 4.0);\n        }\n\n        vec4 SafeHDR(vec4 color) {\n          return color;\n        }\n\n        vec2 getTexelSize(sampler2D tex) {\n          return vec2(1.) / mainTextureSize;\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Prefilter\n\n        vec4 Prefilter(vec4 color, vec2 uv)\n        {\n            vec4 _Threshold = vec4(threshold, threshold - knee, knee * 2., 0.25 / knee); // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\n\n            color = min(vec4(_Clamp), color); // clamp to max\n            color = QuadraticThreshold(color, _Threshold.x, _Threshold.yzw);\n            return color;\n        }\n\n        vec4 FragPrefilter13(vec2 uv)\n        {\n            vec4 color = DownsampleBox13Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return Prefilter(SafeHDR(color), uv);\n        }\n\n        vec4 FragPrefilter4(vec2 uv)\n        {\n            vec4 color = DownsampleBox4Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return Prefilter(SafeHDR(color), uv);\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Downsample\n\n        vec4 FragDownsample13(vec2 uv)\n        {\n            vec4 color = DownsampleBox13Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return color;\n        }\n\n        vec4 FragDownsample4(vec2 uv)\n        {\n            vec4 color = DownsampleBox4Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return color;\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Upsample & combine\n\n        vec4 Combine(vec4 bloom, vec2 uv)\n        {\n            vec4 color = texture2D(secondTexture, uv);\n            return bloom + color;\n        }\n\n        vec4 FragUpsampleTent(vec2 uv)\n        {\n            vec4 bloom = UpsampleTent(mainTexture, uv, getTexelSize(mainTexture), vec4(_SampleScale));\n            return Combine(bloom, uv);\n        }\n\n        vec4 FragUpsampleBox(vec2 uv)\n        {\n            vec4 bloom = UpsampleBox(mainTexture, uv, getTexelSize(mainTexture), vec4(_SampleScale));\n            return Combine(bloom, uv);\n        }\n\n        void main() {\n          vec2 uv = gl_FragCoord.xy / screenSize;\n          vec3 col = texture2D(mainTexture, uv).rgb;\n          vec4 outCol = vec4(1, 0, 1, 1);\n\n          if (stage == 6) {\n            gl_FragColor = vec4(col, 1);\n            return;\n          }\n\n          if (stage == 0) {\n            outCol = FragPrefilter13(uv);\n          }\n          else if (stage == 1) {\n            outCol = FragDownsample13(uv);\n          }\n          else if (stage == 2) {\n            outCol = FragUpsampleTent(uv);\n          }\n\n          gl_FragColor = vec4(outCol.xyz, 1);\n        }\n      "}},webgl2:{bloom:{vertex:"\n        #version 300 es\n\n        in vec2 position;\n\n        void main() {\n          gl_Position = vec4(position, 0.0, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        layout (location = 0) out vec4 fragColor;\n\n        uniform vec2 screenSize;\n        uniform sampler2D mainTexture;\n        uniform sampler2D secondTexture;\n        uniform int stage;\n\n        #define EPSILON 1.0e-4\n\n        uniform float _SampleScale;\n        uniform float threshold;\n        uniform float knee;\n        uniform float _Clamp;\n\n        float Max3(float a, float b, float c)\n        {\n          return max(max(a, b), c);\n        }\n\n        vec4 QuadraticThreshold(vec4 color, float threshold, vec3 curve)\n        {\n            // Pixel brightness\n            float br = Max3(color.r, color.g, color.b);\n\n            // Under-threshold part: quadratic curve\n            float rq = clamp(br - curve.x, 0.0, curve.y);\n            rq = curve.z * rq * rq;\n\n            // Combine and apply the brightness response curve.\n            color *= max(rq, br - threshold) / max(br, EPSILON);\n\n            return color;\n        }\n\n        vec4 DownsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n        {\n            vec4 A = texture(tex, uv + texelSize * vec2(-1.0, -1.0));\n            vec4 B = texture(tex, uv + texelSize * vec2( 0.0, -1.0));\n            vec4 C = texture(tex, uv + texelSize * vec2( 1.0, -1.0));\n            vec4 D = texture(tex, uv + texelSize * vec2(-0.5, -0.5));\n            vec4 E = texture(tex, uv + texelSize * vec2( 0.5, -0.5));\n            vec4 F = texture(tex, uv + texelSize * vec2(-1.0,  0.0));\n            vec4 G = texture(tex, uv                               );\n            vec4 H = texture(tex, uv + texelSize * vec2( 1.0,  0.0));\n            vec4 I = texture(tex, uv + texelSize * vec2(-0.5,  0.5));\n            vec4 J = texture(tex, uv + texelSize * vec2( 0.5,  0.5));\n            vec4 K = texture(tex, uv + texelSize * vec2(-1.0,  1.0));\n            vec4 L = texture(tex, uv + texelSize * vec2( 0.0,  1.0));\n            vec4 M = texture(tex, uv + texelSize * vec2( 1.0,  1.0));\n\n            vec2 div = (1.0 / 4.0) * vec2(0.5, 0.125);\n\n            vec4 o = (D + E + I + J) * div.x;\n            o += (A + B + G + F) * div.y;\n            o += (B + C + H + G) * div.y;\n            o += (F + G + L + K) * div.y;\n            o += (G + H + M + L) * div.y;\n\n            return o;\n        }\n\n        // Standard box filtering\n        vec4 DownsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n        {\n            vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\n\n            vec4 s;\n            s =  (texture(tex, uv + d.xy));\n            s += (texture(tex, uv + d.zy));\n            s += (texture(tex, uv + d.xw));\n            s += (texture(tex, uv + d.zw));\n\n            return s * (1.0 / 4.0);\n        }\n\n        // 9-tap bilinear upsampler (tent filter)\n        vec4 UpsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n        {\n            vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\n\n            vec4 s;\n            s =  texture(tex, uv - d.xy);\n            s += texture(tex, uv - d.wy) * 2.0;\n            s += texture(tex, uv - d.zy);\n\n            s += texture(tex, uv + d.zw) * 2.0;\n            s += texture(tex, uv       ) * 4.0;\n            s += texture(tex, uv + d.xw) * 2.0;\n\n            s += texture(tex, uv + d.zy);\n            s += texture(tex, uv + d.wy) * 2.0;\n            s += texture(tex, uv + d.xy);\n\n            return s * (1.0 / 16.0);\n        }\n\n        // Standard box filtering\n        vec4 UpsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n        {\n            vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * (sampleScale * 0.5);\n\n            vec4 s;\n            s =  (texture(tex, uv + d.xy));\n            s += (texture(tex, uv + d.zy));\n            s += (texture(tex, uv + d.xw));\n            s += (texture(tex, uv + d.zw));\n\n            return s * (1.0 / 4.0);\n        }\n\n        vec4 SafeHDR(vec4 color) {\n          return color;\n        }\n\n        vec2 getTexelSize(sampler2D tex) {\n          return vec2(1.) / vec2(textureSize(tex, 0));\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Prefilter\n\n        vec4 Prefilter(vec4 color, vec2 uv)\n        {\n            vec4 _Threshold = vec4(threshold, threshold - knee, knee * 2., 0.25 / knee); // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\n\n            color = min(vec4(_Clamp), color); // clamp to max\n            color = QuadraticThreshold(color, _Threshold.x, _Threshold.yzw);\n            return color;\n        }\n\n        vec4 FragPrefilter13(vec2 uv)\n        {\n            vec4 color = DownsampleBox13Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return Prefilter(SafeHDR(color), uv);\n        }\n\n        vec4 FragPrefilter4(vec2 uv)\n        {\n            vec4 color = DownsampleBox4Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return Prefilter(SafeHDR(color), uv);\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Downsample\n\n        vec4 FragDownsample13(vec2 uv)\n        {\n            vec4 color = DownsampleBox13Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return color;\n        }\n\n        vec4 FragDownsample4(vec2 uv)\n        {\n            vec4 color = DownsampleBox4Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return color;\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Upsample & combine\n\n        vec4 Combine(vec4 bloom, vec2 uv)\n        {\n            vec4 color = texture(secondTexture, uv);\n            return bloom + color;\n        }\n\n        vec4 FragUpsampleTent(vec2 uv)\n        {\n            vec4 bloom = UpsampleTent(mainTexture, uv, getTexelSize(mainTexture), vec4(_SampleScale));\n            return Combine(bloom, uv);\n        }\n\n        vec4 FragUpsampleBox(vec2 uv)\n        {\n            vec4 bloom = UpsampleBox(mainTexture, uv, getTexelSize(mainTexture), vec4(_SampleScale));\n            return Combine(bloom, uv);\n        }\n\n        void main() {\n          vec2 uv = gl_FragCoord.xy / screenSize;\n          vec3 col = texture(mainTexture, uv).rgb;\n          vec4 outCol = vec4(1, 0, 1, 1);\n\n          if (stage == 6) {\n            fragColor = vec4(col, 1);\n            return;\n          }\n\n          // if (stage == 0) {\n          //   outCol = vec3(col.r, 0, 0);\n          // }\n          // else if (stage == 1) {\n          //   outCol = vec3(0, col.g, 0);\n          // }\n          // else if (stage == 2) {\n          //   outCol = vec3(0, 0, col.b);\n          // }\n          // else if (stage == 3) {\n          //   outCol = vec3(0, 0, 0);\n          // }\n\n          if (stage == 0) {\n            outCol = FragPrefilter13(uv);\n          }\n          // else if (stage == 1) {\n          //   outCol = FragPrefilter4(uv);\n          // }\n          else if (stage == 1) {\n            outCol = FragDownsample13(uv);\n          }\n          // else if (stage == 3) {\n          //   outCol = FragDownsample4(uv);\n          // }\n\n          else if (stage == 2) {\n            outCol = FragUpsampleTent(uv);\n          }\n          // else if (stage == 5) {\n          //   outCol = FragUpsampleBox(uv);\n          // }\n\n          fragColor = vec4(outCol.xyz, 1);\n        }\n      "}}};(0,ne.trimStrings)(Ae);var Me=Ae.webgl1,Fe=Ae.webgl2,Ce={webgl1:{equirectangularToCubemap:{vertex:"\n        attribute vec3 position;\n\n        varying vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main() {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        varying vec3 localPos;\n\n        uniform sampler2D equirectangularMap;\n\n        const vec2 invAtan = vec2(0.1591, 0.3183);\n        vec2 SampleSphericalMap(vec3 v) {\n            vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n\n        void main() {\n            vec2 uv = SampleSphericalMap(normalize(localPos)); // make sure to normalize localPos\n            vec3 color = texture2D(equirectangularMap, uv).rgb;\n            \n            gl_FragColor = vec4(color, 1.0);\n        }\n      "}},webgl2:{equirectangularToCubemap:{vertex:"\n        #version 300 es\n        layout (location = 0) in vec3 position;\n\n        out vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main()\n        {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        out vec4 FragColor;\n        in vec3 localPos;\n\n        uniform sampler2D equirectangularMap;\n\n        const vec2 invAtan = vec2(0.1591, 0.3183);\n        vec2 SampleSphericalMap(vec3 v)\n        {\n            vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n\n        void main()\n        {\n            vec2 uv = SampleSphericalMap(normalize(localPos)); // make sure to normalize localPos\n            vec4 color = texture(equirectangularMap, uv);\n            \n            color.rgb *= pow(2., color.a * 255. - (128. + 8.)) * 255.;\n\n            FragColor = vec4(color.rgb, 1.0);\n        }\n      "}}};(0,ne.trimStrings)(Ce);var De=Ce.webgl1,Pe=Ce.webgl2,Ue={webgl1:{diffuseCubemap:{vertex:"\n        attribute vec3 position;\n\n        varying vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main() {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        varying vec3 localPos;\n\n        uniform samplerCube environmentMap;\n\n        const float PI = 3.14159265359;\n\n        void main() {\t\t\n            // the sample direction equals the hemisphere's orientation \n            vec3 normal = normalize(localPos);\n          \n            vec3 irradiance = vec3(0.0);  \n\n            vec3 up = vec3(0.0, 1.0, 0.0);\n            vec3 right = normalize(cross(up, normal));\n            up = normalize(cross(normal, right));\n\n            const float sampleDelta = 0.025 / 3.;\n            float nrSamples = 0.0; \n            for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {\n                for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta) {\n                    // spherical to cartesian (in tangent space)\n                    vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n                    // tangent space to world\n                    vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal; \n\n                    irradiance += min(textureCube(environmentMap, sampleVec).rgb, vec3(3000)) * cos(theta) * sin(theta);\n                    nrSamples++;\n                }\n            }\n\n            irradiance = PI * irradiance * (1.0 / float(nrSamples));\n          \n            gl_FragColor = vec4(irradiance, 1.0);\n        }\n      "}},webgl2:{diffuseCubemap:{vertex:"\n        #version 300 es\n        layout (location = 0) in vec3 position;\n\n        out vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main()\n        {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        out vec4 FragColor;\n        in vec3 localPos;\n\n        uniform samplerCube environmentMap;\n        const vec3 maxBrightness = vec3(3000000);\n        const float sampleDelta = 0.025 / 3.;\n\n        const float PI = 3.14159265359;\n\n        void main() {\t\t\n            // the sample direction equals the hemisphere's orientation \n            vec3 normal = normalize(localPos);\n          \n            vec3 irradiance = vec3(0.0);  \n\n            vec3 up = vec3(0.0, 1.0, 0.0);\n            vec3 right = normalize(cross(up, normal));\n            up = normalize(cross(normal, right));\n\n            // FragColor = vec4(texture(environmentMap, normal).rgb, 1.0);\n            // return;\n\n            float nrSamples = 0.0; \n            for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {\n                for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta) {\n                    // spherical to cartesian (in tangent space)\n                    vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n                    // tangent space to world\n                    vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal; \n\n                    vec3 sampleColor = texture(environmentMap, sampleVec).rgb;\n                    // sampleColor = pow(sampleColor, vec3(2.2));\n\n                    irradiance += min(sampleColor, maxBrightness) * cos(theta) * sin(theta);\n                    nrSamples++;\n                }\n            }\n\n            irradiance = PI * irradiance * (1.0 / float(nrSamples));\n            // irradiance = pow(irradiance, vec3(1. / 2.2));\n          \n            FragColor = vec4(irradiance, 1.0);\n        }\n      "}}};(0,ne.trimStrings)(Ue);var Ne=Ue.webgl1,Se=Ue.webgl2,Be={webgl1:{specularCubemap:{vertex:"\n        attribute vec3 position;\n\n        varying vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main() {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        #extension GL_EXT_shader_texture_lod : enable\n        precision highp float;\n\n        #ifndef GL_EXT_shader_texture_lod\n        vec4 textureCubeLodEXT(samplerCube t, vec3 n, float lod) {\n          return textureCube(t, n);\n        }\n        #endif\n\n        varying vec3 localPos;\n\n        uniform samplerCube environmentMap;\n        uniform float roughness;\n\n        const float PI = 3.14159265359;\n\n        float VanDerCorput(int n, int base);\n        vec2 Hammersley(int i, int N);\n        vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);\n        float DistributionGGX(float NdotH, float roughness);\n        float saturate(float x);\n          \n        void main()\n        {\t\t\n            vec3 N = normalize(localPos);    \n            vec3 R = N;\n            vec3 V = R;\n\n            const int SAMPLE_COUNT = 512;\n            // const int SAMPLE_COUNT = 4096;\n\n            float totalWeight = 0.0;\n            vec3 prefilteredColor = vec3(0.0);\n\n            float resolution = 1024.0; // resolution of source cubemap (per face)\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n\n            for(int i = 0; i < SAMPLE_COUNT; ++i)\n            {\n                vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n                vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n                vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n                float NdotL = max(dot(N, L), 0.0);\n                if(NdotL > 0.0)\n                {\n                    float NdotH = saturate(dot(N, H));\n                    float HdotV = saturate(dot(H, V));\n\n                    float D   = DistributionGGX(NdotH, roughness);\n                    float pdf = (D * NdotH / (4.0 * HdotV)) + 0.0001; \n                    float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n                    float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); \n\n                    prefilteredColor += min(textureCubeLodEXT(environmentMap, L, mipLevel).rgb, vec3(100)) * NdotL;\n                    totalWeight      += NdotL;\n                }\n            }\n            prefilteredColor = prefilteredColor / totalWeight;\n\n            gl_FragColor = vec4(prefilteredColor, 1.0);\n        }\n\n        float VanDerCorput(int n, int base)\n        {\n            float invBase = 1.0 / float(base);\n            float denom   = 1.0;\n            float result  = 0.0;\n\n            for(int i = 0; i < 32; ++i)\n            {\n                if(n > 0)\n                {\n                    denom   = mod(float(n), 2.0);\n                    result += denom * invBase;\n                    invBase = invBase / 2.0;\n                    n       = int(float(n) / 2.0);\n                }\n            }\n\n            return result;\n        }\n        // ----------------------------------------------------------------------------\n        vec2 Hammersley(int i, int N)\n        {\n            return vec2(float(i)/float(N), VanDerCorput(i, 2));\n        }\n\n        vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n        {\n            float a = roughness*roughness;\n          \n            float phi = 2.0 * PI * Xi.x;\n            float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n            float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n          \n            // from spherical coordinates to cartesian coordinates\n            vec3 H;\n            H.x = cos(phi) * sinTheta;\n            H.y = sin(phi) * sinTheta;\n            H.z = cosTheta;\n          \n            // from tangent-space vector to world-space sample vector\n            vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n            vec3 tangent   = normalize(cross(up, N));\n            vec3 bitangent = cross(N, tangent);\n          \n            vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n            return normalize(sampleVec);\n        }\n\n        float DistributionGGX(float NdotH, float roughness)\n        {\n            float a      = roughness*roughness;\n            float a2     = a*a;\n            float NdotH2 = NdotH*NdotH;\n          \n            float nom   = a2;\n            float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n            denom = PI * denom * denom;\n          \n            return nom / denom;\n        }\n\n        float saturate(float x) {\n            return max(0., min(1., x));\n        }\n      "}},webgl2:{specularCubemap:{vertex:"\n        #version 300 es\n        layout (location = 0) in vec3 position;\n\n        out vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main()\n        {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        out vec4 FragColor;\n        in vec3 localPos;\n\n        uniform samplerCube environmentMap;\n        uniform float roughness;\n\n        const float PI = 3.14159265359;\n\n        float RadicalInverse_VdC(uint bits);\n        vec2 Hammersley(uint i, uint N);\n        vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);\n        float DistributionGGX(float NdotH, float roughness);\n        float saturate(float x);\n\n        // Settings\n        const uint SAMPLE_COUNT = 1024u;//4096u * 4u;\n        const vec3 maxBrightness = vec3(50);\n        // --------\n          \n        void main()\n        {\t\t\n            vec3 N = normalize(localPos);    \n            vec3 R = N;\n            vec3 V = R;\n\n            float totalWeight = 0.0;\n            vec3 prefilteredColor = vec3(0.0);\n\n            float resolution = float(textureSize(environmentMap, 0).x);//1024.0; // resolution of source cubemap (per face)\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n\n            for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n            {\n                vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n                vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n                vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n                float NdotL = max(dot(N, L), 0.0);\n                if(NdotL > 0.0)\n                {\n                    float NdotH = saturate(dot(N, H));\n                    float HdotV = saturate(dot(H, V));\n\n                    float D   = DistributionGGX(NdotH, roughness);\n                    float pdf = (D * NdotH / (4.0 * HdotV)) + 0.0001; \n                    float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n                    float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); \n\n                    prefilteredColor += min(textureLod(environmentMap, L, mipLevel).rgb, maxBrightness) * NdotL;\n                    totalWeight      += NdotL;\n                }\n            }\n            prefilteredColor = prefilteredColor / totalWeight;\n\n            FragColor = vec4(prefilteredColor, 1.0);\n        }\n\n        float RadicalInverse_VdC(uint bits) \n        {\n            bits = (bits << 16u) | (bits >> 16u);\n            bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n            bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n            bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n            bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n            return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n        }\n        // ----------------------------------------------------------------------------\n        vec2 Hammersley(uint i, uint N)\n        {\n            return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n        }\n\n        vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n        {\n            float a = roughness*roughness;\n          \n            float phi = 2.0 * PI * Xi.x;\n            float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n            float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n          \n            // from spherical coordinates to cartesian coordinates\n            vec3 H;\n            H.x = cos(phi) * sinTheta;\n            H.y = sin(phi) * sinTheta;\n            H.z = cosTheta;\n          \n            // from tangent-space vector to world-space sample vector\n            vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n            vec3 tangent   = normalize(cross(up, N));\n            vec3 bitangent = cross(N, tangent);\n          \n            vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n            return normalize(sampleVec);\n        }\n\n        float DistributionGGX(float NdotH, float roughness)\n        {\n            float a      = roughness*roughness;\n            float a2     = a*a;\n            float NdotH2 = NdotH*NdotH;\n          \n            float nom   = a2;\n            float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n            denom = PI * denom * denom;\n          \n            return nom / denom;\n        }\n\n        float saturate(float x) {\n            return max(0., min(1., x));\n        }\n      "}}};(0,ne.trimStrings)(Be);var Le=Be.webgl1,ze=Be.webgl2,Ie=n(283),Ze=`\n${Ie.AO}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent;\nin vec3 color;\nin vec2 uv;\n\nout vec4 vPosition;\nout vec3 vNormal;\nout vec4 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvoid main() {\n  vNormal = mat3(modelMatrix) * normal; // in world-space\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(normal, vTangent.xyz) * vTangent.w, 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  vPosition = worldPosition;\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n`,Oe=`\n${Ie.AO}\n\nlayout (location = 0) out vec4 gPosition;\nlayout (location = 1) out vec3 gNormal;\nlayout (location = 2) out vec3 gAlbedo;\nlayout (location = 3) out vec4 gProperties;\nlayout (location = 4) out vec4 gPositionViewSpace;\n\nin vec4 vPosition;\nin vec3 vNormal;\nin vec4 vTangent;\nin vec3 vColor;\nin vec2 vUV;\nin mat3 vTBN;\n\nuniform float enableMotionBlur;\n\n// Material properties\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform sampler2D normalTexture;\nuniform bool useNormalTexture;\nuniform sampler2D metallicRoughnessTexture;\nuniform bool useMetallicRoughnessTexture;\nuniform sampler2D emissiveTexture;\nuniform bool useEmissiveTexture;\nuniform sampler2D occlusionTexture;\nuniform bool useOcclusionTexture;\n\nuniform vec4 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform vec3 emissiveFactor;\nfloat ao = 1.;\n\nuniform float alphaCutoff;\nuniform float normalStrength;\n\nuniform mat4 viewMatrix;\n\nvec3 setNormalStrength(vec3 normal, float strength) {\n  return vec3(normal.xy * strength, mix(1., normal.z, clamp(strength, 0., 1.)));\n}\n\nvoid main() {\n  vec4 _albedo = albedo * (useTexture ? texture(albedoTexture, vUV) : vec4(1));\n  if (_albedo.a < alphaCutoff) {\n    discard;\n  }\n\n  gPosition = vec4(vPosition.xyz, 1);\n  gPositionViewSpace = viewMatrix * vPosition;\n\n  if (useNormalTexture) {\n    vec3 _tangentNormal = texture(normalTexture, vUV).rgb;\n    _tangentNormal = _tangentNormal * 2. - 1.;\n    _tangentNormal = setNormalStrength(_tangentNormal, normalStrength);\n    gNormal = normalize(vTBN * _tangentNormal);\n  }\n  else {\n    gNormal = normalize(vNormal);\n  }\n\n  if (!gl_FrontFacing) {\n    gNormal *= -1.;\n  }\n\n  gAlbedo = _albedo.rgb + emissiveFactor;\n\n  float _metallic = metallic;\n  float _roughness = roughness;\n  if (useMetallicRoughnessTexture) {\n    vec3 ts = texture(metallicRoughnessTexture, vUV).rgb;\n    _metallic *= ts.b;\n    _roughness *= ts.g;\n  }\n  gProperties = vec4(_roughness, _metallic, enableMotionBlur, 1);\n}\n`;Ze=Ze.trim(),Oe=Oe.trim();var Ve=`\n${Ie.AO}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent;\nin vec3 color;\nin vec2 uv;\nin mat4 modelMatrix;\n\nout vec4 vPosition;\nout vec3 vNormal;\nout vec4 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\nout mat4 vModelMatrix;\n\n// const int levels = 2;\n\n// uniform sharedPerScene {\n//   mat4 projectionMatrix;\n//   mat4 viewMatrix;\n//   mat4 inverseViewMatrix;\n//   float biases[levels];\n// };\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\n\n// //Shadows\n// uniform mat4 textureMatrices[levels];\n// out vec4 projectedTexcoords[levels];\n\nvoid main() {\n  vNormal = mat3(modelMatrix) * normal; // in world-space\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n  vModelMatrix = modelMatrix;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(vNormal, vTangent.xyz) * vTangent.w, 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * vec4(vNormal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  // for (int i = 0; i < levels; i++) {\n  //   projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  // }\n\n  vPosition = worldPosition;\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n`,Xe=Oe;Xe=(Xe=Xe.replace(/modelMatrix/g,"vModelMatrix")).replace(/uniform mat4 vModelMatrix/g,"in mat4 vModelMatrix"),Ve=Ve.trim(),Xe=Xe.trim();var ke=`\n${Ie.AO}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent;\nin vec3 color;\nin vec2 uv;\n\nout vec4 vPosition;\nout vec3 vNormal;\nout vec4 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n//Skinning\nin vec4 weights;\nin vec4 joints;\n\nuniform sampler2D u_jointTexture;\nuniform float u_numJoints;\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.)\n#define ROW1_U ((0.5 + 1.0) / 4.)\n#define ROW2_U ((0.5 + 2.0) / 4.)\n#define ROW3_U ((0.5 + 3.0) / 4.)\n\nmat4 getBoneMatrix(float jointNdx) {\n  float v = (jointNdx + 0.5) / u_numJoints;\n  return mat4(\n    texture(u_jointTexture, vec2(ROW0_U, v)),\n    texture(u_jointTexture, vec2(ROW1_U, v)),\n    texture(u_jointTexture, vec2(ROW2_U, v)),\n    texture(u_jointTexture, vec2(ROW3_U, v))\n  );\n}\n\nvoid main() {\n  mat4 skinMatrix = getBoneMatrix(joints[0]) * weights[0] +\n                    getBoneMatrix(joints[1]) * weights[1] +\n                    getBoneMatrix(joints[2]) * weights[2] +\n                    getBoneMatrix(joints[3]) * weights[3];\n\n  vNormal = mat3(modelMatrix * skinMatrix) * normal; // in world-space\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vec3 _T = normalize(vec3(modelMatrix * skinMatrix * modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * skinMatrix * modelMatrix * vec4(cross(normal, vTangent.xyz) * vTangent.w, 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * skinMatrix * modelMatrix * vec4(normal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * skinMatrix * vec4(position, 1.0);\n  vPosition = worldPosition;\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n`,Ge=Oe;ke=ke.trim(),Ge=Ge.trim();var je=Ie.tM,He=`\n${Ie.AO}\n\n// #define DEBUG_NORMAL\n// #define DEBUG_ALBEDO\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec4 motionVector;\n\nuniform vec2 SIZE;\n\nuniform sampler2D gPosition;\nuniform sampler2D gNormal;\nuniform sampler2D gAlbedo;\nuniform sampler2D gProperties;\n\nstruct LightInfo {\n  int type;\n  vec3 position;\n  vec3 direction;\n  float angle;\n  vec3 color;\n};\nconst int maxLights = 8;\nuniform LightInfo lights[maxLights];\nuniform int nrLights;\n\nuniform vec3 sunDirection;\nuniform vec3 sunIntensity;\nuniform float environmentIntensity;\nuniform vec3 ambientColor;\n\nuniform samplerCube u_diffuseIBL;\nuniform samplerCube u_specularIBL;\nuniform sampler2D u_splitSum;\n\nuniform mat4 inverseViewMatrix;\n\n// Motion blur\nuniform mat4 projectionMatrix;\nuniform mat4 prevViewMatrix;\nuniform mat4 viewMatrix;\n\n// FOG\n\n#define USEFOG\nuniform vec4 fogColor;\nuniform float fogDensity;\n\nvec3 applyFog(vec3 color, vec3 worldPosition) {\n  float distance = length(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - worldPosition);\n  float fogAmount = exp(-pow(distance * fogDensity, 2.));\n  \n  return mix(fogColor.rgb, color, fogAmount);\n}\n\n//\n\n\nbool doNoTiling = false;\n\nconst float PI = 3.141592;\n\n// No tiling\nvec4 hash4( vec2 p ) {\n  return fract(sin(vec4(1.0+dot(p,vec2(37.0,17.0)), \n                        2.0+dot(p,vec2(11.0,47.0)),\n                        3.0+dot(p,vec2(41.0,29.0)),\n                        4.0+dot(p,vec2(23.0,31.0))))*103.0);\n}\n\nvec3 textureNoTile( sampler2D samp, in vec2 uv, float v ) {\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n  \n    // derivatives (for correct mipmapping)\n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n    \n  vec3 va = vec3(0.0);\n  float w1 = 0.0;\n    float w2 = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n    vec4 o = hash4( p + g );\n    vec2 r = g - f + o.xy;\n    float d = dot(r,r);\n        float w = exp(-5.0*d );\n        vec3 c = textureGrad( samp, uv + v*o.zw, ddx, ddy ).xyz;\n    va += w*c;\n    w1 += w;\n        w2 += w*w;\n    }\n    \n    // normal averaging --\x3e lowers contrasts\n    return va/w1;\n\n    // contrast preserving average\n    float mean = 0.3;// textureGrad( samp, uv, ddx*16.0, ddy*16.0 ).x;\n    vec3 res = mean + (va-w1*mean)/sqrt(w2);\n    return mix( va/w1, res, v );\n}\n\n// Texture sampling\nvec4 sampleTexture(sampler2D samp, vec2 uv) {\n  if (doNoTiling) {\n    return vec4(textureNoTile(samp, uv, 1.), 1);\n  }\n  else {\n    return texture(samp, uv);\n  }\n}\n\n//Normal map\nvec3 setNormalStrength(vec3 normal, float strength) {\n  return vec3(normal.xy * strength, mix(1., normal.z, clamp(strength, 0., 1.)));\n}\n\n// vec3 sampleNormalTexture(sampler2D texture, vec2 uv) {\n//   return sampleTexture(texture, uv).rgb * 2. - 1.\n// }\n\n// PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0); // trying this\n  // return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n} \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n  float a      = roughness*roughness;\n  float a2     = a*a;\n  float NdotH  = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH*NdotH;\n\n  float num   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n\n  return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r*r) / 8.0;\n\n  float num   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 F0 = vec3(scalarF0);\n  F0 = mix(F0, albedo, metallic);\n  vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.), F0, roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - metallic;\t  \n    \n  vec3 irradiance = texture(u_diffuseIBL, N).rgb;\n  vec3 diffuse  = irradiance * albedo;\n    \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureLod(u_specularIBL, R, roughness * MAX_REFLECTION_LOD).rgb;\n\n  vec2 uv = vec2(max(dot(N, V), 0.), roughness);\n  uv.y = 1. - uv.y;\n  vec2 envBRDF = texture(u_splitSum, uv).rg;\n\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n  vec3 ambient = (kD * diffuse + specular) * environmentIntensity;\n\n  return ambient;\n}\n\nvec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 L = normalize(lightDir);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;\n  vec3 specular     = nominator / denominator;\n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n\n  kD *= 1.0 - metallic;\n  float NdotL = max(dot(N, L), 0.0);\n\n  vec3 finalColor = (kD * albedo / PI + specular) * radiance * NdotL;\n  return finalColor;\n}\n\nvec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec3 Spotlight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 dir, float angle, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 currentDir = normalize(worldPos - lightPos);\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n\n  float sharpness = 5.;\n  attenuation *= clamp((dot(currentDir, dir) - cos(angle)) * sharpness, 0., 1.);\n\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);\n  \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nconst int levels = 2;\n\nvec4 projectedTexcoords[levels];\nuniform float biases[levels];\nuniform sampler2D projectedTextures[levels];\nuniform mat4 textureMatrices[levels];\n\n${Ie.XS}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / SIZE;\n\n  vec3 position = texture(gPosition, uv).rgb;\n  vec3 normal = texture(gNormal, uv).rgb;\n  vec3 albedo = texture(gAlbedo, uv).rgb;\n  vec4 properties = texture(gProperties, uv);\n\n  float blurFactor = properties.b;\n\n  vec4 prevClipSpace = projectionMatrix * prevViewMatrix * vec4(position, 1.0);\n  vec4 clipSpace = projectionMatrix * viewMatrix * vec4(position, 1.0);\n\n  vec3 NDCPos = (clipSpace / clipSpace.w).xyz;\n  vec3 PrevNDCPos = (prevClipSpace / prevClipSpace.w).xyz;\n  vec2 mv = blurFactor * (NDCPos - PrevNDCPos).xy * 0.5 + 0.5;\n  motionVector = vec4(mv, 0, 1);\n\n  if (normal == vec3(0)) {\n    discard;\n  }\n\n  #ifdef DEBUG_ALBEDO\n  fragColor = vec4(albedo, 1);\n  return;\n  #endif\n\n  #ifdef DEBUG_NORMAL\n  fragColor = vec4(normal, 1);\n  return;\n  #endif\n\n  float _ao = 1.;\n  float _roughness = properties.r;\n  float _metallic = properties.g;\n  vec3 _emission = vec3(0);\n\n  _roughness = clamp(_roughness, 0.01, 0.99);\n\n  vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - position);\n  vec3 N = normal;\n  vec3 R = reflect(-V, N);\n\n  float f0 = 0.04;\n\n  vec3 col = vec3(0);\n  // col += ambientColor;\n\n  for (int i = 0; i < levels; i++) {\n    projectedTexcoords[i] = textureMatrices[i] * vec4(position, 1);\n  }\n  float shadowAmount = getShadowAmount(position, dot(N, sunDirection.xyz));\n\n  col += IBL(N, V, R, albedo, _metallic, _roughness, f0) * _ao * (environmentMinLight + shadowAmount * (1. - environmentMinLight));\n  \n  if (sunIntensity.xyz != vec3(0) && shadowAmount > 0.01) {\n    col += DirectionalLight(position, N, V, sunDirection.xyz, sunIntensity.xyz, albedo, _metallic, _roughness, f0) * _ao * shadowAmount;\n  }\n\n  for (int i = 0; i < int(nrLights); i++) {\n    LightInfo light = lights[i];\n    if (light.type == 0) {\n      col += PositionalLight(position, N, V, light.position, light.color, albedo.rgb, _metallic, _roughness, f0);\n    }\n    else if (light.type == 1) {\n      col += Spotlight(position, N, V, light.position, light.direction, light.angle, light.color, albedo.rgb, _metallic, _roughness, f0);\n    }\n    else if (light.type == 2) {\n      col += DirectionalLight(position, N, V, light.direction, light.color, albedo.rgb, _metallic, _roughness, f0);\n    }\n  }\n\n  col += _emission;\n\n  #ifdef USEFOG\n    col = applyFog(col, position);\n  #endif\n\n  fragColor = vec4(col, 1);\n}\n`;je=je.trim(),He=He.trim();var We=Ie.tM,$e=`\n${Ie.AO}\n\nuniform float scale;\n\nuniform mat4 lensProjection;\nuniform mat4 inverseViewMatrix;\nuniform mat4 viewMatrix;\n\nuniform sampler2D albedoTexture;\nuniform sampler2D positionTexture;\nuniform sampler2D normalTexture;\nuniform sampler2D propertiesTexture;\n\nuniform float maxRoughness;\nuniform float maxDistance;\nuniform float resolution;\nuniform int steps;\nuniform float thickness;\n\n// uniform sampler2D maskTexture;\n// uniform vec2 enabled;\n\nout vec4 fragColor;\n\nvec4 getSceneViewPos(vec2 uv) {\n  vec4 worldPos = texture(positionTexture, uv);\n  if (worldPos.xyz == vec3(0)) {\n    return vec4(0, 0, -1000, 0);\n  }\n\n  // return viewMatrix * vec4(worldPos.rgb, 1);\n  return worldPos;\n}\n\nbool isUVOutside(vec2 uv) {\n  return uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.;\n}\n\nfloat fadeOutUVBorder(vec2 uv, float falloffX, float falloffY) {\n  return smoothstep(0., falloffX, uv.x) * smoothstep(1., 1. - falloffX, uv.x) * smoothstep(0., falloffY, uv.y) * smoothstep(1., 1. - falloffY, uv.y);\n}\n\nfloat random(vec3 seed, int i){\n  vec4 seed4 = vec4(seed,i);\n  float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));\n  return fract(sin(dot_product) * 43758.5453);\n}\n\nvoid main() {\n  // vec2 texSize = vec2(textureSize(positionTexture, 0).xy) * scale;\n  // vec2 texCoord = gl_FragCoord.xy / texSize;\n\n  // if (texture(propertiesTexture, texCoord).r > 0.5) {\n  //   fragColor = vec4(0);\n  //   return;\n  // }\n\n  // vec3 worldNormal = texture(normalTexture, texCoord).xyz;\n  // if (worldNormal == vec3(0)) {\n  //   fragColor = vec4(0);\n  //   return;\n  // }\n\n  // const float maxDistance = 64.;\n\n  // vec3 origin = getSceneViewPos(texCoord).xyz;\n  // vec3 viewNormal = normalize(mat3(viewMatrix) * worldNormal);\n  // vec3 cameraToWorld = normalize(origin);\n  // vec3 rayDirection = normalize(reflect(cameraToWorld, viewNormal));\n  // vec3 end = origin + rayDirection * maxDistance;\n  // // origin += rayDirection * 15.1;\n  // // origin += viewNormal * 0.1;\n\n  // const int initialSteps = 200;\n\n  // // fragColor = vec4(rayDirection, 1);\n  // // return;\n\n  // for (int i = 0; i < initialSteps; i++) {\n  //   vec3 currentView = mix(origin, end, float(i) / float(initialSteps - 1));\n\n  //   vec4 currentScreen = vec4(currentView, 1);\n  //   currentScreen = lensProjection * currentScreen;\n  //   currentScreen.xyz /= currentScreen.w;\n  //   currentScreen.xy = currentScreen.xy * 0.5 + 0.5;\n  //   // currentScreen.xy *= texSize;\n\n  //   if (isUVOutside(currentScreen.xy)) {\n  //     break;\n  //   }\n\n  //   float sceneDepth = getSceneViewPos(currentScreen.xy).z;\n  //   float deltaDepth = (sceneDepth - currentView.z);\n\n  //   if (deltaDepth > 0. && deltaDepth < 10.) {\n  //     fragColor = vec4(texture(albedoTexture, currentScreen.xy).rgb, 1);\n  //     // fragColor = vec4(float(i) / float(initialSteps - 1), 0, 0, 1);\n  //     return;\n  //   }\n  // }\n\n  // fragColor = vec4(0, 0, 1, 1);\n  // return;\n\n\n\n\n\n\n\n\n  vec2 texSize  = vec2(textureSize(positionTexture, 0).xy) * scale;\n  vec2 texCoord = gl_FragCoord.xy / texSize;\n\n  vec4 uv = vec4(0.0);\n\n  vec4 positionFrom = getSceneViewPos(texCoord);\n  // vec4 positionFrom = texture(positionTexture, texCoord);\n  // positionFrom.y *= -1.;\n  // vec4 mask         = texture(maskTexture,     texCoord);\n\n  // fragColor = vec4(getSceneViewPos(texCoord).z * 0.01, 0, 0, 1);\n  // return;\n\n  // fragColor = vec4(texture(albedoTexture, texCoord).rgb, 1);\n  // return;\n\n  // fragColor = texture(positionTexture, texCoord);\n  // // fragColor = viewMatrix * vec4(texture(positionTexture, texCoord).rgb, 1);\n  // return;\n\n  // fragColor = vec4(texCoord, 0, 1);\n  // return;\n\n  // fragColor = vec4(texture(propertiesTexture, texCoord).rgb, 1);\n  // return;\n\n  float roughness = texture(propertiesTexture, texCoord).r;\n  if (\n    // positionFrom.w <= 0.0\n    //  || enabled.x      != 1.0\n    //  || mask.r         <= 0.0\n    roughness > maxRoughness || positionFrom.a == 0.\n  ) {\n    fragColor = vec4(0);\n    return;\n\n    // fragColor = uv;\n    fragColor = vec4(texture(albedoTexture, texCoord).rgb, 1);\n    return;\n  }\n\n  vec3 worldNormal = texture(normalTexture, texCoord).xyz;\n  if (worldNormal == vec3(0)) {\n    fragColor = vec4(0);\n    return;\n\n    fragColor = vec4(texture(albedoTexture, texCoord).rgb, 1);\n    return;\n  }\n\n  vec3 unitPositionFrom = normalize(positionFrom.xyz);\n  vec3 normal           = normalize(mat3(viewMatrix) * worldNormal);\n\n  // fragColor = vec4(normal, 1);\n  // return;\n\n  vec3 pivot            = normalize(reflect(unitPositionFrom, normal));\n  \n  vec4 positionTo = positionFrom;\n\n  vec4 startView = vec4(positionFrom.xyz + (pivot *         (0.01)), 1.0);\n  vec4 endView   = vec4(positionFrom.xyz + (pivot * maxDistance), 1.0);\n\n  // if (endView.z > 0.) {\n  //   fragColor = vec4(1, 0.5, 0, 1);\n  //   return;\n  // }\n\n  vec2 poissonDisk[16] = vec2[]( \n    vec2( -0.94201624, -0.39906216 ), \n    vec2( 0.94558609, -0.76890725 ), \n    vec2( -0.094184101, -0.92938870 ), \n    vec2( 0.34495938, 0.29387760 ), \n    vec2( -0.91588581, 0.45771432 ), \n    vec2( -0.81544232, -0.87912464 ), \n    vec2( -0.38277543, 0.27676845 ), \n    vec2( 0.97484398, 0.75648379 ), \n    vec2( 0.44323325, -0.97511554 ), \n    vec2( 0.53742981, -0.47373420 ), \n    vec2( -0.26496911, -0.41893023 ), \n    vec2( 0.79197514, 0.19090188 ), \n    vec2( -0.24188840, 0.99706507 ), \n    vec2( -0.81409955, 0.91437590 ), \n    vec2( 0.19984126, 0.78641367 ), \n    vec2( 0.14383161, -0.14100790 ) \n  );\n\n  // int index = int(16.0*random(floor(startView.xyz*1000.0), 0))%16;\n  // startView.xy += poissonDisk[index] * 0.05;\n\n  vec4 startFrag      = startView;\n       startFrag      = lensProjection * startFrag;\n       startFrag.xyz /= startFrag.w;\n       startFrag.xy   = startFrag.xy * 0.5 + 0.5;\n       startFrag.xy  *= texSize;\n\n  vec4 endFrag      = endView;\n       endFrag      = lensProjection * endFrag;\n       endFrag.xyz /= endFrag.w;\n       endFrag.xy   = endFrag.xy * 0.5 + 0.5;\n       endFrag.xy  *= texSize;\n\n  vec2 frag  = startFrag.xy;\n       uv.xy = frag / texSize;\n\n  float deltaX    = endFrag.x - startFrag.x;\n  float deltaY    = endFrag.y - startFrag.y;\n  float useX      = abs(deltaX) >= abs(deltaY) ? 1.0 : 0.0;\n  float delta     = mix(abs(deltaY), abs(deltaX), useX) * clamp(resolution, 0.0, 1.0);\n  vec2  increment = vec2(deltaX, deltaY) / max(delta, 0.001);\n\n  float search0 = 0.;\n  float search1 = 0.;\n\n  int hit0 = 0;\n  int hit1 = 0;\n\n  float viewDistance = startView.y;\n  float depth        = thickness;\n\n  int i = 0;\n\n  for (i = 0; i < int(min(delta, 1000.)); ++i) {\n    frag      += increment;\n    uv.xy      = frag / texSize;\n\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) {\n      fragColor = vec4(0);\n      return;\n      \n      fragColor = vec4(texture(albedoTexture, texCoord).rgb, 1);\n      // fragColor = vec4(0, 1, 0, 1);\n      return;\n    }\n\n    // vec4 worldPos = texture(positionTexture, uv.xy);\n    // positionTo = viewMatrix * vec4(worldPos.rgb, 1);\n    // // positionTo = texture(positionTexture, uv.xy);\n    // // positionTo.y *= -1.;\n\n    positionTo = getSceneViewPos(uv.xy);\n\n    search1 =\n      mix\n        ( (frag.y - startFrag.y) / deltaY\n        , (frag.x - startFrag.x) / deltaX\n        , useX\n        );\n\n    search1 = clamp(search1, 0.0, 1.0);\n\n    viewDistance = -sign(endView.z) * (startView.z * endView.z) / mix(endView.z, startView.z, search1);\n    depth        = -(viewDistance - positionTo.z);\n\n    if (viewDistance > 0.) {\n      break;\n    }\n\n    // viewDistance = (startView.y * endView.y) / mix(endView.y, startView.y, search1);\n    // depth        = viewDistance - positionTo.y;\n\n    if (depth > 0. && depth < thickness) {\n      hit0 = 1;\n\n      // // // fragColor = vec4(uv.xy, 0, 1);\n      // fragColor = vec4(0, 0, depth, 1);\n      // // fragColor = vec4(texture(albedoTexture, uv.xy).rgb * vec3(1, 0.5, 0.5), 1);\n      // return;\n\n      break;\n    } else {\n      search0 = search1;\n    }\n  }\n\n  // fragColor = vec4(uv.xy, 0, 1);\n  // return;\n\n  search1 = search0 + ((search1 - search0) / 2.0);\n\n  int currentSteps = steps;\n  currentSteps *= hit0;\n\n  for (i = 0; i < currentSteps; ++i) {\n    frag       = mix(startFrag.xy, endFrag.xy, search1);\n    uv.xy      = frag / texSize;\n\n    // // positionTo = viewMatrix * vec4(texture(positionTexture, uv.xy).rgb, 1);\n    // // // positionTo = texture(positionTexture, uv.xy);\n    // // // positionTo.y *= -1.;\n\n    // vec4 worldPos = texture(positionTexture, uv.xy);\n    // positionTo = viewMatrix * vec4(worldPos.rgb, 1);\n    // // positionTo = texture(positionTexture, uv.xy);\n\n    // if (worldPos.a < 0.01) {\n    //   positionTo = vec4(vec3(1000), 0);\n    // }\n\n    positionTo = getSceneViewPos(uv.xy);\n\n    viewDistance = (startView.z * endView.z) / mix(endView.z, startView.z, search1);\n    depth        = -(viewDistance - positionTo.z);\n\n    // viewDistance = (startView.y * endView.y) / mix(endView.y, startView.y, search1);\n    // depth        = viewDistance - positionTo.y;\n\n    float fineThickness = 0.1;\n    if (depth > -fineThickness * 0.05 && depth < fineThickness) {\n      hit1 = 1;\n      // break;\n    }\n\n    if (depth > 0. && depth < thickness) {\n      search1 = search0 + ((search1 - search0) / 2.);\n    } else {\n      float temp = search1;\n      search1 = search1 + ((search1 - search0) / 2.);\n      search0 = temp;\n    }\n  }\n\n  float visibility =\n    1.\n    * float(hit1)\n    * positionTo.w\n    * ( 1. - max(dot(-unitPositionFrom, pivot), 0.))\n    * ( 1. - clamp(depth / thickness, 0., 1.))\n    * ( 1. - clamp(length(positionTo.xyz - positionFrom.xyz) / maxDistance, 0., 1.))\n    * fadeOutUVBorder(uv.xy, 0.1, 0.1)\n    * (1. - roughness);\n\n  visibility = clamp(visibility, 0., 1.);\n\n  vec3 reflectedColor = texture(albedoTexture, uv.xy).rgb;\n  fragColor = vec4(mix(vec3(0), reflectedColor, visibility), visibility);\n\n  // uv.ba = vec2(visibility);\n  // uv.ba = vec2(1);\n\n  // fragColor = uv;\n\n  // vec3 baseColor = texture(albedoTexture, texCoord.xy).rgb;\n  // vec3 reflectedColor = texture(albedoTexture, uv.xy).rgb;\n\n  // fragColor = vec4(mix(baseColor, reflectedColor, visibility), 1);\n\n  // fragColor = vec4(baseColor, 1);\n}\n`;We=We.trim(),$e=$e.trim();var Ye=Ie.tM,qe=`\n${Ie.AO}\n\nuniform sampler2D combinedTexture;\nuniform sampler2D ssrTexture;\nuniform vec2 SIZE;\nuniform float scale;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / SIZE;\n  \n  vec3 combinedColor = texture(combinedTexture, uv).rgb;\n  vec4 ssrColor = texture(ssrTexture, uv * scale);\n\n  fragColor = vec4(mix(combinedColor, ssrColor.rgb, ssrColor.a), 1);\n}\n`;Ye=Ye.trim(),qe=qe.trim();var Ke=Ie.tM,Qe=`\n${Ie.AO}\nout vec4 fragColor;\n\nuniform vec2 SIZE;\nuniform sampler2D imageTexture;\nuniform bool horizontal;\nuniform int radius;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / SIZE;\n  vec2 texelSize = 1. / vec2(textureSize(imageTexture, 0));\n\n  vec4 col = vec4(0);\n\n  for (int i = -radius; i <= radius; i++) {\n    col += texture(imageTexture, uv + texelSize * float(i) * vec2(horizontal, 1 - int(horizontal)));\n  }\n\n  col /= float(radius * 2 + 1);\n\n  fragColor = col;\n  // fragColor = vec4(col.rgb, texture(imageTexture, uv).a);\n}\n`;Ke=Ke.trim(),Qe=Qe.trim();let Je=new m.Z,et=new m.Z,tt=new m.Z;function nt(e,t){function n(t,n){return(n=n||new m.Z).x=e[3*t],n.y=e[3*t+1],n.z=e[3*t+2],n}if(t){var r=new Array(e.length/3);for(let e=0;e<r.length;e++)r[e]=[];var i=t;for(let e=0;e<i.length;e+=3){n(i[e],Je),n(i[e+1],et),n(i[e+2],tt);let t=w([Je,et,tt]);r[i[e]].push(t),r[i[e+1]].push(t),r[i[e+2]].push(t)}var o=[];for(let e=0;e<r.length;e++){let t=m.Z.divide(r[e].reduce(((e,t)=>m.Z.add(e,t)),m.Z.zero()),r[e].length);o.push(t.x,t.y,t.z)}return new Float32Array(o)}var a=new Float32Array(e.length);for(let t=0;t<e.length/3;t+=3){n(t,Je),n(t+1,et),n(t+2,tt);let e=w([Je,et,tt]);a[3*t]=e.x,a[3*t+1]=e.y,a[3*t+2]=e.z,a[3*(t+1)]=e.x,a[3*(t+1)+1]=e.y,a[3*(t+1)+2]=e.z,a[3*(t+2)]=e.x,a[3*(t+2)+1]=e.y,a[3*(t+2)+2]=e.z}return a}function rt(e,t,n){function r(t){return[e[3*t],e[3*t+1],e[3*t+2]]}function i(e){return[n[2*e],n[2*e+1]]}function o(e,t){for(var n=new Array(e.length),r=0;r<e.length;r++)n[r]=e[r]-t[r];return n}function a(e,t,n,a){var l,c=r(t),u=r(n),h=r(a),f=i(t),d=i(n),v=i(a),p=o(u,c),g=o(h,c),x=o(d,f),b=o(v,f),T=1/(x[0]*b[1]-x[1]*b[0]);if(isNaN(T)||!isFinite(T)){s++;var E=w([m.Z.fromArray(c),m.Z.fromArray(u),m.Z.fromArray(h)]);l=m.Z.toArray(m.Z.findOrthogonal(E))}else l=[(p[0]*b[1]-g[0]*x[1])*T,(p[1]*b[1]-g[1]*x[1])*T,(p[2]*b[1]-g[2]*x[1])*T];var y=.01;return l[0]+=y,l[1]+=y,l[2]+=y,e[4*t]=l[0],e[4*t+1]=l[1],e[4*t+2]=l[2],e[4*t+3]=1,e[4*n]=l[0],e[4*n+1]=l[1],e[4*n+2]=l[2],e[4*n+3]=1,e[4*a]=l[0],e[4*a+1]=l[1],e[4*a+2]=l[2],e[4*a+3]=1,l}var s=0,l=new Float32Array(e.length/3*4);if(t){var c=t;for(let e=0;e<c.length;e+=3)a(l,c[e],c[e+1],c[e+2])}else for(let t=0;t<e.length/3;t+=3)a(l,t,t+1,t+2);return s.length>0&&console.warn(s+" tangents generated without UVs"),l}function it(e,t,n){var r=document.createElement("canvas");return r.width=t,r.height=n,r.getContext("2d").drawImage(e,0,0,t,n),r}const ot=function e(t={}){var n,T=this,E=t.renderScale??1;this.debugMode=t.debug??!0,this.catchProgramErrors=t.catchProgramErrors??!!this.debugMode;var y,F=0,C=0;this.startTime=new Date,this.eventHandler=new M,this.mouse={x:0,y:0,any:!1,left:!1,right:!1,middle:!1,movement:{x:0,y:0},scroll:{x:0,y:0,z:0}};var D=[],P=[],N=[];this.currentScene=0,this.scenes=[],this.godrays=null,this.postprocessing=null,this.bloom=null,this.skybox=null,this.shadowCascades=null,this.UBOLocationCounter=0,this.currentBoundLitPrograms=new WeakMap,this.currentBoundMaterials=new WeakMap;var S={};this.programContainers={get skybox(){return le("skybox",a)},get shadow(){return le("shadow",s)},get shadowInstanced(){return le("shadowInstanced",s)},get shadowSkinned(){return le("shadowSkinned",s)},get postprocessing(){return le("postprocessing",l)},get bloom(){return le("bloom",c)},get equirectangularToCubemap(){return le("equirectangularToCubemap",u)},get diffuseCubemap(){return le("diffuseCubemap",h)},get specularCubemap(){return le("specularCubemap",f)},get lit(){return le("lit",ne)},get litSkinned(){return le("litSkinned",ne)},get litInstanced(){return le("litInstanced",ne)},get litTrail(){return le("litTrail",ne)},get unlit(){return le("unlit",r)},get unlitInstanced(){return le("unlitInstanced",r)},get particle(){return le("particle",o)},get billboard(){return le("billboard",i)}};var B,L,z=null,O=!0,X={enableShadows:!0,enableBloom:!0,enablePostProcessing:!0,loadTextures:!0};this.settings={get enableShadows(){return X.enableShadows},set enableShadows(e){X.enableShadows=e,e||T.shadowCascades.clearShadowmaps()},get enableBloom(){return X.enableBloom},set enableBloom(e){X.enableBloom=e,e||T.bloom.clearBloom()},get enablePostProcessing(){return X.enablePostProcessing},set enablePostProcessing(e){X.enablePostProcessing=e},get loadTextures(){return X.loadTextures},set loadTextures(e){X.loadTextures=e}},this.setupSettings=null,this.renderpipeline=null;let j=0;function H(){var e,t,n=(t=((e=performance.now())-y)/1e3,y=e,t);C+=n,j=0,T.eventHandler.fireEvent("renderloop",n,C,F);let r=document.querySelector("#debug_drawCalls");r&&(r.textContent=j),F++,requestAnimationFrame(H)}function W(){$(),T.postprocessing&&T.postprocessing.resizeFramebuffers(),T.bloom&&T.bloom.resizeFramebuffers(),T.eventHandler.fireEvent("resize")}function $(){var e=T.setupSettings,t=E*(window.devicePixelRatio||1);T.canvas.width=(e.width??innerWidth)*t,T.canvas.height=(e.height??innerHeight)*t,T.canvas.style.width=(e.width??innerWidth)+"px",T.canvas.style.height=(e.height??innerHeight)+"px"}function Y(e){if(T.catchProgramErrors&&!n.getProgramParameter(e,n.LINK_STATUS)){var t="\nCould not compile WebGL program\n\nLink failed: "+n.getProgramInfoLog(e),r=n.getAttachedShaders(e);for(var i of r){var o=n.getShaderInfoLog(i),a=se(n.getShaderParameter(i,n.SHADER_TYPE));o&&(t+="\n"+a+":\n"+o),console.trace(a,n.getShaderSource(i))}throw new Error(t)}}function q(e,t){var r=n.createShader(t);return n.shaderSource(r,e),n.compileShader(r),r}function K(){return T.floatTextures?n.FLOAT:T.textureHalfFloatExt?T.textureHalfFloatExt.HALF_FLOAT_OES:n.UNSIGNED_BYTE}function Q(e,t,r={}){var i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i);var o=n.createTexture();n.bindTexture(n.TEXTURE_2D,o),n.texImage2D(n.TEXTURE_2D,0,1==T.version?n.RGBA:n.RGBA16F,e,t,0,n.RGBA,K(),null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,o,0);var a=n.createRenderbuffer();return n.bindRenderbuffer(n.RENDERBUFFER,a),n.renderbufferStorage(n.RENDERBUFFER,r.depthComponent??n.DEPTH_COMPONENT16,e,t),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,a),{framebuffer:i,colorBuffer:o,depthBuffer:a,width:e,height:t}}function J(e,t=n.ARRAY_BUFFER,r=n.STATIC_DRAW){var i=n.createBuffer();return n.bindBuffer(t,i),n.bufferData(t,e,r),i}function re(e){return e!==z&&(n.useProgram(e),z=e,!0)}function ie(e,t,r,i){B=[e,t,r,i],n.clearColor(e,t,r,i)}function oe(e){if("FLOAT"==e)return"1f";var t=e.match(/FLOAT_VEC([0-9])/);if(t)return t[1]+"f";if("INT"==e||"UNSIGNED_INT"==e||"BOOL"==e||-1!==e.indexOf("SAMPLER"))return"1i";if(t=e.match(/(?:INT|BOOL)_VEC([0-9])/))return t[1]+"i";if(t=e.match(/FLOAT_MAT([0-9]x?[0-9]?)/))return"Matrix"+t[1]+"fv";throw new Error("Invalid uniform type string: "+e)}this.setup=function(e={}){if(this.setupSettings=e,this.path=e.path??"./",this.canvas=e.canvas??document.body.appendChild(document.createElement("canvas")),$(),this.version=e.version??2,1!==this.version&&2!==this.version)throw new Error("Invalid WebGL version: "+this.version);var t="webgl"+(2==this.version?"2":""),r={antialias:!1,premultipliedAlpha:!1};if(n=this.gl=this.canvas.getContext(t,r),!this.gl){if(2!=this.version||"version"in e)throw this.eventHandler.fireEvent("error"),new Error("WebGL "+this.version+" is not supported!");if(this.eventHandler.fireEvent("fallbackVersion"),this.version=1,n=this.gl=this.canvas.getContext("webgl",r),!this.gl)throw this.eventHandler.fireEvent("error"),new Error("WebGL "+this.version+" is not supported!")}console.info("Using Webgl version "+this.version);let i=function(){j++};function o(e,t,n){var r=e[t];return e[t]=function(){return n(...arguments),r.call(e,...arguments)},r}if(o(n,"drawElements",i),o(n,"drawArrays",i),o(n,"drawElementsInstanced",i),o(n,"drawArraysInstanced",i),this.canvas.addEventListener("webglcontextlost",(()=>{console.error("WebGL context lost!"),this.eventHandler.fireEvent("contextlost")})),this.canvas.addEventListener("mousedown",(e=>{this.mouse.any=!0,this.mouse[["left","middle","right"][e.button]]=!0,this.eventHandler.fireEvent("mousedown",e)})),document.addEventListener("mouseup",(e=>{this.mouse.any=0!==e.buttons,this.mouse[["left","middle","right"][e.button]]=!1,this.eventHandler.fireEvent("mouseup",e)})),this.canvas.onmousemove=e=>{var t,n,r,i,o,a=(n=e,r=(t=this.canvas).getBoundingClientRect(),i=t.width/r.width,o=t.height/r.height,{x:(n.clientX-r.left)*i,y:(n.clientY-r.top)*o});this.mouse.x=a.x,this.mouse.y=a.y,this.mouse.movement.x=e.movementX,this.mouse.movement.y=e.movementY,this.eventHandler.fireEvent("mousemove",e)},this.canvas.addEventListener("wheel",(e=>{this.mouse.scroll.x=e.deltaX,this.mouse.scroll.y=e.deltaY,this.mouse.scroll.z=e.deltaZ,this.eventHandler.fireEvent("scroll",e)})),document.addEventListener("keydown",(e=>{D[e.keyCode]=!0,D[e.code]=!0,this.eventHandler.fireEvent("keydown",e)})),document.addEventListener("keyup",(e=>{D[e.keyCode]=!1,D[e.code]=!1,this.eventHandler.fireEvent("keyup",e)})),window.addEventListener("resize",(()=>{W()})),(L={})[n.NO_ERROR]="No error",L[n.INVALID_ENUM]="Invalid enum",L[n.INVALID_VALUE]="Invalid value",L[n.INVALID_OPERATION]="Invalid operation",L[n.INVALID_FRAMEBUFFER_OPERATION]="Invalid framebuffer operation",L[n.OUT_OF_MEMORY]="Out of memory",L[n.CONTEXT_LOST_WEBGL]="Context lost webgl",this.indexTypeLookup={5121:n.UNSIGNED_BYTE,5123:n.UNSIGNED_SHORT,5125:n.UNSIGNED_INT},n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)<32&&console.warn("Max texture units: ",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)),this.EXT_texture_filter_anisotropic=this.getExtension("EXT_texture_filter_anisotropic")||this.getExtension("MOZ_EXT_texture_filter_anisotropic")||this.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),this.MAX_ANISOTROPY=n.getParameter(this.EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT),2==this.version?(this.getExtension("OES_texture_float_linear"),this.getExtension("EXT_color_buffer_float"),this.getExtension("EXT_float_blend"),this.floatTextures=!0):1==this.version&&(this.getExtension("OES_element_index_uint"),this.getExtension("OES_standard_derivatives"),this.getExtension("EXT_shader_texture_lod"),this.floatTextures=this.getExtension("OES_texture_float"),this.floatTextures=this.floatTextures&&this.getExtension("WEBGL_color_buffer_float"),this.getExtension("OES_texture_float_linear"),this.getExtension("EXT_float_blend"),this.colorBufferHalfFloatExt=this.getExtension("EXT_color_buffer_half_float"),this.textureHalfFloatExt=this.getExtension("OES_texture_half_float"),this.getExtension("WEBGL_depth_texture"),this.sRGBExt=this.getExtension("EXT_sRGB"),this.VAOExt=this.getExtension("OES_vertex_array_object"),this.instanceExt=this.getExtension("ANGLE_instanced_arrays")),this.gl.enable(this.gl.DEPTH_TEST),O=!0,this.gl.enable(this.gl.CULL_FACE),this.gl.cullFace(this.gl.BACK),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),ie(...e.clearColor??[0,0,0,1]),n.getError(),null!=e.renderpipeline)if(0==e.renderpipeline)this.renderpipeline=new at(this);else{if(1!=e.renderpipeline)throw new Error("Unknown renderpipeline: "+e.renderpipeline);this.renderpipeline=new st(this)}else this.renderpipeline=new st(this);this.shadowCascades=new be({basic:this.programContainers.shadow,instanced:this.programContainers.shadowInstanced,skinned:this.programContainers.shadowSkinned},e.shadowSizes??[4,16],e.shadowBiases??[-3e-4,-5e-4],e.shadowResolution??1024),de("Shadow cascades"),this.bloom=new ge(this.programContainers.bloom),de("Bloom"),this.postprocessing=new pe,de("Post processing"),e.enableGodrays&&this.createProgramFromFile(this.path+`assets/shaders/built-in/webgl${this.version}/godrays`).then((e=>{var t=new we(e);this.godrays=new xe(t),console.info(this.godrays)})),this.gizmos=new me,this.skybox=new Ee(this.programContainers.skybox),de("Skybox"),this.splitsumTexture=this.loadSplitsum(this.path+"assets/pbr/splitsum.png"),de("Splitsum"),this.ditherTexture=this.loadTexture(this.path+"assets/textures/dither.png"),de("Dither"),y=performance.now(),requestAnimationFrame(H)},this.getTime=function(){return C},this.setRenderScale=function(e){E=e,W()},this.getRenderScale=function(){return E},this.setCanvasSize=function(e,t){-1===e?delete this.setupSettings.width:this.setupSettings.width=e,-1===t?delete this.setupSettings.height:this.setupSettings.height=t,W()},this.update=function(e){this.getActiveScene().update(e)},this.render=function(e,t=null,n={}){const r=this.getActiveScene();if(!r)throw new Error("No active scene");this.postprocessing.exposure.value=r.postprocessing.exposure,this.postprocessing.gamma.value=r.postprocessing.gamma,this.postprocessing.tonemapping.value=r.postprocessing.tonemapping,this.postprocessing.motionBlurStrength.value=r.postprocessing.motionBlurStrength,this.postprocessing.saturation.value=r.postprocessing.saturation,this.postprocessing.contrast.value=r.postprocessing.contrast,this.postprocessing.vignette.amount.value=r.postprocessing.vignette.amount,this.postprocessing.vignette.falloff.value=r.postprocessing.vignette.falloff,this.postprocessing.whiteBalance.temperature.value=r.postprocessing.whiteBalance.temperature,this.postprocessing.whiteBalance.tint.value=r.postprocessing.whiteBalance.tint,this.bloom.setProperties(r.bloom),this.renderpipeline.render(e,t,r,n)},Object.defineProperty(this,"aspect",{get:function(){return n.canvas.clientWidth/n.canvas.clientHeight}}),this.add=function(e){return this.scenes.push(e),e.renderer=this,e.setupUBO(),e},this.on=function(e,t){this.eventHandler.addEvent(e,t)},this.getActiveScene=function(){return this.scenes[this.currentScene]},this.setActiveScene=function(e){if(this.shadowCascades.clearShadowmaps(),"number"==typeof e){if(e<0||e>=this.scenes.length)throw new Error("Scene index outside valid range (0-"+(this.scenes.length-1)+"): "+e);this.currentScene=e}else{if(!(e instanceof V))throw new Error("Scene not valid");var t=this.scenes.indexOf(e);if(-1==t)throw console.error(e),new Error("Scene has not been added to renderer");this.currentScene=t}},this.disableContextMenu=function(){T.canvas.addEventListener("contextmenu",(function(e){e.preventDefault()}))},this.disablePinchToZoom=function(){document.addEventListener("touchmove",(function(e){1!==e.scale&&e.preventDefault()}),{passive:!1})},this.isPointerLocked=function(){return document.pointerLockElement===this.canvas||document.mozPointerLockElement===this.canvas},this.lockPointer=function(){this.canvas.requestPointerLock=this.canvas.requestPointerLock||this.canvas.mozRequestPointerLock,this.canvas.requestPointerLock()},this.unlockPointer=function(){document.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock,document.exitPointerLock()},this.getKey=function(e){return!!D[e]},this.getKeyDown=function(e,t=""){if(this.getKey(e)){if(P[e+t])return P[e+t]=!1,!0}else P[e+t]=!0;return!1},this.getKeyUp=function(e,t=""){if(this.getKey(e))N[e+t]=!0;else if(N[e+t])return N[e+t]=!1,!0;return!1},this.saveCanvasAsImage=function(e){(0,b.gA)(this.canvas,e)},this.createCubemapFromHDR=async function(e,t=1024,r=1){var i=await x(e),o=i.data;if(!this.floatTextures)throw new Error("Half float not currently supported");var a=n.createTexture();n.bindTexture(n.TEXTURE_2D,a),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,0),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,i.width,i.height,0,n.RGBA,n.UNSIGNED_BYTE,o),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);var s=new I(this.programContainers.equirectangularToCubemap,{equirectangularMap:a});s.doubleSided=!0;var l=new U("Cubemap",{meshRenderer:new Ne([s],[new Se(tt())]),castShadows:!1}),c=v.Z.orthographic({size:1}),u=[v.Z.identity(),v.Z.inverse(v.Z.transform([["ry",Math.PI]])),v.Z.inverse(v.Z.transform([["ry",Math.PI/2],["rx",-Math.PI/2]])),v.Z.inverse(v.Z.transform([["ry",Math.PI/2],["rx",Math.PI/2]])),v.Z.inverse(v.Z.transform([["ry",Math.PI/2]])),v.Z.inverse(v.Z.transform([["ry",-Math.PI/2]]))],h=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,h);const f=n.createRenderbuffer();n.bindRenderbuffer(n.RENDERBUFFER,f),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t,t),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,f);var d=n.createTexture();n.bindTexture(n.TEXTURE_CUBE_MAP,d);for(let e=0;e<6;e++)n.bindTexture(n.TEXTURE_CUBE_MAP,d),n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,1==this.version?n.RGBA:n.RGBA32F,t,t,0,n.RGBA,K(),null);n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.TEXTURE_WRAP_R&&n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),T.disableCulling(),n.viewport(0,0,t,t);for(let e=0;e<6;e++)n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+e,d,0),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap,l.render({projectionMatrix:c,viewMatrix:u[e],inverseViewMatrix:v.Z.inverse(u[e])});return n.bindTexture(n.TEXTURE_CUBE_MAP,d),n.generateMipmap(n.TEXTURE_CUBE_MAP),T.enableCulling(),d},this.createSpecularCubemapFromHDR=async function(e,t=1024,r=1){var i=[],o=[];for(let t=0;t<5;t++){var a=await x(e+"/specular_mip_"+t+".hdr"),s=a.data;if(!this.floatTextures)if(T.textureHalfFloatExt)s=(0,b.wo)(s);else{s=new Uint8Array(a.data.length);for(let e=0;e<a.data.length;e++)s[e]=Math.min(255,255*Math.pow(a.data[e]/(a.data[e]+1)*2,1/2.2))}var l=n.createTexture();n.bindTexture(n.TEXTURE_2D,l),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,0),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,a.width,a.height,0,n.RGBA,n.UNSIGNED_BYTE,s),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),i.push({hdr:a,pixelData:s,hdrTexture:l})}var c=new I(this.programContainers.equirectangularToCubemap,{equirectangularMap:l});c.doubleSided=!0;var u,h,f=new U("Cubemap",{meshRenderer:new Ne([c],[new Se(tt())]),castShadows:!1}),d=v.Z.orthographic({size:1}),m=[v.Z.identity(),v.Z.inverse(v.Z.transform([["ry",Math.PI]])),v.Z.inverse(v.Z.transform([["ry",Math.PI/2],["rx",-Math.PI/2]])),v.Z.inverse(v.Z.transform([["ry",Math.PI/2],["rx",Math.PI/2]])),v.Z.inverse(v.Z.transform([["ry",Math.PI/2]])),v.Z.inverse(v.Z.transform([["ry",-Math.PI/2]]))];1!=this.version&&(u=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,u),h=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,h),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t,t),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,h));var p=n.createTexture();n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_CUBE_MAP,p);for(let e=0;e<6;e++)n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,1==this.version?n.RGBA:n.RGBA32F,t,t,0,n.RGBA,K(),null);n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR_MIPMAP_LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.TEXTURE_WRAP_R&&n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),n.generateMipmap(n.TEXTURE_CUBE_MAP),T.disableCulling();for(var g=0;g<5;g++){var E=t*Math.pow(.5,g);1==this.version?o.push(Q(E,E)):(n.bindRenderbuffer(n.RENDERBUFFER,h),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,E,E)),n.viewport(0,0,E,E),c.setUniform("equirectangularMap",i[g].hdrTexture);for(var w=0;w<6;w++)1!=this.version&&n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+w,p,g),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap,f.render({projectionMatrix:d,viewMatrix:m[w],inverseViewMatrix:v.Z.inverse(m[w])}),1==this.version&&(n.bindTexture(n.TEXTURE_CUBE_MAP,p),n.copyTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+w,g,0,0,0,0,E,E))}for(var y of o)n.deleteFramebuffer(y.framebuffer);return T.enableCulling(),p},this.getSpecularCubemap=async function(e,t=128){if(!T.floatTextures&&!T.textureHalfFloatExt)return e;var r=new I(this.programContainers.specularCubemap,{environmentMap:e,roughness:0});r.doubleSided=!0;var i,o,a=new U("Cubemap",{meshRenderer:new Ne([r],[new Se(tt())]),castShadows:!1}),s=v.Z.orthographic({size:1}),l=[v.Z.inverse(v.Z.transform([["ry",-Math.PI/2],["rz",Math.PI]])),v.Z.inverse(v.Z.transform([["ry",Math.PI/2],["rz",Math.PI]])),v.Z.inverse(v.Z.transform([["rx",Math.PI/2]])),v.Z.inverse(v.Z.transform([["rx",-Math.PI/2]])),v.Z.inverse(v.Z.transform([["ry",Math.PI],["rz",Math.PI]])),v.Z.inverse(v.Z.transform([["rz",Math.PI]]))],c=[];1!=this.version&&(i=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,i),o=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,o),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t,t),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,o));var u=n.createTexture();n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_CUBE_MAP,u);for(let e=0;e<6;e++)n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,1==this.version?n.RGBA:n.RGBA16F,t,t,0,n.RGBA,K(),null);n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR_MIPMAP_LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.TEXTURE_WRAP_R&&n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),n.generateMipmap(n.TEXTURE_CUBE_MAP),T.disableCulling();for(var h=0;h<5;h++){var f=t*Math.pow(.5,h);1==this.version?c.push(Q(f,f)):(n.bindRenderbuffer(n.RENDERBUFFER,o),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,f,f)),n.viewport(0,0,f,f);var d=h/4;r.setUniform("roughness",d);for(let e=0;e<6;e++){1!=this.version&&n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+e,u,h),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap;var m=l[e];a.render({projectionMatrix:s,viewMatrix:m,inverseViewMatrix:v.Z.inverse(m)}),1==this.version&&(n.bindTexture(n.TEXTURE_CUBE_MAP,u),n.copyTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+e,h,0,0,0,0,f,f))}}for(var p of c)n.deleteFramebuffer(p.framebuffer);return T.enableCulling(),u},this.getDiffuseCubemap=async function(e){var t=new I(this.programContainers.diffuseCubemap,{environmentMap:e});return await this.createCubemapFromCube(t,32)},this.createCubemapFromCube=async function(e,t){e.doubleSided=!0;var r=new U("Cubemap",{meshRenderer:new Ne([e],[new Se(tt())]),castShadows:!1}),i=v.Z.orthographic({size:1}),o=[v.Z.inverse(v.Z.transform([["ry",-Math.PI/2],["rz",Math.PI]])),v.Z.inverse(v.Z.transform([["ry",Math.PI/2],["rz",Math.PI]])),v.Z.inverse(v.Z.transform([["rx",Math.PI/2]])),v.Z.inverse(v.Z.transform([["rx",-Math.PI/2]])),v.Z.inverse(v.Z.transform([["ry",Math.PI],["rz",Math.PI]])),v.Z.inverse(v.Z.transform([["rz",Math.PI]]))],a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a);const s=n.createRenderbuffer();n.bindRenderbuffer(n.RENDERBUFFER,s),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t,t),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,s);var l=n.createTexture();n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_CUBE_MAP,l);var c=1==this.version?n.RGBA:n.RGBA32F,u=n.RGBA;for(let e=0;e<6;e++)n.bindTexture(n.TEXTURE_CUBE_MAP,l),n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,c,t,t,0,u,K(),null);n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.TEXTURE_WRAP_R&&n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),T.disableCulling(),n.viewport(0,0,t,t);for(let e=0;e<6;e++)n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+e,l,0),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap,r.render({projectionMatrix:i,viewMatrix:o[e],inverseViewMatrix:v.Z.inverse(o[e])}),await(0,b._v)(200);return T.enableCulling(),n.deleteFramebuffer(a),l},this.captureReflectionCubemap=function(e=m.Z.zero(),t=512){var r=v.Z.perspective({fov:Math.PI/4,aspect:1,near:.001,far:100}),i=[v.Z.inverse(v.Z.transform([["translate",e],["ry",-Math.PI/2],["rz",Math.PI]])),v.Z.inverse(v.Z.transform([["translate",e],["ry",Math.PI/2],["rz",Math.PI]])),v.Z.inverse(v.Z.transform([["translate",e],["rx",Math.PI/2]])),v.Z.inverse(v.Z.transform([["translate",e],["rx",-Math.PI/2]])),v.Z.inverse(v.Z.transform([["translate",e],["ry",Math.PI],["rz",Math.PI]])),v.Z.inverse(v.Z.transform([["translate",e],["rz",Math.PI]]))],o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o);const a=n.createRenderbuffer();n.bindRenderbuffer(n.RENDERBUFFER,a),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t,t),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,a);var s=n.createTexture();n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_CUBE_MAP,s);for(let e=0;e<6;e++)n.bindTexture(n.TEXTURE_CUBE_MAP,s),n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,n.RGBA32F,t,t,0,n.RGBA,K(),null);n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.TEXTURE_WRAP_R&&n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),n.viewport(0,0,t,t);for(let e=0;e<6;e++){n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+e,s,0),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT);var l={projectionMatrix:r,viewMatrix:i[e],inverseViewMatrix:v.Z.inverse(i[e]),cameraMatrix:v.Z.inverse(i[e])},c=this.scenes[this.currentScene];c.skyboxVisible&&this.skybox.render(l,c.skyboxCubemap),c.updateUniformBuffers(l.projectionMatrix,l.viewMatrix,l.inverseViewMatrix),n.activeTexture(n.TEXTURE0+2),n.bindTexture(n.TEXTURE_CUBE_MAP,c.diffuseCubemap),n.activeTexture(n.TEXTURE0+1),n.bindTexture(n.TEXTURE_CUBE_MAP,c.specularCubemap),n.activeTexture(n.TEXTURE0+0),n.bindTexture(n.TEXTURE_2D,this.splitsumTexture),n.colorMask(!0,!0,!0,!1),n.disable(n.BLEND),c.render(l,{renderPass:d.OPAQUE}),n.enable(n.BLEND),n.depthMask(!1),c.render(l,{renderPass:d.ALPHA}),n.depthMask(!0),n.colorMask(!0,!0,!0,!0),ue(null)}return s},this.saveSpecularCubemapAsHDR=async function(e,t=5,n=128){for(var r=0;r<t;r++){var i=n*Math.pow(.5,r);await this.saveCubemapAsHDR(e,i,r,"specular_mip_"+r)}},this.saveCubemapAsHDR=async function(e,t=512,r=0,i="cubemap"){var o=t,a=t/2,s=Q(o,a),l=await this.createProgramFromFile(this.path+"assets/shaders/built-in/webgl2/equirectangularFromCubemap"),c=J(new Float32Array([-1,1,-1,-1,1,1,1,-1])),u=n.getAttribLocation(l,"position"),h=J(new Float32Array([0,0,0,1,1,0,1,1])),f=n.getAttribLocation(l,"uv");n.bindFramebuffer(n.FRAMEBUFFER,s.framebuffer),T.disableCulling(),n.viewport(0,0,o,a),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),re(l),ue(null),n.bindBuffer(n.ARRAY_BUFFER,c),n.enableVertexAttribArray(u),n.vertexAttribPointer(u,2,n.FLOAT,!1,8,0),n.bindBuffer(n.ARRAY_BUFFER,h),n.enableVertexAttribArray(f),n.vertexAttribPointer(f,2,n.FLOAT,!1,8,0),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_CUBE_MAP,e),n.uniform1i(n.getUniformLocation(l,"cubemap"),0),n.uniform1f(n.getUniformLocation(l,"mipmapLevel"),r),n.drawArrays(n.TRIANGLE_STRIP,0,4);var d=new Float32Array(o*a*4);return n.readPixels(0,0,o,a,n.RGBA,n.FLOAT,d),function(e,t=1024,n=512,r="new"){for(var i=`#?RADIANCE\nFORMAT=32-bit_rle_rgbe\n\n-Y ${n} +X ${t}\n`,o=(new TextEncoder).encode(i),a=[],s=0;s<e.length;s+=4){var l=e[s],c=e[s+1],u=e[s+2];a.push(...g(l,c,u))}var h=new Uint8Array(o.length+a.length);h.set(o,0),h.set(a,o.length),function(e,t,n){const r=new Blob([e],{type:"application/octet-stream"}),i=window.URL.createObjectURL(r);(function(e,t){const n=document.createElement("a");n.href=e,n.download=t,document.body.appendChild(n),n.style.display="none",n.click(),n.remove()})(i,t),setTimeout((()=>window.URL.revokeObjectURL(i)),1e3)}(h,r+".hdr")}(d,o,a,i),!0},this.saveCubemapAsImages=async function(e,t=512){var r=new we(await this.createProgramFromFile("../assets/shaders/built-in/webgl2/cubemapVis")),i=new I(r,{environmentMap:e});i.doubleSided=!0;var o=new U("Cubemap",{meshRenderer:new Ne([i],[new Se(tt())]),castShadows:!1}),a=v.Z.orthographic({size:1}),s=[v.Z.inverse(v.Z.transform([["ry",-Math.PI/2],["rz",Math.PI]])),v.Z.inverse(v.Z.transform([["ry",Math.PI/2],["rz",Math.PI]])),v.Z.inverse(v.Z.transform([["rx",Math.PI/2]])),v.Z.inverse(v.Z.transform([["rx",-Math.PI/2]])),v.Z.inverse(v.Z.transform([["ry",Math.PI],["rz",Math.PI]])),v.Z.inverse(v.Z.transform([["rz",Math.PI]]))],l=this.canvas.width,c=this.canvas.height;this.canvas.width=t,this.canvas.height=t,n.bindFramebuffer(n.FRAMEBUFFER,null),T.disableCulling(),n.viewport(0,0,t,t);for(var u=0;u<6;u++)n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap,o.render({projectionMatrix:a,viewMatrix:s[u],inverseViewMatrix:v.Z.inverse(s[u])}),(0,b.gA)(T.canvas,"cubemap"+u);return T.enableCulling(),this.canvas.width=l,this.canvas.height=c,!0},this.loadSplitsum=function(e){return Be(e,{TEXTURE_MIN_FILTER:n.LINEAR,TEXTURE_WRAP_S:n.CLAMP_TO_EDGE,TEXTURE_WRAP_T:n.CLAMP_TO_EDGE})},this.loadTextFile=async function(e){return await(await fetch(e,{mode:"cors",headers:{"Access-Control-Allow-Origin":"*"}})).text()},this.createProgramFromFile=async function(e,t){var n=e+"/vertex.glsl",r=e+"/fragment.glsl";null!=t&&(n=e,r=t);var i=await this.loadTextFile(n),o=await this.loadTextFile(r);return this.createProgram(i,o)},this.createProgram=function(e,t){e=e.trim(),t=t.trim();var r=q(e,n.VERTEX_SHADER),i=q(t,n.FRAGMENT_SHADER),o=n.createProgram();return n.attachShader(o,r),n.attachShader(o,i),n.linkProgram(o),Y(o),o},this.updateVertexShader=function(e,t){var r=n.getAttachedShaders(e.program)[0];this.updateShader(r,e,t)},this.updateFragmentShader=function(e,t){var r=n.getAttachedShaders(e.program)[1];this.updateShader(r,e,t)},this.updateShader=function(e,t,r){n.shaderSource(e,r),n.compileShader(e),n.linkProgram(t.program),Y(t.program),t.updateUniformLocations()},this.CustomProgram=class{constructor(e){var t=e["webgl"+T.version]??e;if(t.vertex&&t.fragment){var n=T.createProgram(t.vertex,t.fragment);return new T.ProgramContainer(n)}console.error("Custom program does not have a vertex/fragment shader for version "+T.version)}},this.enableCulling=function(){!0!==O&&(this.gl.enable(this.gl.CULL_FACE),O=!0)},this.disableCulling=function(){!1!==O&&(this.gl.disable(this.gl.CULL_FACE),O=!1)},this.getExtension=function(e){return this.gl.getExtension(e)||(console.error("Could not get extension: "+e),!1)},this.getSRGBFormats=function(){return{internalFormat:1==T.version?T.sRGBExt&&(T.floatTextures||T.textureHalfFloatExt)?T.sRGBExt.SRGB_ALPHA_EXT:n.RGBA:n.SRGB8_ALPHA8,format:1==T.version&&T.sRGBExt&&(T.floatTextures||T.textureHalfFloatExt)?T.sRGBExt.SRGB_ALPHA_EXT:n.RGBA}},this.setClearColor=ie;var ae={};function se(e){var t=ae[e];if(t)return t;for(const t in n)if(n[t]===e)return ae[e]=t,t;return""}function le(e,t=ne){if(!(e in S)){console.log("Loading program:",e);var n=t["webgl"+T.version][e];if(!n||!n.vertex||!n.fragment)return console.error(`Program ${e} not found for version ${T.version}!`),void(S[e]=void 0);var r=T.createProgram(n.vertex,n.fragment);S[e]=new we(r)}return S[e]}function ce(e){return 1==T.version?T.VAOExt.deleteVertexArrayOES(e):n.deleteVertexArray(e)}function ue(e){1==T.version?T.VAOExt.bindVertexArrayOES(e):2==T.version&&n.bindVertexArray(e)}function he(e,t){1==T.version?T.instanceExt.vertexAttribDivisorANGLE(e,t):2==T.version&&n.vertexAttribDivisor(e,t)}function fe(e,t,r,i,o){1==T.version?T.instanceExt.drawElementsInstancedANGLE(e,t,r,i,o):2==T.version&&n.drawElementsInstanced(e,t,r,i,o)}function de(e="",t=!1){var r=n.getError();t?console[r?"error":"log"]("("+e+") "+L[r]):0!==r&&console.error("("+e+") "+L[r])}function me(){var e;this.gameObject=new U("Gizmos");var t=!1,r=()=>{var t=ye({},T.programContainers.unlitInstanced),r=function(){const e=new Float32Array([0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1]),t=new Uint32Array([0,1,2,3,4,5]),r=new Float32Array([0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0]);return new Se({indices:{bufferData:t,target:n.ELEMENT_ARRAY_BUFFER},position:{bufferData:e,size:3},color:{bufferData:r,size:3}})}();(e=new Ue(t,r)).drawMode=n.LINES,this.gameObject.meshRenderer=e};this.visualize=function(n){t||(r(),t=!0);var i=e.addInstance(n.transform.worldMatrix);setInterval((function(){var t=n.transform.worldMatrix;v.Z.setScale(t,m.Z.fill(.3)),e.updateInstance(i,t)}),16)}}function ve(){var e=new Float32Array([-1,1,-1,-1,1,1,1,-1]);this.vertexBuffer=J(e),this.bindBuffers=function(e){n.bindBuffer(n.ARRAY_BUFFER,this.vertexBuffer),n.enableVertexAttribArray(e),n.vertexAttribPointer(e,2,n.FLOAT,!1,8,0)},this.render=function(){n.drawArrays(n.TRIANGLE_STRIP,0,4)}}function pe(){var e=this;function t(e,t=(()=>{})){this.value=e;var n=e;this.onChange=t;var r=!1;this.update=function(){this.value==n&&r||(this.onChange(this.value,n),n=this.value,r=!0)}}this.TONEMAPPING={NONE:0,ACES:1,REINHARD:2},this.exposure=new t(0,(e=>{n.uniform1f(this.programContainer.getUniformLocation("exposure"),e)})),this.gamma=new t(2.2,(e=>{n.uniform1f(this.programContainer.getUniformLocation("gamma"),e)})),this.tonemapping=new t(this.TONEMAPPING.ACES,(e=>{n.uniform1i(this.programContainer.getUniformLocation("tonemapping"),e)})),this.motionBlurStrength=new t(.2,((e,t)=>{o(e,t)||n.uniform1f(this.programContainer.getUniformLocation("motionBlurStrength"),e)})),this.saturation=new t(0,(e=>{n.uniform1f(this.programContainer.getUniformLocation("saturation"),e)})),this.contrast=new t(0,(e=>{n.uniform1f(this.programContainer.getUniformLocation("contrast"),e)})),this.vignette={amount:new t(0,(e=>{n.uniform1f(this.programContainer.getUniformLocation("vignetteAmount"),e)})),falloff:new t(0,(e=>{n.uniform1f(this.programContainer.getUniformLocation("vignetteFalloff"),e)}))},this.whiteBalance={temperature:new t(0,(e=>{n.uniform1f(this.programContainer.getUniformLocation("temperature"),e)})),tint:new t(0,(e=>{n.uniform1f(this.programContainer.getUniformLocation("tint"),e)}))};var r,i,o=(e,t)=>{if(e>0&&0==t||0==e&&t>0){for(var n of(T.updateFragmentShader(this.programContainer,v().fragment),a))n.onChange(n.value,n.value);return m(),console.info("Recompiling postprocessing"),!0}return!1},a=[this.exposure,this.gamma,this.tonemapping,this.motionBlurStrength,this.saturation,this.contrast,this.vignette.amount,this.vignette.falloff,this.whiteBalance.temperature,this.whiteBalance.tint],s=v(),c=T.createProgram(s.vertex,s.fragment);this.programContainer=new we(c);var u,h=n.canvas.width,f=n.canvas.height;T.version,this.framebuffer=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,this.framebuffer),this.colorBuffer=n.createTexture(),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,this.colorBuffer),n.texImage2D(n.TEXTURE_2D,0,1==T.version?n.RGBA:n.RGBA16F,h,f,0,n.RGBA,K(),null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,this.colorBuffer,0),T.version>1&&(this.motionBlurColorBuffer=n.createTexture(),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,this.motionBlurColorBuffer),n.texImage2D(n.TEXTURE_2D,0,1==T.version?n.RGBA:n.RGBA16F,h,f,0,n.RGBA,K(),null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT1,n.TEXTURE_2D,this.motionBlurColorBuffer,0)),u=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,u),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,h,f),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,u),this.downscaledFramebuffer=Q(h/4,f/4);var d=new ve,m=()=>{re(this.programContainer.program),n.uniform1i(this.programContainer.getUniformLocation("mainTexture"),0),n.uniform1i(this.programContainer.getUniformLocation("bloomTexture"),1),this.depthTexture||T.godrays?n.uniform1i(this.programContainer.getUniformLocation("depthTexture"),2):n.uniform1i(this.programContainer.getUniformLocation("enableGodrays"),0),n.uniform1i(this.programContainer.getUniformLocation("motionBlurTexture"),3),this.motionBlurColorBuffer&&n.uniform1i(this.programContainer.getUniformLocation("motionBlurTexture"),16),n.uniform2f(this.programContainer.getUniformLocation("SIZE"),n.canvas.width,n.canvas.height)};function v(){var t=l["webgl"+T.version].postprocessing;if(t&&t.vertex&&t.fragment){var n="#version 300 es\n";return T.version>1&&e.motionBlurStrength.value>1e-6&&(n+="#define ENABLE_MOTIONBLUR\n"),n+="#define TONEMAPPING "+e.tonemapping.value+"\n",T.godrays&&(n+="#define ENABLE_GODRAYS\n"),T.bloom.getIntensity()>1e-6&&(n+="#define ENABLE_BLOOM\n"),n+=t.fragment,{vertex:t.vertex,fragment:n}}console.error(`Program postprocessing not found for version ${T.version}!`)}m(),this.getFramebuffer=function(){return this.preFramebuffer?this.preFramebuffer:this.framebuffer},this.bindFramebuffer=function(){n.bindFramebuffer(n.FRAMEBUFFER,this.getFramebuffer())},this.blitAA=function(){this.preFramebuffer&&(n.bindFramebuffer(n.READ_FRAMEBUFFER,this.preFramebuffer),n.bindFramebuffer(n.DRAW_FRAMEBUFFER,this.framebuffer),n.clearBufferfv(n.COLOR,0,[1,1,1,1]),n.blitFramebuffer(0,0,h,f,0,0,h,f,n.COLOR_BUFFER_BIT,n.LINEAR),n.bindFramebuffer(n.FRAMEBUFFER,this.preFramebuffer))},this.resizeFramebuffers=function(){h=n.canvas.width,f=n.canvas.height,n.bindTexture(n.TEXTURE_2D,this.downscaledFramebuffer.colorBuffer),n.texImage2D(n.TEXTURE_2D,0,1==T.version?n.RGBA:n.RGBA16F,h/4,f/4,0,n.RGBA,K(),null),n.bindTexture(n.TEXTURE_2D,this.colorBuffer),n.texImage2D(n.TEXTURE_2D,0,1==T.version?n.RGBA:n.RGBA16F,n.canvas.width,n.canvas.height,0,n.RGBA,K(),null),this.motionBlurColorBuffer&&(n.bindTexture(n.TEXTURE_2D,this.motionBlurColorBuffer),n.texImage2D(n.TEXTURE_2D,0,1==T.version?n.RGBA:n.RGBA16F,n.canvas.width,n.canvas.height,0,n.RGBA,K(),null)),this.depthTexture?(n.bindTexture(n.TEXTURE_2D,this.depthTexture),n.texImage2D(n.TEXTURE_2D,0,1==T.version?n.DEPTH_COMPONENT:n.DEPTH_COMPONENT16,n.canvas.width,n.canvas.height,0,n.DEPTH_COMPONENT,n.UNSIGNED_INT,null)):this.preFramebuffer?(n.bindRenderbuffer(n.RENDERBUFFER,u),n.renderbufferStorageMultisample(n.RENDERBUFFER,n.getParameter(n.MAX_SAMPLES),n.DEPTH_COMPONENT16,n.canvas.width,n.canvas.height)):(n.bindRenderbuffer(n.RENDERBUFFER,u),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,n.canvas.width,n.canvas.height)),this.preFramebuffer&&(n.bindRenderbuffer(n.RENDERBUFFER,void 0),n.renderbufferStorageMultisample(n.RENDERBUFFER,n.getParameter(n.MAX_SAMPLES),n.RGBA16F,n.canvas.width,n.canvas.height)),n.bindTexture(n.TEXTURE_2D,null)},this.render=function(){n.bindFramebuffer(n.FRAMEBUFFER,null),n.viewport(0,0,n.canvas.width,n.canvas.height),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),re(this.programContainer.program),ue(null),n.bindBuffer(n.ARRAY_BUFFER,d.vertexBuffer);var e=this.programContainer.getAttribLocation("position");for(var t of(n.enableVertexAttribArray(e),n.vertexAttribPointer(e,2,n.FLOAT,!1,8,0),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,this.colorBuffer),n.activeTexture(n.TEXTURE1),n.bindTexture(n.TEXTURE_2D,T.bloom.upsampleFramebuffers[T.bloom.upsampleFramebuffers.length-1].colorBuffer),this.depthTexture?(n.activeTexture(n.TEXTURE2),n.bindTexture(n.TEXTURE_2D,this.depthTexture)):T.godrays&&(n.activeTexture(n.TEXTURE2),n.bindTexture(n.TEXTURE_2D,T.godrays.framebufferData.colorBuffer)),this.motionBlurColorBuffer&&(n.activeTexture(n.TEXTURE25),n.bindTexture(n.TEXTURE_2D,this.motionBlurColorBuffer),n.uniform1i(this.programContainer.getUniformLocation("motionBlurTexture"),25)),this.rainTexture&&(n.activeTexture(n.TEXTURE17),n.bindTexture(n.TEXTURE_2D,this.rainTexture),n.uniform1i(this.programContainer.getUniformLocation("rainTexture"),17)),n.activeTexture(n.TEXTURE18),n.bindTexture(n.TEXTURE_2D,this.downscaledFramebuffer.colorBuffer),n.uniform1i(this.programContainer.getUniformLocation("downscaledTexture"),18),n.uniform1f(this.programContainer.getUniformLocation("iTime"),(new Date-T.startTime)/1e3),n.canvas.width===r&&n.canvas.height===i||(r=n.canvas.width,i=n.canvas.height,n.uniform2f(this.programContainer.getUniformLocation("SIZE"),n.canvas.width,n.canvas.height)),n.uniform1f(this.programContainer.getUniformLocation("bloomIntensity"),T.bloom.getIntensity()),a))t.update();d.render()}}function ge(e){this.programContainer=e;var t=!0,r=1,i=1,o=.5,a=10,s=.05,l={enabled:t};this.downsampleFramebuffers=[],this.upsampleFramebuffers=[];var c=J(new Float32Array([-1,1,-1,-1,1,1,1,-1]));re(this.programContainer.program),n.uniform1i(this.programContainer.getUniformLocation("mainTexture"),0),n.uniform1i(this.programContainer.getUniformLocation("secondTexture"),1),this.resizeFramebuffers=function(){for(let e=0;e<this.downsampleFramebuffers.length;e++)n.deleteFramebuffer(this.downsampleFramebuffers[e].framebuffer);for(let e=0;e<this.upsampleFramebuffers.length;e++)n.deleteFramebuffer(this.upsampleFramebuffers[e].framebuffer);this.downsampleFramebuffers=[],this.upsampleFramebuffers=[];let e=(()=>{let e=Math.min(n.canvas.width,n.canvas.height),t=Math.floor(Math.log(e)/Math.log(2));return Math.min(7,t)})();for(let t=0;t<e;t++){let e=Math.pow(.5,t+1);this.downsampleFramebuffers.push(Q(Math.floor(n.canvas.width*e),Math.floor(n.canvas.height*e)))}for(let t=0;t<e-1;t++){let r=Math.pow(.5,e-1-t);this.upsampleFramebuffers.push(Q(Math.floor(n.canvas.width*r),Math.floor(n.canvas.height*r)))}},this.resizeFramebuffers(),this.render=function(){if(!t&&l.enabled&&this.clearBloom(),l.enabled=t,!t)return;re(this.programContainer.program),n.uniform1f(this.programContainer.getUniformLocation("_SampleScale"),r),n.uniform1f(this.programContainer.getUniformLocation("threshold"),i),n.uniform1f(this.programContainer.getUniformLocation("knee"),o),n.uniform1f(this.programContainer.getUniformLocation("_Clamp"),a);let e=this.programContainer.getAttribLocation("position");n.bindBuffer(n.ARRAY_BUFFER,c),n.enableVertexAttribArray(e),n.vertexAttribPointer(e,2,n.FLOAT,!1,8,0),n.activeTexture(n.TEXTURE0);for(var s=0;s<this.downsampleFramebuffers.length;s++){var u=this.downsampleFramebuffers[s];n.bindFramebuffer(n.FRAMEBUFFER,u.framebuffer),n.viewport(0,0,u.width,u.height),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n.bindTexture(n.TEXTURE_2D,s<1?T.postprocessing.colorBuffer:this.downsampleFramebuffers[s-1].colorBuffer),this.programContainer.getUniformLocation("mainTextureSize")&&n.uniform2fv(this.programContainer.getUniformLocation("mainTextureSize"),s<1?[n.canvas.width,n.canvas.height]:[this.downsampleFramebuffers[s-1].width,this.downsampleFramebuffers[s-1].height]),n.uniform2f(this.programContainer.getUniformLocation("screenSize"),u.width,u.height),n.uniform1i(this.programContainer.getUniformLocation("stage"),0==s?0:1),n.drawArrays(n.TRIANGLE_STRIP,0,4)}n.uniform1i(this.programContainer.getUniformLocation("stage"),2);for(let e=0;e<this.upsampleFramebuffers.length;e++){let t=this.upsampleFramebuffers[e];if(n.bindFramebuffer(n.FRAMEBUFFER,t.framebuffer),n.viewport(0,0,t.width,t.height),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,e<1?this.downsampleFramebuffers[this.downsampleFramebuffers.length-1].colorBuffer:this.upsampleFramebuffers[e-1].colorBuffer),n.activeTexture(n.TEXTURE1),n.bindTexture(n.TEXTURE_2D,this.downsampleFramebuffers[this.downsampleFramebuffers.length-2-e].colorBuffer),this.programContainer.getUniformLocation("mainTextureSize")){let t=e<1?this.downsampleFramebuffers[this.downsampleFramebuffers.length-1]:this.upsampleFramebuffers[e-1];n.uniform2f(this.programContainer.getUniformLocation("mainTextureSize"),t.width,t.height)}n.uniform2f(this.programContainer.getUniformLocation("screenSize"),t.width,t.height),n.drawArrays(n.TRIANGLE_STRIP,0,4)}},this.clearBloom=function(){n.bindFramebuffer(n.FRAMEBUFFER,this.upsampleFramebuffers[this.upsampleFramebuffers.length-1].framebuffer);var e=B;ie(0,0,0,1),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),ie(...e)},this.setProperties=function(e){t=e.enabled,r=e.sampleScale,i=e.threshold,o=e.knee,a=e.clamp,s=e.intensity},this.getIntensity=function(){return s}}function xe(e){this.material=new I(e);var t=.2;this.framebufferData=Q(n.canvas.width*t,n.canvas.height*t);var r=n.createRenderbuffer();n.bindRenderbuffer(n.RENDERBUFFER,r),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,n.canvas.width*t,n.canvas.height*t),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,r),this.render=function(e,t){n.bindFramebuffer(n.FRAMEBUFFER,this.framebufferData.framebuffer),n.viewport(0,0,this.framebufferData.width,this.framebufferData.height),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),e.render(t,{renderPass:d.OPAQUE,materialOverride:this.material}),T.skybox.render(t,e.skyboxCubemap)}}function be(e,t=[50,8],r=[-.0025,-5e-4],i=1024){var o=this;t.reverse(),r.reverse(),this.levels=t.length,this.programContainers=e,this.programContainer=e.basic,Object.defineProperty(this,"program",{get:function(){return o.programContainer.program},set:e=>{o.programContainer.setProgram(e)}}),this.material=new I(this.programContainer),this.materialInstanced=new I(this.programContainers.instanced),this.materialSkinned=new I(this.programContainers.skinned);var a=new Float32Array(16*this.levels);this.shadowmaps=[];for(let e=0;e<this.levels;e++){var s=new Te(i,t[e],r[e],[n["TEXTURE"+(30-2*e)],n["TEXTURE"+(31-2*e)]]);s.textureMatrix=new Float32Array(a.buffer,16*Float32Array.BYTES_PER_ELEMENT*(1-e),16),this.shadowmaps.push(s)}var l=new Array(this.levels),c=new Array(this.levels);for(let e=0;e<this.levels;e++){var u=this.levels-1-e;l[e]=30-2*u,c[e]=this.shadowmaps[u].bias}this.clearShadowmaps=function(){for(var e=0;e<this.levels;e++)this.shadowmaps[e].clearShadowmap()};var h=0;this.refreshRate=0,this.renderShadowmaps=function(e){h++;let t=T.scenes[T.currentScene];t.root.traverseCondition((e=>{e.isCulled=!1}),(e=>e.active&&e.visible));for(let n=0;n<this.levels;n++){if(this.refreshRate>=1&&h%this.refreshRate!==Math.floor(n*this.refreshRate/this.levels))continue;let r=this.shadowmaps[n];r.updateModelMatrix(e),r.bind();let i={projectionMatrix:r.shadowPerspeciveMatrix,viewMatrix:r.shadowViewMatrix,inverseViewMatrix:r.shadowInverseViewMatrix,frustum:r.camera.frustum};t.updateUniformBuffers(i.projectionMatrix,i.viewMatrix,i.inverseViewMatrix),t.root.traverseCondition((e=>{e.isCulled||!e.meshRenderer||i.frustum&&e.getAABB()&&!e.getAABB().isInsideFrustum(i.frustum)?e.isCulled=!0:e.isCulled=!1}),(e=>e.active&&e.visible)),t.render(i,{materialOverride:this.material,materialOverrideInstanced:this.materialInstanced,materialOverrideSkinned:this.materialSkinned,renderPass:d.OPAQUE|d.SHADOWS})}},this.setUniforms=function(e){var t=e.getUniformLocation("textureMatrices[0]");null!=t&&(n.uniformMatrix4fv(t,!1,a),n.uniform1iv(e.getUniformLocation("projectedTextures[0]"),l),n.uniform1fv(e.getUniformLocation("biases[0]"),c))}}function Te(e=512,t=20,r=-.006,i=[n.TEXTURE31,n.TEXTURE30]){this.bias=r,this.textureNumbers=i,this.camera=new G({type:G.Type.Orthographic,size:t,near:1,far:300}),this.shadowPerspeciveMatrix=v.Z.orthographic({size:t,near:1,far:300}),this.shadowModelMatrix=v.Z.identity(),this.shadowViewMatrix=v.Z.identity(),this.shadowInverseViewMatrix=v.Z.identity(),this.textureMatrix=null,this.textureMatrixBase=v.Z.transform([["translate",{x:.5,y:.5,z:.5}],["scale",m.Z.fill(.5)]]),this.depthTexture=n.createTexture(),this.depthTextureSize=e,n.activeTexture(i[0]),n.bindTexture(n.TEXTURE_2D,this.depthTexture),n.texImage2D(n.TEXTURE_2D,0,1==T.version?n.DEPTH_COMPONENT:n.DEPTH_COMPONENT16,this.depthTextureSize,this.depthTextureSize,0,n.DEPTH_COMPONENT,n.UNSIGNED_INT,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),this.depthFramebuffer=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,this.depthFramebuffer),n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,this.depthTexture,0),n.activeTexture(n.TEXTURE0);const o=m.Z.zero(),a=new m.Z,s=m.Z.up(),l=new v.Z,c=new m.Z,u=new m.Z;this.updateModelMatrix=function(n){const r=T.getActiveScene();m.Z.negate(r.sunDirection,a),v.Z.lookAt(o,a,s,this.shadowModelMatrix),v.Z.inverse(this.shadowModelMatrix,l),v.Z.transformVector(l,n,c);const i=t/e*2;u.x=(0,b.Pn)(c.x,i),u.y=(0,b.Pn)(c.y,i),u.z=c.z+100,v.Z.applyTranslation(u,this.shadowModelMatrix),this.camera.transform.matrix=this.shadowModelMatrix,v.Z.inverse(this.shadowModelMatrix,this.shadowViewMatrix),v.Z.copy(this.shadowModelMatrix,this.shadowInverseViewMatrix),v.Z.copy(this.textureMatrixBase,this.textureMatrix),v.Z.multiply(this.textureMatrix,this.shadowPerspeciveMatrix,this.textureMatrix),v.Z.multiply(this.textureMatrix,this.shadowViewMatrix,this.textureMatrix)},this.bind=function(){n.bindFramebuffer(n.FRAMEBUFFER,this.depthFramebuffer),n.viewport(0,0,this.depthTextureSize,this.depthTextureSize),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT)},this.clearShadowmap=function(){n.bindFramebuffer(n.FRAMEBUFFER,this.depthFramebuffer),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT)}}function Ee(e){this.programContainer=e;var t=this;Object.defineProperty(this,"program",{get:function(){return t.programContainer.program},set:e=>{t.programContainer.setProgram(e)}}),this.meshData=new Se({position:{bufferData:new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),size:2}}),this.uniformLocations={viewDirectionProjectionInverse:n.getUniformLocation(this.program,"viewDirectionProjectionInverse"),environmentIntensity:n.getUniformLocation(this.program,"environmentIntensity"),skybox:n.getUniformLocation(this.program,"skybox")};var r=v.Z.identity();this.render=function(e,t){if(!t)return;re(this.program),this.meshData.bindBuffers(this.programContainer),v.Z.copy(e.viewMatrix,r),v.Z.removeTranslation(r),v.Z.multiply(e.projectionMatrix,r,r),v.Z.inverse(r,r);const i=T.getActiveScene();n.uniform1f(this.uniformLocations.environmentIntensity,i.environmentIntensity),n.uniformMatrix4fv(this.uniformLocations.viewDirectionProjectionInverse,!1,r),this.programContainer.setUniform("fogColor",i.fogColor),this.programContainer.setUniform("fogIntensity",i.skyboxFogIntensity),this.programContainer.setUniform("iTime",T.getTime()),this.programContainer.setUniform("_SkyboxSpeed",i.skyboxAnimation.speed),this.programContainer.setUniform("_SkyboxDirection",m.Z.toArray(i.skyboxAnimation.direction)),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_CUBE_MAP,t),n.uniform1i(this.uniformLocations.skybox,0),n.depthFunc(n.LEQUAL),n.drawArrays(n.TRIANGLES,0,6),n.depthFunc(n.LESS)}}function we(e){var t,r=this;this.activeAttributes={},this.activeUniforms={},this.uniformBuffers={},Object.defineProperty(this,"program",{get:function(){return t},set:function(e){r.setProgram(e)}}),this.setProgram=function(e){!function(e){e instanceof WebGLProgram||console.error("Not a program:",e)}(e),t=e,this.updateUniformLocations()},this.getUniformLocation=function(e){var t=this.activeUniforms[e];return t?t.location:null},this.setUniform=function(e,t,r=!0){var i=this.activeUniforms[e];if(i)if(-1===i.setType.indexOf("Matrix"))Array.isArray(t)?n["uniform"+i.setType+"v"](i.location,t):n["uniform"+i.setType](i.location,t);else{if(!ArrayBuffer.isView(t))throw console.error(t),new Error(`Cannot set matrix uniform: ${e}. Matrix must be Float32Array`);n["uniform"+i.setType](i.location,!1,t)}else r&&console.warn(`Cannot set uniform: ${e}. Uniform does not exist`)},this.bindTexture=function(e,t,r=0){n.activeTexture(n.TEXTURE0+r),n.bindTexture(n.TEXTURE_2D,e),n.uniform1i(this.getUniformLocation(t),r)},this.getAttribLocation=function(e){var t=this.activeAttributes[e];if(t)return t.location},this.updateUniformLocations=function(){this.activeAttributes={},this.activeUniforms={},this.uniformBuffers={};const e=n.getProgramParameter(t,n.ACTIVE_ATTRIBUTES);for(let r=0;r<e;r++){const e=n.getActiveAttrib(t,r),i=n.getAttribLocation(t,e.name),o=se(e.type);this.activeAttributes[e.name]={location:i,size:e.size,type:e.type,typeString:o}}const r=n.getProgramParameter(t,n.ACTIVE_UNIFORMS);for(let e=0;e<r;e++){const r=n.getActiveUniform(t,e),i=n.getUniformLocation(t,r.name),o=se(r.type),a=oe(o);this.activeUniforms[r.name]={location:i,size:r.size,type:r.type,typeString:o,setType:a}}if(T.version>1){const e=[...Array(r).keys()];var i=Math.max(...n.getActiveUniforms(t,e,n.UNIFORM_BLOCK_INDEX))+1;if(-1!=i)for(let e=0;e<i;e++){var o=n.getActiveUniformBlockName(t,e);if(null!=o){for(var a=n.getActiveUniformBlockParameter(t,e,n.UNIFORM_BLOCK_DATA_SIZE),s=n.getActiveUniformBlockParameter(t,e,n.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),l=new Array(s.length),c=0;c<l.length;c++)l[c]=n.getActiveUniform(t,s[c]).name;var u=n.getUniformIndices(t,l),h=n.getActiveUniforms(t,u,n.UNIFORM_OFFSET);this.uniformBuffers[o]={name:o,blockIndex:e,blockSize:a,subnames:l,offsets:h}}}}},this.setProgram(e)}function ye(e={},t=T.programContainers.lit){return new Z(t,e)}this.logGLError=de,this.TrailRenderer=function(){this.gameObject=null;var e=m.Z.up();Object.defineProperty(this,"emitNormal",{get:function(){return e},set:function(t){m.Z.set(e,t)}});var t=m.Z.zero(),r=!1;Object.defineProperty(this,"emitPosition",{get:function(){return t},set:function(e){m.Z.set(t,e),r=!0}}),this.emit=!0,this.width=.13,this.maxVertices=500,this.minDistance=.05,this.uvOriginAtStart=!0;var i=0,o=new Array(this.maxVertices);for(let e=0;e<o.length;e++)o[e]={position:m.Z.zero(),normal:m.Z.up(),distance:0,alpha:1};var a=0,s=0,l=new Float32Array(2*this.maxVertices*3),c=new Float32Array(2*this.maxVertices*2),u=new Float32Array(2*this.maxVertices*1),h=new Se({position:{bufferData:l,size:3},uv:{bufferData:c,size:2},alpha:{bufferData:u,size:1}}),f=ye({metallic:1,albedo:[.003,.003,.003,1],albedoTexture:Be(T.path+"assets/textures/skidmarksSoft2.png"),alphaCutoff:0},T.programContainers.litTrail);f.opaque=!1,new Ne(f,h).drawMode=n.TRIANGLE_STRIP;var d=v.Z.identity(),g=new m.Z,x=new p.Z,E=m.Z.zero(),w=()=>{r?m.Z.set(E,t):v.Z.getPosition(this.gameObject.transform.worldMatrix,E);var n=a<=0?o[o.length-1]:o[a-1],l=m.Z.distanceSqr(n.position,E);if(l<this.minDistance*this.minDistance)return!1;var c=Math.sqrt(l);m.Z.set(g,n.position),m.Z.subtractTo(g,E),m.Z.divideTo(g,c);var u=o[a],h=u.normal;return p.Z.angleAxis(Math.PI/2,g,x),p.Z.QxV(x,e,h),m.Z.multiplyTo(h,this.width),m.Z.set(u.position,E),u.distance=n.distance+c,u.alpha=this.emit,i+=c,++a>=o.length&&(a=0),s++,s=Math.min(s,this.maxVertices),!0};const y=(e,t=1)=>(e.set(e.subarray(t)),e.fill(0,-t),e);this.update=function(){if(w()){y(l,6),y(c,4),y(u,2);let e=(0,b.re)(a-1,o.length),t=o[e],n=t.position,r=t.normal,s=this.maxVertices-1;l[6*s+0]=n.x+r.x,l[6*s+1]=n.y+r.y,l[6*s+2]=n.z+r.z,l[6*s+3]=n.x-r.x,l[6*s+4]=n.y-r.y,l[6*s+5]=n.z-r.z;let h=t.distance,f=this.uvOriginAtStart?h:i-h;c[4*s+0]=f,c[4*s+1]=1,c[4*s+2]=f,c[4*s+3]=0;for(let e=this.maxVertices-1;e>=0;e--){let t=(0,b.re)(a-this.maxVertices+e,o.length),n=o[t].alpha;n=(0,b.uZ)(n,0,1),n*=e/(this.maxVertices-1);let r=e;u[2*r+0]=n,u[2*r+1]=n}}let e=n.STREAM_DRAW;n.bindBuffer(n.ARRAY_BUFFER,h.buffers[0].buffer),n.bufferData(n.ARRAY_BUFFER,l,e,6*(this.maxVertices-s)),n.bindBuffer(n.ARRAY_BUFFER,h.buffers[1].buffer),n.bufferData(n.ARRAY_BUFFER,c,e,4*(this.maxVertices-s)),n.bindBuffer(n.ARRAY_BUFFER,h.buffers[2].buffer),n.bufferData(n.ARRAY_BUFFER,u,e,2*(this.maxVertices-s))},this.render=function(e,t,r=!1,i=!0){if(!r){if(null===f.programContainer)return;if(f.isOpaque()!=i)return;re(f.programContainer.program),h.bindBuffers(f.programContainer),Re(f,{camera:e,modelMatrix:d,prevViewMatrix:e.prevViewMatrix,shadowPass:r}),!r&&T.shadowCascades&&T.shadowCascades.setUniforms(f),_e(f,r),n.drawArrays(n.TRIANGLE_STRIP,0,2*s)}}},this.ParticleSystem=function(e=200,t){var r=this;this.maxParticles=e,this.drawOnDownscaledFramebuffer=!1,this.drawMode=n.TRIANGLES,this.material=null,this.meshData=t??ot(),this.particles=new Array(this.maxParticles);for(let e=0;e<this.particles.length;e++)this.particles[e]=new l(new m.Z(0,-1e3,0));var i=[];this.matrixData=new Float32Array(16*this.maxParticles);for(let e=0;e<this.maxParticles;e++)this.matrixData.set(this.particles[e].matrix,16*e);this.colorData=new Float32Array(4*this.maxParticles);for(let e=0;e<this.colorData.length;e++)this.colorData[e]=1;this.matrixBuffer=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,this.matrixBuffer),n.bufferData(n.ARRAY_BUFFER,this.matrixData,n.DYNAMIC_DRAW),this.colorBuffer=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,this.colorBuffer),n.bufferData(n.ARRAY_BUFFER,this.colorData,n.DYNAMIC_DRAW);var o=m.Z.zero();this.orientation="faceVelocity",this.localParticles=!0,this.alpha=1,this.startSize=e=>(e.x=.6*(.8*Math.random()+.2),e.y=.15*(.4*Math.random()+.6),e.z=1,e),this.endSize=e=>m.Z.zero(e),this.emitPosition=e=>m.Z.zero(e),this.emitVelocity=e=>m.Z.zero(e),this.emitHealth=.5,this.alphaCurve=new R,this.alphaCurve.addStage(0,1),this.alphaCurve.addStage(.8,1),this.alphaCurve.addStage(1,0),this.wind=e=>(e.x=10*(Math.random()-.45),e.y=0,e.z=10*(Math.random()-.45),e),this.drag=1,this.gravityScale=1;const a=new v.Z,s=new m.Z;function l(e){this.position=e,this.matrix=v.Z.translate(this.position),this.velocity=m.Z.zero(),this.startSize=m.Z.one(),this.endSize=m.Z.one(),this.health=.5,this.maxHealth=.5,this.alpha=r.alpha,this.active=!0;var t=m.Z.up(),n=m.Z.zero(),a=v.Z.identity(),s=m.Z.zero(),l=new m.Z;this.matrix=v.Z.identity(),this.getAlpha=function(){return this.alpha*r.alphaCurve.getValue(1-this.health/this.maxHealth)},this.getMatrix=function(){if(o){var e,i;if(r.localParticles?(v.Z.copy(r.gameObject.transform.matrix,a),e=v.Z.transformVector(a,this.position),i=v.Z.transformDirection(a,this.velocity)):(e=this.position,i=this.velocity),"faceVelocity"==r.orientation){var l=m.Z.normalize(i),c=m.Z.projectOnPlane(m.Z.subtract(o,e),l);v.Z.lookInDirection(e,c,l,this.matrix)}else{if("faceCamera"!=r.orientation)throw new Error("Unknown orientation mode: "+r.orientation);m.Z.set(n,o),m.Z.subtractTo(n,e),v.Z.lookInDirection(e,n,t,this.matrix)}m.Z.lerp(this.endSize,this.startSize,this.health/this.maxHealth,s),v.Z.scaleWithVector(this.matrix,s)}return this.matrix},this.update=function(e){this.active&&(r.wind(l),m.Z.multiplyTo(l,e),m.Z.addTo(this.velocity,l),this.velocity.x-=r.drag*Math.abs(this.velocity.x)*this.velocity.x*e,this.velocity.y-=r.drag*Math.abs(this.velocity.y)*this.velocity.y*e,this.velocity.z-=r.drag*Math.abs(this.velocity.z)*this.velocity.z*e,this.velocity.y-=9.82*r.gravityScale*e,this.position.x+=this.velocity.x*e,this.position.y+=this.velocity.y*e,this.position.z+=this.velocity.z*e,this.health-=e,this.health<=0&&(this.active=!1,i.push(this)))}}this.emit=function(e=1){for(var t=0;t<e&&i.length>0;t++){var n=i.shift();n.active=!0,n.health=n.maxHealth=this.emitHealth,n.alpha=this.alpha,r.emitPosition(s),m.Z.set(n.position,s),r.emitVelocity(s),m.Z.set(n.velocity,s),r.startSize(s),m.Z.set(n.startSize,s),r.endSize(s),m.Z.set(n.endSize,s)}},this.update=function(e){for(var t of this.particles)t.update(e);for(var r=0;r<this.maxParticles;r++){var i=this.particles[r];i.active?(this.matrixData.set(i.getMatrix(),16*r),this.colorData[4*r+3]=i.getAlpha()):(this.matrixData.set(a,16*r),this.colorData[4*r+3]=0)}n.bindBuffer(n.ARRAY_BUFFER,this.matrixBuffer),n.bufferData(n.ARRAY_BUFFER,this.matrixData,n.DYNAMIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,this.colorBuffer),n.bufferData(n.ARRAY_BUFFER,this.colorData,n.DYNAMIC_DRAW)},this.render=function(e,t,r=!1,i=!0,a,s={}){if(s.downscaledPass==this.drawOnDownscaledFramebuffer&&!i){v.Z.getPosition(e.cameraMatrix,o),null==this.material&&(this.material=ye({albedoTexture:Be(T.path+"assets/textures/bulletTrail.png"),albedo:[40,10,5,1]},T.programContainers.particle),this.material.doubleSided=!0),re(this.material.programContainer.program),this.meshData.bindBuffers(this.material.programContainer),n.bindBuffer(n.ARRAY_BUFFER,this.matrixBuffer);const t=this.material.programContainer.getAttribLocation("modelMatrix");for(var l=0;l<4;l++){const e=t+l;n.enableVertexAttribArray(e),n.vertexAttribPointer(e,4,n.FLOAT,!1,64,16*l),he(e,1)}n.bindBuffer(n.ARRAY_BUFFER,this.colorBuffer);const i=this.material.programContainer.getAttribLocation("color");n.enableVertexAttribArray(i),n.vertexAttribPointer(i,4,n.FLOAT,!1,0,0),he(i,1),this.material instanceof I?Re(this.material,{camera:e,prevViewMatrix:e.prevViewMatrix,shadowPass:r}):this.material.bindUniforms(e),_e(this.material,r),fe(this.drawMode,this.meshData.indices.length,this.meshData.indexType,0,this.maxParticles)}}},this.RenderTexture=function(e=512,t=512,r={}){this.width=e,this.height=t,this.clearFlags=r.clearFlags??n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT,this.framebuffer=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,this.framebuffer),this.colorTexture=n.createTexture(),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,this.colorTexture),n.texImage2D(n.TEXTURE_2D,0,1==T.version?n.RGBA:n.RGBA16F,this.width,this.height,0,n.RGBA,K(),null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,this.colorTexture,0),this.depthTexture=n.createTexture(),n.bindTexture(n.TEXTURE_2D,this.depthTexture),n.texImage2D(n.TEXTURE_2D,0,1==T.version?n.DEPTH_COMPONENT:n.DEPTH_COMPONENT16,this.width,this.height,0,n.DEPTH_COMPONENT,n.UNSIGNED_INT,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,this.depthTexture,0),this.bind=function(){n.bindFramebuffer(n.FRAMEBUFFER,this.framebuffer)},this.resize=function(e,t){this.width=e,this.height=t,n.bindTexture(n.TEXTURE_2D,this.colorTexture),n.texImage2D(n.TEXTURE_2D,0,1==T.version?n.RGBA:n.RGBA16F,this.width,this.height,0,n.RGBA,K(),null),n.bindTexture(n.TEXTURE_2D,this.depthTexture),n.texImage2D(n.TEXTURE_2D,0,1==T.version?n.DEPTH_COMPONENT:n.DEPTH_COMPONENT16,this.width,this.height,0,n.DEPTH_COMPONENT,n.UNSIGNED_INT,null)}},this.UniformBuffer=function(e,t){this.data=new Float32Array,this.location=e,this.buffer=n.createBuffer(),n.bindBuffer(n.UNIFORM_BUFFER,this.buffer),n.bufferData(n.UNIFORM_BUFFER,t,n.DYNAMIC_DRAW),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,this.location,this.buffer),this.update=function(e){this.data=e,n.bindBuffer(n.UNIFORM_BUFFER,this.buffer),n.bufferData(n.UNIFORM_BUFFER,this.data,n.DYNAMIC_DRAW),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,this.location,this.buffer)}},e.ProgramContainer=we,this.ProgramContainer=we,this.LitMaterial=class{constructor(e={},t=T.programContainers.lit){return T.CreateLitMaterial(e,t)}},this.CreateLitMaterial=ye;let _e=(e,t=!1)=>{t?e.doubleSidedShadows?T.disableCulling():T.enableCulling():e.doubleSided?T.disableCulling():T.enableCulling()},Re=(e,t={})=>{Fe(e,e.programContainer,t)},Ae=[0,0,0],Me=[0,0,0],Fe=(e,t,r={})=>{let i=T.getActiveScene(),o=0,a=(e,r)=>{if(!t.activeUniforms[r])return;let i=(e=>{let t=null;if(-1!==(e=e.toUpperCase()).indexOf("SAMPLER_2D_ARRAY"))t=n.TEXTURE_2D_ARRAY;else if(-1!==e.indexOf("SAMPLER_CUBE"))t=n.TEXTURE_CUBE_MAP;else if(-1!==e.indexOf("SAMPLER_3D"))t=n.TEXTURE_3D;else{if(-1===e.indexOf("SAMPLER_2D"))throw new Error("Unknown texture target: ",e);t=n.TEXTURE_2D}return t})(t.activeUniforms[r].typeString);if(Array.isArray(e)){var a=Array.from({length:e.length},((e,t)=>o+t));n.uniform1iv(t.getUniformLocation(r),a);for(var s=0;s<e.length;s++)n.activeTexture(n.TEXTURE0+o),n.bindTexture(i,e[s]),o++}else n.activeTexture(n.TEXTURE0+o),n.bindTexture(i,e),n.uniform1i(t.getUniformLocation(r),o),o++},s=e=>t.getUniformLocation(e);if(r.modelMatrix&&t.setUniform("modelMatrix",r.modelMatrix,!1),r.prevModelMatrix&&t.setUniform("prevModelMatrix",r.prevModelMatrix,!1),e.isLit&&!r.shadowPass&&(a(T.splitsumTexture,"u_splitSum"),a(i.diffuseCubemap,"u_diffuseIBL"),a(i.specularCubemap,"u_specularIBL")),a(T.ditherTexture,"ditherTexture"),!this.currentBoundLitPrograms.has(t)){((e,t)=>{let r=e=>t.getUniformLocation(e);r("iTime")&&n.uniform1f(r("iTime"),C);var i=e.getLights();r("nrLights")&&n.uniform1i(r("nrLights"),i.length);for(let e=0;e<i.length;e++){let t=i[e];r(`lights[${e}].type`)&&n.uniform1i(r(`lights[${e}].type`),t.type),r(`lights[${e}].position`)&&n.uniform3f(r(`lights[${e}].position`),t.position.x,t.position.y,t.position.z),r(`lights[${e}].direction`)&&t.direction&&n.uniform3f(r(`lights[${e}].direction`),t.direction.x,t.direction.y,t.direction.z),r(`lights[${e}].angle`)&&"angle"in t&&n.uniform1f(r(`lights[${e}].angle`),t.angle),r(`lights[${e}].color`)&&n.uniform3f(r(`lights[${e}].color`),t.color[0],t.color[1],t.color[2])}null!=r("sunDirection")&&n.uniform3fv(r("sunDirection"),m.Z.toArray(e.sunDirection,Ae)),null!=r("sunIntensity")&&n.uniform3fv(r("sunIntensity"),m.Z.toArray(e.sunIntensity,Me)),null!=r("environmentIntensity")&&n.uniform1f(r("environmentIntensity"),e.environmentIntensity),null!=r("environmentMinLight")&&n.uniform1f(r("environmentMinLight"),e.environmentMinLight),null!=r("ambientColor")&&n.uniform3fv(r("ambientColor"),e.ambientColor),null!=r("fogDensity")&&n.uniform1f(r("fogDensity"),e.fogDensity),null!=r("fogColor")&&n.uniform4fv(r("fogColor"),e.fogColor)})(i,t);let o=t.uniformBuffers.sharedPerScene;if(o&&i.sharedUBO)n.uniformBlockBinding(t.program,o.blockIndex,i.sharedUBO.location);else{let e=r.camera;e&&(null!=s("projectionMatrix")&&n.uniformMatrix4fv(s("projectionMatrix"),!1,e.projectionMatrix),null!=s("inverseViewMatrix")&&n.uniformMatrix4fv(s("inverseViewMatrix"),!1,e.inverseViewMatrix),null!=s("viewMatrix")&&n.uniformMatrix4fv(s("viewMatrix"),!1,e.viewMatrix))}r.prevViewMatrix&&t.setUniform("prevViewMatrix",r.prevViewMatrix,!1),r.shadowPass||(n.uniform1i(t.getUniformLocation("shadowQuality"),r.shadowQuality??0),T.shadowCascades&&T.shadowCascades.setUniforms(e)),this.currentBoundLitPrograms.set(t,1)}t.setUniform("opaque",e.opaque,!1);for(let n in e.uniforms)t.activeUniforms[n]&&((l=e.uniforms[n])instanceof WebGLTexture||Array.isArray(l)&&l.every((e=>e instanceof WebGLTexture))?a(e.uniforms[n],n):t.setUniform(n,e.uniforms[n]));var l};function Ce(e,t){this.joints=e,this.inverseBindMatrixData=t,this.inverseBindMatrices=[],this.jointMatrices=[],this.jointData=new Float32Array(16*e.length),this.textureIndex=25,this.parentNode=null;for(var r=0;r<e.length;r++)this.inverseBindMatrices.push(new Float32Array(t.buffer,t.byteOffset+16*Float32Array.BYTES_PER_ELEMENT*r,16)),this.jointMatrices.push(new Float32Array(this.jointData.buffer,16*Float32Array.BYTES_PER_ELEMENT*r,16));this.jointTexture=n.createTexture(),n.activeTexture(n.TEXTURE0+this.textureIndex),n.bindTexture(n.TEXTURE_2D,this.jointTexture),n.texImage2D(n.TEXTURE_2D,0,n.RGBA32F,4,this.joints.length,0,n.RGBA,K(),null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),this.copy=function(){var e=new Ce([...this.joints],new Float32Array(t));return e.parentNode=this.parentNode,e},this.update=function(){this.updateMatrixTexture()},this.bindTexture=function(e){n.uniform1i(e.programContainer.getUniformLocation("u_jointTexture"),this.textureIndex),n.uniform1f(e.programContainer.getUniformLocation("u_numJoints"),this.joints.length),n.activeTexture(n.TEXTURE0+this.textureIndex),n.bindTexture(n.TEXTURE_2D,this.jointTexture)},this.updateMatrixTexture=function(){for(let e=0;e<this.joints.length;e++)v.Z.copy(v.Z.multiply(this.joints[e].transform.getWorldMatrix(this.parentNode),this.inverseBindMatrices[e]),this.jointMatrices[e]);n.activeTexture(n.TEXTURE0+this.textureIndex),n.bindTexture(n.TEXTURE_2D,this.jointTexture),n.texSubImage2D(n.TEXTURE_2D,0,0,0,4,this.joints.length,n.RGBA,K(),this.jointData)}}this.Skin=Ce;class De{drawOnDownscaledFramebuffer=!1;constructor(){this.eventHandler=new M,this.on=this.eventHandler.on.bind(this.eventHandler),this.off=this.eventHandler.off.bind(this.eventHandler)}cleanup(){for(let e of this.meshData)e.cleanup()}setShadowQuality(e,t=!1){for(var r of this.materials)r.isOpaque()==t&&null!==r.programContainer&&(re(r.programContainer.program),n.uniform1i(r.programContainer.getUniformLocation("shadowQuality"),e))}isFullyOpaque(){for(let e of this.materials)if(!e.isOpaque())return!1;return!0}isConvex(){for(let e of this.meshData)if(!e.isConvex())return!1;return!0}}e.BaseMeshRenderer=De;class Pe extends De{constructor(e,t,r,i={}){super(),this.materials=Array.isArray(t)?t:[t],this.meshData=Array.isArray(r)?r:[r],this.drawMode=i.drawMode??n.TRIANGLES,this.skin=e}update(){this.skin.update()}render(e,t,r=!1,i=!0,o,a={}){if((a.downscaledPass??!1)==this.drawOnDownscaledFramebuffer)for(var s=0;s<this.meshData.length;s++){var l=this.meshData[s],c=this.materials[s];null!==c.programContainer&&(a.submeshCondition&&!a.submeshCondition(l,c)||c.isOpaque()==i&&(re(c.programContainer.program),l.bindBuffers(c.programContainer),c instanceof I?Re(c,{camera:e,modelMatrix:t,prevModelMatrix:o,prevViewMatrix:e.prevViewMatrix,shadowPass:r}):(c.bindModelMatrixUniform(t,o,e.prevViewMatrix),c.bindUniforms(e)),this.skin.bindTexture(c),r&&n.uniform1iv(c.programContainer.getUniformLocation("projectedTextures[0]"),[0,0]),_e(c,r),l.drawCall(this.drawMode)))}}copy(){var e=[];for(var t of this.materials)e.push(t.copy());var n=[];for(var r of this.meshData)n.push(r.copy());var i=new Pe(this.skin.copy(),e,n);return i.drawMode=this.drawMode,i}}e.SkinnedMeshRenderer=Pe;class Ue extends De{constructor(e,t,r={}){super(),this.materials=Array.isArray(e)?e:[e],this.meshData=Array.isArray(t)?t:[t],this.drawMode=r.drawMode??n.TRIANGLES,this.needsBufferUpdate=!1,this.matrixBuffer=n.createBuffer(),this.matrices=[],this.ditherBuffer=n.createBuffer(),this.ditherAmount=new WeakMap}getAABB(e){(e=e||new A).isEmpty=!0,m.Z.zero(e.bl),m.Z.zero(e.tr);const t=new A;for(let n of this.meshData)for(let r of this.matrices)n.aabb.copy(t).approxTransform(r),e.extend(t);return e}addInstance(e){if(!v.Z.isMatrix(e))throw new Error("Instance must be a matrix");var t=v.Z.copy(e);return this.matrices.push(t),this.needsBufferUpdate=!0,this.ditherAmount.set(t,0),t}addInstanceDontCopy(e){return this.matrices.push(e),this.needsBufferUpdate=!0,this.ditherAmount.set(e,0),e}updateInstance(e,t,r=!0){this.needsBufferUpdate&&(this.updateMatrixData(),this.needsBufferUpdate=!1),v.Z.copy(t,e),this.matrixData.set(e,16*this.matrices.indexOf(e)),r&&(n.bindBuffer(n.ARRAY_BUFFER,this.matrixBuffer),n.bufferSubData(n.ARRAY_BUFFER,0,this.matrixData))}removeInstance(e){var t=this.matrices.indexOf(e);-1!=t&&(this.matrices.splice(t,1),this.needsBufferUpdate=!0)}removeAllInstances(){this.matrices=[],this.needsBufferUpdate=!0}updateMatrixData(){this.matrixData=new Float32Array(16*this.matrices.length);for(var e=0;e<this.matrices.length;e++)this.matrixData.set(this.matrices[e],16*e);n.bindBuffer(n.ARRAY_BUFFER,this.matrixBuffer),n.bufferData(n.ARRAY_BUFFER,this.matrixData,n.DYNAMIC_DRAW)}setDitherAmount(e,t=0){this.ditherAmount.set(e,t)}updateDitherBuffer(){const e=new Float32Array(this.matrices.length);for(var t=0;t<this.matrices.length;t++)e[t]=this.ditherAmount.get(this.matrices[t])??0;n.bindBuffer(n.ARRAY_BUFFER,this.ditherBuffer),n.bufferData(n.ARRAY_BUFFER,e,n.STREAM_DRAW)}render(e,t,r=!1,i=!0,o,a={}){if((a.downscaledPass??!1)==this.drawOnDownscaledFramebuffer&&(this.needsBufferUpdate&&(this.updateMatrixData(),this.needsBufferUpdate=!1),r||this.updateDitherBuffer(),this.matrices.length>0))for(var s=0;s<this.meshData.length;s++){var l=this.meshData[s],c=this.materials[s];if(null===c.programContainer)continue;if(a.submeshCondition&&!a.submeshCondition(l,c))continue;if(c.isOpaque()!=i)continue;re(c.programContainer.program),l.bindBuffers(c.programContainer),n.bindBuffer(n.ARRAY_BUFFER,this.matrixBuffer);for(var u=c.programContainer.getAttribLocation("modelMatrix"),h=0;h<4;h++){const e=u+h;n.enableVertexAttribArray(e),n.vertexAttribPointer(e,4,n.FLOAT,!1,64,16*h),he(e,1)}const t=c.programContainer.getAttribLocation("ditherAmount");t&&(n.bindBuffer(n.ARRAY_BUFFER,this.ditherBuffer),n.enableVertexAttribArray(t),n.vertexAttribPointer(t,1,n.FLOAT,!1,0,0),he(t,1)),c instanceof I?Re(c,{camera:e,prevModelMatrix:o,prevViewMatrix:e.prevViewMatrix,shadowPass:r}):c.bindUniforms(e),_e(c,r),fe(this.drawMode,l.indices.length,l.indexType,0,this.matrices.length)}}copy(){var e=[];for(var t of this.materials)e.push(t.copy());var n=[];for(var r of this.meshData)n.push(r.copy());var i=new Ue(e,n);return i.drawMode=this.drawMode,i}}e.MeshInstanceRenderer=Ue,this.MeshInstanceRenderer=Ue;class Ne extends De{constructor(e,t,r={}){if(super(),this.materials=Array.isArray(e)?e:[e],this.meshData=Array.isArray(t)?t:[t],this.drawMode=r.drawMode??n.TRIANGLES,this.materials.some((e=>!(e instanceof I))))throw console.error(this.materials),new Error("Not a valid Material!");if(this.meshData.some((e=>!(e instanceof Se))))throw console.error(this.meshData),new Error("Not a valid MeshData!");for(let e of this.meshData)e.on("updateAABB",(()=>{this.eventHandler.fireEvent("updateAABB")}))}getAABB(e){for(var t of((e=e||new A).isEmpty=!0,m.Z.zero(e.bl),m.Z.zero(e.tr),this.meshData))e.extend(t.aabb);return e}render(e,t,r=!1,i=!0,o,a={}){if((a.downscaledPass??!1)==this.drawOnDownscaledFramebuffer)for(var s=0;s<this.meshData.length;s++){var l=this.meshData[s],c=this.materials[s];if(null!==c.programContainer&&(!a.submeshCondition||a.submeshCondition(l,c))&&c.isOpaque()==i){if(re(c.programContainer.program),l.bindBuffers(c.programContainer),c instanceof I?Re(c,{camera:e,modelMatrix:t,prevModelMatrix:o,prevViewMatrix:e.prevViewMatrix,shadowPass:r,shadowQuality:a.shadowQuality}):(c.bindModelMatrixUniform(t,o,e.prevViewMatrix),c.bindUniforms(e)),r){let e=c.programContainer.getUniformLocation("projectedTextures[0]");e&&n.uniform1iv(e,[0,0])}_e(c,r),l.drawCall(this.drawMode)}}}getInstanceMeshRenderer(e=T.programContainers.litInstanced){var t=[];for(var n of this.materials){var r=n.copy();r.programContainer=e,t.push(r)}return new Ue(t,this.meshData,{drawMode:this.drawMode})}copy(){var e=this.materials.map((e=>e.copy())),t=this.meshData.map((e=>e.copy())),n=new Ne(e,t);return n.drawMode=this.drawMode,n}}function Se(e){for(var t of(this.eventHandler=new M,this.on=this.eventHandler.on.bind(this.eventHandler),this.data=e,Object.defineProperty(this,"indices",{get:()=>this.data?.indices?.bufferData}),Object.defineProperty(this,"indexType",{get:()=>this.data?.indices?.type??n.UNSIGNED_INT}),this.buffers=[],Object.keys(this.data))){var r=this.data[t];this.buffers.push({attribute:t,buffer:J(r.bufferData,r.target??n.ARRAY_BUFFER),size:r.size,target:r.target??n.ARRAY_BUFFER,type:r.type??n.FLOAT,stride:r.stride??0})}var i=[];this.vaos=new WeakMap;const o=new A,a=new m.Z;let s=()=>{if(o.isEmpty=!0,m.Z.zero(o.bl),m.Z.zero(o.tr),this.data.position)for(var e=0;e<this.data.position.bufferData.length;e+=3)a.x=this.data.position.bufferData[e],a.y=this.data.position.bufferData[e+1],a.z=this.data.position.bufferData[e+2],o.extend(a);this.eventHandler.fireEvent("updateAABB")};s(),Object.defineProperty(this,"aabb",{get:()=>o,set:()=>{throw new Error("Set MeshData aabb")}}),this.updateData=function(e,t=n.DYNAMIC_DRAW){this.data=e;for(let i of Object.keys(e)){var r=this.buffers.find((e=>e.attribute==i));r&&r.size==e[i].size&&r.target==(e[i].target??n.ARRAY_BUFFER)&&r.type==(e[i].type??n.FLOAT)&&r.stride==(e[i].stride??0)?(n.bindBuffer(r.target,r.buffer),n.bufferData(r.target,e[i].bufferData,t)):console.warn("New attribute or missmatching size, target, type or stride: "+i)}s()},this.setAttribute=function(e,t,r=n.DYNAMIC_DRAW){var i=this.buffers.find((t=>t.attribute==e));i?(n.bindBuffer(i.target,i.buffer),n.bufferData(i.target,t.bufferData,r),"size"in t&&(i.size=t.size),"target"in t&&(i.target=t.target),"type"in t&&(i.type=t.type),"stride"in t&&(i.stride=t.stride),this.data[e]=t):this.buffers.push({attribute:e,buffer:J(t.bufferData,t.target??n.ARRAY_BUFFER),size:t.size,target:t.target??n.ARRAY_BUFFER,type:t.type??n.FLOAT,stride:t.stride??0}),"position"===e&&s()},this.recalculateNormals=function(){if(!this.data.position||!this.data.indices)throw new Error("Can't generate normals! Missing positions or indicies");var e=nt(this.data.position.bufferData,this.data.indices.bufferData);this.setAttribute("normal",{bufferData:e,size:3})},this.recalculateTangents=function(){if(!(this.data.position&&this.data.indices&&this.data.uv))throw new Error("Can't generate tangents! Missing positions, indicies or uvs");var e=rt(this.data.position.bufferData,this.data.indices.bufferData,this.data.uv.bufferData);this.setAttribute("tangent",{bufferData:e,size:4})},this.applyTransform=function(e){if(!(this.data&&this.data.position&&this.data.indices))throw new Error("Can't transform MeshData. MeshData is missing 'position' or 'indices' attribute");for(let t=0;t<this.data.position.bufferData.length;t+=3){let n={x:this.data.position.bufferData[t+0],y:this.data.position.bufferData[t+1],z:this.data.position.bufferData[t+2]};n=v.Z.transformVector(e,n),this.data.position.bufferData[t+0]=n.x,this.data.position.bufferData[t+1]=n.y,this.data.position.bufferData[t+2]=n.z}this.setAttribute("position",this.data.position)},this.getSubdivision=function(e=1,t=!1){let r=this.data.position.bufferData,i=this.data.indices.bufferData;function o(e,t,n,r){this.a=e,this.b=t,this.v=n,this.last=r}let a=(e,t)=>((t=t||new m.Z).x=r[3*e+0],t.y=r[3*e+1],t.z=r[3*e+2],t),s=[],l=[];s=[...r];let c=new Map,u=e=>c.get(`${e[0]}-${e[1]}`),h=e=>{let t=[];for(let n=0;n<i.length;n+=3){let r=i[n+0],o=i[n+1],a=i[n+2],s=[[r,o],[o,a],[a,r]],l=[a,r,o];for(let n=0;n<s.length;n++){let r=s[n];(r[0]==e[0]&&r[1]==e[1]||r[0]==e[1]&&r[1]==e[0])&&t.push({a:e[0],b:e[1],last:l[n]})}}return t},f=new Array(r.length/3);for(let e=0;e<f.length;e++)f[e]=[];for(let e=0;e<i.length;e+=3){let t=i[e+0],n=i[e+1],r=i[e+2],o=[[t,n],[n,r],[r,t]],a=[r,t,n];for(let e=0;e<a.length;e++)f[a[e]].push(...o[e])}for(let e=0;e<f.length;e++)f[e]=Array.from(new Set(f[e]));const d=new m.Z;let v=m.Z.zero();for(let e=0;e<r.length/3;e++){let t=f[e],n=t.length,r=2==n?1/8:3==n?3/16:3/8/n,i=n>=3?1-n*r:3/4;m.Z.zero(v);for(let e of t)m.Z.multiply(a(e),r,d),m.Z.addTo(v,d);m.Z.multiply(a(e),i,d),m.Z.addTo(v,d),s[3*e+0]=v.x,s[3*e+1]=v.y,s[3*e+2]=v.z}for(let e=0;e<i.length;e+=3){let n=i[e+0],r=i[e+1],f=i[e+2],d=[[n,r],[r,f],[f,n]],v=[f,n,r],p=[];for(let e=0;e<d.length;e++){let n=d[e];if(t){let t=u(n);if(t){let n=m.Z.multiply(a(v[e]),1/8);s[3*t.v+0]+=n.x,s[3*t.v+1]+=n.y,s[3*t.v+2]+=n.z,p.push(t.v)}else{let r=a(n[0]),i=a(n[1]),l=m.Z.add(m.Z.multiply(r,3/8),m.Z.multiply(i,3/8));m.Z.addTo(l,m.Z.multiply(a(v[e]),1/8)),s.push(l.x,l.y,l.z),p.push(s.length/3-1),t=new o(n[0],n[1],s.length/3-1,v[e]),c.set(`${n[0]}-${n[1]}`,t),c.set(`${n[1]}-${n[0]}`,t)}}else{let e=u(n);if(e)p.push(e.v);else{let e=h(n);if(2==e.length){let t=m.Z.zero();m.Z.addTo(t,m.Z.multiply(a(e[0].a),3/8)),m.Z.addTo(t,m.Z.multiply(a(e[0].b),3/8)),m.Z.addTo(t,m.Z.multiply(a(e[0].last),1/8)),m.Z.addTo(t,m.Z.multiply(a(e[1].last),1/8)),s.push(t.x,t.y,t.z),p.push(s.length/3-1)}else if(1==e.length){let t=m.Z.zero();m.Z.addTo(t,m.Z.multiply(a(e[0].a),.5)),m.Z.addTo(t,m.Z.multiply(a(e[0].b),.5)),s.push(t.x,t.y,t.z),p.push(s.length/3-1)}else console.warn(e.length);let t=new o(n[0],n[1],s.length/3-1,null);c.set(`${n[0]}-${n[1]}`,t),c.set(`${n[1]}-${n[0]}`,t)}}}l.push(n,p[0],p[2]),l.push(p[0],r,p[1]),l.push(p[1],f,p[2]),l.push(p[0],p[1],p[2])}return{indices:{bufferData:new Uint32Array(l),type:5125,target:n.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(s),size:3}}},this.subdivide=function(e=1){let t=this.getSubdivision(e);this.setAttribute("indices",t.indices),this.setAttribute("position",t.position),this.recalculateNormals()},this.isConvex=function(){const e=this.data.indices.bufferData,t=(e,t)=>new m.Z(e[3*t],e[3*t+1],e[3*t+2]),n=(n,r)=>{for(let i=0;i<e.length;i++){const o=e[i];if(_(t(e,o),n,r)>0)return!1}return!0};for(let r=0;r<e.length;r+=3){const i=e[r],o=e[r+1],a=e[r+2],s=t(e,i);if(!n(s,w([s,t(e,o),t(e,a)])))return!1}return!0},this.copy=function(){return this},this.bindBuffers=function(e){var t=e.program,r=this.vaos.get(t);if(null==r){r=1==T.version?T.VAOExt.createVertexArrayOES():2==T.version?n.createVertexArray():void 0,i.push(r),this.vaos.set(t,r),ue(r);for(var o=e.activeAttributes,a=0;a<this.buffers.length;a++){var s=this.buffers[a];if(s.target==n.ELEMENT_ARRAY_BUFFER)n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,s.buffer);else{var l=o[s.attribute];void 0!==l&&-1!=(l=l.location)&&(n.bindBuffer(s.target,s.buffer),n.enableVertexAttribArray(l),he(l,0),n.vertexAttribPointer(l,s.size,s.type,!1,s.stride,0))}}}else ue(r)},this.drawCall=function(e){this.indices?n.drawElements(e,this.indices.length,this.indexType,0):this.data.position?e==n.TRIANGLE_STRIP?n.drawArrays(e,0,this.data.position.bufferData.length/3):n.drawArrays(e,0,this.data.position.bufferData.length):console.warn("Can't render meshData")},this.cleanup=function(){for(var e of i)ce(e);for(var t of this.buffers)n.deleteBuffer(t.buffer)}}function Be(e,t={}){var r=n.createTexture();if(n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,new Uint8Array([0,0,255,255])),"string"==typeof e){var i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=function(){ze(r,i,t)}}else ze(r,e,t);return r}async function Le(e,t={}){var r;return r="string"==typeof e?await(0,b.po)(e):e,ze(n.createTexture(),r,t)}function ze(e,t,r){if(Object.prototype.hasOwnProperty.call(r,"anisotropicFiltering")||(r.anisotropicFiltering=!0),Object.prototype.hasOwnProperty.call(r,"generateMipmap")||(r.generateMipmap=!0),Object.prototype.hasOwnProperty.call(r,"maxTextureSize")&&t.width>r.maxTextureSize){var i=t.width/t.height;t=it(t,r.maxTextureSize,r.maxTextureSize/i)}if(1==T.version){var o=Math.pow(2,Math.floor(Math.log2(t.width)));t=it(t,o,o)}if(n.bindTexture(n.TEXTURE_2D,e),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,0),n.texImage2D(n.TEXTURE_2D,r.level??0,r.internalFormat??n.RGBA,r.format??n.RGBA,n.UNSIGNED_BYTE,t),r.generateMipmap&&(1!=T.version||1==T.version&&(0,b.rz)(t.width)&&(0,b.rz)(t.height))&&35906!=r.format?n.generateMipmap(n.TEXTURE_2D):n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),r.TEXTURE_WRAP_R&&n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_R,r.TEXTURE_WRAP_R),r.TEXTURE_WRAP_S&&n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,r.TEXTURE_WRAP_S),r.TEXTURE_WRAP_T&&n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,r.TEXTURE_WRAP_T),r.TEXTURE_MIN_FILTER&&n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,r.TEXTURE_MIN_FILTER),r.TEXTURE_MAG_FILTER&&n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,r.TEXTURE_MAG_FILTER),r.anisotropicFiltering&&T.EXT_texture_filter_anisotropic){const e=T.EXT_texture_filter_anisotropic,t=T.MAX_ANISOTROPY;n.texParameterf(n.TEXTURE_2D,e.TEXTURE_MAX_ANISOTROPY_EXT,t)}return e}this.MeshRenderer=Ne,this.MeshData=Se,this.loadMetalRoughness=function(e,t){var r=n.createTexture();return n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,new Uint8Array([0,255,0,255])),Promise.all([(0,b.po)(e),(0,b.po)(t)]).then((([e,t])=>{if(e.width!=t.width||e.height!=t.height)throw new Error("Dimension mismatch!");for(var i=(0,b.DJ)(e),o=(0,b.DJ)(t),a=new Uint8Array(e.width*e.height*4),s=0;s<a.length;s+=4)a[s]=0,a[s+1]=o[s+1],a[s+2]=i[s+2],a[s+3]=255;n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,a),n.generateMipmap(n.TEXTURE_2D)})).catch((e=>{throw e})),r},this.loadTexture=Be,this.loadTextureAsync=Le,this.loadGLTF=async function(e,t={}){console.groupCollapsed("Load GLTF: "+e);var n=await this.getGLTFData(e),r=await this.createGameObjectFromGLTFData(n,t);return console.groupEnd(),r},this.getGLTFData=async function(e){return new Promise(((t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=async function(){if(200==r.status){var i=r.response;if(i){let n=new TextDecoder;for(var o,a=new Uint8Array(i),s=[],l=12;l<a.byteLength;){var c=(0,b.mB)(a.slice(l,l+4)),u=(0,b.mB)(a.slice(l+4,l+8)),h=a.slice(l+8,l+8+c);if(1313821514==u){var f=n.decode(h);o=JSON.parse(f)}else{if(5130562!=u)throw new Error("Invalid chunk type: "+u.toString(16));s.push(h)}l+=c+8}t({json:o,buffers:s,path:e})}}else n("Could not load GLTF model: "+r.statusText)},r.send(null)}))};var Ie={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Je={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},et={5120:8,5121:8,5122:16,5123:16,5125:32,5126:32};function tt(){var e=new Float32Array([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1]),t=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),r=new Uint32Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),i=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0]),o=rt(e,r,i);return{indices:{bufferData:r,target:n.ELEMENT_ARRAY_BUFFER},position:{bufferData:e,size:3},normal:{bufferData:t,size:3},tangent:{bufferData:o,size:4},uv:{bufferData:i,size:2}}}function ot(e=1){var t=new Float32Array([e,e,0,-e,e,0,-e,-e,0,e,-e,0]),r=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1]),i=new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0]),o=new Uint32Array([0,1,2,0,2,3]),a=new Float32Array([1,1,0,1,0,0,1,0]);return new Se({indices:{bufferData:o,target:n.ELEMENT_ARRAY_BUFFER},position:{bufferData:t,size:3},normal:{bufferData:r,size:3},tangent:{bufferData:i,size:3},uv:{bufferData:a,size:2}})}function at(t){if(!(t instanceof e))throw new Error("renderer is not of class 'Renderer'");console.info("Using %cforward%c renderpipeline","color: green; text-transform: uppercase; font-weight: bold;",""),this.renderer=t;var n=this.renderer.gl;this.render=function(e,r,i,o){if(void 0===e)throw new Error("Camera is not defined");if(this.renderer.currentBoundMaterials=new WeakMap,this.renderer.shadowCascades&&X.enableShadows&&(0!=i.sunIntensity.x||0!=i.sunIntensity.y||0!=i.sunIntensity.z)&&!1!==o.shadows&&this.renderer.shadowCascades.renderShadowmaps(e.transform.position),i.updateUniformBuffers(e.projectionMatrix,e.viewMatrix,e.inverseViewMatrix),this.renderer.postprocessing&&X.enablePostProcessing?this.renderer.postprocessing.bindFramebuffer():n.bindFramebuffer(n.FRAMEBUFFER,null),t.version>1&&n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.viewport(0,0,n.canvas.width,n.canvas.height),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),t.version>1&&(n.drawBuffers([n.NONE,n.COLOR_ATTACHMENT1]),n.viewport(0,0,n.canvas.width,n.canvas.height),n.clearColor(.5,.5,0,1),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.clearColor(...B)),n.disable(n.BLEND),i.skyboxVisible&&this.renderer.skybox.render(e,i.skyboxCubemap),i.root.traverseCondition((t=>{t.meshRenderer&&(!e.frustum||!t.getAABB()||t.getAABB().isInsideFrustum(e.frustum))||t.disableFrustumCulling?t.isCulled=!1:t.isCulled=!0}),(e=>e.active&&e.visible)),1==B[3]&&n.colorMask(!0,!0,!0,!1),n.disable(n.BLEND),i.render(e,{renderPass:d.OPAQUE}),this.renderer.gizmos.gameObject.render(e),n.enable(n.BLEND),n.depthMask(!1),i.render(e,{renderPass:d.ALPHA}),n.depthMask(!0),t.version>1&&n.drawBuffers([n.COLOR_ATTACHMENT0]),r)for(var a of r)i.updateUniformBuffers(a.projectionMatrix,a.viewMatrix,a.inverseViewMatrix),a.renderTexture?(a.renderTexture.bind(),n.viewport(0,0,a.renderTexture.width,a.renderTexture.height),n.clear(a.renderTexture.clearFlags)):(this.renderer.postprocessing&&X.enablePostProcessing?this.renderer.postprocessing.bindFramebuffer():n.bindFramebuffer(n.FRAMEBUFFER,null),n.clear(n.DEPTH_BUFFER_BIT)),i.render(a,{renderPass:d.OPAQUE}),n.depthMask(!1),i.render(a,{renderPass:d.ALPHA}),n.depthMask(!0);n.colorMask(!0,!0,!0,!0),this.renderer.godrays&&this.renderer.godrays.render(i,e),ue(null),this.renderer.postprocessing&&X.enablePostProcessing&&this.renderer.postprocessing.blitAA(),this.renderer.bloom&&X.enableBloom&&this.renderer.bloom.render(),this.renderer.postprocessing&&X.enablePostProcessing&&this.renderer.postprocessing.render(),v.Z.copy(e.viewMatrix,e.prevViewMatrix)}}function st(t){if(!(t instanceof e))throw new Error("Renderer is not of class 'Renderer'");if(t.version<2)throw new Error("Deferred rendering is only available with WebGL2");console.info("Using %cdeferred%c renderpipeline","color: red; text-transform: uppercase; font-weight: bold;",""),this.renderer=t;var n=this.renderer.gl,r=n.canvas.width,i=n.canvas.height;const o=K();for(var a={basic:new we(this.renderer.createProgram(Ze,Oe)),instanced:new we(this.renderer.createProgram(Ve,Xe)),skinned:new we(this.renderer.createProgram(ke,Ge))},s=new we(this.renderer.createProgram(je,He)),l=new ve,c=A(r,i),u=R(r,i),h=[],f=0;f<Object.keys(c.colorBuffers).length;f++)h.push(n.COLOR_ATTACHMENT0+f);var d=new function(){this.scale=.5,this.blur=5,this.blurHMultiplier=1,this.blurVMultiplier=1,this.maxRoughness=.5,this.maxDistance=64,this.stepResolution=.1,this.refinementSteps=10,this.thickness=10;var e=new ve,o=new we(t.createProgram(We,$e)),a=new we(t.createProgram(Ye,qe));this.framebuffer=Q(r,i),this.resizeFramebuffers=function(){n.deleteFramebuffer(this.framebuffer.framebuffer),this.framebuffer=Q(n.canvas.width,n.canvas.height)},this.pass=function(t,r,i,a){n.bindFramebuffer(n.FRAMEBUFFER,this.framebuffer.framebuffer),n.viewport(0,0,n.canvas.width*this.scale,n.canvas.height*this.scale),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),re(o.program),ue(null),e.bindBuffers(o.getAttribLocation("position")),o.setUniform("scale",this.scale),o.setUniform("maxRoughness",this.maxRoughness),o.setUniform("maxDistance",this.maxDistance),o.setUniform("resolution",this.stepResolution),o.setUniform("steps",this.refinementSteps),o.setUniform("thickness",this.thickness),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,c.colorBuffers.positionViewSpace),n.uniform1i(o.getUniformLocation("positionTexture"),0),n.activeTexture(n.TEXTURE1),n.bindTexture(n.TEXTURE_2D,c.colorBuffers.normal),n.uniform1i(o.getUniformLocation("normalTexture"),1),n.activeTexture(n.TEXTURE2),n.bindTexture(n.TEXTURE_2D,c.colorBuffers.properties),n.uniform1i(o.getUniformLocation("propertiesTexture"),2),n.activeTexture(n.TEXTURE3),n.bindTexture(n.TEXTURE_2D,u.colorBuffer),n.uniform1i(o.getUniformLocation("albedoTexture"),3),n.uniformMatrix4fv(o.getUniformLocation("lensProjection"),!1,t.projectionMatrix),n.uniformMatrix4fv(o.getUniformLocation("inverseViewMatrix"),!1,t.inverseViewMatrix),n.uniformMatrix4fv(o.getUniformLocation("viewMatrix"),!1,t.viewMatrix),e.render()},this.combinePass=function(t){n.bindFramebuffer(n.FRAMEBUFFER,t),n.viewport(0,0,n.canvas.width,n.canvas.height),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),re(a.program),ue(null),e.bindBuffers(a.getAttribLocation("position")),n.uniform2f(a.getUniformLocation("SIZE"),n.canvas.width,n.canvas.height),n.uniform1f(a.getUniformLocation("scale"),this.scale),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,u.colorBuffer),n.uniform1i(a.getUniformLocation("combinedTexture"),0),n.activeTexture(n.TEXTURE1),n.bindTexture(n.TEXTURE_2D,this.framebuffer.colorBuffer),n.uniform1i(a.getUniformLocation("ssrTexture"),1),e.render()}};this.ssr=d;var p=new function(){var e=new ve,r=new we(t.createProgram(Ke,Qe)),i=Q(n.canvas.width,n.canvas.height);this.resizeFramebuffers=function(){n.deleteFramebuffer(i.framebuffer),i=Q(n.canvas.width,n.canvas.height)},this.pass=function(t,o=null,a=20,s=1,l=1){re(r.program),ue(null),e.bindBuffers(r.getAttribLocation("position")),n.uniform2f(r.getUniformLocation("SIZE"),n.canvas.width,n.canvas.height),n.bindFramebuffer(n.FRAMEBUFFER,i.framebuffer),n.viewport(0,0,n.canvas.width,n.canvas.height),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,t),n.uniform1i(r.getUniformLocation("imageTexture"),0),n.uniform1i(r.getUniformLocation("horizontal"),0),n.uniform1i(r.getUniformLocation("radius"),a*s),e.render(),n.bindFramebuffer(n.FRAMEBUFFER,o),n.viewport(0,0,n.canvas.width,n.canvas.height),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,i.colorBuffer),n.uniform1i(r.getUniformLocation("imageTexture"),0),n.uniform1i(r.getUniformLocation("horizontal"),1),n.uniform1i(r.getUniformLocation("radius"),a*l),e.render()}};this.enableSSR=!1,this.renderer.on("resize",(()=>{this.resizeFramebuffers(),d.resizeFramebuffers(),p.resizeFramebuffers()})),this.resizeFramebuffers=function(){n.deleteFramebuffer(c.framebuffer),c=A(n.canvas.width,n.canvas.height),n.deleteFramebuffer(u.framebuffer),u=R(n.canvas.width,n.canvas.height)},this.render=function(e,t,o,a){r=n.canvas.width,i=n.canvas.height,n.viewport(0,0,n.canvas.width,n.canvas.height),x(e,t,o,a),g(e,t,o,a);var s=this.enableSSR?u.framebuffer:this.renderer.postprocessing.getFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.viewport(0,0,n.canvas.width,n.canvas.height),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),ue(null),this.renderer.skybox.render(e,o.skyboxCubemap),ue(null),E(e,t,o,a),ue(null),T(s,e,t,o,a),ue(null),M(e,t,o,a),ue(null),b(),ue(null),this.renderer.postprocessing.render(),v.Z.copy(e.viewMatrix,e.prevViewMatrix)};var g=(e,t,r,i)=>{n.bindFramebuffer(n.FRAMEBUFFER,c.framebuffer),n.viewport(0,0,n.canvas.width,n.canvas.height),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n.drawBuffers(h);for(var o=0;o<32;o++)n.activeTexture(n.TEXTURE0+o),n.bindTexture(n.TEXTURE_2D,null);for(let t in a){let r=a[t];re(r.program),n.uniformMatrix4fv(r.getUniformLocation("projectionMatrix"),!1,e.projectionMatrix),n.uniformMatrix4fv(r.getUniformLocation("inverseViewMatrix"),!1,e.inverseViewMatrix),n.uniformMatrix4fv(r.getUniformLocation("viewMatrix"),!1,e.viewMatrix)}ue(null),r.root.traverseCondition((t=>{if(t.meshRenderer){if(e.frustum&&t.getAABB()&&!t.getAABB().isInsideFrustum(e.frustum))return;var r=t.meshRenderer;if(r instanceof Ue){let e=a.instanced;if(re(e.program),r.needsBufferUpdate&&(r.updateMatrixData(),r.needsBufferUpdate=!1),r.matrices.length>0)for(let i=0;i<r.meshData.length;i++){let o=r.meshData[i],a=r.materials[i];if(null!==a.programContainer&&a.programContainer!=this.renderer.programContainers.litInstanced)continue;if(!a.isOpaque())continue;o.bindBuffers(e),n.bindBuffer(n.ARRAY_BUFFER,r.matrixBuffer);let s=e.getAttribLocation("modelMatrix");for(let e=0;e<4;e++){const t=s+e;n.enableVertexAttribArray(t),n.vertexAttribPointer(t,4,n.FLOAT,!1,64,16*e),he(t,1)}y(e,a,t.transform.worldMatrix),fe(r.drawMode,o.indices.length,o.indexType,0,r.matrices.length)}}else if(r instanceof Ne){let e=a.basic;re(e.program);for(let n=0;n<r.meshData.length;n++){let i=r.meshData[n],o=r.materials[n];null!==o.programContainer&&o.programContainer!=this.renderer.programContainers.lit||o.isOpaque()&&(i.bindBuffers(e),y(e,o,t.transform.worldMatrix),i.drawCall(r.drawMode))}}else if(r instanceof Pe){let e=a.skinned;re(e.program);for(var i=0;i<r.meshData.length;i++){var o=r.meshData[i],s=r.materials[i];null!==s.programContainer&&s.programContainer!=this.renderer.programContainers.litSkinned||s.isOpaque()&&(o.bindBuffers(e),y(e,s,t.transform.worldMatrix),r.skin.bindTexture({programContainer:e}),o.drawCall(r.drawMode))}}}}),(e=>e.active&&e.visible))},x=(e,t,n,r)=>{ue(null),this.renderer.shadowCascades&&X.enableShadows&&(0!=n.sunIntensity.x||0!=n.sunIntensity.y||0!=n.sunIntensity.z)&&!1!==r.shadows&&n.shadowQuality>0&&this.renderer.shadowCascades.renderShadowmaps(e.transform.position)},b=()=>{this.renderer.bloom?.render()},T=(e,t,o,a,s)=>{n.bindFramebuffer(n.DRAW_FRAMEBUFFER,e),n.bindFramebuffer(n.READ_FRAMEBUFFER,c.framebuffer),n.blitFramebuffer(0,0,r,i,0,0,r,i,n.DEPTH_BUFFER_BIT,n.NEAREST),n.bindFramebuffer(n.FRAMEBUFFER,e),a.updateUniformBuffers(t.projectionMatrix,t.viewMatrix,t.inverseViewMatrix),n.activeTexture(n.TEXTURE0+2),n.bindTexture(n.TEXTURE_CUBE_MAP,a.diffuseCubemap),n.activeTexture(n.TEXTURE0+1),n.bindTexture(n.TEXTURE_CUBE_MAP,a.specularCubemap),n.activeTexture(n.TEXTURE0+0),n.bindTexture(n.TEXTURE_2D,this.renderer.splitsumTexture),1==B[3]&&n.colorMask(!0,!0,!0,!1),n.disable(n.BLEND),a.root.traverseCondition((e=>{let n=!0;if(e.meshRenderer){let r=e.transform.worldMatrix;e.meshRenderer.setShadowQuality?.(e.receiveShadows?2:0,n),e.meshRenderer.render(t,r,!1,n,e.prevModelMatrix,{submeshCondition:(e,t)=>null!==t.programContainer&&!(S.lit&&t.programContainer==this.renderer.programContainers.lit||S.litInstanced&&t.programContainer==this.renderer.programContainers.litInstanced||S.litSkinned&&t.programContainer==this.renderer.programContainers.litSkinned)}),e.updatePrevModelMatrix()}for(var r of e.getComponents())if("function"==typeof r.render){let i=e.transform.worldMatrix;r.render(t,i,!1,n)}}),(e=>e.active&&e.visible)),n.enable(n.BLEND),n.depthMask(!1),a.root.traverseCondition((e=>{let n=!1;if(e.meshRenderer){let r=e.transform.worldMatrix;e.meshRenderer.setShadowQuality?.(e.receiveShadows?2:0,n),e.meshRenderer.render(t,r,!1,n,e.prevModelMatrix)}for(var r of e.getComponents())if("function"==typeof r.render){let i=e.transform.worldMatrix;r.render(t,i,!1,n)}}),(e=>e.active&&e.visible)),n.disable(n.BLEND),n.depthMask(!0),n.colorMask(!0,!0,!0,!0)},E=(e,t,r,i)=>{re(s.program),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.bindBuffer(n.ARRAY_BUFFER,l.vertexBuffer);var o=s.getAttribLocation("position");n.enableVertexAttribArray(o),n.vertexAttribPointer(o,2,n.FLOAT,!1,8,0),n.uniform2f(s.getUniformLocation("SIZE"),n.canvas.width,n.canvas.height),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,c.colorBuffers.position),n.uniform1i(s.getUniformLocation("gPosition"),0),n.activeTexture(n.TEXTURE1),n.bindTexture(n.TEXTURE_2D,c.colorBuffers.normal),n.uniform1i(s.getUniformLocation("gNormal"),1),n.activeTexture(n.TEXTURE2),n.bindTexture(n.TEXTURE_2D,c.colorBuffers.albedo),n.uniform1i(s.getUniformLocation("gAlbedo"),2),n.activeTexture(n.TEXTURE6),n.bindTexture(n.TEXTURE_2D,c.colorBuffers.properties),n.uniform1i(s.getUniformLocation("gProperties"),6),n.activeTexture(n.TEXTURE3),n.bindTexture(n.TEXTURE_CUBE_MAP,r.diffuseCubemap),n.uniform1i(s.getUniformLocation("u_diffuseIBL"),3),n.activeTexture(n.TEXTURE4),n.bindTexture(n.TEXTURE_CUBE_MAP,r.specularCubemap),n.uniform1i(s.getUniformLocation("u_specularIBL"),4),n.activeTexture(n.TEXTURE5),n.bindTexture(n.TEXTURE_2D,this.renderer.splitsumTexture),n.uniform1i(s.getUniformLocation("u_splitSum"),5);var a=r.getLights();n.uniform1i(s.getUniformLocation("nrLights"),a.length);for(let e=0;e<a.length;e++){let t=a[e];n.uniform1i(s.getUniformLocation(`lights[${e}].type`),t.type),n.uniform3f(s.getUniformLocation(`lights[${e}].position`),t.position.x,t.position.y,t.position.z),t.direction&&n.uniform3f(s.getUniformLocation(`lights[${e}].direction`),t.direction.x,t.direction.y,t.direction.z),"angle"in t&&n.uniform1f(s.getUniformLocation(`lights[${e}].angle`),t.angle),n.uniform3f(s.getUniformLocation(`lights[${e}].color`),t.color[0],t.color[1],t.color[2])}n.uniformMatrix4fv(s.getUniformLocation("projectionMatrix"),!1,e.projectionMatrix),n.uniformMatrix4fv(s.getUniformLocation("viewMatrix"),!1,e.viewMatrix),n.uniformMatrix4fv(s.getUniformLocation("prevViewMatrix"),!1,e.prevViewMatrix),n.uniformMatrix4fv(s.getUniformLocation("inverseViewMatrix"),!1,e.inverseViewMatrix),n.uniform3fv(s.getUniformLocation("sunDirection"),m.Z.toArray(r.sunDirection)),n.uniform3fv(s.getUniformLocation("sunIntensity"),m.Z.toArray(r.sunIntensity)),n.uniform3fv(s.getUniformLocation("ambientColor"),m.Z.toArray(r.ambientColor)),n.uniform1f(s.getUniformLocation("environmentIntensity"),r.environmentIntensity),n.uniform1f(s.getUniformLocation("environmentMinLight"),r.environmentMinLight),null!=s.getUniformLocation("fogDensity")&&n.uniform1f(s.getUniformLocation("fogDensity"),r.fogDensity),s.setUniform("fogColor",r.fogColor),n.uniform1i(s.getUniformLocation("shadowQuality"),r.shadowQuality),_(s),l.render()},w={modelMatrix:null,shadowPass:!1},y=(e,t,r)=>{w.modelMatrix=r,Fe(t,e,w),e.setUniform("enableMotionBlur",t.uniforms.enableMotionBlur??1),n.uniformMatrix4fv(e.getUniformLocation("modelMatrix"),!1,r),_e(t,!1)},_=e=>{var r=t.shadowCascades;r.setUniforms(e);var i=Array.from({length:r.levels},((e,t)=>30-2*t)).reverse();n.uniform1iv(e.getUniformLocation("projectedTextures[0]"),i);for(let e=0;e<r.levels;e++){let t=30-2*e;n.activeTexture(n.TEXTURE0+t),n.bindTexture(n.TEXTURE_2D,r.shadowmaps[e].depthTexture)}};function R(e,r){var i=Q(e,r);return i.motionBlurColorBuffer=n.createTexture(),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,i.motionBlurColorBuffer),n.texImage2D(n.TEXTURE_2D,0,1==t.version?n.RGBA:n.RGBA16F,e,r,0,n.RGBA,o,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT1,n.TEXTURE_2D,i.motionBlurColorBuffer,0),i}function A(e,t){var r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r);var i={position:{internalFormat:n.RGBA32F,type:o,filter:n.NEAREST},albedo:{internalFormat:n.RGBA16F,type:o,filter:n.LINEAR},normal:{internalFormat:n.RGBA16F,type:o,filter:n.LINEAR},properties:{internalFormat:n.RGBA,type:n.UNSIGNED_BYTE,filter:n.LINEAR},positionViewSpace:{internalFormat:n.RGBA32F,type:o,filter:n.NEAREST}},a={position:null,normal:null,albedo:null,properties:null,positionViewSpace:null};n.activeTexture(n.TEXTURE0);var s=0;for(var l in a){var c=n.createTexture();n.bindTexture(n.TEXTURE_2D,c);var u=i[l],h=u?.internalFormat??n.RGBA32F,f=u?.type??o;n.texImage2D(n.TEXTURE_2D,0,h,e,t,0,n.RGBA,f,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,u?.filter??n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,u?.filter??n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+s,n.TEXTURE_2D,c,0),a[l]=c,s++}var d=n.createRenderbuffer();return n.bindRenderbuffer(n.RENDERBUFFER,d),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,e,t),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,d),{framebuffer:r,colorBuffers:a,depthBuffer:d}}var M=(e,t,n,r)=>{this.enableSSR&&(d.pass(e,t,n,r),d.blur>0&&p.pass(d.framebuffer.colorBuffer,d.framebuffer.framebuffer,d.blur,d.blurVMultiplier,d.blurHMultiplier),d.combinePass(this.renderer.postprocessing.getFramebuffer()))}}this.createGameObjectFromGLTFData=async function(e,t={}){var{json:r,buffers:i,path:o}=e,a=[],s=[];console.time("Loading "+o),console.info(r);var l=o.indexOf(".glb")+4,c=o.lastIndexOf("/",l)+1,u=new U(o.slice(c,l)),h=[],f=[],d=[],p=r.scene??0,g=r.scenes[p];for(let e=0;e<g.nodes.length;e++)f=f.concat(await N(g.nodes[e]));if(u.addChildren(f),!t.disableAnimations&&!(0,b.z)(r.animations))for(var x of(u.animationController=new te,r.animations)){var E=[];for(var w of x.channels){var y,_,R=x.samplers[w.sampler],A=L(R.input).buffer,M=L(R.output),F=M.accessor,C=M.buffer,D=C;if("VEC3"==F.type){let e=[];for(let t=0;t<C.byteLength/4;t+=3)e.push({x:C[t],y:C[t+1],z:C[t+2]});D=e}else if("VEC4"==F.type){let e=[];for(let t=0;t<C.byteLength/4;t+=4)e.push({x:C[t],y:C[t+1],z:C[t+2],w:C[t+3]});D=e}"CUBICSPLINE"==R.interpolation&&(y=D.filter(((e,t)=>t%3==0)),_=D.filter(((e,t)=>t%3==0)),D=D.filter(((e,t)=>t%3==1))),E.push({target:h[w.target.node],path:w.target.path,interpolation:R.interpolation,inputBuffer:A,outputBuffer:D,inputTangents:y,outputTangents:_})}var P=new ee(x.name,E);u.animationController.animations.push(P)}for(let e=0;e<d.length;e++){let t=d[e],n=[];for(let e=0;e<t.joints.length;e++){let r=h[t.joints[e]];r?n[e]=r:console.warn("Invalid joint index!")}let r=[];for(let e=0;e<t.obj.meshRenderer.materials.length;e++){let n=null;T.renderpipeline instanceof at&&(n=T.programContainers.litSkinned);let i=t.obj.meshRenderer.materials[e],o=new Z(n,i.uniforms);r.push(o)}t.obj.meshRenderer=new Pe(new Ce(n,t.inverseBindMatrixData),r,t.obj.meshRenderer.meshData),t.obj.meshRenderer.skin.parentNode=t.obj.parent}return u.traverse((e=>{e.transform.matrix=e.transform.matrix})),console.timeEnd("Loading "+o),u;async function N(e,i=0){var o=r.nodes[e],a=v.Z.identity();o.matrix?v.Z.copy(o.matrix,a):(o.translation&&v.Z.translate(m.Z.fromArray(o.translation),a),o.rotation&&v.Z.multiply(a,v.Z.fromQuaternion(m.Z.fromArray(o.rotation)),a),o.scale&&v.Z.transform([["scale",m.Z.fromArray(o.scale)]],a));var l=new U(o.name,{matrix:a,...t.gameObjectOptions});if(l.nodeIndex=e,h[e]=l,o.extensions&&o.extensions.KHR_lights_punctual){var c=r.extensions.KHR_lights_punctual.lights[o.extensions.KHR_lights_punctual.light],u=c.intensity??1,f=c.color??[1,1,1],p=c.type,g=l.addComponent(new k);g.color=[f[0]*u,f[1]*u,f[2]*u],g.type={point:0,spot:1,directional:2}[p],c.spot&&"spot"==p&&(g.angle=c.spot.outerConeAngle)}var x=o.extras;if(x&&(console.info("Custom data:",x),l.customData={...x}),null!=o.mesh){var b=r.meshes[o.mesh],E=b.extras;E&&(console.info("Custom mesh data:",E),l.customData={...l.customData,...E});for(var w=t.loadNormals??!0,y=t.loadTangents??!0,_=[],R=[],A=0;A<b.primitives.length;A++){var M=b.primitives[A],F={},C=L(M.attributes.POSITION);F.position={bufferData:C.buffer,size:C.size,stride:C.stride};var D=L(M.indices);D&&(F.indices={bufferData:D.buffer,type:T.indexTypeLookup[D.type],target:n.ELEMENT_ARRAY_BUFFER,stride:D.stride});const e=t.loadVertexColors??!0;var P=L(M.attributes.COLOR_0);e&&P&&(F.color={bufferData:S(P.buffer),size:P.size,stride:P.stride});var z=L(M.attributes.TEXCOORD_0);if(z&&(F.uv={bufferData:z.buffer,size:z.size,stride:z.stride}),w){var I=L(M.attributes.NORMAL);I?F.normal={bufferData:I.buffer,size:I.size,stride:I.stride}:(console.warn("Generating normals"),F.normal={bufferData:nt(C.buffer,D.buffer),size:3})}if(y){var Z=L(M.attributes.TANGENT);Z?F.tangent={bufferData:Z.buffer,size:Z.size,stride:Z.stride}:z&&(console.warn("Generating tangents"),F.tangent={bufferData:rt(C.buffer,D.buffer,z.buffer),size:4})}if(M.attributes.JOINTS_0){let e=L(M.attributes.JOINTS_0);F.joints={bufferData:e.buffer,size:e.size,type:e.type,stride:e.stride}}if(M.attributes.WEIGHTS_0){let e=L(M.attributes.WEIGHTS_0);F.weights={bufferData:e.buffer,size:e.size,type:e.type,stride:e.stride}}var O=t.loadMaterials??!0,V=void 0,G=M.material;if(O&&null!=G)if(null!=s[G])V=s[G];else{var j=[0,0,0],H=[1,1,1,1],W=void 0,$=void 0,Y=void 0,q=void 0,K=void 0,Q=1,J=1,ee=.5,te=1,ne=!1,re=r.materials[G],ie=re.pbrMetallicRoughness;if(re.doubleSided&&(ne=!0),"BLEND"==re.alphaMode?(ee=0,te=0):"MASK"==re.alphaMode?(ee=re.alphaCutoff??.5,te=1):"OPAQUE"!=re.alphaMode&&"alphaMode"in re||(ee=-1,te=1),null!=ie){if(H=ie.baseColorFactor??[1,1,1,1],ie.metallicRoughnessTexture||(Q=0,J=1),X.loadTextures){var oe=1==T.version?T.sRGBExt&&(T.floatTextures||T.textureHalfFloatExt)?T.sRGBExt.SRGB_ALPHA_EXT:n.RGBA:n.SRGB8_ALPHA8,ae=1==T.version&&T.sRGBExt&&(T.floatTextures||T.textureHalfFloatExt)?T.sRGBExt.SRGB_ALPHA_EXT:n.RGBA;ie.baseColorTexture&&(W=await B(ie.baseColorTexture.index,{internalFormat:oe,format:ae})),ie.metallicRoughnessTexture&&(Y=await B(ie.metallicRoughnessTexture.index)),re.normalTexture&&($=await B(re.normalTexture.index,t.sRGBNormalMap?{internalFormat:oe,format:ae}:{})),null!=re.emissiveTexture&&(q=await B(re.emissiveTexture.index,{internalFormat:oe,format:ae})),null!=re.occlusionTexture&&(K=await B(re.occlusionTexture.index))}null!=re.emissiveFactor&&(j=re.emissiveFactor),null!=ie.metallicFactor&&(Q=ie.metallicFactor),null!=ie.roughnessFactor&&(J=ie.roughnessFactor)}(V=ye({alphaCutoff:ee,albedo:H,albedoTexture:W,normalTexture:$,metallicRoughnessTexture:Y,roughness:J,metallic:Q,emissiveFactor:j,emissiveTexture:q,occlusionTexture:K})).opaque=!!te,V.doubleSided=ne,V.name=re.name||"No name!",s[G]=V}_.push(V??ye()),R.push(new Se(F))}l.meshRenderer=new Ne(_,R)}if(null!=o.skin){var se=r.skins[o.skin],le=L(se.inverseBindMatrices).buffer;0!=L(se.inverseBindMatrices).stride&&console.warn("Stride in skin ibm data");var ce=se.joints;d.push({obj:l,joints:ce,inverseBindMatrixData:le})}var ue=[];if(null!=o.children)for(var he=0;he<o.children.length;he++)ue=ue.concat(await N(o.children[he],i+1));return l.addChildren(ue),[l]}function S(e){for(var t=0;t<e.length;t++)e[t]=1-e[t];return e}async function B(e,n){if(null==a[e]){var o=await async function(e,n={}){var o=r.textures[e],a=o.source,s=r.bufferViews[r.images[a].bufferView],l=i[s.buffer].slice(s.byteOffset??0,(s.byteOffset??0)+s.byteLength);const c=new Blob([l],{type:r.images[a].mimeType});var u=URL.createObjectURL(c);if(t.downloadTextures&&(0,b.UR)(u,"texture"),Object.prototype.hasOwnProperty.call(t,"maxTextureSize")&&(n.maxTextureSize=t.maxTextureSize),o.sampler){var h=r.samplers[o.sampler];n.TEXTURE_WRAP_S=h.wrapS,n.TEXTURE_WRAP_T=h.wrapT,n.TEXTURE_MIN_FILTER=h.minFilter,n.TEXTURE_MAG_FILTER=h.magFilter}return await Le(u,n)}(e,n);return a[e]=o,o}return a[e]}function L(e){if(null!=e&&e>=0){var t=r.accessors[e],n=r.bufferViews[t.bufferView],o=n.byteStride??0,a=o?o/(et[t.componentType]/8)/Je[t.type]:1,s=(n.byteOffset??0)+(t.byteOffset??0),l=i[n.buffer].slice(s,s+t.count*Je[t.type]*et[t.componentType]/8*a);return{buffer:new Ie[t.componentType](l.buffer),size:Je[t.type],type:t.componentType,stride:o,accessor:t}}}},this.getLineCubeData=function(){const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]);return{indices:{bufferData:new Uint32Array([0,1,1,3,3,2,2,0,4,5,5,7,7,6,6,4,0,4,1,5,3,7,2,6]),target:n.ELEMENT_ARRAY_BUFFER},position:{bufferData:e,size:3}}},this.getCubeData=tt,this.getSubdividedPlaneMeshData=function(e){const t=[],r=[],i=[],o=[],a=Math.pow(2,e);for(let e=0;e<=a;e++)for(let n=0;n<=a;n++){const i=e/a*2-1,o=n/a*2-1,s=0,l=e/a,c=n/a;r.push(i,o,s),t.push(l,c)}const s=new Array(r.length/3);for(let e=0;e<s.length;e++)s[e]=[];for(let e=0;e<a;e++)for(let t=0;t<a;t++){const n=t+e*(a+1),o=[n,n+a+1,n+1,n+1,n+a+1,n+a+1+1];i.push(...o);const l=w([m.Z.fromArray(r,3*o[0]),m.Z.fromArray(r,3*o[1]),m.Z.fromArray(r,3*o[2])]),c=w([m.Z.fromArray(r,3*o[3]),m.Z.fromArray(r,3*o[4]),m.Z.fromArray(r,3*o[5])]);s[o[0]].push(l),s[o[1]].push(l),s[o[2]].push(l),s[o[3]].push(c),s[o[4]].push(c),s[o[5]].push(c)}const l=[];for(let e=0;e<s.length;e++){const t=m.Z.divide(s[e].reduce(((e,t)=>m.Z.add(e,t)),m.Z.zero()),s[e].length);l.push(t.x,t.y,t.z),o.push(t.y,t.x,t.z,-1)}return new Se({indices:{bufferData:new Uint32Array(i),target:n.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(r),size:3},normal:{bufferData:new Float32Array(l),size:3},tangent:{bufferData:new Float32Array(o),size:4},uv:{bufferData:new Float32Array(t),size:2}})},this.getPlaneData=function(){var e=new Float32Array([1,1,0,-1,1,0,-1,-1,0,1,-1,0]),t=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1]),r=new Float32Array([1,0,0,-1,1,0,0,-1,1,0,0,-1,1,0,0,-1]),i=new Uint32Array([0,1,2,0,2,3]),o=new Float32Array([1,1,0,1,0,0,1,0]);return{indices:{bufferData:i,target:n.ELEMENT_ARRAY_BUFFER},position:{bufferData:e,size:3},normal:{bufferData:t,size:3},tangent:{bufferData:r,size:4},uv:{bufferData:o,size:2}}},this.getSphereData=function(e=3){var t=.5257311121191336,r=.8506508083520399,i=[-t,0,r,t,0,r,-t,0,-r,t,0,-r,0,r,t,0,r,-t,0,-r,t,0,-r,-t,r,t,0,-r,t,0,r,-t,0,-r,-t,0],o=[0,1,4,0,4,9,9,4,5,4,8,5,4,1,8,8,1,10,8,10,3,5,8,3,5,3,2,2,3,7,7,3,10,7,10,6,7,6,11,11,6,0,0,6,1,6,10,1,9,11,0,9,2,11,9,5,2,7,11,2];for(let t=0;t<e;t++){let e=[],t=[];for(let n=0;n<o.length;n+=3){let r=[];for(let e=0;e<3;e++){let a=o[n+e],s=o[n+(e+1)%3],c=l(t,a,s);if(c)r.push(c);else{let e=m.Z.fromArray(i.slice(3*a,3*a+3)),n=m.Z.fromArray(i.slice(3*s,3*s+3)),o=m.Z.normalize(m.Z.lerp(e,n,.5));i.push(o.x,o.y,o.z),r.push(i.length/3-1),t.push({edge:[a,s],index:r[r.length-1]})}}e.push(o[n],r[0],r[2]),e.push(o[n+1],r[1],r[0]),e.push(o[n+2],r[2],r[1]),e.push(r[0],r[1],r[2])}o=e}var a=[];for(let e=0;e<i.length;e+=3){let t=m.Z.normalize(m.Z.fromArray(i.slice(e,e+3)));a.push(t.x,t.y,t.z)}let s=[];for(let e=0;e<i.length;e+=3){let t=m.Z.normalize(m.Z.fromArray(i.slice(e,e+3))),n=Math.atan2(t.x,t.z)/(2*Math.PI)+.5,r=Math.asin(t.y)/Math.PI+.5;s.push(n,r)}return new this.MeshData({indices:{bufferData:new Uint32Array(o),target:n.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(i),size:3},normal:{bufferData:new Float32Array(a),size:3},uv:{bufferData:new Float32Array(s),size:2}});function l(e,t,n){return e.find((e=>e.edge[0]==t&&e.edge[1]==n||e.edge[0]==n&&e.edge[1]==t))?.index}},this.getParticleMeshData=ot,this.loadObj=async function(e,t=!1){var r="No name",i={},o=[],a=[],s=[],l=(await(await fetch(e)).text()).split("\n");for(let e=0;e<l.length;e++){let t=l[e].split(" ");switch(t[0]){case"o":i[r=t[1]+" #"+Math.floor(1e4*Math.random())]=[[],[],[]];break;case"v":o.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]));break;case"vn":a.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]));break;case"vt":s.push(parseFloat(t[1]),parseFloat(t[2]));break;case"f":if(4==t.length)for(let e=0;e<3;e++)i[r][e].push(parseInt(t[1].split("/")[e])-1,parseInt(t[2].split("/")[e])-1,parseInt(t[3].split("/")[e])-1);else if(5==t.length)for(let e=0;e<3;e++)i[r][e].push(parseInt(t[1].split("/")[e])-1,parseInt(t[2].split("/")[e])-1,parseInt(t[3].split("/")[e])-1,parseInt(t[1].split("/")[e])-1,parseInt(t[3].split("/")[e])-1,parseInt(t[4].split("/")[e])-1)}}var c={},u=[],h=[],f=[],d=[u,f,h],m=[o,s,a],v=0;for(let e in i){let t=i[e];c[e]=[];for(let n=0;n<t[0].length;n++){for(let e=0;e<3;e+=2)d[e].push(m[e][3*t[e][n]],m[e][3*t[e][n]+1],m[e][3*t[e][n]+2]);c[e].push(v),v++}c[e]=new Uint32Array(c[e]);for(let e=0;e<t[0].length;e++){let n=1;d[n].push(m[n][2*t[n][e]],m[n][2*t[n][e]+1])}}let p=c;if(!t){p=[];for(let e in c)p=p.concat(Array.from(c[e]));p=new Uint32Array(p)}return new Se({indices:{bufferData:p,target:n.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(u),size:3},normal:{bufferData:new Float32Array(h),size:3},uv:{bufferData:new Float32Array(f),size:2}})},this.CreateShape=function(e,t=null,n=3){var r;if("plane"==(e=e.toLowerCase()))r=new this.MeshData(this.getPlaneData());else if("cube"==e)r=new this.MeshData(this.getCubeData());else{if("sphere"!=e)throw new Error("Invalid shape: "+e);r=this.getSphereData(n)}t=t??this.CreateLitMaterial();var i=new Ne(t,r),o=new U("Shape");return o.meshRenderer=i,o},this.CreatePlane=function(e=0,t=m.Z.zero(),n=m.Z.up(),r=null){const i=0===e?new Se(this.getPlaneData()):this.getSubdividedPlaneMeshData(e);r=r??this.CreateLitMaterial();const o=new Ne(r,i),a=new U("Plane");return a.transform.matrix=v.Z.lookInDirection(t,n,Math.abs(m.Z.dot(n,m.Z.up()))>.999?new m.Z(1,0,0):m.Z.up()),a.meshRenderer=o,a},this.CreatePBRGrid=async function(e,t=10,n=10,r="sphere"){for(var i="cube"==r?(await this.loadGLTF(this.path+"assets/models/primitives/cube.glb")).children[0].meshRenderer.meshData[0]:(await this.loadGLTF(this.path+"assets/models/primitives/uvSphere.glb")).children[0].meshRenderer.meshData[0],o=0;o<n;o++)for(var a=0;a<t;a++){var s=ye({roughness:a/(t-1),metallic:o/(n-1)}),l=new Ne(s,i),c=new U;c.transform.position=new m.Z(2.1*(a-(t-1)/2),2.1*(o-(n-1)/2),0),c.meshRenderer=l,"cube"==r&&(c.transform.scale=new m.Z(.5,.5,100)),e.add(c)}},this.BatchGameObject=function(e){var t=new U(e.name+" (Batched)"),n=[];e.traverse((e=>{var r=e.findComponents("Light");if(r.length>0){var i=new U(e.name+" (Copy)");for(var o of(i.transform.matrix=e.transform.worldMatrix,r))i.addComponent(o.copy());t.addChild(i)}if(e.meshRenderer){var a=v.Z.copy(e.transform.worldMatrix);v.Z.removeTranslation(a);for(let t=0;t<e.meshRenderer.meshData.length;t++){let r=e.meshRenderer.materials[t],i=e.meshRenderer.meshData[t],o=n.find((e=>e.material==r));if(o||(o={material:r,vertices:[],indices:[],tangent:[],normal:[],uv:[],indexOffset:0},n.push(o)),i.data.position&&i.data.indices){let t=function(e,t=3){if(i.data[e])for(var n=i.data[e].bufferData,r=i.data[e].size,s=0,l=0;l<n.length;l+=r){var c=m.Z.fromArray(n,l,1,3);c=m.Z.normalize(v.Z.transformVector(a,c)),o[e][o.indexOffset*t+s]=c.x,o[e][o.indexOffset*t+s+1]=c.y,o[e][o.indexOffset*t+s+2]=c.z,4==t&&(o[e][o.indexOffset*t+s+3]=4==r?n[l+3]:1),s+=t}};for(let t=0;t<i.data.position.bufferData.length;t+=3){let n={x:i.data.position.bufferData[t],y:i.data.position.bufferData[t+1],z:i.data.position.bufferData[t+2]};n=v.Z.transformVector(e.transform.worldMatrix,n),o.vertices.push(n.x,n.y,n.z)}for(let e=0;e<i.data.indices.bufferData.length;e++)o.indices.push(i.data.indices.bufferData[e]+o.indexOffset);if(i.data.uv)for(let e=0;e<i.data.uv.bufferData.length;e++)o.uv[2*o.indexOffset+e]=i.data.uv.bufferData[e];t("normal"),t("tangent",4),o.indexOffset+=i.data.position.bufferData.length/3}i.cleanup()}}}));var r=[],i=[];for(var o of n){for(let e=0;e<o.uv.length;e++)void 0===o.uv[e]&&(o.uv[e]=0);for(let e=0;e<o.normal.length;e++)void 0===o.normal[e]&&(o.normal[e]=0);for(let e=0;e<o.tangent.length;e++)void 0===o.tangent[e]&&(o.tangent[e]=0);r.push(o.material),i.push(new Se({position:{bufferData:new Float32Array(o.vertices),size:3},indices:{bufferData:new Uint32Array(o.indices),target:T.gl.ELEMENT_ARRAY_BUFFER},tangent:{bufferData:new Float32Array(o.tangent),size:4},normal:{bufferData:new Float32Array(o.normal),size:3},uv:{bufferData:new Float32Array(o.uv),size:2}}))}return t.meshRenderer=new Ne(r,i),t},t.dontCallSetup||this.setup(t),this.DeferredPBRRenderpipeline=st}},367:(e,t,n)=>{n.d(t,{Z:()=>h});var r=n(358);class i{constructor(e=0,t=0,n=0,r){return(r=r||{x:0,y:0,z:0}).x=e,r.y=t,r.z=n,r}static zero(e){return(e=e||new i).x=0,e.y=0,e.z=0,e}static one(e){return(e=e||new i).x=1,e.y=1,e.z=1,e}static up(e){return(e=e||new i).x=0,e.y=1,e.z=0,e}static down(e){return(e=e||new i).x=0,e.y=-1,e.z=0,e}static fill(e=0,t){return(t=t||new i).x=e,t.y=e,t.z=e,t}static set(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e}static copy(e,t){return(t=t||new i).x=e.x,t.y=e.y,t.z=e.z,t}static fromArray(e,t=0,n=1,r=4,i){return(i=i||{x:0,y:0,z:0,w:0}).x=r>=1?e[t]??0:0,i.y=r>=2?e[t+n]??0:0,i.z=r>=3?e[t+2*n]??0:0,i.w=r>=4?e[t+3*n]??0:0,i}static toArray(e,t){return(t=t||[0,0,0])[0]=e.x,t[1]=e.y,t[2]=e.z,t}static equal(e,t,n=1e-6){return Math.abs(e.x-t.x)<n&&Math.abs(e.y-t.y)<n&&Math.abs(e.z-t.z)<n}static isVectorIsh(e){return null!=e&&"object"==typeof e&&("x"in e||"y"in e||"z"in e)}static isNaN(e){return isNaN(e.x)||isNaN(e.y)||isNaN(e.z)}static add(e,t,n){return(n=n||new i).x=e.x+t.x,n.y=e.y+t.y,n.z=e.z+t.z,n}static addTo(e,t){return e.x+=t.x,e.y+=t.y,e.z+=t.z,e}static subtract(e,t,n){return(n=n||new i).x=e.x-t.x,n.y=e.y-t.y,n.z=e.z-t.z,n}static subtractTo(e,t){return e.x-=t.x,e.y-=t.y,e.z-=t.z,e}static multiply(e,t,n){return(n=n||new i).x=e.x*t,n.y=e.y*t,n.z=e.z*t,n}static multiplyTo(e,t){return e.x*=t,e.y*=t,e.z*=t,e}static negate(e,t){return(t=t||new i).x=-e.x,t.y=-e.y,t.z=-e.z,t}static negateTo(e){return e.x=-e.x,e.y=-e.y,e.z=-e.z,e}static compMultiply(e,t,n){return(n=n||new i).x=e.x*t.x,n.y=e.y*t.y,n.z=e.z*t.z,n}static compMultiplyTo(e,t){return e.x*=t.x,e.y*=t.y,e.z*=t.z,e}static divide(e,t,n){return(n=n||new i).x=e.x/t,n.y=e.y/t,n.z=e.z/t,n}static divideTo(e,t){return e.x/=t,e.y/=t,e.z/=t,e}static compDivide(e,t,n){return(n=n||new i).x=e.x/t.x,n.y=e.y/t.y,n.z=e.z/t.z,n}static compDivideTo(e,t){return e.x/=t.x,e.y/=t.y,e.z/=t.z,e}static average(e,t,n){return n=n||new i,i.add(e,t,n),i.divideTo(n,2),n}static applyFunc(e,t,n){return(n=n||new i).x=t(e.x),n.y=t(e.y),n.z=t(e.z),n}static compFunc(e,t,n,r){return(r=r||new i).x=n(e.x,t.x),r.y=n(e.y,t.y),r.z=n(e.z,t.z),r}static rotate2D(e,t,n){return(n=n||new i).x=e.x*Math.cos(t)-e.y*Math.sin(t),n.y=e.x*Math.sin(t)+e.y*Math.cos(t),n.z=0,n}static rotateAround(e,t,n,r){r=r||new i,i.multiply(t,i.dot(e,t)/i.dot(t,t),a),i.subtract(e,a,s),i.cross(t,s,l);let o=i.length(s);var h=Math.cos(n)/o,f=Math.sin(n)/i.length(l);return i.multiply(s,h,c),i.multiply(l,f,u),i.addTo(c,u),i.multiplyTo(c,o),i.add(c,a,r),r}static project(e,t,n){n=n||new i;const r=i.dot(t,e);return i.set(n,t),i.multiplyTo(n,r),n}static projectOnPlane(e,t,n){n=n||new i;const r=i.dot(t,e);return i.set(o,t),i.multiplyTo(o,r),i.set(n,e),i.subtractTo(n,o),n}static findOrthogonal(e,t){return t=t||new i,Math.abs(e.x)>=1/Math.sqrt(3)?(t.x=e.y,t.y=-e.x,t.z=0):(t.x=0,t.y=e.z,t.z=-e.y),i.normalizeTo(t),t}static formOrthogonalBasis(e){var t=i.findOrthogonal(e);return[t,i.cross(t,e)]}static lengthNonVector(e=0,t=0,n=0){return Math.sqrt(e*e+t*t+n*n)}static length(e){var t=e.x*e.x+e.y*e.y;return e.z&&(t+=e.z*e.z),Math.sqrt(t)}static lengthSqr(e){var t=e.x*e.x+e.y*e.y;return e.z&&(t+=e.z*e.z),t}static tangent(e,t,n){return n=n||new i,i.set(n,t),i.subtractTo(n,e),i.normalizeTo(n),n}static distance(e,t){return i.set(o,e),i.subtractTo(o,t),i.length(o)}static distanceSqr(e,t){return i.set(o,e),i.subtractTo(o,t),i.lengthSqr(o)}static normalize(e,t){t=t||new i;var n=i.lengthSqr(e);return n<1e-12?i.copy(e,t):i.divide(e,Math.sqrt(n),t),t}static normalizeTo(e){var t=i.length(e);return t<1e-6?e:i.divideTo(e,t)}static dot(e,t){var n=e.x*t.x+e.y*t.y;return e.z&&t.z&&(n+=e.z*t.z),n}static cross(e,t,n){n=n||new i;const r=e.x,o=e.y,a=e.z,s=t.x,l=t.y,c=t.z;return n.x=o*c-a*l,n.y=a*s-r*c,n.z=r*l-o*s,n}static lerp(e,t,n,o){return(o=o||new i).x=(0,r.t7)(e.x,t.x,n),o.y=(0,r.t7)(e.y,t.y,n),o.z=(0,r.t7)(e.z,t.z,n),o}static inverseLerp(e,t,n,o){return(o=o||new i).x=(0,r.ii)(e.x,t.x,n),o.y=(0,r.ii)(e.y,t.y,n),o.z=(0,r.ii)(e.z,t.z,n),o}static slerp(e,t,n,o){o=o||new i;var a=(0,r.uZ)(i.dot(e,t),-1,1),s=Math.acos(a)*n,l=i.normalize(i.subtract(t,i.multiply(e,a))),c=i.multiply(e,Math.cos(s)),u=i.multiply(l,Math.sin(s));return i.add(c,u,o),o}static clamp(e,t,n,o){o=o||new i;var a=i.isVectorIsh(t),s=i.isVectorIsh(n);return o.x=(0,r.uZ)(e.x,a?t.x:t,s?n.x:n),o.y=(0,r.uZ)(e.y,a?t.y:t,s?n.y:n),o.z=(0,r.uZ)(e.z,a?t.z:t,s?n.z:n),o}static map(e,t,n){return(n=n||new i).x=t(e.x),n.y=t(e.y),n.z=t(e.z),n}}const o=new i,a=new i,s=new i,l=new i,c=new i,u=new i,h=i},472:(e,t,n)=>{n.d(t,{ZP:()=>g});class r{constructor(e,t,n,i,o="div"){this.parent=e,this.object=t,this.property=n,this._disabled=!1,this._hidden=!1,this.initialValue=this.getValue(),this.domElement=document.createElement(o),this.domElement.classList.add("controller"),this.domElement.classList.add(i),this.$name=document.createElement("div"),this.$name.classList.add("name"),r.nextNameID=r.nextNameID||0,this.$name.id="lil-gui-name-"+ ++r.nextNameID,this.$widget=document.createElement("div"),this.$widget.classList.add("widget"),this.$disable=this.$widget,this.domElement.appendChild(this.$name),this.domElement.appendChild(this.$widget),this.domElement.addEventListener("keydown",(e=>e.stopPropagation())),this.domElement.addEventListener("keyup",(e=>e.stopPropagation())),this.parent.children.push(this),this.parent.controllers.push(this),this.parent.$children.appendChild(this.domElement),this._listenCallback=this._listenCallback.bind(this),this.name(n)}name(e){return this._name=e,this.$name.innerHTML=e,this}onChange(e){return this._onChange=e,this}_callOnChange(){this.parent._callOnChange(this),void 0!==this._onChange&&this._onChange.call(this,this.getValue()),this._changed=!0}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(){this._changed&&(this.parent._callOnFinishChange(this),void 0!==this._onFinishChange&&this._onFinishChange.call(this,this.getValue())),this._changed=!1}reset(){return this.setValue(this.initialValue),this._callOnFinishChange(),this}enable(e=!0){return this.disable(!e)}disable(e=!0){return e===this._disabled||(this._disabled=e,this.domElement.classList.toggle("disabled",e),this.$disable.toggleAttribute("disabled",e)),this}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}options(e){const t=this.parent.add(this.object,this.property,e);return t.name(this._name),this.destroy(),t}min(e){return this}max(e){return this}step(e){return this}decimals(e){return this}listen(e=!0){return this._listening=e,void 0!==this._listenCallbackID&&(cancelAnimationFrame(this._listenCallbackID),this._listenCallbackID=void 0),this._listening&&this._listenCallback(),this}_listenCallback(){this._listenCallbackID=requestAnimationFrame(this._listenCallback);const e=this.save();e!==this._listenPrevValue&&this.updateDisplay(),this._listenPrevValue=e}getValue(){return this.object[this.property]}setValue(e){return this.object[this.property]=e,this._callOnChange(),this.updateDisplay(),this}updateDisplay(){return this}load(e){return this.setValue(e),this._callOnFinishChange(),this}save(){return this.getValue()}destroy(){this.listen(!1),this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.controllers.splice(this.parent.controllers.indexOf(this),1),this.parent.$children.removeChild(this.domElement)}}class i extends r{constructor(e,t,n){super(e,t,n,"boolean","label"),this.$input=document.createElement("input"),this.$input.setAttribute("type","checkbox"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$input.addEventListener("change",(()=>{this.setValue(this.$input.checked),this._callOnFinishChange()})),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.checked=this.getValue(),this}}function o(e){let t,n;return(t=e.match(/(#|0x)?([a-f0-9]{6})/i))?n=t[2]:(t=e.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))?n=parseInt(t[1]).toString(16).padStart(2,0)+parseInt(t[2]).toString(16).padStart(2,0)+parseInt(t[3]).toString(16).padStart(2,0):(t=e.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i))&&(n=t[1]+t[1]+t[2]+t[2]+t[3]+t[3]),!!n&&"#"+n}const a={isPrimitive:!0,match:e=>"number"==typeof e,fromHexString:e=>parseInt(e.substring(1),16),toHexString:e=>"#"+e.toString(16).padStart(6,0)},s={isPrimitive:!1,match:e=>Array.isArray(e),fromHexString(e,t,n=1){const r=a.fromHexString(e);t[0]=(r>>16&255)/255*n,t[1]=(r>>8&255)/255*n,t[2]=(255&r)/255*n},toHexString:([e,t,n],r=1)=>a.toHexString(e*(r=255/r)<<16^t*r<<8^n*r<<0)},l={isPrimitive:!1,match:e=>Object(e)===e,fromHexString(e,t,n=1){const r=a.fromHexString(e);t.r=(r>>16&255)/255*n,t.g=(r>>8&255)/255*n,t.b=(255&r)/255*n},toHexString:({r:e,g:t,b:n},r=1)=>a.toHexString(e*(r=255/r)<<16^t*r<<8^n*r<<0)},c=[{isPrimitive:!0,match:e=>"string"==typeof e,fromHexString:o,toHexString:o},a,s,l];class u extends r{constructor(e,t,n,r){var i;super(e,t,n,"color"),this.$input=document.createElement("input"),this.$input.setAttribute("type","color"),this.$input.setAttribute("tabindex",-1),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$text=document.createElement("input"),this.$text.setAttribute("type","text"),this.$text.setAttribute("spellcheck","false"),this.$text.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$display.appendChild(this.$input),this.$widget.appendChild(this.$display),this.$widget.appendChild(this.$text),this._format=(i=this.initialValue,c.find((e=>e.match(i)))),this._rgbScale=r,this._initialValueHexString=this.save(),this._textFocused=!1,this.$input.addEventListener("input",(()=>{this._setValueFromHexString(this.$input.value)})),this.$input.addEventListener("blur",(()=>{this._callOnFinishChange()})),this.$text.addEventListener("input",(()=>{const e=o(this.$text.value);e&&this._setValueFromHexString(e)})),this.$text.addEventListener("focus",(()=>{this._textFocused=!0,this.$text.select()})),this.$text.addEventListener("blur",(()=>{this._textFocused=!1,this.updateDisplay(),this._callOnFinishChange()})),this.$disable=this.$text,this.updateDisplay()}reset(){return this._setValueFromHexString(this._initialValueHexString),this}_setValueFromHexString(e){if(this._format.isPrimitive){const t=this._format.fromHexString(e);this.setValue(t)}else this._format.fromHexString(e,this.getValue(),this._rgbScale),this._callOnChange(),this.updateDisplay()}save(){return this._format.toHexString(this.getValue(),this._rgbScale)}load(e){return this._setValueFromHexString(e),this._callOnFinishChange(),this}updateDisplay(){return this.$input.value=this._format.toHexString(this.getValue(),this._rgbScale),this._textFocused||(this.$text.value=this.$input.value.substring(1)),this.$display.style.backgroundColor=this.$input.value,this}}class h extends r{constructor(e,t,n){super(e,t,n,"function"),this.$button=document.createElement("button"),this.$button.appendChild(this.$name),this.$widget.appendChild(this.$button),this.$button.addEventListener("click",(e=>{e.preventDefault(),this.getValue().call(this.object),this._callOnChange()})),this.$button.addEventListener("touchstart",(()=>{}),{passive:!0}),this.$disable=this.$button}}class f extends r{constructor(e,t,n,r,i,o){super(e,t,n,"number"),this._initInput(),this.min(r),this.max(i);const a=void 0!==o;this.step(a?o:this._getImplicitStep(),a),this.updateDisplay()}decimals(e){return this._decimals=e,this.updateDisplay(),this}min(e){return this._min=e,this._onUpdateMinMax(),this}max(e){return this._max=e,this._onUpdateMinMax(),this}step(e,t=!0){return this._step=e,this._stepExplicit=t,this}updateDisplay(){const e=this.getValue();if(this._hasSlider){let t=(e-this._min)/(this._max-this._min);t=Math.max(0,Math.min(t,1)),this.$fill.style.width=100*t+"%"}return this._inputFocused||(this.$input.value=void 0===this._decimals?e:e.toFixed(this._decimals)),this}_initInput(){this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("aria-labelledby",this.$name.id),window.matchMedia("(pointer: coarse)").matches&&(this.$input.setAttribute("type","number"),this.$input.setAttribute("step","any")),this.$widget.appendChild(this.$input),this.$disable=this.$input;const e=e=>{const t=parseFloat(this.$input.value);isNaN(t)||(this._snapClampSetValue(t+e),this.$input.value=this.getValue())};let t,n,r,i,o,a=!1;const s=e=>{if(a){const r=e.clientX-t,i=e.clientY-n;Math.abs(i)>5?(e.preventDefault(),this.$input.blur(),a=!1,this._setDraggingStyle(!0,"vertical")):Math.abs(r)>5&&l()}if(!a){const t=e.clientY-r;o-=t*this._step*this._arrowKeyMultiplier(e),i+o>this._max?o=this._max-i:i+o<this._min&&(o=this._min-i),this._snapClampSetValue(i+o)}r=e.clientY},l=()=>{this._setDraggingStyle(!1,"vertical"),this._callOnFinishChange(),window.removeEventListener("mousemove",s),window.removeEventListener("mouseup",l)};this.$input.addEventListener("input",(()=>{let e=parseFloat(this.$input.value);isNaN(e)||(this._stepExplicit&&(e=this._snap(e)),this.setValue(this._clamp(e)))})),this.$input.addEventListener("keydown",(t=>{"Enter"===t.key&&this.$input.blur(),"ArrowUp"===t.code&&(t.preventDefault(),e(this._step*this._arrowKeyMultiplier(t))),"ArrowDown"===t.code&&(t.preventDefault(),e(this._step*this._arrowKeyMultiplier(t)*-1))})),this.$input.addEventListener("wheel",(t=>{this._inputFocused&&(t.preventDefault(),e(this._step*this._normalizeMouseWheel(t)))}),{passive:!1}),this.$input.addEventListener("mousedown",(e=>{t=e.clientX,n=r=e.clientY,a=!0,i=this.getValue(),o=0,window.addEventListener("mousemove",s),window.addEventListener("mouseup",l)})),this.$input.addEventListener("focus",(()=>{this._inputFocused=!0})),this.$input.addEventListener("blur",(()=>{this._inputFocused=!1,this.updateDisplay(),this._callOnFinishChange()}))}_initSlider(){this._hasSlider=!0,this.$slider=document.createElement("div"),this.$slider.classList.add("slider"),this.$fill=document.createElement("div"),this.$fill.classList.add("fill"),this.$slider.appendChild(this.$fill),this.$widget.insertBefore(this.$slider,this.$input),this.domElement.classList.add("hasSlider");const e=e=>{const t=this.$slider.getBoundingClientRect();let n=(r=e,i=t.left,o=t.right,a=this._min,(r-i)/(o-i)*(this._max-a)+a);var r,i,o,a;this._snapClampSetValue(n)},t=t=>{e(t.clientX)},n=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("mousemove",t),window.removeEventListener("mouseup",n)};let r,i,o=!1;const a=t=>{t.preventDefault(),this._setDraggingStyle(!0),e(t.touches[0].clientX),o=!1},s=t=>{if(o){const e=t.touches[0].clientX-r,n=t.touches[0].clientY-i;Math.abs(e)>Math.abs(n)?a(t):(window.removeEventListener("touchmove",s),window.removeEventListener("touchend",l))}else t.preventDefault(),e(t.touches[0].clientX)},l=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("touchmove",s),window.removeEventListener("touchend",l)},c=this._callOnFinishChange.bind(this);let u;this.$slider.addEventListener("mousedown",(r=>{this._setDraggingStyle(!0),e(r.clientX),window.addEventListener("mousemove",t),window.addEventListener("mouseup",n)})),this.$slider.addEventListener("touchstart",(e=>{e.touches.length>1||(this._hasScrollBar?(r=e.touches[0].clientX,i=e.touches[0].clientY,o=!0):a(e),window.addEventListener("touchmove",s,{passive:!1}),window.addEventListener("touchend",l))}),{passive:!1}),this.$slider.addEventListener("wheel",(e=>{if(Math.abs(e.deltaX)<Math.abs(e.deltaY)&&this._hasScrollBar)return;e.preventDefault();const t=this._normalizeMouseWheel(e)*this._step;this._snapClampSetValue(this.getValue()+t),this.$input.value=this.getValue(),clearTimeout(u),u=setTimeout(c,400)}),{passive:!1})}_setDraggingStyle(e,t="horizontal"){this.$slider&&this.$slider.classList.toggle("active",e),document.body.classList.toggle("lil-gui-dragging",e),document.body.classList.toggle("lil-gui-"+t,e)}_getImplicitStep(){return this._hasMin&&this._hasMax?(this._max-this._min)/1e3:.1}_onUpdateMinMax(){!this._hasSlider&&this._hasMin&&this._hasMax&&(this._stepExplicit||this.step(this._getImplicitStep(),!1),this._initSlider(),this.updateDisplay())}_normalizeMouseWheel(e){let{deltaX:t,deltaY:n}=e;return Math.floor(e.deltaY)!==e.deltaY&&e.wheelDelta&&(t=0,n=-e.wheelDelta/120,n*=this._stepExplicit?1:10),t+-n}_arrowKeyMultiplier(e){let t=this._stepExplicit?1:10;return e.shiftKey?t*=10:e.altKey&&(t/=10),t}_snap(e){const t=Math.round(e/this._step)*this._step;return parseFloat(t.toPrecision(15))}_clamp(e){return e<this._min&&(e=this._min),e>this._max&&(e=this._max),e}_snapClampSetValue(e){this.setValue(this._clamp(this._snap(e)))}get _hasScrollBar(){const e=this.parent.root.$children;return e.scrollHeight>e.clientHeight}get _hasMin(){return void 0!==this._min}get _hasMax(){return void 0!==this._max}}class d extends r{constructor(e,t,n,r){super(e,t,n,"option"),this.$select=document.createElement("select"),this.$select.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$select.addEventListener("change",(()=>{this.setValue(this._values[this.$select.selectedIndex]),this._callOnFinishChange()})),this.$select.addEventListener("focus",(()=>{this.$display.classList.add("focus")})),this.$select.addEventListener("blur",(()=>{this.$display.classList.remove("focus")})),this.$widget.appendChild(this.$select),this.$widget.appendChild(this.$display),this.$disable=this.$select,this.options(r)}options(e){return this._values=Array.isArray(e)?e:Object.values(e),this._names=Array.isArray(e)?e:Object.keys(e),this.$select.replaceChildren(),this._names.forEach((e=>{const t=document.createElement("option");t.innerHTML=e,this.$select.appendChild(t)})),this.updateDisplay(),this}updateDisplay(){const e=this.getValue(),t=this._values.indexOf(e);return this.$select.selectedIndex=t,this.$display.innerHTML=-1===t?e:this._names[t],this}}class m extends r{constructor(e,t,n){super(e,t,n,"string"),this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$input.addEventListener("input",(()=>{this.setValue(this.$input.value)})),this.$input.addEventListener("keydown",(e=>{"Enter"===e.code&&this.$input.blur()})),this.$input.addEventListener("blur",(()=>{this._callOnFinishChange()})),this.$widget.appendChild(this.$input),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.value=this.getValue(),this}}let v=!1;class p{constructor({parent:e,autoPlace:t=void 0===e,container:n,width:r,title:i="Controls",closeFolders:o=!1,injectStyles:a=!0,touchStyles:s=!0}={}){if(this.parent=e,this.root=e?e.root:this,this.children=[],this.controllers=[],this.folders=[],this._closed=!1,this._hidden=!1,this.domElement=document.createElement("div"),this.domElement.classList.add("lil-gui"),this.$title=document.createElement("div"),this.$title.classList.add("title"),this.$title.setAttribute("role","button"),this.$title.setAttribute("aria-expanded",!0),this.$title.setAttribute("tabindex",0),this.$title.addEventListener("click",(()=>this.openAnimated(this._closed))),this.$title.addEventListener("keydown",(e=>{"Enter"!==e.code&&"Space"!==e.code||(e.preventDefault(),this.$title.click())})),this.$title.addEventListener("touchstart",(()=>{}),{passive:!0}),this.$children=document.createElement("div"),this.$children.classList.add("children"),this.domElement.appendChild(this.$title),this.domElement.appendChild(this.$children),this.title(i),this.parent)return this.parent.children.push(this),this.parent.folders.push(this),void this.parent.$children.appendChild(this.domElement);this.domElement.classList.add("root"),s&&this.domElement.classList.add("allow-touch-styles"),!v&&a&&(function(e){const t=document.createElement("style");t.innerHTML='.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--title-height:calc(var(--widget-height) + var(--spacing)*1.25);--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{background:var(--background-color);display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles,.lil-gui.force-touch-styles .lil-gui{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:""}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui button,.lil-gui input,.lil-gui label{-webkit-tap-highlight-color:transparent}.lil-gui input{background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input[type=checkbox]{appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{background:var(--widget-color);border:none;border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);outline:none;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles,.lil-gui.allow-touch-styles .lil-gui{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.number .slider:hover,.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color)}.lil-gui button:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}}';const n=document.querySelector("head link[rel=stylesheet], head style");n?document.head.insertBefore(t,n):document.head.appendChild(t)}(),v=!0),n?n.appendChild(this.domElement):t&&(this.domElement.classList.add("autoPlace"),document.body.appendChild(this.domElement)),r&&this.domElement.style.setProperty("--width",r+"px"),this._closeFolders=o}add(e,t,n,r,o){if(Object(n)===n)return new d(this,e,t,n);const a=e[t];switch(typeof a){case"number":return new f(this,e,t,n,r,o);case"boolean":return new i(this,e,t);case"string":return new m(this,e,t);case"function":return new h(this,e,t)}console.error("gui.add failed\n\tproperty:",t,"\n\tobject:",e,"\n\tvalue:",a)}addColor(e,t,n=1){return new u(this,e,t,n)}addFolder(e){const t=new p({parent:this,title:e});return this.root._closeFolders&&t.close(),t}load(e,t=!0){return e.controllers&&this.controllers.forEach((t=>{t instanceof h||t._name in e.controllers&&t.load(e.controllers[t._name])})),t&&e.folders&&this.folders.forEach((t=>{t._title in e.folders&&t.load(e.folders[t._title])})),this}save(e=!0){const t={controllers:{},folders:{}};return this.controllers.forEach((e=>{if(!(e instanceof h)){if(e._name in t.controllers)throw new Error(`Cannot save GUI with duplicate property "${e._name}"`);t.controllers[e._name]=e.save()}})),e&&this.folders.forEach((e=>{if(e._title in t.folders)throw new Error(`Cannot save GUI with duplicate folder "${e._title}"`);t.folders[e._title]=e.save()})),t}open(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),this.domElement.classList.toggle("closed",this._closed),this}close(){return this.open(!1)}_setClosed(e){this._closed!==e&&(this._closed=e,this._callOnOpenClose(this))}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}openAnimated(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),requestAnimationFrame((()=>{const t=this.$children.clientHeight;this.$children.style.height=t+"px",this.domElement.classList.add("transition");const n=e=>{e.target===this.$children&&(this.$children.style.height="",this.domElement.classList.remove("transition"),this.$children.removeEventListener("transitionend",n))};this.$children.addEventListener("transitionend",n);const r=e?this.$children.scrollHeight:0;this.domElement.classList.toggle("closed",!e),requestAnimationFrame((()=>{this.$children.style.height=r+"px"}))})),this}title(e){return this._title=e,this.$title.innerHTML=e,this}reset(e=!0){return(e?this.controllersRecursive():this.controllers).forEach((e=>e.reset())),this}onChange(e){return this._onChange=e,this}_callOnChange(e){this.parent&&this.parent._callOnChange(e),void 0!==this._onChange&&this._onChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(e){this.parent&&this.parent._callOnFinishChange(e),void 0!==this._onFinishChange&&this._onFinishChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onOpenClose(e){return this._onOpenClose=e,this}_callOnOpenClose(e){this.parent&&this.parent._callOnOpenClose(e),void 0!==this._onOpenClose&&this._onOpenClose.call(this,e)}destroy(){this.parent&&(this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.folders.splice(this.parent.folders.indexOf(this),1)),this.domElement.parentElement&&this.domElement.parentElement.removeChild(this.domElement),Array.from(this.children).forEach((e=>e.destroy()))}controllersRecursive(){let e=Array.from(this.controllers);return this.folders.forEach((t=>{e=e.concat(t.controllersRecursive())})),e}foldersRecursive(){let e=Array.from(this.folders);return this.folders.forEach((t=>{e=e.concat(t.foldersRecursive())})),e}}const g=p},744:(e,t,n)=>{n.r(t),n.d(t,{fragment:()=>o,vertex:()=>i});var r=n(453);const i=`\n${r.shaderBase}\n\nin vec3 position;\nin vec3 normal;\nin vec2 uv;\n\nout vec3 vNormal;\nout vec2 vUV;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n};\n\nuniform mat4 modelMatrix;\n\nuniform sampler2D simplexNoiseTexture;\nuniform float height;\nuniform int shells;\nuniform int shellIndex;\nuniform float heightBias;\n\nvoid main() {\n  vNormal = normal;\n  vUV = uv;\n\n  float currentHeight = pow(float(shellIndex) / float(shells - 1), heightBias/*0.3*/) * height;// + texture(simplexNoiseTexture, position.xy * 0.1).r;\n  vec3 offsetPosition = position + normalize(normal) * currentHeight;\n\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(offsetPosition, 1.0);\n}\n`,o=`\n${r.shaderBase}\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\nin vec2 vUV;\n\nuniform float iTime;\n\nuniform int shells;\nuniform int shellIndex;\n\nuniform vec4 baseColor;\nuniform float density;\nuniform float thickness;\n\nuniform float swayStrength;\nuniform float swayDensity;\nuniform float windSpeed;\nuniform sampler2D simplexNoiseTexture;\n\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\nfloat hash( uvec2 q ) {\n  q *= uvec2(M1, M2); \n  \n  uint n = (q.x ^ q.y) * M1;\n  \n  return float(n) * (1.0 / float(0xffffffffU));\n}\n\nvoid main() {\n  motionVector = vec2(0.5);\n\n  float normalizedIndex = float(shellIndex) / float(shells - 1);\n\n  vec2 scaledUVs = vUV * density - normalizedIndex * swayStrength * (texture(simplexNoiseTexture, iTime * windSpeed + vUV * swayDensity).r - 0.5) * 2.;\n  uvec2 intUVs = uvec2(floor(scaledUVs));\n  float n = hash(intUVs);\n\n  float distanceToCenter = length(fract(scaledUVs) * 2. - 1.);\n  bool outsideStrand = distanceToCenter > thickness * ((1. - normalizedIndex) - n);\n  \n  if (outsideStrand && shellIndex > 0) {\n    discard;\n  }\n\n  vec3 color = baseColor.rgb * pow(normalizedIndex + 0.05, 0.8);\n\n  fragColor = vec4(color, 1);\n}\n\n`}},o={};function a(e){var t=o[e];if(void 0!==t)return t.exports;var n=o[e]={exports:{}};return i[e](n,n.exports,a),n.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",n="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",r=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},a.a=(i,o,a)=>{var s;a&&((s=[]).d=-1);var l,c,u,h=new Set,f=i.exports,d=new Promise(((e,t)=>{u=t,c=e}));d[t]=f,d[e]=e=>(s&&e(s),h.forEach(e),d.catch((e=>{}))),i.exports=d,o((i=>{var o;l=(i=>i.map((i=>{if(null!==i&&"object"==typeof i){if(i[e])return i;if(i.then){var o=[];o.d=0,i.then((e=>{a[t]=e,r(o)}),(e=>{a[n]=e,r(o)}));var a={};return a[e]=e=>e(o),a}}var s={};return s[e]=e=>{},s[t]=i,s})))(i);var a=()=>l.map((e=>{if(e[n])throw e[n];return e[t]})),c=new Promise((t=>{(o=()=>t(a)).r=0;var n=e=>e!==s&&!h.has(e)&&(h.add(e),e&&!e.d&&(o.r++,e.push(o)));l.map((t=>t[e](n)))}));return o.r?c:a()}),(e=>(e?u(d[n]=e):c(f),r(s)))),s&&s.d<0&&(s.d=0)},a.d=(e,t)=>{for(var n in t)a.o(t,n)&&!a.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a(220)})();