/*! For license information please see bundle.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={388:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z:()=>__WEBPACK_DEFAULT_EXPORT__});const JSONfn={};(function(exports){exports.stringify=function(e){return JSON.stringify(e,(function(e,t){var n;return t instanceof Function||"function"==typeof t?(n=t.toString()).length<8||"function"!==n.substring(0,8)?"_NuFrRa_"+n:n:t instanceof RegExp?"_PxEgEr_"+t:t}))},exports.parse=function(str,date2obj){var iso8061=!!date2obj&&/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;return JSON.parse(str,(function(key,value){var prefix;return"string"!=typeof value||value.length<8?value:(prefix=value.substring(0,8),iso8061&&value.match(iso8061)?new Date(value):"function"===prefix?eval("("+value+")"):"_PxEgEr_"===prefix||"_NuFrRa_"===prefix?eval(value.slice(8)):value)}))},exports.clone=function(e,t){return exports.parse(exports.stringify(e),t)}})(JSONfn);const __WEBPACK_DEFAULT_EXPORT__=JSONfn}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](n,n.exports,__webpack_require__),n.exports}__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__={};(()=>{var e={};__webpack_require__.r(e),__webpack_require__.d(e,{fogBase:()=>vt,litAttributesAndUniforms:()=>dt,litBase:()=>mt,motionBlurMain:()=>pt,shaderBase:()=>ft,trimStrings:()=>ht,webgl1:()=>At,webgl2:()=>Dt});var t={};__webpack_require__.r(t),__webpack_require__.d(t,{webgl1:()=>Bt,webgl2:()=>It});var n={};__webpack_require__.r(n),__webpack_require__.d(n,{webgl2:()=>Vt});var r={};__webpack_require__.r(r),__webpack_require__.d(r,{webgl1:()=>Xt,webgl2:()=>jt});var i={};__webpack_require__.r(i),__webpack_require__.d(i,{webgl1:()=>Wt,webgl2:()=>qt});var o={};__webpack_require__.r(o),__webpack_require__.d(o,{webgl1:()=>Kt,webgl2:()=>$t});var a={};__webpack_require__.r(a),__webpack_require__.d(a,{webgl1:()=>Zt,webgl2:()=>Jt});var s={};__webpack_require__.r(s),__webpack_require__.d(s,{webgl1:()=>tn,webgl2:()=>nn});var l={};__webpack_require__.r(l),__webpack_require__.d(l,{webgl1:()=>on,webgl2:()=>an});var c={};__webpack_require__.r(c),__webpack_require__.d(c,{webgl1:()=>ln,webgl2:()=>cn});var u={};__webpack_require__.r(u),__webpack_require__.d(u,{webgl1:()=>hn,webgl2:()=>fn});var h={};__webpack_require__.r(h),__webpack_require__.d(h,{M3_E30:()=>lr,audiRS6:()=>hr,aventador:()=>nr,bus:()=>ur,crownVic:()=>cr,drift:()=>rr,drift2:()=>ir,gtr:()=>or,lowpolyJeep:()=>mr,lowpolySportsCar:()=>fr,myLowpolySportsCar:()=>dr,porscheCarreraGTConcept2000:()=>vr,ranger:()=>ar,skyline:()=>sr});var f={};__webpack_require__.r(f),__webpack_require__.d(f,{webgl2:()=>xr});var d={};__webpack_require__.r(d),__webpack_require__.d(d,{webgl2:()=>br});var m=function(){var e=0,t=document.createElement("div");function n(e){return t.appendChild(e.dom),e}function r(n){for(var r=0;r<t.children.length;r++)t.children[r].style.display=r===n?"block":"none";e=n}t.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",t.addEventListener("click",(function(n){n.preventDefault(),r(++e%t.children.length)}),!1);var i=(performance||Date).now(),o=i,a=0,s=n(new m.Panel("FPS","#0ff","#002")),l=n(new m.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var c=n(new m.Panel("MB","#f08","#201"));return r(0),{REVISION:16,dom:t,addPanel:n,showPanel:r,begin:function(){i=(performance||Date).now()},end:function(){a++;var e=(performance||Date).now();if(l.update(e-i,200),e>=o+1e3&&(s.update(1e3*a/(e-o),100),o=e,a=0,c)){var t=performance.memory;c.update(t.usedJSHeapSize/1048576,t.jsHeapSizeLimit/1048576)}return e},update:function(){i=this.end()},domElement:t,setMode:r}};m.Panel=function(e,t,n){var r=1/0,i=0,o=Math.round,a=o(window.devicePixelRatio||1),s=80*a,l=48*a,c=3*a,u=2*a,h=3*a,f=15*a,d=74*a,m=30*a,v=document.createElement("canvas");v.width=s,v.height=l,v.style.cssText="width:80px;height:48px";var p=v.getContext("2d");return p.font="bold "+9*a+"px Helvetica,Arial,sans-serif",p.textBaseline="top",p.fillStyle=n,p.fillRect(0,0,s,l),p.fillStyle=t,p.fillText(e,c,u),p.fillRect(h,f,d,m),p.fillStyle=n,p.globalAlpha=.9,p.fillRect(h,f,d,m),{dom:v,update:function(l,g){r=Math.min(r,l),i=Math.max(i,l),p.fillStyle=n,p.globalAlpha=1,p.fillRect(0,0,s,f),p.fillStyle=t,p.fillText(o(l)+" "+e+" ("+o(r)+"-"+o(i)+")",c,u),p.drawImage(v,h+a,f,d-a,m,h,f,d-a,m),p.fillRect(h+d-a,f,a,m),p.fillStyle=n,p.globalAlpha=.9,p.fillRect(h+d-a,f,a,o((1-l/g)*m))}}};class v{constructor(e={}){if(e.hasOwnProperty("elementID")){if(null==(t=document.getElementById(e.elementID)))throw Error("No element with the id '"+e.elementID+"' was found!");if(!(t instanceof HTMLCanvasElement))throw Error("Element is not a canvas!");this.canvas=t}else if(e.hasOwnProperty("elementClass")){if(null==(t=document.getElementsByClassName(e.elementClass)[0]))throw Error("No element with the class '"+e.elementClass+"' was found!");if(!(t instanceof HTMLCanvasElement))throw Error("Element is not a canvas!");this.canvas=t}else if(e.hasOwnProperty("element")){var t;if(null==(t=e.element))throw Error("Element is null or undefined!");if(!(t instanceof HTMLCanvasElement))throw Error("Element '"+t+"' is not a canvas!");this.canvas=t}else this.canvas=document.createElement("canvas"),document.body.appendChild(this.canvas);if(e.hasOwnProperty("width")){if(isNaN(e.width))throw Error("Width is not a number: "+e.width);this.canvas.width=e.width}if(e.hasOwnProperty("height")){if(isNaN(e.height))throw Error("Height is not a number: "+e.height);this.canvas.height=e.height}if(e.hasOwnProperty("width")||e.hasOwnProperty("height")||e.hasOwnProperty("noFullscreen")&&(!e.hasOwnProperty("noFullscreen")||e.noFullscreen)?(this.disableContextMenu=!!e.hasOwnProperty("disableContextMenu")&&e.disableContextMenu,this.disableMiddleMouse=!!e.hasOwnProperty("disableMiddleMouse")&&e.disableMiddleMouse,this.disableScrollOnMobile=!!e.hasOwnProperty("disableScrollOnMobile")&&e.disableScrollOnMobile,this.disableKeyShortcuts=!!e.hasOwnProperty("disableKeyShortcuts")&&e.disableKeyShortcuts,this.updateCanvasSizeOnResize=!!e.hasOwnProperty("updateCanvasSizeOnResize")&&e.updateCanvasSizeOnResize,this.publicMethods=!e.hasOwnProperty("publicMethods")||e.publicMethods):(this.canvas.width=Math.ceil(window.innerWidth)+1,this.canvas.height=Math.ceil(window.innerHeight)+1,this.canvas.style.position="absolute",this.canvas.style.top="0",this.canvas.style.bottom="0",this.canvas.style.left="0",this.canvas.style.right="0",document.body.style.overflow="hidden",this.disableContextMenu=!e.hasOwnProperty("disableContextMenu")||e.disableContextMenu,this.disableMiddleMouse=!e.hasOwnProperty("disableMiddleMouse")||e.disableMiddleMouse,this.disableScrollOnMobile=!e.hasOwnProperty("disableScrollOnMobile")||e.disableScrollOnMobile,this.disableKeyShortcuts=!!e.hasOwnProperty("disableKeyShortcuts")&&e.disableKeyShortcuts,this.updateCanvasSizeOnResize=!e.hasOwnProperty("updateCanvasSizeOnResize")||e.updateCanvasSizeOnResize,this.publicMethods=!e.hasOwnProperty("publicMethods")||e.publicMethods),this.ctx=this.canvas.getContext("2d"),this.font="Arial",this.fontWeight="normal",this.images=[],this.imageData=void 0,this.imageDataData=void 0,this.audioContext=new(window.AudioContext||window.webkitAudioContext),this.keys={keysDown:[],ctrlPressed:!1,shiftSPressed:!1,altPressed:!1},this.mouse={x:0,y:0,lastX:0,lastY:0,movementX:0,movementY:0,left:!1,right:!1,middle:!1,any:!1},this.mouseLookupTable=["left","middle","right"],this.touch={x:0,y:0,isTouching:!1,nrTouches:0,touches:[]},this.eventFunctions={mousedown:"undefined"!=typeof OnMouseDown,mouseup:"undefined"!=typeof OnMouseUp,mousemove:"undefined"!=typeof OnMouseMove,contextmenu:"undefined"!=typeof OnContextMenu,touchstart:"undefined"!=typeof OnTouchStart,touchend:"undefined"!=typeof OnTouchEnd,touchmove:"undefined"!=typeof OnTouchMove,keydown:"undefined"!=typeof OnKeyDown,keyup:"undefined"!=typeof OnKeyUp,resize:"undefined"!=typeof OnResize},this.ENUM={LINECAP:{DEFAULT:"butt",BUTT:"butt",ROUND:"round",SQUARE:"square"},TEXTALIGN:{X:{DEFAULT:"start",START:"start",END:"end",CENTER:"center",LEFT:"left",RIGHT:"right"},Y:{DEFAULT:"alphabetic",ALPHABETIC:"alphabetic",TOP:"top",HANGING:"hanging",MIDDLE:"middle",CENTER:"middle",IDEOGRAPHIC:"ideographic",BOTTOM:"bottom"}}},document.addEventListener("keydown",(e=>{if(this.keys.altPressed=e.altKey,this.keys.shiftPressed=e.shiftKey,this.keys.ctrlPressed=e.ctrlKey,this.keys.keysDown[e.key]=this.keys.keysDown[e.keyCode]=this.keys.keysDown[e.code]=!0,this.eventFunctions.keydown&&OnKeyDown(e),this.disableKeyShortcuts)return e.preventDefault(),!1})),document.addEventListener("keyup",(e=>{this.keys.altPressed=e.altKey,this.keys.shiftPressed=e.shiftKey,this.keys.ctrlPressed=e.ctrlKey,this.keys.keysDown[e.key]=this.keys.keysDown[e.keyCode]=this.keys.keysDown[e.code]=!1,this.eventFunctions.keyup&&OnKeyUp(e)})),this.canvas.addEventListener("mousemove",(e=>{let t=this.canvas.getBoundingClientRect();this.mouse.x=(e.clientX-t.left)/(t.width/this.width),this.mouse.y=(e.clientY-t.top)/(t.height/this.height),this.mouse.movementX=e.movementX,this.mouse.movementY=e.movementY,this.eventFunctions.mousemove&&OnMouseMove(e)})),this.canvas.addEventListener("mousedown",(e=>{let t=e.button;if(t<3&&(this.mouse[this.mouseLookupTable[t]]=!0),this.mouse.any=this.mouse.left||this.mouse.right||this.mouse.middle,this.eventFunctions.mousedown&&OnMouseDown(e),1==t&&this.disableMiddleMouse)return e.preventDefault(),!1})),this.canvas.addEventListener("mouseup",(e=>{let t=e.button;t<3&&(this.mouse[this.mouseLookupTable[t]]=!1),this.mouse.any=this.mouse.left||this.mouse.right||this.mouse.middle||this.touch.touches.length>0,this.eventFunctions.mouseup&&OnMouseUp(e)})),this.canvas.addEventListener("contextmenu",(e=>(this.eventFunctions.contextmenu&&OnContextMenu(e),!this.disableContextMenu||(e.preventDefault(),!1)))),this.updateTouches=function(e){let t=this.canvas.getBoundingClientRect();this.touch.touches=[];for(let o=0;o<e.touches.length;o++){var n=e.touches[o],r=(n.pageX-t.left)/(t.width/this.width),i=(n.pageY-t.top)/(t.height/this.height);this.touch.touches[o]={x:r,y:i,id:n.identifier,force:n.force,radiusX:n.radiusX,radiusY:n.radiusY,rotationAngle:n.rotationAngle}}},this.canvas.addEventListener("touchmove",(e=>{this.disableScrollOnMobile&&e.preventDefault(),this.updateTouches(e),this.touch.x=this.touch.touches[0].x,this.touch.y=this.touch.touches[0].y,this.eventFunctions.touchmove&&OnTouchMove(e)})),this.canvas.addEventListener("touchstart",(e=>{this.disableScrollOnMobile&&e.preventDefault(),this.updateTouches(e),this.touch.x=this.touch.touches[0].x,this.touch.y=this.touch.touches[0].y,this.touch.isTouching=!0,this.mouse.any=!0,this.eventFunctions.touchstart&&OnTouchStart(e)})),this.canvas.addEventListener("touchend",(e=>{this.disableScrollOnMobile&&e.preventDefault(),this.updateTouches(e),this.touch.isTouching=this.touch.touches.length>0,this.mouse.any=this.mouse.left||this.mouse.right||this.mouse.middle||this.touch.touches.length>0,this.eventFunctions.touchend&&OnTouchEnd(e)})),window.addEventListener("resize",(e=>{this.updateCanvasSizeOnResize&&(this.width=Math.ceil(window.innerWidth)+1,this.height=Math.ceil(window.innerHeight)+1),this.eventFunctions.resize&&OnResize(e)})),this.isPassed=function(e){return void 0!==e},this.publicMethods){var n=Object.getOwnPropertyNames(v.prototype);for(var r of n)["constructor","width","height"].includes(r)||(window[r]=this[r].bind(this));for(var i of["width","height"])Object.defineProperty(window,i,{get:function(e,t){return function(){return e[t]}}(this,i),set:function(e,t){return function(n){e[t]=n}}(this,i),configurable:!0});for(var o of["mouse","touch"])Object.defineProperty(window,o,{get:function(e,t){return function(){return e[t]}}(this,o),configurable:!0})}}get width(){return this.canvas.width}get height(){return this.canvas.height}set width(e){this.canvas.width=e}set height(e){this.canvas.height=e}requestFullscreen(){this.canvas.requestFullscreen?this.canvas.requestFullscreen():this.canvas.mozRequestFullScreen?this.canvas.mozRequestFullScreen():this.canvas.webkitRequestFullscreen?this.canvas.webkitRequestFullscreen():this.canvas.msRequestFullscreen&&this.canvas.msRequestFullscreen()}exitFullscreen(){document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen?document.webkitExitFullscreen():document.msExitFullscreen&&document.msExitFullscreen()}lockPointer(){this.canvas.requestPointerLock=this.canvas.requestPointerLock||this.canvas.mozRequestPointerLock,this.canvas.requestPointerLock()}unlockPointer(){document.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock,document.exitPointerLock()}clearScreen(){this.ctx.clearRect(0,0,this.width,this.height)}background(e){this.ctx.fillStyle=e,this.ctx.fillRect(0,0,this.width,this.height)}arc(e,t,n,r,i,o){this.ctx.arc(e,t,n,r,i,o)}circle(e,t,n,r,i,o){this.ctx.beginPath(),this.ctx.arc(e,t,n,0,2*Math.PI),this.ctx.fillStyle=r,i&&(this.ctx.strokeStyle=i),o&&(this.ctx.lineWidth=o),this.ctx.fill(),i&&this.ctx.stroke()}ring(e,t,n,r,i){this.ctx.beginPath(),this.ctx.arc(e,t,n,0,2*Math.PI),this.ctx.strokeStyle=r,i&&(this.ctx.lineWidth=i),this.ctx.stroke()}ellipse(e,t,n,r,i,o=0,a,s){this.ctx.beginPath(),this.ctx.ellipse(e,t,n,r,o,0,2*Math.PI),this.ctx.fillStyle=i,a&&(this.ctx.strokeStyle=a),s&&(this.ctx.lineWidth=s),this.ctx.fill(),a&&this.ctx.stroke()}rectangle(e,t,n,r,i,o,a){i&&(this.ctx.fillStyle=i),a&&(this.ctx.lineWidth=a),o?(this.ctx.beginPath(),this.ctx.strokeStyle=o,this.ctx.rect(e,t,n,r),i&&this.ctx.fill(),this.ctx.stroke()):this.ctx.fillRect(e,t,n,r)}roundedRectangle(e,t,n,r,i,o,a,s){"number"==typeof o&&(o=[o,o,o,o]),this.ctx.beginPath(),this.ctx.arc(e+o[0],t+o[0],o[0],Math.PI,1.5*Math.PI),this.ctx.lineTo(e+n-o[1],t),this.ctx.arc(e+n-o[1],t+o[1],o[1],1.5*Math.PI,2*Math.PI),this.ctx.lineTo(e+n,t+r-o[2]),this.ctx.arc(e+n-o[2],t+r-o[2],o[2],0,.5*Math.PI),this.ctx.lineTo(e+o[3],t+r),this.ctx.arc(e+o[3],t+r-o[3],o[3],.5*Math.PI,Math.PI),this.ctx.closePath(),a&&(s&&(this.ctx.lineWidth=s),this.ctx.strokeStyle=a,this.ctx.stroke()),this.ctx.fillStyle=i,this.ctx.fill()}triangle(e,t,n,r,i,o,a,s,l){this.ctx.beginPath(),this.ctx.moveTo(e,t),this.ctx.lineTo(n,r),this.ctx.lineTo(i,o),this.ctx.closePath(),this.ctx.fillStyle=a,l&&(this.ctx.lineWidth=l),this.ctx.fill(),s&&(this.ctx.strokeStyle=s,this.ctx.stroke())}line(e,t,n,r,i,o){this.ctx.beginPath(),this.ctx.moveTo(e,t),this.ctx.lineTo(n,r),i&&(this.ctx.strokeStyle=i),o&&(this.ctx.lineWidth=o),this.ctx.stroke()}clippedPicture(e,t,n,r,i,o,a,s,l){var c=this.images[e];if(c)c.complete&&0!==c.naturalWidth&&(s=s||c.width,l=l||c.height,this.ctx.drawImage(c,t,n,r,i,o,a,s,l));else{var u=new Image;u.src=e,u.onload=()=>{s=s||u.width,l=l||u.height,this.ctx.drawImage(u,t,n,r,i,o,a,s,l)},this.images[e]=u}}picture(e,t,n,r,i){var o=this.images[e];if(o)o.complete&&(r=r||o.width,i=i||o.height,this.ctx.drawImage(o,t,n,r,i));else{var a=new Image;a.src=e,a.onload=()=>{r=r||a.width,i=i||a.height,this.ctx.drawImage(a,t,n,r,i)},this.images[e]=a}}text(e,t,n,r,i,o,a){this.ctx.beginPath(),this.ctx.font=this.fontWeight+" "+r+"px "+this.font,this.ctx.fillStyle=i,a&&(this.ctx.lineWidth=a),this.ctx.fillText(e,t,n),o&&(this.ctx.strokeStyle=o,this.ctx.strokeText(e,t,n))}drawVector(e,t,n,r=1,i="black"){var o=this.normalizeVector(n),a=-o.y,s=o.x,l=e+o.x*r,c=t+o.y*r;this.line(e,t,l,c,3,i),this.triangle(l,c,l-7*o.x+7*a,c-7*o.y+7*s,l-7*o.x-7*a,c-7*o.y-7*s,i)}polygon(e,t,n,r,i,o,a){this.ctx.beginPath(),this.ctx.moveTo(e[0].x+t,e[0].y+n);for(var s=1;s<e.length;s++){var l=e[s];this.ctx.lineTo(l.x+t,l.y+n)}r&&this.ctx.closePath(),i&&(this.ctx.fillStyle=i,this.ctx.fill()),o&&(a&&(this.ctx.lineWidth=a),this.ctx.strokeStyle=o,this.ctx.stroke())}rgb(e=0,t=0,n=0){return`rgb(${e}, ${t}, ${n})`}getPixelData(){this.imageData=this.ctx.getImageData(0,0,this.width,this.height),this.imageDataData=this.imageData.data}updatePixel(e,t,n,r,i,o=255){let a=4*(e+t*this.width);this.imageDataData[a]=n,this.imageDataData[a+1]=r,this.imageDataData[a+2]=i,this.imageDataData[a+3]=o}updatePixelIndex(e,t,n,r,i=255){var o=4*e;this.imageDataData[o]=t,this.imageDataData[o+1]=n,this.imageDataData[o+2]=r,this.imageDataData[o+3]=i}getPixel(e,t){let n=4*(e+t*this.width);return[this.imageDataData[n],this.imageDataData[n+1],this.imageDataData[n+2],this.imageDataData[n+3]]}getPixelIndex(e){let t=4*e;return[this.imageDataData[t],this.imageDataData[t+1],this.imageDataData[t+2],this.imageDataData[t+3]]}renderPixelData(){this.ctx.putImageData(this.imageData,0,0)}save(){this.ctx.save()}restore(){this.ctx.restore()}rotate(e){this.ctx.rotate(e)}translate(e,t){this.ctx.translate(e,t)}beginPath(){this.ctx.beginPath()}closePath(){this.ctx.closePath()}moveTo(e,t){this.ctx.moveTo(e,t)}lineTo(e,t){this.ctx.lineTo(e,t)}quadraticCurveTo(e,t,n,r){this.ctx.quadraticCurveTo(e,t,n,r)}quadraticTo(e,t,n,r){this.ctx.quadraticCurveTo(e,t,n,r)}bezierCurveTo(e,t,n,r,i,o){this.ctx.bezierCurveTo(e,t,n,r,i,o)}bezierTo(e,t,n,r,i,o){this.ctx.bezierCurveTo(e,t,n,r,i,o)}fill(){this.ctx.fill()}stroke(){this.ctx.stroke()}fillStyle(e){this.ctx.fillStyle=e}strokeStyle(e){this.ctx.strokeStyle=e}setLineWidth(e){this.ctx.lineWidth=e}lineWidth(e){this.ctx.lineWidth=e}strokeWeight(e){this.ctx.lineWidth=e}setLineCap(e){this.ctx.lineCap=e}resetLineCap(){this.ctx.lineCap="butt"}setFont(e){this.font=e}setTextAlign(e){this.ctx.textAlign=e}setTextXAlign(e){this.ctx.textAlign=e}setTextAlignX(e){this.ctx.textAlign=e}setTextYAlign(e){this.ctx.textBaseline=e}setTextAlignY(e){this.ctx.textBaseline=e}resetTextXAlign(){this.ctx.textAlign="left"}resetTextAlignX(){this.ctx.textAlign="left"}resetTextYAlign(){this.ctx.textBaseline="alphabetic"}resetTextAlignY(){this.ctx.textBaseline="alphabetic"}clip(){this.ctx.clip()}createSound(e,t=1,n=0,r=!1){var i=new Audio(e);return i.loop=r,i.currentTime=n,i.volume=t,{volume:t,startTime:n,audio:i}}playSound(e){e.audio.currentTime=e.startTime,e.audio.volume=e.volume,e.audio.play()}stopSound(e){e.audio.stop()}pauseSound(e){e.audio.pause()}backgroundMusic(e){var t=new Audio(e);return t.loop=!0,t.play(),t}fadeOutSound(e,t=1){var n=e.volume,r=0,i=setInterval((()=>{e.audio.volume=n/(20*t)*(20*t-r),++r>20*t&&(e.audio.pause(),clearInterval(i))}),50)}playTone(e=440,t=1,n=1,r="sine"){var i=this.audioContext.createOscillator(),o=this.audioContext.createGain();o.gain.value=n,o.connect(this.audioContext.destination),i.type=r,i.frequency.value=e,i.connect(o),i.start(),setTimeout((()=>{i.stop()}),1e3*t)}getDistanceSqr(e,t,n,r){var i=e-n,o=t-r;return i*i+o*o}getDistanceSqr3D(e,t,n,r,i,o){var a=e-n,s=t-r,l=i-o;return a*a+s*s+l*l}getDistance(e,t,n,r){return Math.sqrt(top.getDistanceSqr(e,t,n,r))}getDistance3D(e,t,n,r,i,o){return Math.sqrt(top.getDistanceSqr3D(e,t,n,r,i,o))}getAngle(e,t,n,r){return Math.atan2(r-t,n-e)}normalize(e,t){var n=Math.sqrt(e*e+t*t);return{x:e/n,y:t/n}}normalizeVector(e){var t=Math.sqrt(e.x*e.x+e.y*e.y);return{x:e.x/t,y:e.y/t}}normalize3D(e,t,n){var r=Math.sqrt(e*e+t*t+n*n);return{x:e/r,y:t/r,z:n/r}}normalize3DVector(e){var t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z);return{x:e.x/t,y:e.y/t,z:e.z/t}}lengthVector(e){return Math.sqrt(e.x*e.x+e.y*e.y)}length3DVector(e){return Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z)}dot(e,t){return e.x*t.x+e.y*t.y}dot3D(e,t){return e.x*t.x+e.y*t.y+e.z*t.z}crossProduct3D(e,t){return{x:e.y*t.z-e.z*t.y,y:e.z*t.x-e.x*t.z,z:e.x*t.y-e.y*t.x}}clamp(e,t,n){return Math.max(t,Math.min(n,e))}lerp(e,t,n){return e*(1-n)+t*n}rectanglesIntersect(e,t,n,r,i,o,a,s){return e+n>i&&e<i+a&&t+r>o&&t<o+s}circlesIntersect(e,t,n,r,i,o){return this.getDistance(e,t,r,i)<n+o}circleRectangleIntersect(e,t,n,r,i,o,a){var s=Math.abs(e-(r+o/2)),l=Math.abs(t-(i+a/2));if(s>o/2+n)return!1;if(l>a/2+n)return!1;if(s<=o/2)return!0;if(l<=a/2)return!0;var c=s-o/2,u=l-a/2;return c*c+u*u<=n*n}random(e){return Math.random()*e}randomInt(e){return Math.random()*e>>0}randomArray(e){return e[Math.floor(Math.random()*e.length)]}randomColor(e){if("number"!=typeof e||isNaN(e))return"rgb("+(256*Math.random()>>0)+","+(256*Math.random()>>0)+","+(256*Math.random()>>0)+")";if(0===e)throw Error("Colordepth cannot be 0");var t=256/e;return"rgb("+Math.ceil(Math.floor(256*Math.random())/t)*t+","+Math.ceil(Math.floor(256*Math.random())/t)*t+","+Math.ceil(Math.floor(256*Math.random())/t)*t+")"}canvasToURL(){return top.canvas.toDataURL()}canvasToImage(){var e=new Image;return e.src=top.canvas.toDataURL(),e}saveToFile(e="canvas.png"){var t=document.createElement("a");t.download=e,t.href=top.canvas.toDataURL(),t.click()}setCookie(e,t,n=36500){let r=new Date;r.setTime(r.getTime()+24*n*60*60*1e3);let i="expires="+r.toUTCString();document.cookie=e+"="+t+";"+i+";path=/"}getCookie(e){if(0==e.length)return!1;var t=e+"=",n=document.cookie.split(";");for(let e=0;e<n.length;e++){let i=n[e];var r=i.indexOf(t);if(r>0)return i.substr(r+t.length)}return!1}deleteCookie(e){document.cookie=e+"=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/"}isCtrlPressed(){return this.keys.ctrlPressed}isAltPressed(){return this.keys.AltPressed}isShiftPressed(){return this.keys.shiftPressed}key(e){return!!this.keys.keysDown[e]}create2DArray(e,t,n=((e,t)=>0)){for(var r=new Array(e),i=0;i<e;i++){r[i]=new Array(t);for(var o=0;o<t;o++)r[i][o]=n(i,o)}return r}mapValue(e,t,n,r,i){return(e-t)*(i-r)/(n-t)+r}gradient(e,t,n,r,i,o){var a=this.ctx.createLinearGradient(n,r,i,o);return a.addColorStop(0,e),a.addColorStop(1,t),a}prettyprint(e){"object"==typeof e&&console.log(JSON.stringify(e,null,2))}}const p={SHADOWS:1,OPAQUE:2,ALPHA:4,DOWNSCALED:8},g="cube";function x(e,t,n){return e<t?0:e>=n?1:(e=(e-t)/(n-t))*e*(3-2*e)}function b(e,t){return(e%t+t)%t}function y(e,t,n){return Math.max(t,Math.min(n,e))}function T(e,t,n){return e*(1-n)+t*n}function w(e,t,n){return Math.abs(e-t)<1e-6?0:(n-e)/(t-e)}function E(e,t){return Math.round(e/t)*t}function M(e){return 0==(e&e-1)}function _(e){for(var t=new Uint16Array(e.length),n=0;n<t.length;n++)t[n]=F(e[n]);return t}var R,C,F=(R=new Float32Array(1),C=new Int32Array(R.buffer),function(e){R[0]=e;var t=C[0],n=t>>16&32768,r=t>>12&2047,i=t>>23&255;return i<103?n:i>142?(n|=31744,n|=(255==i?0:1)&&8388607&t):i<113?n|=((r|=2048)>>114-i)+(r>>113-i&1):(n|=i-112<<10|r>>1,n+=1&r)});function A(e){return new DataView(Uint8Array.from(e).buffer).getInt32(0,!0)}function D(e){return new Promise((t=>setTimeout(t,e)))}function P(e){return new Promise(((t,n)=>{let r=new Image;r.addEventListener("load",(e=>t(r))),r.addEventListener("error",(()=>{n(new Error(`Failed to load image's URL: ${e}`))})),r.src=e}))}function S(e,t,n){var r=document.createElement("canvas");r.width=t??e.width,r.height=n??e.height;var i=r.getContext("2d");return i.drawImage(e,0,0),i.getImageData(0,0,r.width,r.height).data}function N(e){e.classList.add("hidden")}function U(e){e.classList.remove("hidden")}function z(e,t="download"){var n=document.createElement("a");n.download=t+".png",n.href=e.toDataURL(),n.click()}class L{constructor(e=0,t=0,n=0,r){return(r=r||{x:0,y:0,z:0}).x=e,r.y=t,r.z=n,r}static zero(e){return(e=e||new L).x=0,e.y=0,e.z=0,e}static one(e){return(e=e||new L).x=1,e.y=1,e.z=1,e}static up(e){return(e=e||new L).x=0,e.y=1,e.z=0,e}static down(e){return(e=e||new L).x=0,e.y=-1,e.z=0,e}static fill(e=0,t){return(t=t||new L).x=e,t.y=e,t.z=e,t}static set(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e}static copy(e,t){return(t=t||new L).x=e.x,t.y=e.y,t.z=e.z,t}static fromArray(e,t=0,n=1,r=4,i){return(i=i||{x:0,y:0,z:0,w:0}).x=r>=1?e[t]??0:0,i.y=r>=2?e[t+n]??0:0,i.z=r>=3?e[t+2*n]??0:0,i.w=r>=4?e[t+3*n]??0:0,i}static toArray(e,t){return(t=t||[0,0,0])[0]=e.x,t[1]=e.y,t[2]=e.z,t}static equal(e,t,n=1e-6){return Math.abs(e.x-t.x)<n&&Math.abs(e.y-t.y)<n&&Math.abs(e.z-t.z)<n}static isVectorIsh(e){return"object"==typeof e&&("x"in e||"y"in e||"z"in e)}static isNaN(e){return isNaN(e.x)||isNaN(e.y)||isNaN(e.z)}static add(e,t,n){return(n=n||new L).x=e.x+t.x,n.y=e.y+t.y,n.z=e.z+t.z,n}static addTo(e,t){return e.x+=t.x,e.y+=t.y,e.z+=t.z,e}static subtract(e,t,n){return(n=n||new L).x=e.x-t.x,n.y=e.y-t.y,n.z=e.z-t.z,n}static subtractTo(e,t){return e.x-=t.x,e.y-=t.y,e.z-=t.z,e}static multiply(e,t,n){return(n=n||new L).x=e.x*t,n.y=e.y*t,n.z=e.z*t,n}static multiplyTo(e,t){return e.x*=t,e.y*=t,e.z*=t,e}static negate(e,t){return(t=t||new L).x=-e.x,t.y=-e.y,t.z=-e.z,t}static negateTo(e){return e.x=-e.x,e.y=-e.y,e.z=-e.z,e}static compMultiply(e,t,n){return(n=n||new L).x=e.x*t.x,n.y=e.y*t.y,n.z=e.z*t.z,n}static compMultiplyTo(e,t){return e.x*=t.x,e.y*=t.y,e.z*=t.z,e}static divide(e,t,n){return(n=n||new L).x=e.x/t,n.y=e.y/t,n.z=e.z/t,n}static divideTo(e,t){return e.x/=t,e.y/=t,e.z/=t,e}static compDivide(e,t,n){return(n=n||new L).x=e.x/t.x,n.y=e.y/t.y,n.z=e.z/t.z,n}static compDivideTo(e,t){return e.x/=t.x,e.y/=t.y,e.z/=t.z,e}static average(e,t,n){return n=n||new L,L.add(e,t,n),L.divideTo(n,2),n}static applyFunc(e,t,n){return(n=n||new L).x=t(e.x),n.y=t(e.y),n.z=t(e.z),n}static compFunc(e,t,n,r){return(r=r||new L).x=n(e.x,t.x),r.y=n(e.y,t.y),r.z=n(e.z,t.z),r}static rotate2D(e,t,n){return(n=n||new L).x=e.x*Math.cos(t)-e.y*Math.sin(t),n.y=e.x*Math.sin(t)+e.y*Math.cos(t),n.z=0,n}static rotateAround(e,t,n,r){r=r||new L,L.multiply(t,L.dot(e,t)/L.dot(t,t),I),L.subtract(e,I,O),L.cross(t,O,k);let i=L.length(O);var o=Math.cos(n)/i,a=Math.sin(n)/L.length(k);return L.multiply(O,o,V),L.multiply(k,a,G),L.addTo(V,G),L.multiplyTo(V,i),L.add(V,I,r),r}static project(e,t,n){n=n||new L;const r=L.dot(t,e);return L.set(n,t),L.multiplyTo(n,r),n}static projectOnPlane(e,t,n){n=n||new L;const r=L.dot(t,e);return L.set(B,t),L.multiplyTo(B,r),L.set(n,e),L.subtractTo(n,B),n}static findOrthogonal(e,t){return t=t||new L,Math.abs(e.x)>=1/Math.sqrt(3)?(t.x=e.y,t.y=-e.x,t.z=0):(t.x=0,t.y=e.z,t.z=-e.y),L.normalizeTo(t),t}static formOrthogonalBasis(e){var t=L.findOrthogonal(e);return[t,L.cross(t,e)]}static lengthNonVector(e=0,t=0,n=0){return Math.sqrt(e*e+t*t+n*n)}static length(e){var t=e.x*e.x+e.y*e.y;return e.z&&(t+=e.z*e.z),Math.sqrt(t)}static lengthSqr(e){var t=e.x*e.x+e.y*e.y;return e.z&&(t+=e.z*e.z),t}static distance(e,t){return L.set(B,e),L.subtractTo(B,t),L.length(B)}static distanceSqr(e,t){return L.set(B,e),L.subtractTo(B,t),L.lengthSqr(B)}static normalize(e,t){t=t||new L;var n=L.lengthSqr(e);return n<1e-12?L.copy(e,t):L.divide(e,Math.sqrt(n),t),t}static normalizeTo(e){var t=L.length(e);return t<1e-6?e:L.divideTo(e,t)}static dot(e,t){var n=e.x*t.x+e.y*t.y;return e.z&&t.z&&(n+=e.z*t.z),n}static cross(e,t,n){n=n||new L;const r=e.x,i=e.y,o=e.z,a=t.x,s=t.y,l=t.z;return n.x=i*l-o*s,n.y=o*a-r*l,n.z=r*s-i*a,n}static lerp(e,t,n,r){return(r=r||new L).x=T(e.x,t.x,n),r.y=T(e.y,t.y,n),r.z=T(e.z,t.z,n),r}static inverseLerp(e,t,n,r){return(r=r||new L).x=w(e.x,t.x,n),r.y=w(e.y,t.y,n),r.z=w(e.z,t.z,n),r}static slerp(e,t,n,r){r=r||new L;var i=y(L.dot(e,t),-1,1),o=Math.acos(i)*n,a=L.normalize(L.subtract(t,L.multiply(e,i))),s=L.multiply(e,Math.cos(o)),l=L.multiply(a,Math.sin(o));return L.add(s,l,r),r}static clamp(e,t,n,r){r=r||new L;var i=L.isVectorIsh(t),o=L.isVectorIsh(n);return r.x=y(e.x,i?t.x:t,o?n.x:n),r.y=y(e.y,i?t.y:t,o?n.y:n),r.z=y(e.z,i?t.z:t,o?n.z:n),r}static map(e,t,n){return(n=n||new L).x=t(e.x),n.y=t(e.y),n.z=t(e.z),n}}const B=new L,I=new L,O=new L,k=new L,V=new L,G=new L,X=L;class j{constructor(e=0,t=0,n=0,r=0,i){return(i=i||{x:0,y:0,z:0,w:0}).x=e,i.y=t,i.z=n,i.w=r,i}static isQuaternionIsh(e){return"object"==typeof e&&"x"in e&&"y"in e&&"z"in e&&"w"in e}static zero(){return{x:0,y:0,z:0,w:0}}static identity(e){return(e=e||new j).x=0,e.y=0,e.z=0,e.w=1,e}static copy(e){return{x:e.x,y:e.y,z:e.z,w:e.w}}static set(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}static equal(e,t,n=1e-6){return Math.abs(e.x-t.x)<n&&Math.abs(e.y-t.y)<n&&Math.abs(e.z-t.z)<n&&Math.abs(e.w-t.w)<n}static isNaN(e){return isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||isNaN(e.w)}static lengthSqr(e){return e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w}static length(e){return Math.sqrt(j.lengthSqr(e))}static normalize(e,t){t=t||new j;const n=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w);return t.x=e.x/n,t.y=e.y/n,t.z=e.z/n,t.w=e.w/n,t}static normalizeTo(e){const t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w);return e.x/=t,e.y/=t,e.z/=t,e.w/=t,e}static dot(e,t){return e.x*t.x+e.y*t.y+e.z*t.z+e.w*t.w}static add(e,t){return{x:e.x+t.x,y:e.y+t.y,z:e.z+t.z,w:e.w+t.w}}static multiply(e,t){return{x:e.x*t,y:e.y*t,z:e.z*t,w:e.w*t}}static QxQ(e,t,n){n=n||new j;const r=e.x,i=e.y,o=e.z,a=e.w,s=t.x,l=t.y,c=t.z,u=t.w;return n.x=a*s+r*u+i*c-o*l,n.y=a*l-r*c+i*u+o*s,n.z=a*c+r*l-i*s+o*u,n.w=a*u-r*s-i*l-o*c,n}static QxV(e,t,n){n=n||new X;var r=t.x,i=t.y,o=t.z,a=e.x,s=e.y,l=e.z,c=e.w,u=c*r+s*o-l*i,h=c*i+l*r-a*o,f=c*o+a*i-s*r,d=-a*r-s*i-l*o;return n.x=u*c+d*-a+h*-l-f*-s,n.y=h*c+d*-s+f*-a-u*-l,n.z=f*c+d*-l+u*-s-h*-a,n}static slerp(e,t,n){var r=j.dot(e,t);if(Math.abs(1-r)<1e-5)return e;var i=r>=0?e:j.multiply(e,-1),o=Math.acos(Math.abs(r)),a=j.add(j.multiply(i,Math.sin((1-n)*o)),j.multiply(t,Math.sin(n*o)));return j.multiply(a,1/Math.sin(o))}static lerp(e,t,n){return{x:T(e.x,t.x,n),y:T(e.y,t.y,n),z:T(e.z,t.z,n),w:T(e.w,t.w,n)}}static euler(e,t,n,r){r=r||new j;const i=e,o=t,a=n,s=Math.sin(i/2)*Math.cos(o/2)*Math.cos(a/2)-Math.cos(i/2)*Math.sin(o/2)*Math.sin(a/2),l=Math.cos(i/2)*Math.sin(o/2)*Math.cos(a/2)+Math.sin(i/2)*Math.cos(o/2)*Math.sin(a/2),c=Math.cos(i/2)*Math.cos(o/2)*Math.sin(a/2)-Math.sin(i/2)*Math.sin(o/2)*Math.cos(a/2),u=Math.cos(i/2)*Math.cos(o/2)*Math.cos(a/2)+Math.sin(i/2)*Math.sin(o/2)*Math.sin(a/2);return r.x=s,r.y=l,r.z=c,r.w=u,r}static eulerVector(e,t){return j.euler(e.x,e.y,e.z,t)}static toEulerAngles(e){var[t,n,r,i]=[e.x,e.y,e.z,e.w],o=2*(i*t+n*r),a=1-2*(t*t+n*n),s=2*(i*n-r*t);s=(s=s>1?1:s)<-1?-1:s;var l=2*(i*r+t*n),c=1-2*(n*n+r*r);return[Math.atan2(o,a),Math.asin(s),Math.atan2(l,c)]}static angleAxis(e,t,n){return(n=n||new j).x=t.x*Math.sin(e/2),n.y=t.y*Math.sin(e/2),n.z=t.z*Math.sin(e/2),n.w=Math.cos(e/2),n}static fromMatrix(e,t){t=t||new j;var n=K.get(e,0,0)+K.get(e,1,1)+K.get(e,2,2);if(n>0){let r=.5/Math.sqrt(n+1);t.x=(K.get(e,2,1)-K.get(e,1,2))*r,t.y=(K.get(e,0,2)-K.get(e,2,0))*r,t.z=(K.get(e,1,0)-K.get(e,0,1))*r,t.w=.25/r}else if(K.get(e,0,0)>K.get(e,1,1)&&K.get(e,0,0)>K.get(e,2,2)){let n=2*Math.sqrt(1+K.get(e,0,0)-K.get(e,1,1)-K.get(e,2,2));t.x=.25*n,t.y=(K.get(e,0,1)+K.get(e,1,0))/n,t.z=(K.get(e,0,2)+K.get(e,2,0))/n,t.w=(K.get(e,2,1)-K.get(e,1,2))/n}else if(K.get(e,1,1)>K.get(e,2,2)){let n=2*Math.sqrt(1+K.get(e,1,1)-K.get(e,0,0)-K.get(e,2,2));t.x=(K.get(e,0,1)+K.get(e,1,0))/n,t.y=.25*n,t.z=(K.get(e,1,2)+K.get(e,2,1))/n,t.w=(K.get(e,0,2)+K.get(e,2,0))/n}else{let n=2*Math.sqrt(1+K.get(e,2,2)-K.get(e,0,0)-K.get(e,1,1));t.x=(K.get(e,0,2)+K.get(e,2,0))/n,t.y=(K.get(e,1,2)+K.get(e,2,1))/n,t.z=.25*n,t.w=(K.get(e,1,0)+K.get(e,0,1))/n}return t}static inverse(e,t){t=t||new j;const n=j.lengthSqr(e);return t.x=-e.x/n,t.y=-e.y/n,t.z=-e.z/n,t.w=e.w/n,t}}const H=new Float32Array(16),W=new j,q=new Float32Array(16);function Y(e,t,n,r,i,o,a,s,l,c,u,h,f,d,m,v,p){return e[0]=t,e[1]=n,e[2]=r,e[3]=i,e[4]=o,e[5]=a,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=h,e[11]=f,e[12]=d,e[13]=m,e[14]=v,e[15]=p,e}class K{constructor(e=0,t=0,n=0,r=0,i=0,o=0,a=0,s=0,l=0,c=0,u=0,h=0,f=0,d=0,m=0,v=0){var p=new Float32Array(16);return Y(p,e,t,n,r,i,o,a,s,l,c,u,h,f,d,m,v),p}static identity(e){return Y(e=e||new Float32Array(16),1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),e}static set(e,t,n,r,i,o,a,s,l,c,u,h,f,d,m,v,p){return Y(e,t,n,r,i,o,a,s,l,c,u,h,f,d,m,v,p)}static copy(e,t){return(t=t||new Float32Array(16)).set(e),t}static isNaN(e){return isNaN(e[0])||isNaN(e[1])||isNaN(e[2])||isNaN(e[3])||isNaN(e[4])||isNaN(e[5])||isNaN(e[6])||isNaN(e[7])||isNaN(e[8])||isNaN(e[9])||isNaN(e[10])||isNaN(e[11])||isNaN(e[12])||isNaN(e[13])||isNaN(e[14])||isNaN(e[15])}static equal(e,t,n=1e-6){return Math.abs(e[0]-t[0])<n&&Math.abs(e[1]-t[1])<n&&Math.abs(e[2]-t[2])<n&&Math.abs(e[3]-t[3])<n&&Math.abs(e[4]-t[4])<n&&Math.abs(e[5]-t[5])<n&&Math.abs(e[6]-t[6])<n&&Math.abs(e[7]-t[7])<n&&Math.abs(e[8]-t[8])<n&&Math.abs(e[9]-t[9])<n&&Math.abs(e[10]-t[10])<n&&Math.abs(e[11]-t[11])<n&&Math.abs(e[12]-t[12])<n&&Math.abs(e[13]-t[13])<n&&Math.abs(e[14]-t[14])<n&&Math.abs(e[15]-t[15])<n}static add(e,t,n){return Y(n=n||new Float32Array(16),e[0]+t[0],e[1]+t[1],e[2]+t[2],e[3]+t[3],e[4]+t[4],e[5]+t[5],e[6]+t[6],e[7]+t[7],e[8]+t[8],e[9]+t[9],e[10]+t[10],e[11]+t[11],e[12]+t[12],e[13]+t[13],e[14]+t[14],e[15]+t[15]),n}static subtract(e,t,n){return Y(n=n||new Float32Array(16),e[0]-t[0],e[1]-t[1],e[2]-t[2],e[3]-t[3],e[4]-t[4],e[5]-t[5],e[6]-t[6],e[7]-t[7],e[8]-t[8],e[9]-t[9],e[10]-t[10],e[11]-t[11],e[12]-t[12],e[13]-t[13],e[14]-t[14],e[15]-t[15]),n}static lerp(e,t,n,r){return Y(r=r||new Float32Array(16),T(e[0],t[0],n),T(e[1],t[1],n),T(e[2],t[2],n),T(e[3],t[3],n),T(e[4],t[4],n),T(e[5],t[5],n),T(e[6],t[6],n),T(e[7],t[7],n),T(e[8],t[8],n),T(e[9],t[9],n),T(e[10],t[10],n),T(e[11],t[11],n),T(e[12],t[12],n),T(e[13],t[13],n),T(e[14],t[14],n),T(e[15],t[15],n)),r}static transpose(e,t){return Y(t=t||new Float32Array(16),e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],e[3],e[7],e[11],e[15]),t}static inverse(e,t){Y(H,e[5]*e[10]*e[15]-e[5]*e[11]*e[14]-e[9]*e[6]*e[15]+e[9]*e[7]*e[14]+e[13]*e[6]*e[11]-e[13]*e[7]*e[10],-e[1]*e[10]*e[15]+e[1]*e[11]*e[14]+e[9]*e[2]*e[15]-e[9]*e[3]*e[14]-e[13]*e[2]*e[11]+e[13]*e[3]*e[10],e[1]*e[6]*e[15]-e[1]*e[7]*e[14]-e[5]*e[2]*e[15]+e[5]*e[3]*e[14]+e[13]*e[2]*e[7]-e[13]*e[3]*e[6],-e[1]*e[6]*e[11]+e[1]*e[7]*e[10]+e[5]*e[2]*e[11]-e[5]*e[3]*e[10]-e[9]*e[2]*e[7]+e[9]*e[3]*e[6],-e[4]*e[10]*e[15]+e[4]*e[11]*e[14]+e[8]*e[6]*e[15]-e[8]*e[7]*e[14]-e[12]*e[6]*e[11]+e[12]*e[7]*e[10],e[0]*e[10]*e[15]-e[0]*e[11]*e[14]-e[8]*e[2]*e[15]+e[8]*e[3]*e[14]+e[12]*e[2]*e[11]-e[12]*e[3]*e[10],-e[0]*e[6]*e[15]+e[0]*e[7]*e[14]+e[4]*e[2]*e[15]-e[4]*e[3]*e[14]-e[12]*e[2]*e[7]+e[12]*e[3]*e[6],e[0]*e[6]*e[11]-e[0]*e[7]*e[10]-e[4]*e[2]*e[11]+e[4]*e[3]*e[10]+e[8]*e[2]*e[7]-e[8]*e[3]*e[6],e[4]*e[9]*e[15]-e[4]*e[11]*e[13]-e[8]*e[5]*e[15]+e[8]*e[7]*e[13]+e[12]*e[5]*e[11]-e[12]*e[7]*e[9],-e[0]*e[9]*e[15]+e[0]*e[11]*e[13]+e[8]*e[1]*e[15]-e[8]*e[3]*e[13]-e[12]*e[1]*e[11]+e[12]*e[3]*e[9],e[0]*e[5]*e[15]-e[0]*e[7]*e[13]-e[4]*e[1]*e[15]+e[4]*e[3]*e[13]+e[12]*e[1]*e[7]-e[12]*e[3]*e[5],-e[0]*e[5]*e[11]+e[0]*e[7]*e[9]+e[4]*e[1]*e[11]-e[4]*e[3]*e[9]-e[8]*e[1]*e[7]+e[8]*e[3]*e[5],-e[4]*e[9]*e[14]+e[4]*e[10]*e[13]+e[8]*e[5]*e[14]-e[8]*e[6]*e[13]-e[12]*e[5]*e[10]+e[12]*e[6]*e[9],e[0]*e[9]*e[14]-e[0]*e[10]*e[13]-e[8]*e[1]*e[14]+e[8]*e[2]*e[13]+e[12]*e[1]*e[10]-e[12]*e[2]*e[9],-e[0]*e[5]*e[14]+e[0]*e[6]*e[13]+e[4]*e[1]*e[14]-e[4]*e[2]*e[13]-e[12]*e[1]*e[6]+e[12]*e[2]*e[5],e[0]*e[5]*e[10]-e[0]*e[6]*e[9]-e[4]*e[1]*e[10]+e[4]*e[2]*e[9]+e[8]*e[1]*e[6]-e[8]*e[2]*e[5]);let n=e[0]*H[0]+e[1]*H[4]+e[2]*H[8]+e[3]*H[12];if(!n)return e;n=1/n;for(let e=0;e<16;e++)H[e]*=n;return t||(t=new Float32Array(16)),K.copy(H,t),t}static multiply(e,t,n){const r=e,i=t,o=n=n||new Float32Array(16),a=r[0],s=r[4],l=r[8],c=r[12],u=r[1],h=r[5],f=r[9],d=r[13],m=r[2],v=r[6],p=r[10],g=r[14],x=r[3],b=r[7],y=r[11],T=r[15],w=i[0],E=i[4],M=i[8],_=i[12],R=i[1],C=i[5],F=i[9],A=i[13],D=i[2],P=i[6],S=i[10],N=i[14],U=i[3],z=i[7],L=i[11],B=i[15];return o[0]=a*w+s*R+l*D+c*U,o[4]=a*E+s*C+l*P+c*z,o[8]=a*M+s*F+l*S+c*L,o[12]=a*_+s*A+l*N+c*B,o[1]=u*w+h*R+f*D+d*U,o[5]=u*E+h*C+f*P+d*z,o[9]=u*M+h*F+f*S+d*L,o[13]=u*_+h*A+f*N+d*B,o[2]=m*w+v*R+p*D+g*U,o[6]=m*E+v*C+p*P+g*z,o[10]=m*M+v*F+p*S+g*L,o[14]=m*_+v*A+p*N+g*B,o[3]=x*w+b*R+y*D+T*U,o[7]=x*E+b*C+y*P+T*z,o[11]=x*M+b*F+y*S+T*L,o[15]=x*_+b*A+y*N+T*B,n}static basis(e,t,n,r){return Y(r=r||new Float32Array(16),e.x,e.y,e.z,0,t.x,t.y,t.z,0,n.x,n.y,n.z,0,0,0,0,1),r}static getForward(e,t){return(t=t||new X).x=-e[8],t.y=-e[9],t.z=-e[10],X.normalizeTo(t),t}static getRight(e,t){return(t=t||new X).x=e[0],t.y=e[1],t.z=e[2],X.normalizeTo(t),t}static getUp(e,t){return(t=t||new X).x=e[4],t.y=e[5],t.z=e[6],X.normalizeTo(t),t}static forward(e,t){return K.getForward(e,t)}static right(e,t){return K.getRight(e,t)}static up(e,t){return K.getUp(e,t)}static translate(e={x:0,y:0,z:0},t){return Y(t=t||new Float32Array(16),1,0,0,0,0,1,0,0,0,0,1,0,e.x,e.y,e.z,1),t}static getTranslationMatrix(e,t){return Y(t=t||new Float32Array(16),1,0,0,0,0,1,0,0,0,0,1,0,e[12],e[13],e[14],1),t}static getPosition(e,t){return(t=t||X.zero()).x=e[12],t.y=e[13],t.z=e[14],t}static setPosition(e,t){e[12]=t.x,e[13]=t.y,e[14]=t.z}static removeTranslation(e){return e[12]=0,e[13]=0,e[14]=0,e}static setRotation(e,t){var n=X.length({x:e[4],y:e[5],z:e[6]}),r=X.length({x:e[0],y:e[1],z:e[2]}),i=X.length({x:e[8],y:e[9],z:e[10]});e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[8]=t[8]*i,e[9]=t[9]*i,e[10]=t[10]*i}static getRotationMatrix(e,t){t=t||new Float32Array(16);const n=X.lengthNonVector(e[0],e[1],e[2]),r=X.lengthNonVector(e[4],e[5],e[6]),i=X.lengthNonVector(e[8],e[9],e[10]);return Y(t,e[0]/n,e[1]/n,e[2]/n,0,e[4]/r,e[5]/r,e[6]/r,0,e[8]/i,e[9]/i,e[10]/i,0,0,0,0,1),t}static rotateX(e,t,n){var r=new Float32Array([1,0,0,0,0,Math.cos(t),Math.sin(t),0,0,-Math.sin(t),Math.cos(t),0,0,0,0,1]);return K.multiply(e,r,n)}static rotateY(e,t,n){var r=new Float32Array([Math.cos(t),0,-Math.sin(t),0,0,1,0,0,Math.sin(t),0,Math.cos(t),0,0,0,0,1]);return K.multiply(e,r,n)}static rotateZ(e,t,n){var r=new Float32Array([Math.cos(t),Math.sin(t),0,0,-Math.sin(t),Math.cos(t),0,0,0,0,1,0,0,0,0,1]);return K.multiply(e,r,n)}static scale(e={x:1,y:1,z:1},t){return Y(t=t||new Float32Array(16),e.x,0,0,0,0,e.y,0,0,0,0,e.z,0,0,0,0,1),t}static scaleWithScalar(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e[4]*=t,e[5]*=t,e[6]*=t,e[8]*=t,e[9]*=t,e[10]*=t,e}static scaleWithVector(e,t){return e[0]*=t.x,e[1]*=t.x,e[2]*=t.x,e[4]*=t.y,e[5]*=t.y,e[6]*=t.y,e[8]*=t.z,e[9]*=t.z,e[10]*=t.z,e}static setScale(e,t){var n=X.length({x:e[0],y:e[1],z:e[2]})/t.x,r=X.length({x:e[4],y:e[5],z:e[6]})/t.y,i=X.length({x:e[8],y:e[9],z:e[10]})/t.z;e[0]/=n,e[1]/=n,e[2]/=n,e[4]/=r,e[5]/=r,e[6]/=r,e[8]/=i,e[9]/=i,e[10]/=i}static getScale(e,t){return(t=t||new X).x=X.lengthNonVector(e[0],e[1],e[2]),t.y=X.lengthNonVector(e[4],e[5],e[6]),t.z=X.lengthNonVector(e[8],e[9],e[10]),t}static getScaleMatrix(e,t){return Y(t=t||new Float32Array(16),X.lengthNonVector(e[0],e[1],e[2]),0,0,0,0,X.lengthNonVector(e[4],e[5],e[6]),0,0,0,0,X.lengthNonVector(e[8],e[9],e[10]),0,0,0,0,1),t}static applyTranslation(e,t){t=t||K.identity();const n=e.x||0,r=e.y||0,i=e.z||0;return t[12]+=t[0]*n+t[4]*r+t[8]*i,t[13]+=t[1]*n+t[5]*r+t[9]*i,t[14]+=t[2]*n+t[6]*r+t[10]*i,t[15]+=t[3]*n+t[7]*r+t[11]*i,t}static applyRotationX(e=0,t){return t=t||K.identity(),K.set(q,1,0,0,0,0,Math.cos(e),Math.sin(e),0,0,-Math.sin(e),Math.cos(e),0,0,0,0,1),K.multiply(t,q,t),t}static applyRotationY(e=0,t){return t=t||K.identity(),K.set(q,Math.cos(e),0,-Math.sin(e),0,0,1,0,0,Math.sin(e),0,Math.cos(e),0,0,0,0,1),K.multiply(t,q,t),t}static applyRotationZ(e=0,t){return t=t||K.identity(),K.set(q,Math.cos(e),Math.sin(e),0,0,-Math.sin(e),Math.cos(e),0,0,0,0,1,0,0,0,0,1),K.multiply(t,q,t),t}static applyScaleX(e,t){t[0]*=e,t[1]*=e,t[2]*=e,t[3]*=e}static applyScaleY(e,t){t[4]*=e,t[5]*=e,t[6]*=e,t[7]*=e}static applyScaleZ(e,t){t[8]*=e,t[9]*=e,t[10]*=e,t[11]*=e}static applyScale(e,t){const n=e.x??1,r=e.y??1,i=e.z??1;t[0]*=n,t[1]*=n,t[2]*=n,t[3]*=n,t[4]*=r,t[5]*=r,t[6]*=r,t[7]*=r,t[8]*=i,t[9]*=i,t[10]*=i,t[11]*=i}static transform(e=[],t){t=t||K.identity();for(var n=0;n<e.length;n++){var r=e[n];switch(r[0]){case"translate":K.applyTranslation(r[1],t);break;case"rx":K.applyRotationX(r[1],t);break;case"ry":K.applyRotationY(r[1],t);break;case"rz":K.applyRotationZ(r[1],t);break;case"sx":K.applyScaleX(r[1],t);break;case"sy":K.applyScaleY(r[1],t);break;case"sz":K.applyScaleZ(r[1],t);break;case"scale":K.applyScale(r[1],t)}}return t}static lookAt(e,t,n=X.up(),r){r=r||new Float32Array(16);var i=X.normalize(X.subtract(e,t)),o=X.normalize(X.cross(n,i)),a=X.cross(i,o);return Y(r,o.x,o.y,o.z,0,a.x,a.y,a.z,0,i.x,i.y,i.z,0,e.x,e.y,e.z,1),r}static lookInDirection(e,t,n=X.up(),r){r=r||new Float32Array(16);var i=X.normalize(t),o=X.cross(n,i),a=X.normalizeTo(o),s=X.cross(i,a);return Y(r,a.x,a.y,a.z,0,s.x,s.y,s.z,0,i.x,i.y,i.z,0,e.x,e.y,e.z,1),r}static perspective(e={},t){t=t||new Float32Array(16);var n=e.fov||1.5,r=e.aspect||1,i=e.near||.1,o=e.far||100,a=Math.sin(n),s=1/(o-i),l=Math.cos(n)/a;return Y(t,l/r,0,0,0,0,l,0,0,0,0,-(o+i)*s,-1,0,0,-2*i*o*s,0),t}static setPerspectiveFov(e,t,n){var r=Math.cos(n)/Math.sin(n);e[0]=r/t,e[5]=r}static orthographic(e={},t){t=t||new Float32Array(16);var n=e.top||e.size||5,r=e.bottom||-e.size||-5,i=e.left||-e.size||5,o=e.right||e.size||-5,a=e.far||100,s=e.near||1;return Y(t,2/(o-i),0,0,0,0,2/(n-r),0,0,0,0,-2/(a-s),0,-(o+i)/(o-i),-(n+r)/(n-r),-(a+s)/(a-s),1),t}static transformVector(e,t,n){n=n||new X;const r=t.x,i=t.y,o=t.z;return n.x=e[0]*r+e[4]*i+e[8]*o+e[12],n.y=e[1]*r+e[5]*i+e[9]*o+e[13],n.z=e[2]*r+e[6]*i+e[10]*o+e[14],n}static transformDirection(e,t){for(var n=[],r=0;r<4;r++)n[r]=e[r]*t.x+e[r+4]*t.y+e[r+8]*t.z+0*e[r+12];return{x:n[0],y:n[1],z:n[2]}}static fromQuaternion(e,t){t=t||new Float32Array(16),j.normalize(e,W);const n=W;return Y(t,1-2*n.y*n.y-2*n.z*n.z,2*n.x*n.y-2*n.z*n.w,2*n.x*n.z+2*n.y*n.w,0,2*n.x*n.y+2*n.z*n.w,1-2*n.x*n.x-2*n.z*n.z,2*n.y*n.z-2*n.x*n.w,0,2*n.x*n.z-2*n.y*n.w,2*n.y*n.z+2*n.x*n.w,1-2*n.x*n.x-2*n.y*n.y,0,0,0,0,1),K.transpose(t,t),t}static get(e,t,n){return e[t+4*n]}static isMatrix(e){return e instanceof Float32Array&&16==e.length}static pprint(e){e=K.transpose(e),console.table([[...e.slice(0,4)],[...e.slice(4,8)],[...e.slice(8,12)],[...e.slice(12,16)]])}}function $(e,t,n){var r=Math.max(e,t,n);if(r<1e-32)return[0,0,0,0];var[i,o]=function(e){const t=[e=Number(e),0];if(0!==e&&Number.isFinite(e)){const n=Math.abs(e),r=Math.log2||function(e){return Math.log(e)*Math.LOG2E};let i=Math.max(-1023,Math.floor(r(n))+1),o=n*Math.pow(2,-i);for(;o<.5;)o*=2,i--;for(;o>=1;)o*=.5,i++;e<0&&(o=-o),t[0]=o,t[1]=i}return t}(r);return r=256*i/r,[parseInt(e*r),parseInt(t*r),parseInt(n*r),parseInt(o+128)]}async function Q(e){const t=await fetch(e),n=await t.arrayBuffer();console.time("Load hdr");for(var r=0,i=new Uint8Array(n),o="";!o.match(/\n\n[^\n]+\n/g);)o+=String.fromCharCode(i[r++]);var a=o.match(/FORMAT=(.*)$/m)[1];if("32-bit_rle_rgbe"!=a)return this.onerror(),console.warn("unknown format : "+a);var s=o.split(/\n/).reverse()[1].split(" "),l=parseInt(s[3]),c=parseInt(s[1]);const u=new Uint8Array(l*c*4);let h=0;const f=new Uint8Array(4*l);for(let e=0;e<c;e++){const e=i.subarray(r,r+=4);if(2!=e[0]||2!=e[1]||128&e[2]){let e=l,t=0;for(r-=4;e>0;)if(u.set(i.slice(r,r+=4),h),1==u[h]&&1==u[h+1]&&1==u[h+2]){for(u[h+3];d>0;d--)u.set(u.slice(h-4,h),h),h+=4,e--;t+=8}else e--,h+=4,t=0}else{if((e[2]<<8)+e[3]!=l)return void console.warn("HDR line mismatch ..");for(var d=0;d<4;d++){let e,t=d*l,n=(d+1)*l;for(;t<n;){let n=i[r],o=i[r+1];if(r+=2,n>128)e=n-128,f.fill(o,t,t+e),t+=e;else for(e=n-1,f[t++]=o;e-- >0;)f[t++]=i[r++]}}for(d=0;d<l;d++)u[h++]=f[d],u[h++]=f[d+l],u[h++]=f[d+2*l],u[h++]=f[d+3*l]}}return console.timeEnd("Load hdr"),{data:u,width:l,height:c}}function Z(e,t){let n=[];for(let r=0;r<3;r++){let i=e[r],o=X.subtract(e[(r+1)%3],e[r]),a=X.normalize(o),s=X.length(o),l=ee(i,a,t[0],t[1],t[2]);l&&l.distance>=0&&l.distance<=s&&(n.push({hit:l,from:e[r],to:e[(r+1)%3]}),window.gldebug&&window.gldebug.Point(l.point,.02))}if(2==n.length){let n,r,i=-1/0,o=-1/0;for(let n of e){let e=X.dot(X.subtract(n,t[0]),he(t));J(n,t[0],t[1],t[2])&&e<=0&&Math.abs(e)>o&&(o=Math.abs(e),r={point:n,normal:he(t),depth:-Math.abs(e)})}let a,s=1/0;if(console.log(n,r),n||r)return Math.min(i,o)<s?i<o&&n||!r?[n]:[r]:(console.log("test1",a),[a])}let r=[];for(let n=0;n<3;n++){let i=t[n],o=X.subtract(t[(n+1)%3],t[n]),a=X.normalize(o),s=X.length(o),l=ee(i,a,e[0],e[1],e[2]);l&&l.distance>=0&&l.distance<=s&&r.push({hit:l,from:t[n],to:t[(n+1)%3]})}if(1==n.length&&1==r.length){let i=null,o=1/0;for(let t=0;t<3;t++){let n=me(e[t],e[(t+1)%3],r[0].hit.point);if(n<o){o=n;let a=ve(e[t],e[(t+1)%3],r[0].hit.point);i={edge:[e[t],e[(t+1)%3]],normal:X.normalize(X.subtract(r[0].hit.point,a)),point:a,depth:-X.distance(a,r[0].hit.point)}}}for(let e=0;e<3;e++){let r=me(t[e],t[(e+1)%3],n[0].hit.point);if(r<o){o=r;let a=ve(t[e],t[(e+1)%3],n[0].hit.point);i={edge:[t[e],t[(e+1)%3]],normal:X.negate(X.normalize(X.subtract(n[0].hit.point,a))),point:n[0].hit.point,depth:-X.distance(a,n[0].hit.point)}}}return[{depth:i.depth,point:i.point,normal:i.normal}]}if(2==r.length){console.info("2 b inters",e,t);const n=Z(t,e);if(console.log(n),!n)return null;console.log("not null");const r=n[0],i=X.add(r.point,X.multiply(r.normal,r.depth)),o=X.negate(r.normal);return[{depth:r.depth,point:i,normal:o}]}return r.length>2&&console.error("hhhhm"),null}function J(e,t,n,r){var i=X.normalize(X.cross(X.subtract(n,t),X.subtract(r,t))),o=X.dot(e,i)-X.dot(t,i),a=X.add(e,X.multiply(i,-o)),s=r.x-t.x,l=r.y-t.y,c=r.z-t.z,u=n.x-t.x,h=n.y-t.y,f=n.z-t.z,d=a.x-t.x,m=a.y-t.y,v=a.z-t.z,p=s*s+l*l+c*c,g=s*u+l*h+c*f,x=s*d+l*m+c*v,b=u*u+h*h+f*f,y=u*d+h*m+f*v,T=p*b-g*g;if(Math.abs(T)<1e-30)return null;var w=1/T,E=(b*x-g*y)*w,M=(p*y-g*x)*w;return E>=0&&M>=0&&E+M<1?a:null}{let e=new X,t=new X,n=new X,r=new X,i=new X,o=new X;var ee=function(a,s,l,c,u){X.subtract(c,l,e),X.subtract(u,l,t),X.cross(s,t,n);var h=X.dot(e,n);if(h>-1e-7&&h<1e-7)return!1;var f=1/h;X.subtract(a,l,r);var d=X.dot(r,n)*f;if(d<0||d>1)return!1;X.cross(r,e,i);var m=f*X.dot(s,i);if(m<0||d+m>1)return!1;var v=f*X.dot(t,i);return v>1e-7&&(X.set(o,s),X.multiplyTo(o,v),X.addTo(o,a),{point:X.copy(o),distance:v})}}var te=[new X(1,0,0),new X(0,1,0),new X(0,0,1)],ne=["x","y","z"];function re(e,t){var n=1/0,r=-1/0;for(var i of e){var o=X.dot(t,i);o<n&&(n=o),o>r&&(r=o)}return[n,r]}function ie(e,t,n,r,i,o){return Math.max(e.x,t.x,n.x)>=Math.min(r.x,i.x,o.x)&&Math.min(e.x,t.x,n.x)<=Math.max(r.x,i.x,o.x)&&Math.max(e.y,t.y,n.y)>=Math.min(r.y,i.y,o.y)&&Math.min(e.y,t.y,n.y)<=Math.max(r.y,i.y,o.y)&&Math.max(e.z,t.z,n.z)>=Math.min(r.z,i.z,o.z)&&Math.min(e.z,t.z,n.z)<=Math.max(r.z,i.z,o.z)}const oe={bl:new X,tr:new X};function ae(e,t,n,r,i){return oe.bl.x=Math.min(n.x,r.x,i.x),oe.bl.y=Math.min(n.y,r.y,i.y),oe.bl.z=Math.min(n.z,r.z,i.z),oe.tr.x=Math.max(n.x,r.x,i.x),oe.tr.y=Math.max(n.y,r.y,i.y),oe.tr.z=Math.max(n.z,r.z,i.z),le(e,t,oe)}const se={min:0,max:0};function le(e,t,n){const r=(n.bl.x-e.x)/t.x,i=(n.tr.x-e.x)/t.x,o=(n.bl.y-e.y)/t.y,a=(n.tr.y-e.y)/t.y,s=(n.bl.z-e.z)/t.z,l=(n.tr.z-e.z)/t.z,c=Math.min(Math.min(Math.max(r,i),Math.max(o,a)),Math.max(s,l));if(c<0)return!1;const u=Math.max(Math.max(Math.min(r,i),Math.min(o,a)),Math.min(s,l));return!(u>c)&&(se.min=u,se.max=c,se)}const ce=new X,ue=new X;function he(e,t){return t=t||new X,X.subtract(e[1],e[0],ce),X.subtract(e[2],e[0],ue),X.cross(ce,ue,t),X.normalizeTo(t),t}function fe(e,t,n,r,i,o=!1){var a=he([n,r,i]),s=X.dot(X.subtract(e,n),a);if(!o&&s<0)return!1;if(s<-t||s>t)return!1;var l=X.subtract(e,X.multiply(a,s)),c=X.cross(X.subtract(l,n),X.subtract(r,n)),u=X.cross(X.subtract(l,r),X.subtract(i,r)),h=X.cross(X.subtract(l,i),X.subtract(n,i)),f=X.dot(c,a)<=0&&X.dot(u,a)<=0&&X.dot(h,a)<=0,d=t*t,m=ve(n,r,e),v=X.subtract(e,m),p=X.dot(v,v)<d,g=ve(r,i,e),x=X.subtract(e,g);p|=X.dot(x,x)<d;var b=ve(i,n,e),y=X.subtract(e,b);if(p|=X.dot(y,y)<d,f||p){var T,w=l;if(f)T=X.subtract(e,l);else{var E=X.subtract(e,m),M=X.dot(E,E);w=m,T=E,E=X.subtract(e,g);var _=X.dot(E,E);_<M&&(M=_,w=g,T=E),E=X.subtract(e,b),(_=X.dot(E,E))<M&&(M=_,w=b,T=E)}var R=X.length(T),C=X.normalize(T);return X.lengthSqr(C)<1e-4&&(C=a),{normal:C,depth:t-R,point:w}}return!1}function de(e,t,n,r,i,o,a=!1){var s,l=X.normalize(X.subtract(t,e)),c=X.multiply(l,n),u=X.subtract(e,c),h=(X.add(t,c),he([r,i,o])),f=X.dot(h,l);if(Math.abs(f)<1e-5)s=X.copy(e);else{var d=X.dot(h,X.divide(X.subtract(r,u),f));s=X.add(u,X.multiply(l,d))}var m,v=X.cross(X.subtract(s,r),X.subtract(i,r)),p=X.cross(X.subtract(s,i),X.subtract(o,i)),g=X.cross(X.subtract(s,o),X.subtract(r,o));if(X.dot(v,h)<=0&&X.dot(p,h)<=0&&X.dot(g,h)<=0)m=s;else{var x=ve(r,i,s),b=X.subtract(s,x),y=X.dot(b,b),T=y;m=x;var w=ve(i,o,s),E=X.subtract(s,w);(y=X.dot(E,E))<T&&(m=w,T=y);var M=ve(o,r,s),_=X.subtract(s,M);(y=X.dot(_,_))<T&&(m=M,T=y)}return fe(ve(e,t,m),n,r,i,o,a)}function me(e,t,n){return X.distance(ve(e,t,n),n)}function ve(e,t,n){var r=X.subtract(t,e),i=X.dot(X.subtract(n,e),r)/X.dot(r,r);return X.add(e,X.multiply(r,function(e){return y(e,0,1)}(i)))}function pe(){this.wrapMode=pe.WrapModes.Clamp;var e=[],t=1/0,n=-1/0;this.addStage=function(r,i){e.some((e=>e.t==r))?console.warn("Time "+r+" already has a value!"):(e.push({t:r,value:i}),e.sort(((e,t)=>e.t-t.t)),t=Math.min(t,e[0].t),n=Math.max(n,e[e.length-1].t))};var r=e=>{return this.wrapMode==pe.WrapModes.Clamp?y(e,t,n):this.wrapMode==pe.WrapModes.Repeat?((e-t)%(r=n-t)+r)%r+t:y(e,t,n);var r};this.getValue=function(t){if(0==e.length)return 0;t=r(t);for(var n=e[0],i=e[1],o=0;o<e.length;o++)t>=e[o].t&&(n=e[o],i=e[Math.min(e.length-1,o+1)]);var a=w(n.t,i.t,t);return T(n.value,i.value,a)}}function ge(e,t=.5,n=!1){this.alpha=t,this.points=e,this.loop=n;for(var r=[],i=0;i<e.length-(this.loop?0:3);i++)r.push(new xe(e[(i+0)%e.length],e[(i+1)%e.length],e[(i+2)%e.length],e[(i+3)%e.length],this.alpha));this.getTangent=function(e){const t=this.getPoint(e),n=this.getPoint(e+.01);return X.normalize(X.subtract(n,t))},this.distanceToPoint=function(e){var t=this.distanceSqrToPoint(e);return{distance:Math.sqrt(t.distance),point:t.point,t:t.t}},this.distanceSqrToPoint=function(e){let t,n,i=1/0;for(let o of r){let r=o.distanceSqrToPoint(e);r.distance<i&&(i=r.distance,t=r.point,n=this.localToGlobalT(o,r.t))}return{distance:i,point:t,t:n}},this.getPoint=function(e){if(this.loop)e=b(e,1);else{if(e<=0)return r[0].getPoint(e);if(e>=1)return r[r.length-1].getPoint(e)}var t=Math.floor(e*r.length);return r[t].getPoint(e*r.length%1)},this.localToGlobalT=function(e,t){const n=r.indexOf(e);return-1===n?null:(n+t)/r.length}}function xe(e,t,n,r,i=.5){this.p0=e,this.p1=t,this.p2=n,this.p3=r,this.alpha=i,this.startStepSize=.5,this.endStepSize=.03125,this.distanceToPoint=function(e){var t=this.distanceSqrToPoint(e);return{distance:Math.sqrt(t.distance),point:t.point,t:t.t}};const o=new X;this.distanceSqrToPoint=function(e){var t;X.copy(e,o);for(var n=this.startStepSize,r=0,i=1;n>=this.endStepSize;)r=(t=this._getClosestDistanceInRange(o,r,i,n)).newStart,i=t.newEnd,n/=2;return{distance:t.distance,point:t.point,t:t.newStart}},this._getClosestDistanceInRange=function(e,t,n,r){let i=1/0,o=null,a=null,s=null;for(let l=t;l<=n-r;l+=r){const t=l,n=l+r,c=s??this.getPoint(t),u=this.getPoint(n),h=ve(c,u,e),f=X.distanceSqr(e,h);f<i&&(i=f,o=h,a=t),s=u}return{distance:i,point:o,newStart:a,newEnd:a+r}};const a=new X,s=new X,l=new X,c=new X,u=new X;function h(e,t,n,r,i,o){return X.lerp(n,r,(i-e)/(t-e),o)}function f(e,t){return Math.pow(X.distanceSqr(e,t),i/2)}this.getPoint=function(e,t){t=t||new X;var n=f(this.p0,this.p1),r=f(this.p1,this.p2)+n,i=f(this.p2,this.p3)+r,o=T(n,r,e);return h(0,n,this.p0,this.p1,o,a),h(n,r,this.p1,this.p2,o,s),h(r,i,this.p2,this.p3,o,l),h(0,r,a,s,o,c),h(n,i,s,l,o,u),h(n,r,c,u,o,t),t}}function be(e,t=5){this.aabb=e,this.children=[],this.items=[],this.maxDepth=t,this.divided=!1,this.trianglesArray=null,this.gameObjectLookup=null,this.gameObjects=null,this.query=function(e,t){var n=this._query((n=>le(e,t,n)));if(!n)return!1;var r=new Array(n.length),i=new Array(n.length);for(let e=0;e<n.length;e++)r[e]=this.getTriangleFromIndex(this.trianglesArray,n[e]),this.gameObjectLookup&&(i[e]=this.gameObjectLookup[n[e]/9]);return{triangles:r,gameObjectIndices:i}},this.queryAABB=function(e){var t=this._query((t=>{return r=e,(n=t).tr.x>=r.bl.x&&n.bl.x<=r.tr.x&&n.tr.y>=r.bl.y&&n.bl.y<=r.tr.y&&n.tr.z>=r.bl.z&&n.bl.z<=r.tr.z;var n,r}));if(!t)return!1;var n=new Array(t.length),r=new Array(t.length);for(let e=0;e<t.length;e++)n[e]=this.getTriangleFromIndex(this.trianglesArray,t[e]);return{triangles:n,nameIndices:r}},this._query=function(e,t=[]){if(e(this.aabb)){for(let e=0;e<this.items.length;e++)t.push(this.items[e]);for(let n=0;n<this.children.length;n++)this.children[n]._query(e,t);return t}},this.addTriangles=function(e,t,n){"undefined"!=typeof window&&(window.aabbcalls=0),this.trianglesArray=e,this.gameObjectLookup=t,this.gameObjects=n;for(var r=0;r<this.trianglesArray.length;r+=9){var i={x:this.trianglesArray[r+0],y:this.trianglesArray[r+1],z:this.trianglesArray[r+2]},o={x:this.trianglesArray[r+3],y:this.trianglesArray[r+4],z:this.trianglesArray[r+5]},a={x:this.trianglesArray[r+6],y:this.trianglesArray[r+7],z:this.trianglesArray[r+8]};this.addTriangle(r,[i,o,a])}},this.addTriangle=function(e,t,n=0){if(n>this.maxDepth||!function(e,t,n,r){return Math.max(e.x,t.x,n.x)>=r.bl.x&&Math.min(e.x,t.x,n.x)<=r.tr.x&&Math.max(e.y,t.y,n.y)>=r.bl.y&&Math.min(e.y,t.y,n.y)<=r.tr.y&&Math.max(e.z,t.z,n.z)>=r.bl.z&&Math.min(e.z,t.z,n.z)<=r.tr.z}(t[0],t[1],t[2],this.aabb)||!function(e,t){for(let i=0;i<3;i++)if(n=e,(r=t[i]).x>=n.bl.x&&r.y>=n.bl.y&&r.z>=n.bl.z&&r.x<=n.tr.x&&r.y<=n.tr.y&&r.z<=n.tr.z)return!0;var n,r,i=function(e){return[{x:e.bl.x,y:e.bl.y,z:e.bl.z},{x:e.tr.x,y:e.bl.y,z:e.bl.z},{x:e.tr.x,y:e.bl.y,z:e.tr.z},{x:e.bl.x,y:e.bl.y,z:e.tr.z},{x:e.bl.x,y:e.tr.y,z:e.bl.z},{x:e.tr.x,y:e.tr.y,z:e.bl.z},{x:e.tr.x,y:e.tr.y,z:e.tr.z},{x:e.bl.x,y:e.tr.y,z:e.tr.z}]}(e);for(let n=0;n<3;n++){let[r,i]=re(t,te[n]);if(i<e.bl[ne[n]]||r>e.tr[ne[n]])return!1}var o=he(t),a=X.dot(o,t[0]),[s,l]=re(i,o);if(l<a||s>a)return!1;var c=[X.subtract(t[0],t[1]),X.subtract(t[1],t[2]),X.subtract(t[2],t[0])];for(let e=0;e<3;e++)for(let n=0;n<3;n++){let n=X.cross(c[e],te[e]),[r,o]=re(i,n),[a,s]=re(t,n);if(o<a||r>s)return!1}return!0}(this.aabb,t))return!1;!this.divided&&n<this.maxDepth&&(this.subdivide(),this.divided=!0);for(var r=!1,i=0;i<this.children.length;i++)this.children[i].addTriangle(e,t,n+1)&&(r=!0);return r||this.items.push(e),!0},this.getTriangleFromIndex=function(e,t){return[{x:e[t+0],y:e[t+1],z:e[t+2]},{x:e[t+3],y:e[t+4],z:e[t+5]},{x:e[t+6],y:e[t+7],z:e[t+8]}]},this.getGameObjectFromIndex=function(e){return Array.isArray(this.gameObjects)?this.gameObjects[e]:null},this.subdivide=function(){this.children.push(new be(new ye(this.aabb.bl,X.average(this.aabb.bl,this.aabb.tr)),this.maxDepth),new be(new ye({x:(this.aabb.bl.x+this.aabb.tr.x)/2,y:this.aabb.bl.y,z:this.aabb.bl.z},{x:this.aabb.tr.x,y:(this.aabb.bl.y+this.aabb.tr.y)/2,z:(this.aabb.bl.z+this.aabb.tr.z)/2}),this.maxDepth),new be(new ye({x:this.aabb.bl.x,y:this.aabb.bl.y,z:(this.aabb.bl.z+this.aabb.tr.z)/2},{x:(this.aabb.bl.x+this.aabb.tr.x)/2,y:(this.aabb.bl.y+this.aabb.tr.y)/2,z:this.aabb.tr.z}),this.maxDepth),new be(new ye({x:(this.aabb.bl.x+this.aabb.tr.x)/2,y:this.aabb.bl.y,z:(this.aabb.bl.z+this.aabb.tr.z)/2},{x:this.aabb.tr.x,y:(this.aabb.bl.y+this.aabb.tr.y)/2,z:this.aabb.tr.z}),this.maxDepth),new be(new ye({x:this.aabb.bl.x,y:(this.aabb.bl.y+this.aabb.tr.y)/2,z:this.aabb.bl.z},{x:(this.aabb.bl.x+this.aabb.tr.x)/2,y:this.aabb.tr.y,z:(this.aabb.bl.z+this.aabb.tr.z)/2}),this.maxDepth),new be(new ye({x:(this.aabb.bl.x+this.aabb.tr.x)/2,y:(this.aabb.bl.y+this.aabb.tr.y)/2,z:this.aabb.bl.z},{x:this.aabb.tr.x,y:this.aabb.tr.y,z:(this.aabb.bl.z+this.aabb.tr.z)/2}),this.maxDepth),new be(new ye({x:this.aabb.bl.x,y:(this.aabb.bl.y+this.aabb.tr.y)/2,z:(this.aabb.bl.z+this.aabb.tr.z)/2},{x:(this.aabb.bl.x+this.aabb.tr.x)/2,y:this.aabb.tr.y,z:this.aabb.tr.z}),this.maxDepth),new be(new ye(X.average(this.aabb.bl,this.aabb.tr),this.aabb.tr),this.maxDepth))},this.render=function(e,t=!0){if(this.items.length>0){var n=this.aabb;e.root.getChild("AABB").meshRenderer.addInstance(K.transform([["translate",X.divide(X.add(n.bl,n.tr),2)],["sx",(n.tr.x-n.bl.x)/2],["sy",(n.tr.y-n.bl.y)/2],["sz",(n.tr.z-n.bl.z)/2]]),!1)}if(0==this.children.length);else for(var r=0;r<this.children.length;r++)this.children[r].render(e,!1);t&&e.root.getChild("AABB").meshRenderer.updateMatrixData()}}function ye(e,t){"undefined"!=typeof window&&window.aabbcalls++,this.bl=e,this.tr=t}function Te(e,t){this.isEmpty=!e&&!t,this.bl=e??X.zero(),this.tr=t??X.zero();var n=X.fill(1/0),r=X.fill(-1/0);this.copy=function(e){let t=e||new Te;return t.bl=X.copy(this.bl),t.tr=X.copy(this.tr),t.isEmpty=this.isEmpty,t},this.addPadding=function(e=0){this.bl.x-=e,this.bl.y-=e,this.bl.z-=e,this.tr.x+=e,this.tr.y+=e,this.tr.z+=e},this.extend=function(e){if(e instanceof Te){var t=e;X.compFunc(this.isEmpty?n:this.bl,t.bl,Math.min,this.bl),X.compFunc(this.isEmpty?r:this.tr,t.tr,Math.max,this.tr)}else if(X.isVectorIsh(e)){var i=e;X.compFunc(this.isEmpty?n:this.bl,i,Math.min,this.bl),X.compFunc(this.isEmpty?r:this.tr,i,Math.max,this.tr)}else this.addPadding(e);this.isEmpty=!1},this.pointInside=function(e){return e.x>=this.bl.x&&e.y>=this.bl.y&&e.z>=this.bl.z&&e.x<=this.tr.x&&e.y<=this.tr.y&&e.z<=this.tr.z},this.getVertices=function(){return[{x:this.bl.x,y:this.bl.y,z:this.bl.z},{x:this.tr.x,y:this.bl.y,z:this.bl.z},{x:this.tr.x,y:this.bl.y,z:this.tr.z},{x:this.bl.x,y:this.bl.y,z:this.tr.z},{x:this.bl.x,y:this.tr.y,z:this.bl.z},{x:this.tr.x,y:this.tr.y,z:this.bl.z},{x:this.tr.x,y:this.tr.y,z:this.tr.z},{x:this.bl.x,y:this.tr.y,z:this.tr.z}]},this.getEdges=function(){return[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]]};const i=new X;this.getCenter=function(){return X.average(this.tr,this.bl,i),X.copy(i)};const o=new X;this.getSize=function(){return X.subtract(this.tr,this.bl,o),X.copy(o)},this.translate=function(e){X.addTo(this.bl,e),X.addTo(this.tr,e)};const a=new X;this.approxTransform=function(e){var t=this.getVertices();for(var n of(this.isEmpty=!0,X.zero(this.bl),X.zero(this.tr),t))K.transformVector(e,n,a),this.extend(a);return this},this.isInsideFrustum=function(e){return this.isAbovePlane(e.leftPlane)&&this.isAbovePlane(e.rightPlane)&&this.isAbovePlane(e.nearPlane)&&this.isAbovePlane(e.farPlane)&&this.isAbovePlane(e.topPlane)&&this.isAbovePlane(e.bottomPlane)};const s=new X;this.isAbovePlane=function(e){return X.subtract(this.tr,this.bl,s),X.divideTo(s,2),X.average(this.tr,this.bl,i),-(s.x*Math.abs(e.normal.x)+s.y*Math.abs(e.normal.y)+s.z*Math.abs(e.normal.z))<=e.getSignedDistanceToPlane(i)}}function we(e,t,n){var r=new Te;return e.traverse((e=>{if((!n||!n.includes(e))&&e.meshRenderer&&!e.meshRenderer.skin)for(var t=0;t<e.meshRenderer.meshData.length;t++){var i=e.meshRenderer.meshData[t];if(i.data.position&&i.data.indices)for(var o=0;o<i.data.position.bufferData.length;o+=3){var a={x:i.data.position.bufferData[o],y:i.data.position.bufferData[o+1],z:i.data.position.bufferData[o+2]};a=K.transformVector(e.transform.worldMatrix,a),r.extend(a)}}})),t&&r.addPadding(t),r}function Ee(e,t={}){if(void 0!==e&&!(e instanceof Ye))throw new Error("scene is not of class 'Scene'");var n=this;this.scene=e,this.gravity=new X(0,-9.82,0);var r=[];let i=[];this.constraintIterations=20,this.constraintBias=.4,this.dt=1/60;var o=performance.now(),a=0;this.time=0,this.multipleTimestepsPerFrame=t.multipleTimestepsPerFrame??!0,this.fixedUpdate=()=>{};var s=[];this.octree=new be(new Te(X.fill(-1),X.fill(1)),t.octreeLevels??4),this.eventHandler=new Ue,this.on=this.eventHandler.on.bind(this.eventHandler),this.add=function(e){return r.push(e),e};const l=new X,c=new X,u=new X,h=[new X,new X,new X],f=new X;function d(e=0,t=new X,n=new X,r=null){this.distance=e,this.normal=t,this.point=n,this.gameObject=r}this.Raycast=function(e,t,n=new d){let r,i,o=1/0,a=!1;var s=this.octree.query(e,t);if(s){let n=s.triangles;for(let l=0;l<n.length;l++){let c=ee(e,t,n[l][0],n[l][1],n[l][2]);c&&c.distance<o&&(a=!0,o=c.distance,X.set(h[0],n[l][0]),X.set(h[1],n[l][1]),X.set(h[2],n[l][2]),X.set(f,c.point),r=s.gameObjectIndices[l],i=this.octree)}}if(this.scene&&this.scene.root.traverseCondition((function(n){const s=n.getComponents();for(const n of s)if("MeshCollider"==n.type){const s=n.octree;if(s){const n=s.trianglesArray,d=[];s._query((n=>le(e,t,n)),d);for(let m=0;m<d.length;m++){const v=d[m];if(l.x=n[v+0],l.y=n[v+1],l.z=n[v+2],c.x=n[v+3],c.y=n[v+4],c.z=n[v+5],u.x=n[v+6],u.y=n[v+7],u.z=n[v+8],!ae(e,t,l,c,u))continue;const p=ee(e,t,l,c,u);p&&p.distance<o&&(a=!0,o=p.distance,X.set(h[0],l),X.set(h[1],c),X.set(h[2],u),X.set(f,p.point),r=s.gameObjectLookup[v/9],i=s)}}}}),(e=>e.active&&e.visible)),a){n=n||new d;const e=i.getGameObjectFromIndex(r);return n.distance=o,he(h,n.normal),X.set(n.point,f),n.gameObject=e,n}return null},this.RaycastAll=function(e,t,n){n=n||[];var r=this.octree.query(e,t);if(r){let i,o,a,s=1/0,l=r.triangles;for(let n=0;n<l.length;n++){let c=ee(e,t,l[n][0],l[n][1],l[n][2]);c&&c.distance<s&&(s=c.distance,i=he(l[n]),o=c.point,a=r.gameObjectIndices[n])}if(o){let e={distance:s,normal:i,point:o,gameObject:this.octree.getGameObjectFromIndex(a)};n.push(e)}}this.scene&&this.scene.root.traverseCondition((function(r){var i=r.getComponents();for(var o of i)if("MeshCollider"==o.type){var a=o;if(a.octree){var s=a.octree.query(e,t);if(s){let r=s.triangles;for(var l=0;l<r.length;l++)if(ae(e,t,r[l][0],r[l][1],r[l][2])){var c=ee(e,t,r[l][0],r[l][1],r[l][2]);c&&n.push({distance:c.distance,normal:he(r[l]),point:c.point,gameObject:a.octree.getGameObjectFromIndex(s.gameObjectIndices[l])})}}}}}),(e=>e.active&&e.visible));for(var i,o=1/0,a=0;a<n.length;a++){var s=n[a].distance;s<o&&(o=s,i=n[a])}return{firstHit:i,allHits:n}},this.addMeshCollider=function(e){s.push(e)},this.setupMeshCollider=function(){var e;if(t.bounds)e=t.bounds;else{e=new Te(X.zero(),X.zero());for(let t of s)e.extend(we(t,.1))}this.octree=new be(e,t.octreeLevels??4);for(let e of s)this._addMeshToOctree(e);s=[]},this._addMeshToOctree=function(e){var t=0;e.traverse((e=>{if(e.meshRenderer)for(var n=0;n<e.meshRenderer.meshData.length;n++){var r=e.meshRenderer.meshData[n].data;t+=r.indices.bufferData.length/3}}));var n=[],r=0,i=new Uint16Array(t),o=new Float32Array(3*t*3);e.traverse((e=>{if(e.meshRenderer){n.push(e);let d=n.length-1;for(var t=e.transform.worldMatrix,a=0;a<e.meshRenderer.meshData.length;a++)for(var s=e.meshRenderer.meshData[a].data,l=0;l<s.indices.bufferData.length;l+=3){for(var c=0;c<3;c++){var u=3*s.indices.bufferData[l+c],h=X.fromArray(s.position.bufferData,u);h={x:h.x,y:h.y,z:h.z};var f=K.transformVector(t,h);o[9*r+3*c+0]=f.x,o[9*r+3*c+1]=f.y,o[9*r+3*c+2]=f.z}i[r]=d,r++}}})),this.octree.addTriangles(o,i,n)};var m=()=>{i=[];var e=[],t=[];for(var o of(this.scene&&this.scene.root.traverseCondition((r=>{var o=r.findComponents("Rigidbody")[0];if(o){e.push(o),o.grounded=!1;let R=!1;var a=o.gameObject.findComponents("SphereCollider");for(let e of a){R=!0;var s=K.removeTranslation(K.copy(o.gameObject.transform.worldMatrix)),l=X.add(o.position,K.transformVector(s,e.offset)),c=X.fill(1.1*e.radius),u=n.octree.queryAABB(new Te(X.subtract(l,c),X.add(l,c)))?.triangles;if(u)for(var h=0;h<u.length;h++)if(x=fe(l,e.radius,u[h][0],u[h][1],u[h][2],!0)){var f=x.normal,d=X.add(l,X.multiply(f,-e.radius));i.push({C:-x.depth,bodies:[{collider:e,body:o,normal:f,p:d}]})}}var m=o.gameObject.findComponents("CapsuleCollider");for(let e of m){R=!0,s=K.removeTranslation(K.copy(o.gameObject.transform.worldMatrix));var v=X.add(o.position,K.transformVector(s,e.a)),p=X.add(o.position,K.transformVector(s,e.b)),g=(c=X.fill(10*e.radius),X.average(v,p));if(u=n.octree.queryAABB(new Te(X.subtract(g,c),X.add(g,c)))?.triangles,u)for(h=0;h<u.length;h++){var x;if(x=de(v,p,e.radius,u[h][0],u[h][1],u[h][2],!0)){var b=X.dot(X.up(),x.normal),y=(f=X.length(X.projectOnPlane(o.velocity,x.normal))<2&&b>.8?new X(0,1,0):x.normal,f=x.normal,x.depth/X.dot(f,x.normal));d=X.add(x.point,X.multiply(x.normal,-x.depth)),i.push({C:-y,bodies:[{collider:e,body:o,normal:f,p:d}]}),X.dot(X.up(),f)>.5&&(o.grounded=!0,o.groundNormal=f),Debug.Vector(d,f,y)}}}var T=o.gameObject.findComponents("BoxCollider");for(let e of T){R=!0;var w=e.planeY,E=e.gameObject.transform.worldMatrix;for(var M of e.aabb.getVertices()){var _=K.transformVector(E,M);_.y<w&&i.push({C:_.y-w,bodies:[{collider:e,body:o,normal:X.up(),p:_}]})}}let C=[],F=o.gameObject.findComponents("MeshCollider");for(let e of F){R=!0;let t=r.transform.worldMatrix,n=e.gameObject.meshRenderer.getAABB().approxTransform(t);this.scene.root.traverseCondition((i=>{if(i===r)return;i.transform.worldMatrix;let a=i.findComponents("MeshCollider");for(let r of a){var s=r.octree?.queryAABB(n)?.triangles;if(s){console.log(s.length);for(var l=0;l<s.length;l++){let n=s[l];if(e.gameObject&&e.gameObject.meshRenderer)for(let r=0;r<e.gameObject.meshRenderer.meshData.length;r++){let i=e.gameObject.meshRenderer.meshData[r].data;for(let r=0;r<i.indices.bufferData.length;r+=3){let a=[];for(let e=0;e<3;e++){let n=3*i.indices.bufferData[r+e],o=X.fromArray(i.position.bufferData,n);o={x:o.x,y:o.y,z:o.z};let s=K.transformVector(t,o);a.push(s)}if(ie(a[0],a[1],a[2],n[0],n[1],n[2])){let t=Z(a,n);if(t)for(let n of t)window.gldebug&&window.gldebug.Vector(n.point,n.normal,-1e3*n.depth),C.push({C:n.depth,bodies:[{collider:e,body:o,normal:n.normal,p:n.point}]})}}}}}}}))}i=i.concat(C),R&&t.push(o)}}),(e=>e.active&&e.visible)),t))for(var a of t)if(o!=a)for(var s of o.gameObject.findComponents("SphereCollider"))for(var l of a.gameObject.findComponents("SphereCollider"))if((g=X.distance(o.position,a.position)-(s.radius+l.radius))<0){var c=X.normalize(X.subtract(o.position,a.position)),u=X.add(o.position,X.multiply(c,s.radius)),h=X.add(a.position,X.multiply(c,-l.radius));i.push({C:g,bodies:[{collider:s,body:o,normal:c,p:u},{collider:l,body:a,normal:X.negate(c),p:h}]})}for(var f of e)f.applyForces(this.dt);this.fixedUpdate(this.dt),this.eventHandler.fireEvent("fixedUpdate",this.dt);for(let e of r)e.fixedUpdate?.(this.dt);var d=new Array(i.length).fill(0);let m=new Array(r.length).fill(0);for(var v=0;v<this.constraintIterations;v++){for(let e=0;e<r.length;e++){let t=r[e];t.solveConstraint?.(this.dt,m,e)}for(var p=0;p<i.length;p++){var g,x=i[p];if((g=x.C??0)<-0){var b=[],T=[],w=[],E=[],M=[];if(x.bodies.length>0){for(var _ of x.bodies){var R=_.collider.disableRotationImpulse?0:1,C=X.cross(X.subtract(_.p,_.body.position),_.normal);b.push(_.normal.x,_.normal.y,_.normal.z,C.x*R,C.y*R,C.z*R);var[F,A]=X.formOrthogonalBasis(_.normal);C=X.cross(X.subtract(_.p,_.body.position),F),T.push(F.x,F.y,F.z,C.x*R,C.y*R,C.z*R),C=X.cross(X.subtract(_.p,_.body.position),A),w.push(A.x,A.y,A.z,C.x*R,C.y*R,C.z*R),E.push(_.body.velocity.x,_.body.velocity.y,_.body.velocity.z,_.body.angularVelocity.x,_.body.angularVelocity.y,_.body.angularVelocity.z);var D=_.body.inverseWorldInertia;M.push(_.body.mass,_.body.mass,_.body.mass,1/D[0],1/D[5],1/D[10])}var{impulses:P,lambda:S}=De(b,E,M,g,this.dt,this.constraintBias,d,p);if(!P.some((e=>isNaN(e)))){var N=0;for(var _ of x.bodies)_.body.velocity.x+=P[N+0]/M[N+0],_.body.velocity.y+=P[N+1]/M[N+1],_.body.velocity.z+=P[N+2]/M[N+2],_.body.lockRotation||(_.body.angularVelocity.x+=P[N+3]/M[N+3],_.body.angularVelocity.y+=P[N+4]/M[N+4],_.body.angularVelocity.z+=P[N+5]/M[N+5]),N+=6}var U=Ne(x.bodies);if(U>1e-4){var z=[T,w];for(var b of z){var L=Pe(Se(b,M),b,E,0);L=y(L,-U*S,U*S);for(var P=[],B=0;B<b.length;B++)P[B]=b[B]*L;if(!P.some((e=>isNaN(e))))for(var _ of(N=0,x.bodies))_.body.velocity.x+=P[N+0]/M[N+0],_.body.velocity.y+=P[N+1]/M[N+1],_.body.velocity.z+=P[N+2]/M[N+2],_.body.lockRotation||(_.body.angularVelocity.x+=P[N+3]/M[N+3],_.body.angularVelocity.y+=P[N+4]/M[N+4],_.body.angularVelocity.z+=P[N+5]/M[N+5]),N+=6}}}}}}for(let t of e)t.integrate(this.dt)};this.update=function(){if(this.multipleTimestepsPerFrame){var e=performance.now(),t=(e-o)/1e3;for(t=Math.min(t,.4),o=e,a+=t;a>=this.dt;)m(),a-=this.dt,this.time+=this.dt}else m(),this.time+=this.dt},this.getConstraintImpulse=De,this.getLambda=Pe,this.getEffectiveMass=Se}pe.WrapModes={Clamp:0,Repeat:1},Te.bounds=function(e){for(var t=X.fill(1/0),n=X.fill(-1/0),r=0;r<e.length;r++){var i=e[r];t=X.compFunc(t,i,Math.min),n=X.compFunc(n,i,Math.max)}return new Te(t,n)};class Me{constructor(){this.componentType="Collider",this.gameObject=null,this.isStatic=!1,this.friction=.5,this.disableRotationImpulse=!1}}class _e extends Me{#e=null;constructor(){super(),this.componentType="MeshCollider",this.type="MeshCollider"}get octree(){return this.#e||this.#t(),this.#e}clear(){this.#e=null,this.aabb=null}#t(){if(this.gameObject&&this.gameObject.meshRenderer){var e=new Te(X.fill(1/0),X.fill(-1/0)),t=0;for(let e=0;e<this.gameObject.meshRenderer.meshData.length;e++)t+=this.gameObject.meshRenderer.meshData[e].data.indices.bufferData.length/3;var n=[this.gameObject],r=new Uint16Array(t),i=new Float32Array(3*t*3),o=0,a=this.gameObject.transform.worldMatrix;for(let t=0;t<this.gameObject.meshRenderer.meshData.length;t++){let n=this.gameObject.meshRenderer.meshData[t].data;for(var s=0;s<n.indices.bufferData.length;s+=3){for(var l=0;l<3;l++){var c=3*n.indices.bufferData[s+l],u=X.fromArray(n.position.bufferData,c);u={x:u.x,y:u.y,z:u.z};var h=K.transformVector(a,u);h.x<e.bl.x&&(e.bl.x=h.x),h.y<e.bl.y&&(e.bl.y=h.y),h.z<e.bl.z&&(e.bl.z=h.z),h.x>e.tr.x&&(e.tr.x=h.x),h.y>e.tr.y&&(e.tr.y=h.y),h.z>e.tr.z&&(e.tr.z=h.z),i[9*o+3*l+0]=h.x,i[9*o+3*l+1]=h.y,i[9*o+3*l+2]=h.z}r[o]=0,o++}}e.addPadding(.1);const f=1e3,d=t<=0?0:Math.floor(Math.log(t/f)/Math.log(8)+1);this.#e=new be(e,d),this.#e.addTriangles(i,r,n),this.aabb=e}else this.#e=null,this.aabb=null}}class Re extends Me{constructor(e=new Te(X.fill(-1),X.fill(1)),t=-5){super(),this.componentType="BoxCollider",this.aabb=e,this.planeY=t}}var Ce=new X,Fe=new X;class Ae{#n=new X;#r=new X;#i=new j;#o=new K;constructor(){this.componentType="Rigidbody",this.gameObject=null,this.COMOffset=X.zero(),this.mass=1,this.position=X.zero(),this.velocity=X.zero(),this.acceleration=X.zero(),this.force=X.zero(),this._inertia=X.one(),this._inverseLocalInertiaMatrix=K.identity(),this.inverseWorldInertia=K.identity(),this.rotation=j.identity(),this.angularVelocity=X.zero(),this.torque=X.zero(),this.frozen=!1,this.lockRotation=!1,this.gravity=new X(0,-9.82,0),this.gravityScale=1,this._worldCOMOffset=X.zero(),this.lastVelocity=new X}set inertia(e){X.set(this._inertia,e),K.set(this._inverseLocalInertiaMatrix,1/this.inertia.x,0,0,0,0,1/this.inertia.y,0,0,0,0,1/this.inertia.z,0,0,0,0,1)}get inertia(){return this._inertia}_updateInverseWorldInertiaMatrix(){this.gameObject&&(K.copy(this.gameObject.transform.worldMatrix,this.#o),K.removeTranslation(this.#o),K.identity(this.inverseWorldInertia),K.multiply(this.#o,this._inverseLocalInertiaMatrix,this.inverseWorldInertia),K.transpose(this.#o,this.#o),K.multiply(this.inverseWorldInertia,this.#o,this.inverseWorldInertia))}_updateWorldCOMOffset(){this.gameObject?(K.copy(this.gameObject.transform.worldMatrix,this.#o),K.removeTranslation(this.#o),K.transformVector(this.#o,this.COMOffset,this._worldCOMOffset)):X.set(this._worldCOMOffset,this.COMOffset)}getWorldCOMOffset(){return this._worldCOMOffset}GetPointVelocity(e,t){t=t||new X;let n=this.getWorldCOMOffset();return X.set(Ce,e),X.subtractTo(Ce,this.position),X.subtractTo(Ce,n),X.set(t,this.velocity),X.cross(this.angularVelocity,Ce,Fe),X.addTo(t,Fe),t}AddForceAtPosition(e,t){if(X.isNaN(e))console.error("Force is NaN: ",e);else if(X.isNaN(t))console.error("Position is NaN: ",t);else if(!this.frozen){this.AddForce(e);var n=this.getWorldCOMOffset();X.set(Ce,t),X.subtractTo(Ce,this.position),X.subtractTo(Ce,n),X.cross(Ce,e,Ce),this.AddTorque(Ce)}}AddImpulseAtPosition(e,t){if(X.isNaN(e))console.error("Impulse is NaN: ",e);else if(X.isNaN(t))console.error("Position is NaN: ",t);else if(!this.frozen){X.set(Ce,e),X.multiplyTo(Ce,1/this.mass),X.addTo(this.velocity,Ce);var n=this.getWorldCOMOffset();X.set(Ce,t),X.subtractTo(Ce,this.position),X.subtractTo(Ce,n),X.cross(Ce,e,Ce),K.transformVector(this.inverseWorldInertia,Ce,Ce),X.addTo(this.angularVelocity,Ce)}}AddForce(e){X.isNaN(e)?console.error("Force is NaN: ",e):this.frozen||X.addTo(this.force,e)}AddTorque(e){X.isNaN(e)?console.error("Torque is NaN: ",e):this.frozen||X.addTo(this.torque,e)}applyForces(e){this.frozen||(X.set(this.lastVelocity,this.velocity),X.set(this.#r,this.force),X.multiplyTo(this.#r,e/this.mass),X.addTo(this.velocity,this.#r),X.zero(this.force),X.set(this.#n,this.gravity),X.multiplyTo(this.#n,e*this.gravityScale),X.addTo(this.velocity,this.#n),this.lockRotation||(K.transformVector(this.inverseWorldInertia,this.torque,this.#r),X.addTo(this.angularVelocity,this.#r)),X.zero(this.torque))}integrate(e){this.frozen||(X.set(this.#r,this.velocity),X.multiplyTo(this.#r,e),X.addTo(this.position,this.#r),this.lockRotation?j.identity(this.rotation):(new j(this.angularVelocity.x,this.angularVelocity.y,this.angularVelocity.z,0,this.#i),this.rotation=j.add(this.rotation,j.multiply(j.QxQ(this.#i,this.rotation),e/2))),X.set(this.acceleration,this.velocity),X.subtractTo(this.acceleration,this.lastVelocity),X.multiplyTo(this.acceleration,e),this.updateGameObject())}updateGameObject(){null!=this.gameObject&&(this.gameObject.transform.worldPosition=this.position,this.gameObject.transform.worldRotation=this.rotation),this._updateInverseWorldInertiaMatrix(),this._updateWorldCOMOffset()}}function De(e,t,n,r,i,o=.5,a,s,l=-.01){var c;c=isNaN(parseFloat(l))?o/i*r:r<l?o/i*(r-l):0;var u=Pe(Se(e,n),e,t,c);Array.isArray(a)&&(a[s]+u<0&&(u=-a[s]),a[s]+=u);for(var h=[],f=0;f<e.length;f++)h[f]=e[f]*u;return{impulses:h,lambda:u}}function Pe(e,t,n,r){for(var i=0,o=0;o<t.length;o++)i+=t[o]*n[o];return-e*(i+r)}function Se(e,t){for(var n=0,r=0;r<e.length;r++)n+=e[r]/t[r]*e[r];return 1/n}function Ne(e){var t=1;for(var n of e)t*=n.collider.friction;return t}function Ue(){this.events={},this.addEvent=this.on=function(e,t){if("function"!=typeof t)throw new Error("[EventHandler]: Not a function");this.events[e]?this.events[e].functions.push(t):this.events[e]={functions:[t]}},this.removeEvent=this.off=function(e,t){var n=this.events[e];if(n){var r=n.functions.indexOf(t);-1!==r&&n.functions.splice(r,1)}},this.fireEvent=function(e,...t){if(this.events[e]){for(var n of this.events[e].functions)n(...t);return!0}return!1}}const ze=K.identity(),Le=new K,Be=new j;function Ie(e,t,n,r){var i=this;this.gameObject=null,this.eventHandler=new Ue,this.on=this.eventHandler.on.bind(this.eventHandler),this._hasChanged={matrix:!1,worldMatrix:!1};var o=K.identity(),a=K.identity(),s=K.identity(),l=K.identity(),c=K.identity(),u=t??X.zero(),h=n??j.identity(),f=r??X.one(),d=w(u,b),m=w(h,(()=>{b()})),v=w(f,b),p=X.copy(u),g=j.copy(h),x=X.copy(f);function b(){i.gameObject?(i.gameObject.traverse((e=>{e.transform._hasChanged.matrix=!0,e.transform._hasChanged.worldMatrix=!0})),i.gameObject.traverse((e=>{e.transform.eventHandler.fireEvent("transformChange")}))):(i._hasChanged.matrix=!0,i._hasChanged.worldMatrix=!0,i.eventHandler.fireEvent("transformChange"))}function y(){K.translate(u,ze),K.multiply(ze,l,ze),K.applyScale(f,ze),T(ze,!1)}function T(e,t=!0){K.isNaN(e)?console.error("Matrix is NaN: ",e):(K.copy(e,o),K.getTranslationMatrix(o,s),K.getRotationMatrix(o,l),K.getScaleMatrix(o,c),t&&(K.getPosition(o,d),j.fromMatrix(o,m),K.getScale(o,v),X.set(p,d),j.set(g,m),X.set(x,v)),i.onUpdateMatrix?.(o))}function w(e,t=(()=>{})){return new Proxy(e,{set:function(e,n,r){if("x"==n||"y"==n||"z"==n||"w"==n){if(isNaN(r))return console.error("Proxy property "+n+" is NaN",e,n,r),!0;e[n]=r,t?.()}else e[n]=r;return!0},get:function(){return Reflect.get(...arguments)}})}null!=e?T(e):y(),this.set=function(e){this.matrix=e.matrix},Object.defineProperty(this,"position",{get:function(){return d},set:function(e){if(X.isVectorIsh(e)){if(X.equal(e,p))return;if(X.isNaN(e))return void console.error("Position is NaN: ",e);d.x=e.x,d.y=e.y,d.z=e.z,X.set(p,e)}else console.warn("Position is not vector",e)}}),Object.defineProperty(this,"worldPosition",{get:function(){return K.getPosition(i.worldMatrix)},set:e=>{X.isVectorIsh(e)?X.isNaN(e)?console.error("Position is NaN: ",e):this.gameObject&&this.gameObject.parent?(K.inverse(this.gameObject.parent.transform.worldMatrix,Le),K.transformVector(Le,e,this.position)):this.position=e:console.warn("World position is not vector",e)}}),Object.defineProperty(this,"rotation",{get:function(){return m},set:function(e){if(j.isQuaternionIsh(e)){if(j.equal(e,g))return;if(j.isNaN(e))return void console.error("Rotation is NaN: ",e);m.x=e.x,m.y=e.y,m.z=e.z,m.w=e.w,K.fromQuaternion(h,l),j.set(g,e)}else console.warn("Rotation is not quaternion",e)}}),Object.defineProperty(this,"worldRotation",{get:function(){return j.fromMatrix(a)},set:e=>{j.isQuaternionIsh(e)?j.isNaN(e)?console.error("World rotation is NaN: ",e):this.gameObject&&this.gameObject.parent?(j.fromMatrix(this.gameObject.parent.transform.worldMatrix,Be),j.inverse(Be,Be),j.QxQ(Be,e,Be),this.rotation=Be):this.rotation=e:console.warn("World rotation is not quaternion",e)}}),Object.defineProperty(this,"scale",{get:function(){return v},set:function(e){if(X.isVectorIsh(e)){if(X.equal(e,x))return;if(X.isNaN(e))return void console.error("Scale is NaN: ",e);v.x=e.x,v.y=e.y,v.z=e.z,X.set(x,e)}else console.warn("Scale is not vector",e)}}),Object.defineProperty(this,"matrix",{get:function(){return i._hasChanged.matrix&&(i._hasChanged.matrix=!1,y()),o},set:function(e){b(),T(e)}}),Object.defineProperty(this,"worldMatrix",{get:function(){return i._hasChanged.worldMatrix&&(i._hasChanged.worldMatrix=!1,i.gameObject&&i.gameObject.parent?K.multiply(i.gameObject.parent.transform.worldMatrix,i.matrix,a):K.copy(i.matrix,a)),a},set:function(e){K.isNaN(e)?console.error("World matrix is NaN: ",e):(K.inverse(i.gameObject.parent.transform.worldMatrix,Le),K.multiply(Le,e,i.matrix))}}),Object.defineProperty(this,"translationMatrix",{get:function(){return s}}),Object.defineProperty(this,"rotationMatrix",{get:function(){return l},set:function(e){K.isNaN(e)?console.error("Rotation matrix is NaN: ",e):(b(),j.fromMatrix(e,h),K.copy(e,l))}}),Object.defineProperty(this,"scaleMatrix",{get:function(){return c}}),Object.defineProperty(this,"forward",{get:function(){return K.getForward(i.worldMatrix)}}),Object.defineProperty(this,"up",{get:function(){return K.getUp(i.worldMatrix)}}),this.getWorldMatrix=function(e){return this.gameObject&&this.gameObject.parent&&this.gameObject.parent!=e?K.multiply(this.gameObject.parent.transform.getWorldMatrix(e),this.matrix):this.matrix}}function Oe(e="Unnamed",t={}){var n=this;this.name=e,this.children=ke(t.children,[]),this.parent=null,this.transform=new Ie(t.matrix,t.position,t.rotation,t.scale),this.transform.gameObject=this,this.prevModelMatrix=K.copy(this.transform.worldMatrix),this.isCulled=!1;var r=null,i=!0;let o=()=>{i=!0};this.getAABB=function(){return r},this.transform.on("transformChange",o),this.customData={},this.layer=1,this.visible=ke(t.visible,!0),this.castShadows=ke(t.castShadows,!0),this.receiveShadows=ke(t.receiveShadows,!0),this.runUpdate=ke(t.runUpdate,!0),this.active=ke(t.active,!0),this.animationController=null;var a,s,l=[];function c(e,t,n){e.parent&&e!=t&&(n.push(e.parent.children.indexOf(e)),c(e.parent,t,n))}Object.defineProperty(this,"meshRenderer",{get:function(){return s},set:function(e){s&&s.off("updateAABB",o),(s=e)&&s.materials&&(a=new Array(s.materials.length)),s&&s.on("updateAABB",o)}}),this.meshRenderer=ke(t.meshRenderer,null),this.traverse=function(e){for(var t of(e(this),this.children))t.traverse(e)},this.traverseCondition=function(e,t=(()=>!0)){for(var n of(e(this),this.children))t(n)&&n.traverseCondition(e,t)},this.setReceiveShadows=function(e,t=!1){t?this.traverse((t=>{t.receiveShadows=e})):this.receiveShadows=e},this.setLayer=function(e,t=!1){t?this.traverse((t=>{t.layer=e})):this.layer=e},this.getComponents=function(){return l},this.addComponent=function(e){return e.gameObject=this,l.push(e),e.onAdd?.(),e},this.removeComponent=function(e){return l.splice(l.indexOf(e),1),delete e.gameObject,e},this.findComponents=function(e){return l.filter((t=>t.componentType===e))},this.getComponent=function(e){return l.find((t=>t.componentType===e))},this.copy=function(e=!0){var t=new Oe(this.name+(e?" (Copy)":""));for(var r of(t.layer=this.layer,t.visible=this.visible,t.castShadows=this.castShadows,t.transform.matrix=n.transform.matrix,this.meshRenderer&&(t.meshRenderer=this.meshRenderer.copy()),this.animationController&&(t.animationController=this.animationController.copy()),l))r.copy?t.addComponent(r.copy(t)):t.addComponent(r);for(var i of this.children)t.addChild(i.copy(!1));var o=this,a=t;if(a.traverse((e=>{if(e!=a&&e.meshRenderer&&e.meshRenderer.skin){var t=[];for(var n of e.meshRenderer.skin.joints){let e=n.getHierarchyPath(o);t.push(a.getChildFromHierarchyPath(e))}var r=e.meshRenderer.skin,i=new(0,r.constructor)(t,r.inverseBindMatrixData),s=r.parentNode.getHierarchyPath(o);i.parentNode=a.getChildFromHierarchyPath(s),e.meshRenderer.skin=i}})),o.animationController)for(var s=0;s<o.animationController.animations.length;s++)for(var c=o.animationController.animations[s],u=0;u<c.data.length;u++){var h=c.data[u].target.getHierarchyPath(o),f=a.getChildFromHierarchyPath(h);a.animationController.animations[s].data[u].target=f}return t},this.getChildrenWithCustomData=function(e){var t=[];return this.traverse((n=>{n.customData&&e in n.customData&&t.push(n)})),t},this.getChild=function(e,t=!1){var n;return t?(this.traverse((t=>{t.name.match(e)&&!n&&(n=t)})),n):this.children.find((t=>t.name.match(e)))},this.getChildren=function(e,t=!1,n=!0){if(t){var r=[];return this.traverse((t=>{(n&&t.name===e||!n&&-1!==t.name.indexOf(e))&&r.push(t)})),r}return this.children.every((t=>n&&t.name===e||!n&&-1!==t.name.indexOf(e)))},this.addChild=function(e){if(null==e.parent)return e.parent=this,this.children.push(e),e;throw new Error("Can't add child! Child already has parent")},this.add=this.addChild,this.addChildren=function(e){for(var t=0;t<e.length;t++)this.addChild(e[t]);return e},this.removeChild=function(e){var t=this.children.indexOf(e);-1!==t&&(e.parent=null,this.children.splice(t,1))},this.setParent=function(e){null!=this.parent&&this.parent.removeChild(this),this.parent=e,e.children.push(this)},this.delete=function(){this.parent.removeChild(this)},this.getChildFromHierarchyPath=function(e){var t=this;for(var n of e)t=t.children[n];return t},this.getHierarchyPath=function(e){var t=[];return c(this,e,t),t.reverse()},this.update=function(e){if(this.runUpdate&&this.active){for(var t of(i&&this.meshRenderer&&this.meshRenderer.getAABB&&(r||(r=new Te),this.meshRenderer.getAABB(r),this.meshRenderer instanceof Un.MeshInstanceRenderer||r.approxTransform(this.transform.worldMatrix),i=!1),this.animationController&&this.animationController.update(e),this.meshRenderer?.update?.(e),l))t.update?.(e);for(var n=0;n<this.children.length;n++)this.children[n].update(e)}},this.render=function(e,t={}){if(this.visible&&this.active){var n=!!t.renderPass&&!!(p.SHADOWS&t.renderPass),r=!(t.renderPass&&p.ALPHA&t.renderPass),i=!!t.renderPass&&!!(p.DOWNSCALED&t.renderPass);if(n&&!this.castShadows)return;if((e.layer??65535)&this.layer){if(this.meshRenderer&&(!n||this.castShadows)&&!this.isCulled)if(t.materialOverride){var o=t.materialOverride;this.meshRenderer instanceof Un.MeshInstanceRenderer?o=t.materialOverrideInstanced:this.meshRenderer instanceof Un.SkinnedMeshRenderer&&(o=t.materialOverrideSkinned);for(let e=0;e<this.meshRenderer.materials.length;e++)a[e]=this.meshRenderer.materials[e].programContainer,this.meshRenderer.materials[e].programContainer=o.programContainer;this.meshRenderer.render(e,this.transform.worldMatrix,n,r,this.prevModelMatrix);for(let e=0;e<this.meshRenderer.materials.length;e++)this.meshRenderer.materials[e].programContainer=a[e]}else this.meshRenderer.render(e,this.transform.worldMatrix,n,r,this.prevModelMatrix,{downscaledPass:i,shadowQuality:this.receiveShadows?2:0});for(var s of l)s.render?.(e,this.transform.worldMatrix,n,r,this.prevModelMatrix,{downscaledPass:i})}for(var c=0;c<this.children.length;c++)this.children[c].render(e,t);n||this.isCulled||this.updatePrevModelMatrix()}},this.updatePrevModelMatrix=function(){K.copy(this.transform.worldMatrix,this.prevModelMatrix)},this.getChildStructure=function(e=0,t=[]){var n=this.name;this.visible||(n+=" (Not visible)"),this.active||(n+=" (Not active)"),(this.children.length>0||this.getComponents().length>0)&&(n+="\n");var r=[];for(let e=0;e<this.getComponents().length;e++){var i=this.getComponents()[e],o=e==this.getComponents().length-1&&0==this.children.length;let n="";for(let e=0;e<t.length;e++)n+=t[e]?"   ":"|  ";n+=o?"":"";let a=n+"(COMPONENT) "+i.componentType??`No type: ${i.constructor.name}`;r.push(a)}for(let n=0;n<this.children.length;n++){var a=n==this.children.length-1,s="";for(let e=0;e<t.length;e++)s+=t[e]?"   ":"|  ";s+=a?"":"";var l=[...t];l.push(a),r.push(s+this.children[n].getChildStructure(e+1,l))}return n+=r.join("\n"),1!=e||t[t.length-1]||(n+="\n|"),n}}function ke(e,t){return void 0===e?t:e}function Ve(e={}){this.exposure=e.exposure??0,this.gamma=e.gamma??2.2,this.tonemapping=e.tonemapping??Ve.TONEMAPPING.ACES,this.motionBlurStrength=e.motionBlurStrength??.2,this.saturation=e.saturation??0,this.contrast=e.contrast??0,this.vignette=e.vignette??new Xe,this.whiteBalance=e.whiteBalance??new Ge}function Ge(e={}){this.temperature=e.temperature??0,this.tint=e.tint??0}function Xe(e={}){this.amount=e.amount??.2,this.falloff=e.falloff??.3}function je(e={}){this.enabled=e.enabled??!0,this.sampleScale=e.sampleScale??1,this.threshold=e.threshold??1,this.knee=e.knee??.5,this.clamp=e.clamp??100,this.intensity=e.intensity??.05}Ve.TONEMAPPING={NONE:0,ACES:1,REINHARD:2};class He{constructor(e,t={}){if("object"!=typeof t||null===t||Array.isArray(t))throw new Error("Uniforms is not a dictionary (object)");if(null!==e&&!(e instanceof Un.ProgramContainer))throw new Error("Could not create material. Not a program container: "+e);this.programContainer=e,null===e&&console.warn("Program container is null"),this.name="No name",this.doubleSided=!1,this.doubleSidedShadows=!0,this.uniforms=t,this.opaque=!0}setUniform(e,t){this.programContainer&&!this.programContainer.activeUniforms[e]&&console.warn("[setUniform] Uniform does not exist on current shader-program: "+e),this.uniforms[e]=t}getUniform(e){return this.uniforms[e]}isOpaque(){return this.opaque}getUniformLocation(e){if(!this.programContainer)throw new Error("Material does not have a program container associated with it");return this.programContainer.getUniformLocation(e)}copy(){return qe.call(this,He)}}class We extends He{constructor(e,t={}){super(e,t),this.isLit=!0,this.uniforms.albedo=this.uniforms.albedo??[1,1,1,1],this.uniforms.emissiveFactor=this.uniforms.emissiveFactor??[0,0,0],this.uniforms.metallic=this.uniforms.metallic??0,this.uniforms.roughness=this.uniforms.roughness??1,this.uniforms.alphaCutoff=this.uniforms.alphaCutoff??.5,this.uniforms.doNoTiling=this.uniforms.doNoTiling??!1,this.uniforms.normalStrength=this.uniforms.normalStrength??1,this.uniforms.useVertexColor=this.uniforms.useVertexColor??!0,this.uniforms.useTexture=!!this.uniforms.albedoTexture,this.uniforms.useNormalTexture=!!this.uniforms.normalTexture,this.uniforms.useMetallicRoughnessTexture=!!this.uniforms.metallicRoughnessTexture,this.uniforms.useEmissiveTexture=!!this.uniforms.emissiveTexture,this.uniforms.useOcclusionTexture=!!this.uniforms.occlusionTexture,"opaque"in this.uniforms&&(this.opaque=!!this.uniforms.opaque,delete this.uniforms.opaque)}setUniform(e,t){super.setUniform(e,t),"albedoTexture"==e?this.uniforms.useTexture=!!t:"normalTexture"==e?this.uniforms.useNormalTexture=!!t:"metallicRoughnessTexture"==e?this.uniforms.useMetallicRoughnessTexture=!!t:"emissiveTexture"==e?this.uniforms.useEmissiveTexture=!!t:"occlusionTexture"==e&&(this.uniforms.useOcclusionTexture=!!t)}copy(){return qe.call(this,We)}}function qe(e){var t={};for(var n in this.uniforms){let e=this.uniforms[n];e instanceof WebGLTexture?t[n]=e:t[n]=void 0===e?e:JSON.parse(JSON.stringify(e))}var r=new e(this.programContainer,t);return r.name=this.name,r.doubleSided=this.doubleSided,r.doubleSidedShadows=this.doubleSidedShadows,r.opaque=this.opaque,r}function Ye(e){this.renderer=null,this.name=e,this.root=new Oe("root"),this.sunDirection=X.normalize({x:-.8,y:1.3,z:-1.2}),this.sunIntensity=X.multiply(new X(1,.9,.85),10),this.skyboxVisible=!0,this.smoothSkybox=!1,this.environmentIntensity=1,this.environmentMinLight=.25,this.ambientColor=[0,0,0],this.skyboxFogIntensity=.8,this.fogDensity=.0035,this.fogColor=[.23,.24,.26,1],this.shadowQuality=2,this.postprocessing=new Ve,this.bloom=new je;var t=[];this.setupUBO=function(){var e=this.renderer.programContainers.lit.uniformBuffers.sharedPerScene;if(e){this.sharedUBO=new this.renderer.UniformBuffer(this.renderer.UBOLocationCounter++,e.blockSize);var t=this.renderer.gl;t.bindBuffer(t.UNIFORM_BUFFER,this.sharedUBO.buffer),t.bufferSubData(t.UNIFORM_BUFFER,e.offsets[3],new Float32Array([this.renderer.shadowCascades.shadowmaps[1].bias]),0),t.bufferSubData(t.UNIFORM_BUFFER,e.offsets[3]+16,new Float32Array([this.renderer.shadowCascades.shadowmaps[0].bias]),0)}},this.updateUniformBuffers=function(e,t,n){if(this.sharedUBO){var r=this.renderer.programContainers.lit.uniformBuffers.sharedPerScene,i=this.renderer.gl;i.bindBuffer(i.UNIFORM_BUFFER,this.sharedUBO.buffer),i.bufferSubData(i.UNIFORM_BUFFER,r.offsets[0],e,0),i.bufferSubData(i.UNIFORM_BUFFER,r.offsets[1],t,0),i.bufferSubData(i.UNIFORM_BUFFER,r.offsets[2],n,0)}},this.loadEnvironment=async function(e={}){if(this.renderer){this.specularCubemap=null;var t=e.res??1024;if(e.hdr)this.skyboxCubemap=await this.renderer.createCubemapFromHDR(e.hdr,t),console.warn("No prebaked diffuse map. Generating one..."),this.diffuseCubemap=await this.renderer.getDiffuseCubemap(this.skyboxCubemap);else if(e.hdrFolder){var n=e.hdrFolder;this.skyboxCubemap=await this.renderer.createCubemapFromHDR(n+"/skybox.hdr",t);try{this.diffuseCubemap=await this.renderer.createCubemapFromHDR(n+"/diffuse.hdr",32)}catch(e){console.warn("No prebaked diffuse map. Generating one..."),this.diffuseCubemap=await this.renderer.getDiffuseCubemap(this.skyboxCubemap)}try{this.renderer.version,this.specularCubemap=await this.renderer.createSpecularCubemapFromHDR(n,t)}catch(e){console.error(e),console.warn("No prebaked specular map. Generating one...")}}else if(e.cubemap)this.skyboxCubemap=e.cubemap,this.diffuseCubemap=await this.renderer.getDiffuseCubemap(this.skyboxCubemap);else{var r=new this.renderer.ProgramContainer(await this.renderer.createProgramFromFile(this.renderer.path+`assets/shaders/built-in/webgl${this.renderer.version}/procedualSkybox`)),i=new He(r);this.skyboxCubemap=await this.renderer.createCubemapFromCube(i,t),this.diffuseCubemap=await this.renderer.getDiffuseCubemap(this.skyboxCubemap)}return this.specularCubemap||(this.specularCubemap=await this.renderer.getSpecularCubemap(this.skyboxCubemap)),this.smoothSkybox&&(this.skyboxCubemap=this.diffuseCubemap),!0}return console.error("Add scene to renderer before loading environment"),!1},this.copyEnvironment=function(e){this.skyboxCubemap=e.skyboxCubemap,this.diffuseCubemap=e.diffuseCubemap,this.specularCubemap=e.specularCubemap},this.add=function(e){return Array.isArray(e)?this.root.addChildren(e):this.root.addChild(e)},this.remove=function(e){if(Array.isArray(e))for(var t of e)this.root.removeChild(t);else this.root.removeChild(e)},this.update=function(e){this.updateLights(),this.root.update(e)},this.render=function(){this.renderer.currentBoundLitPrograms=new WeakMap,this.root.render(...arguments)},this.getLights=function(){return t},this.updateLights=function(){return t=[],this.root.traverseCondition((e=>{let n=e.getComponents();for(var r of n)"Light"==r.componentType&&t.push({type:r.type,position:K.getPosition(e.transform.worldMatrix),direction:K.getForward(e.transform.worldMatrix),angle:r.angle,color:r.color})}),(e=>e.active&&e.visible)),!0}}function Ke(){this.componentType="Light",this.gameObject=null,this.angle=Math.PI/3,this.color=[1,.5,.1],this.type=0,this.kelvinToRgb=function(e,t=1){return Ke.kelvinToRgb(e,t)},this.copy=function(){var e=new Ke;return e.angle=this.angle,e.color=Array.from(this.color),e.type=this.type,e}}function $e(e={}){var t=this;this.frustum=new Qe,this.transform=new Ie(null,e.position,e.rotation),this.layer=e.layer??65535,this.renderTexture=e.renderTexture??null;var n=K.identity();this.prevViewMatrix=K.identity(),this.aspect=1;var r=e.fov??45,i=e.near??.3,o=e.far??100,a=e.size??20;function s(){K.inverse(t.transform.matrix,n),t.updateFrustum()}this.type=e.type??$e.Type.Perspective,this.type==$e.Type.Perspective?this.projectionMatrix=K.perspective({fov:r*Math.PI/180,aspect:this.aspect,near:i,far:o}):this.type==$e.Type.Orthographic&&(this.projectionMatrix=K.orthographic({size:a,near:i,far:o})),this.updateFrustum=function(){if(K.getPosition(this.transform.matrix,Je),K.getForward(this.transform.matrix,et),K.getUp(this.transform.matrix,tt),K.getRight(this.transform.matrix,nt),X.set(rt,et),X.multiplyTo(rt,o),this.type==$e.Type.Perspective){const e=o*Math.tan(r*Math.PI/180),t=e*this.aspect;X.set(this.frustum.nearPlane.position,et),X.multiplyTo(this.frustum.nearPlane.position,i),X.addTo(this.frustum.nearPlane.position,Je),X.set(this.frustum.nearPlane.normal,et),X.set(this.frustum.farPlane.position,rt),X.addTo(this.frustum.farPlane.position,Je),X.set(this.frustum.farPlane.normal,et),X.negateTo(this.frustum.farPlane.normal),X.set(this.frustum.rightPlane.position,Je),X.set(it,nt),X.multiplyTo(it,t),X.subtractTo(it,rt),X.cross(it,tt,this.frustum.rightPlane.normal),X.set(this.frustum.leftPlane.position,Je),X.set(it,nt),X.multiplyTo(it,t),X.addTo(it,rt),X.cross(it,tt,this.frustum.leftPlane.normal),X.set(this.frustum.topPlane.position,Je),X.set(it,tt),X.multiplyTo(it,e),X.subtractTo(it,rt),X.cross(nt,it,this.frustum.topPlane.normal),X.set(this.frustum.bottomPlane.position,Je),X.set(it,tt),X.multiplyTo(it,e),X.addTo(it,rt),X.cross(nt,it,this.frustum.bottomPlane.normal),X.normalizeTo(this.frustum.rightPlane.normal),X.normalizeTo(this.frustum.leftPlane.normal),X.normalizeTo(this.frustum.topPlane.normal),X.normalizeTo(this.frustum.bottomPlane.normal),X.negateTo(this.frustum.leftPlane.normal),X.negateTo(this.frustum.rightPlane.normal),X.negateTo(this.frustum.topPlane.normal),X.negateTo(this.frustum.bottomPlane.normal)}else this.type==$e.Type.Orthographic&&(X.set(this.frustum.nearPlane.position,et),X.multiplyTo(this.frustum.nearPlane.position,i),X.addTo(this.frustum.nearPlane.position,Je),X.set(this.frustum.nearPlane.normal,et),X.set(this.frustum.farPlane.position,rt),X.addTo(this.frustum.farPlane.position,Je),X.set(this.frustum.farPlane.normal,et),X.negateTo(this.frustum.farPlane.normal),X.set(it,nt),X.multiplyTo(it,a),X.addTo(it,Je),X.set(this.frustum.rightPlane.position,it),X.set(this.frustum.rightPlane.normal,nt),X.negateTo(this.frustum.rightPlane.normal),X.set(it,nt),X.multiplyTo(it,-a),X.addTo(it,Je),X.set(this.frustum.leftPlane.position,it),X.set(this.frustum.leftPlane.normal,nt),X.set(it,tt),X.multiplyTo(it,a),X.addTo(it,Je),X.set(this.frustum.topPlane.position,it),X.set(this.frustum.topPlane.normal,tt),X.negateTo(this.frustum.topPlane.normal),X.set(it,tt),X.multiplyTo(it,-a),X.addTo(it,Je),X.set(this.frustum.bottomPlane.position,it),X.set(this.frustum.bottomPlane.normal,tt))},Object.defineProperty(this,"cameraMatrix",{get:function(){return t.transform.matrix}}),Object.defineProperty(this,"inverseViewMatrix",{get:function(){return t.transform.matrix}}),Object.defineProperty(this,"viewMatrix",{get:function(){return(t.transform._hasChanged.matrix||t.transform._hasChanged.worldMatrix)&&K.inverse(t.transform.matrix,n),n}}),this.setAspect=function(e){this.type==$e.Type.Perspective?(this.aspect=e,K.perspective({fov:r*Math.PI/180,aspect:this.aspect,near:i,far:o},this.projectionMatrix),this.updateFrustum()):console.warn("Can't set aspect ratio of orthographic camera")},this.setFOV=function(e){this.type==$e.Type.Perspective?e!=r&&(r=e,K.setPerspectiveFov(this.projectionMatrix,this.aspect,r*Math.PI/180),this.updateFrustum()):console.warn("Can't set FOV of orthographic camera")},this.getFOV=function(){return this.type==$e.Type.Orthographic&&console.error("Orthographic camera does not use FOV"),r},this.transform.onUpdateMatrix=s,s()}function Qe(){this.topPlane=new Ze,this.bottomPlane=new Ze,this.rightPlane=new Ze,this.leftPlane=new Ze,this.farPlane=new Ze,this.nearPlane=new Ze}function Ze(){this.normal=new X,this.position=new X,this.getSignedDistanceToPlane=function(e){return X.dot(this.normal,X.subtract(e,this.position,it))}}Ke.kelvinToRgb=function(e,t=1){var n=[0,0,0];if((e=y(e,1e3,4e4)/100)<=66)n[0]=1,n[1]=y(.3900815787690196*Math.log(e)-.6318414437886274,0,1);else{var r=e-60;n[0]=y(1.292936186062745*Math.pow(r,-.1332047592),0,1),n[1]=y(1.129890860895294*Math.pow(r,-.0755148492),0,1)}return n[2]=e>66?1:e<=19?0:y(.543206789110196*Math.log(e-10)-1.19625408914,0,1),n[0]*=t,n[1]*=t,n[2]*=t,n},$e.Type={Perspective:0,Orthographic:1};const Je=new X,et=new X,tt=new X,nt=new X,rt=new X,it=new X;function ot(e=[]){this.x=0,this.y=0,this.z=0,this.blendCoords=e,this.getWeight=function(e){var t=this.blendCoords.find((t=>t.animation==e));return t?y(1-X.distance(new X(this.x,this.y,this.z),t.coords),0,1)/this.getWeightSum():0},this.getWeightSum=function(){var e=0;for(var t of this.blendCoords)e+=y(1-X.distance(new X(this.x,this.y,this.z),t.coords),0,1);return e}}function at(e="Unnamed animation",t=[],n){if(this.name=e,this.data=t,this.speed=1,null==n)if(this.data.length>0){var r=0;for(var i of this.data){var o=i.inputBuffer[i.inputBuffer.length-1];o>r&&(r=o)}this.length=r}else this.length=4;else this.length=n;this.copy=function(){var e=[];for(var t of this.data)e.push({...t});var n=new at(this.name+" (Copy)",e,this.length);return n.speed=this.speed,n},this.transfer=function(e,t){for(var n of this.data)n.target=t.getChild(n.target.name,!0)}}function st(e=[]){function t(e,t,n,r,i="LINEAR"){var o=e.outputBuffer[t],a=e.outputBuffer[n];if("LINEAR"==i)return X.lerp(o,a,r);if("STEP"==i)return X.copy(a);if("CUBICSPLINE"==i&&e.inputTangents&&e.outputTangents){var s=e.inputBuffer[t]-e.inputBuffer[n];return function(e,t,n,r,i){var o=i*i,a=o*i,s=X.multiply(e,2*a-3*o+1),l=X.multiply(t,a-2*o+i),c=X.multiply(n,-2*a+3*o),u=X.multiply(r,a-o);return X.add(X.add(s,l),X.add(c,u))}(a,X.multiply(e.inputTangents[t],s),o,X.multiply(e.outputTangents[t],s),r=1-r)}return X.zero()}function n(e,t,n,r,i="LINEAR"){var o=e.outputBuffer[t],a=e.outputBuffer[n];if("LINEAR"==i)return j.slerp(o,a,r);if("STEP"==i)return j.copy(a);if("CUBICSPLINE"==i&&e.inputTangents&&e.outputTangents){var s=e.inputBuffer[t]-e.inputBuffer[n];return function(e,t,n,r,i){var o=i*i,a=o*i,s=j.multiply(e,2*a-3*o+1),l=j.multiply(t,a-2*o+i),c=j.multiply(n,-2*a+3*o),u=j.multiply(r,a-o);return j.add(j.add(s,l),j.add(c,u))}(a,j.multiply(e.inputTangents[t],s),o,j.multiply(e.outputTangents[t],s),r=1-r)}return j.identity()}this.animations=e,this.speed=1,this.loop=!1,this.animationTimes=new WeakMap,this.weightsHandler=new function(){this.weights=new WeakMap,this.getWeight=function(e){var t=this.weights.get(e);return void 0!==t?t:0}},this.copy=function(){var e=new st;e.speed=this.speed,e.loop=this.loop,this.weightsHandler instanceof ot&&(e.weightsHandler=new ot);for(let t of this.animations){let n=t.copy();e.animationTimes.set(n,this.animationTimes.get(t)),e.animations.push(n),this.weightsHandler.weights&&e.weightsHandler.weights.set(n,this.weightsHandler.weights.get(t)??0),this.weightsHandler instanceof ot&&e.weightsHandler.blendCoords.push({animation:n,coords:this.weightsHandler.blendCoords.find((e=>e.animation==t)).coords})}return e},this.update=function(e){var t=new WeakMap,n=[];for(var r of this.animations){var i=(this.animationTimes.get(r)??0)+e*this.speed*r.speed;this.loop&&(i%=r.length)<0&&(i=r.length+i),this.animationTimes.set(r,i);var o=this.weightsHandler.getWeight(r);if(o>.001&&(i<1.2*r.length||this.loop)){var a=this.getCurrentMatrices(r);for(var s of a){t.get(s.target)||(t.set(s.target,{position:[],rotation:[],scale:[],totalWeight:0}),n.push(s.target));var l=t.get(s.target),c=o;c>.001&&(s.translation&&l.position.push(X.multiply(s.translation,c)),s.rotation&&l.rotation.push(j.multiply(s.rotation,c)),s.scale&&l.scale.push(X.multiply(s.scale,c)))}}}for(var u of n){var h=t.get(u);h.position.length>0&&(u.transform.position=h.position.reduce(((e,t)=>X.add(e,t)),X.zero())),h.rotation.length>0&&(u.transform.rotation=h.rotation.reduce(((e,t)=>j.add(e,t)),j.zero())),h.scale.length>0&&(u.transform.scale=h.scale.reduce(((e,t)=>X.add(e,t)),X.zero()))}},this.play=function(e){if(e instanceof at)return this.animationTimes.set(e,0),void this.weightsHandler.weights.set(e,1);var t=e?.toLowerCase();for(var n of this.animations)null!=e&&-1==n.name.toLowerCase().indexOf(t)||(this.animationTimes.set(n,0),this.weightsHandler.weights.set(n,1))},this.getCurrentMatrices=function(e){var t=this.animationTimes.get(e)??0;return this.getStates(e,t)},this.getStates=function(e,r){for(var i=e.data,o=[],a=0;a<i.length;a++){var s=i[a],l={target:s.target},c=this.getClosestIndex(s.inputBuffer,r);"translation"==s.path?l.translation=t(s,c.indices[0],c.indices[1],c.lerpTime,s.interpolation):"rotation"==s.path?l.rotation=n(s,c.indices[0],c.indices[1],c.lerpTime,s.interpolation):"scale"==s.path&&(l.scale=t(s,c.indices[0],c.indices[1],c.lerpTime,s.interpolation)),o.push(l)}return o},this.getClosestIndex=function(e,t){for(var n=0;n<e.length;n++)if(t<e[n])return{indices:[n,Math.max(0,n-1)],lerpTime:w(e[n],e[Math.max(0,n-1)],t)};return{indices:[e.length-1,e.length-1],lerpTime:0}}}var lt="\n#version 300 es\nprecision highp float;\nprecision mediump int;\n",ct="\n#version 300 es\n\nin vec2 position;\n\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n",ut="\nuniform float environmentMinLight;\n\n// const int levels = 2;\n\n// vec4 projectedTexcoords[levels];\n// uniform float biases[levels];\n// uniform sampler2D projectedTextures[levels];\n// uniform mat4 textureMatrices[levels];\n\nuniform int shadowQuality;\nconst bool blurShadows = true;\nconst int shadowSamples = 8 * 2;\nconst float shadowSampleRadius = 3.;\n\nfloat shadowDarkness = 0.;\nconst float shadowKernalSize = 2.;\n// mat3 shadowKernel = mat3(\n//   1, 2, 1,\n//   2, 4, 2,\n//   1, 2, 1\n// );\nvec2 poissonDisk[16] = vec2[]( \n  vec2( -0.94201624, -0.39906216 ), \n  vec2( 0.94558609, -0.76890725 ), \n  vec2( -0.094184101, -0.92938870 ), \n  vec2( 0.34495938, 0.29387760 ), \n  vec2( -0.91588581, 0.45771432 ), \n  vec2( -0.81544232, -0.87912464 ), \n  vec2( -0.38277543, 0.27676845 ), \n  vec2( 0.97484398, 0.75648379 ), \n  vec2( 0.44323325, -0.97511554 ), \n  vec2( 0.53742981, -0.47373420 ), \n  vec2( -0.26496911, -0.41893023 ), \n  vec2( 0.79197514, 0.19090188 ), \n  vec2( -0.24188840, 0.99706507 ), \n  vec2( -0.81409955, 0.91437590 ), \n  vec2( 0.19984126, 0.78641367 ), \n  vec2( 0.14383161, -0.14100790 ) \n);\n\nbool inRange(vec3 projCoord) {\n  return projCoord.x >= 0.0 &&\n         projCoord.x <= 1.0 &&\n         projCoord.y >= 0.0 &&\n         projCoord.y <= 1.0 &&\n         projCoord.z <  1.0;\n}\n\nfloat fadeOutShadow(float visibility, vec3 proj) {\n  return mix(visibility, 1., clamp(pow(length(proj.xy - vec2(0.5, 0.5)) * 2., 5.), 0., 1.));\n}\n\nfloat fadeToNextShadowMap(float v1, float v2, vec3 proj) {\n  return mix(v1, v2, clamp(pow(length(proj.xy - vec2(0.5, 0.5)) * 2., 30.), 0., 1.));\n}\n\n// float random(vec3 seed, int i){\n//   vec4 seed4 = vec4(seed,i);\n//   float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));\n//   return fract(sin(dot_product) * 43758.5453);\n// }\n\nvec2 hash( vec2 p ) { // replace this by something better\n  p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n  return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat getBias(float bias, float cosTheta) {\n  bias = -bias * (cosTheta > 0. ? 1. : 0.);\n  bias = bias * tan(acos(cosTheta));\n  bias = clamp(bias, 0.0, 0.1);\n\n  return bias;\n}\n\nfloat getShadowAmount(vec3 worldPosition, float cosTheta) {\n  // for (int i = 0; i < levels; i++) {\n  //   projectedTexcoords[i] = textureMatrices[i] * vec4(worldPosition, 1);\n  // }\n\n  if (shadowQuality == 0) {\n    return 1.;\n  }\n\n  if (shadowQuality == 1) {\n    vec3 proj = projectedTexcoords[0].xyz / projectedTexcoords[0].w;\n    bool inside = inRange(proj);\n    \n    if (inside) {\n      // float bias = 0.005*tan(acos(cosTheta)); // cosTheta is dot( n,l ), clamped between 0 and 1\n      // bias = clamp(bias, 0.0, 0.01);\n\n      float projectedDepth = texture(projectedTextures[0], proj.xy).r;\n      float currentDepth = proj.z + biases[0];\n      return (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n    }\n    \n    proj = projectedTexcoords[1].xyz / projectedTexcoords[1].w;\n    inside = inRange(proj);\n\n    if (inside) {\n      float currentDepth = proj.z + biases[1];\n      float projectedDepth = texture(projectedTextures[1], proj.xy).r;\n      return (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n    }\n\n    return 1.;\n  }\n\n  vec2 shadowStepSize = vec2(1) / vec2(textureSize(projectedTextures[0], 0));\n\n  if (shadowQuality >= 2) {\n    vec4 ShadowCoord = projectedTexcoords[0];\n    vec3 proj = ShadowCoord.xyz / ShadowCoord.w;\n\n    float bias = -biases[0];//getBias(biases[0], cosTheta);\n\n    float currentDepth = proj.z - bias;\n    bool inside = inRange(proj);\n\n    if (inside) {\n      float outShadow = 0.;\n\n      if (blurShadows) {\n        float visibility = 1.;\n        for (int i = 0; i < shadowSamples; i++) {\n          // int index = int(16.0*random(gl_FragCoord.xyy + float(i) * vec3(1, 0.4, -0.5), i))%16;\n          // int index = int(16.0*random(floor(worldPosition.xyz*500.0), i))%16;\n          \n          // if (texture(projectedTextures[0], proj.xy + poissonDisk[index] * shadowStepSize * 4.).r < currentDepth) {\n          //   visibility -= 1. / 64.;\n          // }\n\n          if (texture(projectedTextures[0], proj.xy + hash(worldPosition.xz + worldPosition.zy + float(i) * vec2(1, -.9)) * shadowStepSize * shadowSampleRadius).r < currentDepth) {\n            visibility -= 1. / float(shadowSamples);\n          }\n\n          // visibility -= 0.01*(1.0-textureProj(projectedTextures[0], vec3(ShadowCoord.xy + poissonDisk[index]/700.0, (ShadowCoord.z-bias * 3.) / ShadowCoord.w)).r);\n        }\n\n        outShadow =  visibility;\n      }\n      else {\n        float sum = 0.0;\n        for (float j = -shadowKernalSize / 2. + 0.5; j <= shadowKernalSize / 2. - 0.5; j++) {\n          for (float k = -shadowKernalSize / 2. + 0.5; k <= shadowKernalSize / 2. - 0.5; k++) {\n            // float projectedDepth = texture(projectedTextures[0], proj.xy + shadowStepSize * hash(vec2(j, k) / 1000.)).r;\n            float projectedDepth = texture(projectedTextures[0], proj.xy + shadowStepSize * vec2(j, k)).r;\n\n            sum += 1. - step(projectedDepth, currentDepth);//(projectedDepth <= currentDepth ? shadowDarkness : 1.);// * shadowKernel[j + 1][k + 1];\n          }\n        }\n\n        outShadow = sum / float(shadowKernalSize * shadowKernalSize);\n      }\n\n      // bruh double calc\n      vec3 projNext = projectedTexcoords[1].xyz / projectedTexcoords[1].w;\n\n      float bias = getBias(biases[1], cosTheta);\n\n      float depthNext = projNext.z - bias;\n      float projectedDepthNext = texture(projectedTextures[1], projNext.xy).r;\n      float nextVis = (projectedDepthNext <= depthNext ? shadowDarkness : 1.);\n      return fadeToNextShadowMap(outShadow, nextVis, proj);\n    }\n\n    proj = projectedTexcoords[1].xyz / projectedTexcoords[1].w;\n    inside = inRange(proj);\n\n    if (inside) {\n      float bias = getBias(biases[1], cosTheta);\n      currentDepth = proj.z - bias;\n      \n      if (shadowQuality == 2) {\n        float projectedDepth = texture(projectedTextures[1], proj.xy).r;\n        return fadeOutShadow((projectedDepth <= currentDepth ? shadowDarkness : 1.), proj);\n      }\n\n      if (shadowQuality == 3) {\n        float sum = 0.0;\n        for (float j = -shadowKernalSize / 2. + 0.5; j <= shadowKernalSize / 2. - 0.5; j++) {\n          for (float k = -shadowKernalSize / 2. + 0.5; k <= shadowKernalSize / 2. - 0.5; k++) {\n            float projectedDepth = texture(projectedTextures[1], proj.xy + shadowStepSize * vec2(j, k)).r;\n            sum += (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n          }\n        }\n\n        return fadeOutShadow(sum / 16., proj);\n      }\n    }\n\n    return 1.;\n  }\n\n  return 1.;\n}\n";function ht(e){for(var t in e){var n=e[t];"object"==typeof n?ht(n):"string"==typeof n&&(e[t]=e[t].trim())}}var ft="\n#version 300 es\nprecision highp float;\nprecision mediump int;\n",dt="\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\n// Attributes\nin vec3 vPosition;\nin vec3 vNormal;\nin vec4 vTangent; // in vec3 vTangent;\nin vec3 vColor;\nin vec2 vUV;\nin mat3 vTBN;\n\n// Motion blur\nin vec4 clipSpace;\nin vec4 prevClipSpace;\n//#in\n\n// Material properties\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform sampler2D normalTexture;\nuniform bool useNormalTexture;\nuniform sampler2D metallicRoughnessTexture;\nuniform bool useMetallicRoughnessTexture;\nuniform sampler2D emissiveTexture;\nuniform bool useEmissiveTexture;\nuniform sampler2D occlusionTexture;\nuniform bool useOcclusionTexture;\n\nuniform vec4 albedo;\nuniform bool useVertexColor;\nuniform float metallic;\nuniform float roughness;\nuniform vec3 emissiveFactor;\nfloat ao = 1.;\nuniform bool opaque;\nuniform float alphaCutoff;\nuniform float normalStrength;\nuniform bool doNoTiling;\n\n// bruh make shared uniform into uniform block\n// Light info\nstruct LightInfo {\n  int type;\n  vec3 position;\n  vec3 direction;\n  float angle;\n  vec3 color;\n};\nconst int maxLights = 16;\nuniform LightInfo lights[maxLights];\nuniform int nrLights;\nuniform vec3 sunDirection;\nuniform vec3 sunIntensity;\n\n// Environment\nuniform vec3 ambientColor;\nuniform float environmentIntensity;\nuniform samplerCube u_diffuseIBL;\nuniform samplerCube u_specularIBL;\nuniform sampler2D u_splitSum;\n\n// Shadows\nconst int levels = 2;\nin vec4 projectedTexcoords[levels];\n// uniform float biases[levels];\nuniform sampler2D projectedTextures[levels];\n\n// uniform mat4 inverseViewMatrix;\nuniform mat4 modelMatrix;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n",mt=`\nconst float PI = 3.141592;\n\n// No tiling\nvec4 hash4( vec2 p ) {\n  return fract(sin(vec4(1.0+dot(p,vec2(37.0,17.0)), \n                        2.0+dot(p,vec2(11.0,47.0)),\n                        3.0+dot(p,vec2(41.0,29.0)),\n                        4.0+dot(p,vec2(23.0,31.0))))*103.0);\n}\n\nvec3 textureNoTile( sampler2D samp, in vec2 uv, float v ) {\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n\t\n    // derivatives (for correct mipmapping)\n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n    \n\tvec3 va = vec3(0.0);\n\tfloat w1 = 0.0;\n    float w2 = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec4 o = hash4( p + g );\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n        float w = exp(-5.0*d );\n        vec3 c = textureGrad( samp, uv + v*o.zw, ddx, ddy ).xyz;\n\t\tva += w*c;\n\t\tw1 += w;\n        w2 += w*w;\n    }\n    \n    // normal averaging --\x3e lowers contrasts\n    return va/w1;\n\n    // contrast preserving average\n    float mean = 0.3;// textureGrad( samp, uv, ddx*16.0, ddy*16.0 ).x;\n    vec3 res = mean + (va-w1*mean)/sqrt(w2);\n    return mix( va/w1, res, v );\n}\n\nvec2 noiseHash( vec2 p ) { // replace this by something better\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n  const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n  const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n  vec2  a = p - i + (i.x+i.y)*K2;\n  float m = step(a.y,a.x); \n  vec2  o = vec2(m,1.0-m);\n  vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n  vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,noiseHash(i+0.0)), dot(b,noiseHash(i+o)), dot(c,noiseHash(i+1.0)));\n  return (dot( n, vec3(70.0) ) + 1.) / 2.;\n}\n\nconst int OCTAVES = 4;\nfloat LayeredNoise(vec2 p) {\n  float _noise = 0.;\n  float frequency = 1.;\n  float factor = 1.;\n\n  float persistance = 0.45;\n  float roughness = 3.;\n\n  for (int i = 0; i < OCTAVES; i++) {\n    _noise += noise(p * frequency + float(i) * 0.72354) * factor;\n    factor *= persistance;\n    frequency *= roughness;\n  }\n\n  return _noise;\n}\n\n// Texture sampling\nvec4 sampleTexture(sampler2D samp, vec2 uv) {\n  if (doNoTiling) {\n    return vec4(textureNoTile(samp, uv, 1.), 1);\n  }\n  else {\n    return texture(samp, uv);\n  }\n}\n\n//Normal map\nvec3 setNormalStrength(vec3 normal, float strength) {\n  return vec3(normal.xy * strength, mix(1., normal.z, clamp(strength, 0., 1.)));\n}\n\n// vec3 sampleNormalTexture(sampler2D texture, vec2 uv) {\n//   return sampleTexture(texture, uv).rgb * 2. - 1.\n// }\n\n${ut}\n\n// PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0); // trying this\n  // return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n} \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n  float a      = roughness*roughness;\n  float a2     = a*a;\n  float NdotH  = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH*NdotH;\n\n  float num   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n\n  return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r*r) / 8.0;\n\n  float num   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 F0 = vec3(scalarF0);\n  F0 = mix(F0, albedo, metallic);\n  vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.), F0, roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - metallic;\t  \n    \n  vec3 irradiance = texture(u_diffuseIBL, N).rgb;\n  vec3 diffuse  = irradiance * albedo;\n    \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureLod(u_specularIBL, R, roughness * MAX_REFLECTION_LOD).rgb;\n\n  vec2 uv = vec2(max(dot(N, V), 0.), roughness);\n  uv.y = 1. - uv.y;\n  vec2 envBRDF = texture(u_splitSum, uv).rg;\n\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n  vec3 ambient = (kD * diffuse + specular) * environmentIntensity;\n\n  return ambient;\n}\n\nvec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 L = normalize(lightDir);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;\n  vec3 specular     = nominator / denominator;\n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n\n  kD *= 1.0 - metallic;\n  float NdotL = max(dot(N, L), 0.0);\n\n  vec3 finalColor = (kD * albedo / PI + specular) * radiance * NdotL;\n  return finalColor;\n}\n\nvec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec3 Spotlight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 dir, float angle, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 currentDir = normalize(worldPos - lightPos);\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n\n  float sharpness = 5.;\n  attenuation *= clamp((dot(currentDir, dir) - cos(angle)) * sharpness, 0., 1.);\n\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);\n  \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec4 lit(vec4 _albedo, float _alphaCutoff, vec3 _emission, vec3 _tangentNormal, float _metallic, float _roughness, float _ao) {\n  _roughness = clamp(_roughness, 0.01, 0.99);\n  \n  if (_albedo.a <= _alphaCutoff) {\n    discard;\n  }\n\n  if (opaque) {\n    _albedo.a = 1.;\n  }\n\n  // vec3 N = normalize(mat3(modelMatrix) * vNormal);\n  vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n\n  vec3 N;\n  if (vTangent.xyz != vec3(0)) { //if (vTangent != vec3(0)) {\n    N = normalize(vTBN * _tangentNormal);\n  }\n  else {\n    N = normalize(mat3(modelMatrix) * vNormal);\n  }\n\n  if (!gl_FrontFacing) {\n    N *= -1.;\n  }\n\n  vec3 R = reflect(-V, N);\n\n  float f0 = 0.04;\n\n  float shadowAmount = getShadowAmount(vPosition, dot(sunDirection.xyz, N));\n  // float environmentMinLight = 0.25;\n\n  vec3 col = vec3(0);\n  col += ambientColor;\n  col += IBL(N, V, R, _albedo.rgb, _metallic, _roughness, f0) * _ao * (environmentMinLight + shadowAmount * (1. - environmentMinLight));\n  \n  if (sunIntensity.xyz != vec3(0)) {\n    col += DirectionalLight(vPosition, N, V, sunDirection.xyz, sunIntensity.xyz, _albedo.rgb, _metallic, _roughness, f0) * _ao * shadowAmount;\n  }\n\n  for (int i = 0; i < int(nrLights); i++) {\n    LightInfo light = lights[i];\n    if (light.type == 0) {\n      col += PositionalLight(vPosition, N, V, light.position, light.color, _albedo.rgb, _metallic, _roughness, f0);\n    }\n    else if (light.type == 1) {\n      col += Spotlight(vPosition, N, V, light.position, light.direction, light.angle, light.color, _albedo.rgb, _metallic, _roughness, f0);\n    }\n    else if (light.type == 2) {\n      col += DirectionalLight(vPosition, N, V, light.direction, light.color, _albedo.rgb, _metallic, _roughness, f0);\n    }\n  }\n\n  col += _emission;\n\n  return vec4(col, _albedo.a);\n}\n`,vt="\n#define USEFOG\n\nuniform vec4 fogColor;// = vec4(0.23, 0.24, 0.26, 1);\nuniform float fogDensity;// = 0.0035;\n\nvec4 applyFog(vec4 color) {\n  float distance = length(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n  float fogAmount = exp(-pow(distance * fogDensity, 2.));\n  \n  return mix(fogColor, color, fogAmount);\n}\n",pt="\nvec3 NDCPos = (clipSpace / clipSpace.w).xyz;\nvec3 PrevNDCPos = (prevClipSpace / prevClipSpace.w).xyz;\nmotionVector = (NDCPos - PrevNDCPos).xy * 0.5 + 0.5;\n",gt="\n// Motion blur\nout vec4 clipSpace;\nout vec4 prevClipSpace;\nuniform mat4 prevViewMatrix;\nuniform mat4 prevModelMatrix;\n",xt="\n// Motion blur\nvec4 prevCs = projectionMatrix * prevViewMatrix * prevModelMatrix * vec4(position, 1.0);\nprevClipSpace = prevCs;\nclipSpace = gl_Position;\n",bt=`\n${ft}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent; // in vec3 tangent;\nin vec3 color;\nin vec2 uv;\n//#in\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec4 vTangent; // out vec3 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\n//#out\n\nconst int levels = 2;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n// uniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n//Shadows\nuniform mat4 textureMatrices[levels];\nout vec4 projectedTexcoords[levels];\n\n${gt}\n\nvoid main() {\n  //#main\n\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(vNormal, vTangent.xyz) * vTangent.w, 0.0))); // bruh According to comment on stackoverflow (https://blender.stackexchange.com/questions/220756/why-does-blender-output-vec4-tangents-for-gltf), tangents are vec4 and .w is used for bitangent sign (who could have known... :(\n  vec3 _N = normalize(vec3(modelMatrix * vec4(vNormal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  for (int i = 0; i < levels; i++) {\n    projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  }\n\n  vPosition = vec3(worldPosition);\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n\n  ${xt}\n}\n`,yt=`\n${ft}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent; //in vec3 tangent;\nin vec3 color;\nin vec2 uv;\nin mat4 modelMatrix;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec4 vTangent; //out vec3 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat4 vModelMatrix;\nout mat3 vTBN;\n\nconst int levels = 2;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n//Shadows\nuniform mat4 textureMatrices[levels];\nout vec4 projectedTexcoords[levels];\n\n${gt}\n\nvoid main() {\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n  vModelMatrix = modelMatrix;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(vNormal, vTangent.xyz) * vTangent.w, 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * vec4(vNormal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  for (int i = 0; i < levels; i++) {\n    projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  }\n\n  vPosition = vec3(worldPosition);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n\n  ${xt}\n}\n`,Tt=`\n${ft}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent;\nin vec3 color;\nin vec2 uv;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec4 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\nout mat4 vSkin;\n\nconst int levels = 2;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n// uniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n//Skinning\nin vec4 weights;\nin vec4 joints;\n\nuniform sampler2D u_jointTexture;\nuniform float u_numJoints;\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.)\n#define ROW1_U ((0.5 + 1.0) / 4.)\n#define ROW2_U ((0.5 + 2.0) / 4.)\n#define ROW3_U ((0.5 + 3.0) / 4.)\n \nmat4 getBoneMatrix(float jointNdx) {\n  float v = (jointNdx + 0.5) / u_numJoints;\n  return mat4(\n    texture(u_jointTexture, vec2(ROW0_U, v)),\n    texture(u_jointTexture, vec2(ROW1_U, v)),\n    texture(u_jointTexture, vec2(ROW2_U, v)),\n    texture(u_jointTexture, vec2(ROW3_U, v))\n  );\n}\n\n//Shadows\nuniform mat4 textureMatrices[levels];\nout vec4 projectedTexcoords[levels];\n\n${gt}\n\nvoid main() {\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vNormal = normal;\n  // vNormal = mat3(inverse(modelMatrix * skinMatrix)) * normal;\n  // vNormal = mat3(world * inverse(modelMatrix)) * normal;\n\n  mat4 skinMatrix = getBoneMatrix(joints[0]) * weights[0] +\n                    getBoneMatrix(joints[1]) * weights[1] +\n                    getBoneMatrix(joints[2]) * weights[2] +\n                    getBoneMatrix(joints[3]) * weights[3];\n  \n  mat4 world = modelMatrix * skinMatrix;\n  // mat4 world = skinMatrix * modelMatrix;\n  // mat4 world = modelMatrix;\n\n  mat4 TBNWorld = modelMatrix * skinMatrix * modelMatrix;\n  // vec3 _T = normalize(vec3(TBNWorld * vec4(tangent, 0.0)));\n  // vec3 _B = normalize(vec3(TBNWorld * vec4(cross(normal, tangent), 0.0)));\n  // vec3 _N = normalize(vec3(TBNWorld * vec4(normal, 0.0)));\n  vec3 _T = normalize(vec3(TBNWorld * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(TBNWorld * vec4(cross(normal, vTangent.xyz) * vTangent.w, 0.0))); // bruh According to comment on stackoverflow (https://blender.stackexchange.com/questions/220756/why-does-blender-output-vec4-tangents-for-gltf), tangents are vec4 and .w is used for bitangent sign (who could have known... :(\n  vec3 _N = normalize(vec3(TBNWorld * vec4(normal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = world * vec4(position, 1.0);\n  for (int i = 0; i < levels; i++) {\n    projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  }\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n  vPosition = worldPosition.xyz;\n\n  vSkin = skinMatrix;\n\n  // Motion blur\n  vec4 prevCs = projectionMatrix * prevViewMatrix * prevModelMatrix * skinMatrix * vec4(position, 1.0);\n  prevClipSpace = prevCs;\n  clipSpace = gl_Position;\n}\n`,wt=bt;wt=(wt=(wt=wt.replace("//#in","in float alpha;")).replace("//#out","out float vAlpha;")).replace("//#main","vAlpha = alpha;");var Et=`\n${ft}\n\n${dt}\n\n${mt}\n\n${vt}\n\nvoid main() {\n  ${pt}\n  \n  // fragColor = vec4(1, 0, 0, 1);\n  // return;\n\n  // fragColor = vec4(vNormal, 1);\n  // return;\n\n  vec4 currentAlbedo = useTexture ? sampleTexture(albedoTexture, vUV) : vec4(1);\n  currentAlbedo *= albedo;\n  if (useVertexColor) {\n    currentAlbedo.xyz *= vec3(1) - vColor;\n  }\n  //#currentAlbedo\n\n  // if (doNoTiling) {\n  //   currentAlbedo.rgb *= mix(vec3(1.0), vec3(0.4, 0.7, 0.4), clamp(LayeredNoise(vUV / 40.), 0., 1.));\n  // }\n\n  // fragColor = currentAlbedo + vec4(emissiveFactor, 0.);\n  // return;\n\n  vec3 _emission = emissiveFactor;\n  if (useEmissiveTexture) {\n    _emission *= sampleTexture(emissiveTexture, vUV).rgb;\n  }\n\n  float _ao = ao;\n  if (useOcclusionTexture) {\n    _ao *= sampleTexture(occlusionTexture, vUV).r;\n  }\n\n  float _metallic = metallic;\n  float _roughness = roughness;\n  if (useMetallicRoughnessTexture) {\n    vec4 ts = sampleTexture(metallicRoughnessTexture, vUV);\n    _metallic *= ts.b;\n    _roughness *= ts.g;\n  }\n\n  vec3 _tangentNormal = vec3(0, 0, 1);\n  if (useNormalTexture) {\n    _tangentNormal = sampleTexture(normalTexture, vUV).rgb;\n    \n    // Accoring to GLTF NormalTangentTest, it's correct to flip none of the channels here! Update: yup, should not flip anything here\n    // _tangentNormal.r = 1. - _tangentNormal.r;\n    // _tangentNormal.g = 1. - _tangentNormal.g; // Convert from DirectX to OpenGL normal map format (remove this line if the normal map looks inverted)\n\n    // _tangentNormal.rg = _tangentNormal.gr;\n\n    _tangentNormal = _tangentNormal * 2. - 1.;\n    _tangentNormal = setNormalStrength(_tangentNormal, normalStrength);\n  }\n\n  // fragColor = vec4(_tangentNormal, 1);\n  // return;\n\n  vec4 litColor = lit(currentAlbedo, alphaCutoff, _emission, _tangentNormal, _metallic, _roughness, _ao);\n \n  #ifdef USEFOG\n    litColor = applyFog(litColor);\n  #endif\n\n  fragColor = litColor;\n}\n`,Mt=Et;Mt=(Mt=(Mt=Mt.replace(/modelMatrix/g,"vModelMatrix")).replace(/uniform mat4 vModelMatrix/g,"in mat4 vModelMatrix")).replace("motionVector = (NDCPos - PrevNDCPos).xy * 0.5 + 0.5;","motionVector = vec2(0.5);");var _t=Et,Rt=Et;Rt=(Rt=Rt.replace("//#in","in float vAlpha;")).replace("//#currentAlbedo","currentAlbedo *= vec4(1, 1, 1, vAlpha);");var Ct="\n// lit - vertex.glsl\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 tangent;\nattribute vec3 color;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vTangent;\nvarying vec3 vColor;\nvarying vec2 vUV;\nvarying mat3 vTBN;\n\n//Shadows\nconst int levels = 2;\nuniform mat4 textureMatrices[levels];\n// varying vec4 projectedTexcoords[levels];\n\nvoid main() {\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(vNormal, vTangent), 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * vec4(vNormal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  // for (int i = 0; i < levels; i++) {\n  //   projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  // }\n\n  vPosition = vec3(worldPosition);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",Ft="\n#extension GL_EXT_shader_texture_lod : enable\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n\n#ifndef GL_EXT_shader_texture_lod\nvec4 textureCubeLodEXT(samplerCube t, vec3 n, float lod) {\n  return textureCube(t, n);\n}\n#endif\n\nconst float PI = 3.141592;\n\n// Attributes\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vTangent;\nvarying vec3 vColor;\nvarying vec2 vUV;\nvarying mat3 vTBN;\n\nuniform mat4 inverseViewMatrix;\nuniform mat4 modelMatrix;\n\n// Material properties\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform sampler2D normalTexture;\nuniform bool useNormalTexture;\nuniform sampler2D metallicRoughnessTexture;\nuniform bool useMetallicRoughnessTexture;\nuniform sampler2D emissiveTexture;\nuniform bool useEmissiveTexture;\nuniform sampler2D occlusionTexture;\nuniform bool useOcclusionTexture;\n\nuniform vec4 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform vec3 emissiveFactor;\nfloat ao = 1.;\nuniform bool opaque;\nuniform float alphaCutoff;\nuniform float normalStrength;\nuniform bool doNoTiling;\n\n// bruh make shared uniform into uniform block\n// Light info\nstruct LightInfo {\n  int type;\n  vec3 position;\n  vec3 direction;\n  float angle;\n  vec3 color;\n};\nconst int maxLights = 8;\nuniform LightInfo lights[maxLights];\nuniform int nrLights;\nuniform vec3 sunDirection;\nuniform vec3 sunIntensity;\n\n// Environment\nuniform float environmentIntensity;\nuniform samplerCube u_diffuseIBL;\nuniform samplerCube u_specularIBL;\nuniform sampler2D u_splitSum;\n\n// Shadows\nfloat shadowDarkness = 0.;\nvec2 shadowStepSize = 1. / vec2(1024);\nconst int shadowKernalSize = 3;\nmat3 shadowKernel = mat3(\n  1, 2, 1,\n  2, 4, 2,\n  1, 2, 1\n);\n\nconst int levels = 2;\n// in vec4 projectedTexcoords[levels];\nuniform float biases[levels];\nuniform sampler2D projectedTextures[levels];\n\n// Debug\nuniform sampler2D unsued2D;\nuniform samplerCube unsued3D;\n\n// No tiling\nvec4 hash4(vec2 p);\nvec2 hash(vec2 p);\n\n// Texture sampling\nvec4 sampleTexture(sampler2D samp, vec2 uv);\n\n//Normal map\nvec3 setNormalStrength(vec3 normal, float strength);\n\n// Shadow functions\nbool inRange(vec3 projCoord);\nfloat getShadowAmount();\n\n// PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0);\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness);\nfloat DistributionGGX(vec3 N, vec3 H, float roughness);\nfloat GeometrySchlickGGX(float NdotV, float roughness);\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness);\nvec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0);\nvec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0);\nvec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0);\nvec3 Spotlight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 dir, float angle, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0);\nvec4 lit(vec4 _albedo, float _alphaCutoff, vec3 _emission, vec3 _tangentNormal, float _metallic, float _roughness, float _ao);\n\nvoid main() {\n  vec4 currentAlbedo = useTexture ? sampleTexture(albedoTexture, vUV) : vec4(1);\n  currentAlbedo *= albedo;\n  currentAlbedo *= vec4(vec3(1) - vColor, 1);\n\n  vec3 _emission = emissiveFactor;\n  if (useEmissiveTexture) {\n    _emission *= sampleTexture(emissiveTexture, vUV).rgb;\n  }\n\n  float _ao = ao;\n  if (useOcclusionTexture) {\n    _ao *= sampleTexture(occlusionTexture, vUV).r;\n  }\n\n  float _metallic = metallic;\n  float _roughness = roughness;\n  if (useMetallicRoughnessTexture) {\n    vec3 ts = sampleTexture(metallicRoughnessTexture, vUV).rgb;\n    _metallic *= ts.b;\n    _roughness *= ts.g;\n  }\n\n  vec3 _tangentNormal = vec3(0, 0, 1);\n  if (useNormalTexture) {\n    _tangentNormal = sampleTexture(normalTexture, vUV).rgb * 2. - 1.;\n\n    if (normalStrength != 0.) {\n    _tangentNormal = setNormalStrength(_tangentNormal, normalStrength);\n    }\n  }\n\n  gl_FragColor = lit(currentAlbedo, alphaCutoff, _emission, _tangentNormal, _metallic, _roughness, _ao);\n}\n\n// Texture sampling\nvec4 sampleTexture(sampler2D samp, vec2 uv) {\n  return texture2D(samp, uv);\n}\n\n//Normal map\nvec3 setNormalStrength(vec3 normal, float strength) {\n  return vec3(normal.xy * strength, mix(1., normal.z, clamp(strength, 0., 1.)));\n}\n\n// Shadow functions\nbool inRange(vec3 projCoord) {\n  return projCoord.x >= 0.0 &&\n      projCoord.x <= 1.0 &&\n      projCoord.y >= 0.0 &&\n      projCoord.y <= 1.0;\n}\n\nfloat getShadowAmount() {\n  return 1.;\n}\n\n// PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n} \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n  float a      = roughness*roughness;\n  float a2     = a*a;\n  float NdotH  = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH*NdotH;\n\n  float num   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n\n  return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r*r) / 8.0;\n\n  float num   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 F0 = vec3(scalarF0); \n  F0 = mix(F0, albedo, metallic);\n  vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.), F0, roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - metallic;\t  \n    \n  vec3 irradiance = textureCube(u_diffuseIBL, N).rgb;\n  vec3 diffuse  = irradiance * albedo;\n\n    \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureCubeLodEXT(u_specularIBL, R, roughness * MAX_REFLECTION_LOD).rgb;   \n  \n  // vec2 envBRDF = texture2D(u_splitSum, vec2(max(dot(N, V), 0.), roughness)).rg;\n\n  vec2 uv = vec2(max(dot(N, V), 0.), roughness);\n  uv.y = 1. - uv.y;\n  vec2 envBRDF = texture2D(u_splitSum, uv).rg;\n  \n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n  vec3 ambient = (kD * diffuse + specular) * ao;\n\n  return ambient;\n}\n\nvec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 L = normalize(lightDir);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec3 Spotlight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 dir, float angle, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 currentDir = normalize(worldPos - lightPos);\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n\n  float sharpness = 5.;\n  attenuation *= clamp((dot(currentDir, dir) - cos(angle)) * sharpness, 0., 1.);\n\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec4 lit(vec4 _albedo, float _alphaCutoff, vec3 _emission, vec3 _tangentNormal, float _metallic, float _roughness, float _ao) {\n  _roughness = clamp(_roughness, 0.01, 0.99);\n\n  if (_albedo.a <= _alphaCutoff) {\n    discard;\n  }\n\n  if (opaque) {\n    _albedo.a = 1.;\n  }\n\n  // vec3 N = normalize(mat3(modelMatrix) * vNormal);\n  vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n\n  vec3 N = normalize(vTBN * _tangentNormal);\n  if (!gl_FrontFacing) {\n    N *= -1.;\n  }\n\n  vec3 R = reflect(-V, N);\n\n  float f0 = 0.04;\n\n  vec3 col = vec3(0);\n  col += IBL(N, V, R, _albedo.rgb, _metallic, _roughness, f0) * _ao * environmentIntensity;\n  \n  if (sunIntensity != vec3(0)) {\n    col += DirectionalLight(vPosition, N, V, sunDirection, sunIntensity, _albedo.rgb, _metallic, _roughness, f0) * _ao * getShadowAmount();\n  }\n\n  for (int i = 0; i < maxLights; i++) {\n    if (i < nrLights) {\n      LightInfo light = lights[i];\n      if (light.type == 0) {\n        col += PositionalLight(vPosition, N, V, light.position, light.color, _albedo.rgb, _metallic, _roughness, f0);\n      }\n      else if (light.type == 1) {\n        col += Spotlight(vPosition, N, V, light.position, light.direction, light.angle, light.color, _albedo.rgb, _metallic, _roughness, f0);\n      }\n    }\n  }\n\n  // if (nrLights >= 1) {\n  //   const int i = 0;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 2) {\n  //   const int i = 1;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 3) {\n  //   const int i = 2;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 4) {\n  //   const int i = 3;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 5) {\n  //   const int i = 4;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 6) {\n  //   const int i = 5;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 7) {\n  //   const int i = 6;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 8) {\n  //   const int i = 7;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n\n  col += _emission;\n\n  return vec4(col, _albedo.a);\n}\n\n\n\n\n\n\n\n\n// #extension GL_EXT_shader_texture_lod : enable\n// precision highp float;\n\n// #ifndef GL_EXT_shader_texture_lod\n// vec4 textureCubeLodEXT(samplerCube t, vec3 n, float lod) {\n//   return textureCube(t, n);\n// }\n// #endif\n\n// varying vec3 vPosition;\n// varying vec3 vNormal;\n// varying vec3 vTangent;\n// varying vec3 vColor;\n// varying vec2 vUV;\n// varying mat3 vTBN;\n\n// uniform sampler2D albedoTexture;\n// uniform bool useTexture;\n// uniform sampler2D normalTexture;\n// uniform bool useNormalTexture;\n// uniform sampler2D metallicRoughnessTexture;\n// uniform bool useMetallicRoughnessTexture;\n// uniform sampler2D emissiveTexture;\n// uniform bool useEmissiveTexture;\n// uniform sampler2D occlusionTexture;\n// uniform bool useOcclusionTexture;\n\n// uniform mat4 inverseViewMatrix;\n// uniform mat4 modelMatrix;\n\n// uniform samplerCube u_diffuseIBL;\n// uniform samplerCube u_specularIBL;\n// uniform sampler2D u_splitSum;\n\n// uniform vec3 sunDirection;\n// uniform vec3 sunIntensity;\n\n// float shadowDarkness = 0.;\n\n// uniform vec4 albedo;\n// uniform float metallic;\n// uniform float roughness;\n// uniform vec3 emissiveFactor;\n// float ao = 1.;\n\n// uniform bool opaque;\n// uniform float alphaCutoff;\n\n// uniform bool doNoTiling;\n\n// const float PI = 3.141592;\n\n// vec2 hash( vec2 p ) // replace this by something better\n// {\n// \tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n// \treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n// }\n\n// float noise( in vec2 p )\n// {\n//   const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n//   const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n// \tvec2  i = floor( p + (p.x+p.y)*K1 );\n//   vec2  a = p - i + (i.x+i.y)*K2;\n//   float m = step(a.y,a.x); \n//   vec2  o = vec2(m,1.0-m);\n//   vec2  b = a - o + K2;\n// \tvec2  c = a - 1.0 + 2.0*K2;\n//   vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n// \tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n//   return (dot( n, vec3(70.0) ) + 1.) / 2.;\n// }\n\n// // Texture sampling\n// vec4 sampleTexture(sampler2D samp, vec2 uv) {\n//   return texture2D(samp, uv);\n// }\n\n// //Shadows\n// vec2 shadowStepSize = 1. / vec2(1024);\n// const int shadowKernalSize = 3;\n// mat3 shadowKernel = mat3(\n//   1, 2, 1,\n//   2, 4, 2,\n//   1, 2, 1\n// );\n\n// const int levels = 2;\n// uniform float biases[levels];\n// uniform sampler2D projectedTextures[levels];\n// // varying vec4 projectedTexcoords[levels];\n\n// bool inRange(vec3 projCoord) {\n//   return projCoord.x >= 0.0 &&\n//       projCoord.x <= 1.0 &&\n//       projCoord.y >= 0.0 &&\n//       projCoord.y <= 1.0;\n// }\n\n// float getShadowAmount() {\n//   // vec3 proj = projectedTexcoords[0].xyz / projectedTexcoords[0].w;\n//   // float currentDepth = proj.z + biases[0];\n//   // float projectedDepth = texture2D(projectedTextures[0], proj.xy).r;\n//   // bool inside = inRange(proj);\n  \n//   // if (inside) {\n//   //   return (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n//   // }\n  \n//   // proj = projectedTexcoords[1].xyz / projectedTexcoords[1].w;\n//   // currentDepth = proj.z + biases[1];\n//   // projectedDepth = texture2D(projectedTextures[1], proj.xy).r;\n//   // inside = inRange(proj);\n\n//   // if (inside) {\n//   //   return (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n//   // }\n\n//   return 1.;\n// }\n\n// // PBR\n// vec3 fresnelSchlick(float cosTheta, vec3 F0) {\n//   return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n// }\n\n// vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n//   return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n// } \n\n// float DistributionGGX(vec3 N, vec3 H, float roughness) {\n//   float a      = roughness*roughness;\n//   float a2     = a*a;\n//   float NdotH  = max(dot(N, H), 0.0);\n//   float NdotH2 = NdotH*NdotH;\n\n//   float num   = a2;\n//   float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n//   denom = PI * denom * denom;\n\n//   return num / denom;\n// }\n\n// float GeometrySchlickGGX(float NdotV, float roughness) {\n//   float r = (roughness + 1.0);\n//   float k = (r*r) / 8.0;\n\n//   float num   = NdotV;\n//   float denom = NdotV * (1.0 - k) + k;\n\n//   return num / denom;\n// }\n\n// float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n//   float NdotV = max(dot(N, V), 0.0);\n//   float NdotL = max(dot(N, L), 0.0);\n//   float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n//   float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n//   return ggx1 * ggx2;\n// }\n\n// vec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0) {\n//   vec3 F0 = vec3(scalarF0); \n//   F0 = mix(F0, albedo, metallic);\n//   vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.), F0, roughness);\n\n//   vec3 kS = F;\n//   vec3 kD = 1.0 - kS;\n//   kD *= 1.0 - metallic;\n    \n//   vec3 irradiance = textureCube(u_diffuseIBL, N).rgb;\n//   vec3 diffuse  = irradiance * albedo;\n    \n//   const float MAX_REFLECTION_LOD = 4.0;\n//   vec3 prefilteredColor = textureCubeLodEXT(u_specularIBL, R, roughness * MAX_REFLECTION_LOD).rgb;   \n//   vec2 envBRDF = texture2D(u_splitSum, vec2(max(dot(N, V), 0.), roughness)).rg;\n//   vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n//   vec3 ambient = (kD * diffuse + specular) * ao;\n\n//   return ambient;\n// }\n\n// vec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n//   vec3 L = normalize(lightDir);  \n//   vec3 H = normalize(V + L);  \n//   vec3 radiance     = lightColor;     \n//   vec3 F0 = vec3(scalarF0); \n//   F0      = mix(F0, albedo, metallic);\n//   vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n//   float NDF = DistributionGGX(N, H, roughness);       \n//   float G   = GeometrySmith(N, V, L, roughness);     \n//   vec3 nominator    = NDF * G * F;\n//   float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n//   vec3 specular     = nominator / denominator;       \n//   vec3 kS = F;\n//   vec3 kD = vec3(1.0) - kS;\n    \n//   kD *= 1.0 - metallic;     \n//   float NdotL = max(dot(N, L), 0.0);        \n//   return (kD * albedo / PI + specular) * radiance * NdotL;  \n// }\n\n// void main() {\n//   vec4 currentAlbedo = useTexture ? sampleTexture(albedoTexture, vUV) : vec4(1);\n//   currentAlbedo *= albedo;\n\n//   if (currentAlbedo.a <= alphaCutoff) {\n//     discard;\n//   }\n\n//   if (opaque) {\n//     currentAlbedo.a = 1.;\n//   }\n\n//   float _metallic = metallic;\n//   float _roughness = roughness;\n//   if (useMetallicRoughnessTexture) {\n//     vec3 ts = sampleTexture(metallicRoughnessTexture, vUV).rgb;\n//     _metallic *= ts.b;\n//     _roughness *= ts.g;\n//   }\n\n//   float _ao = ao;\n//   if (useOcclusionTexture) {\n//     _ao *= sampleTexture(occlusionTexture, vUV).r;\n//   }\n\n//   vec3 N = normalize(mat3(modelMatrix) * vNormal);\n//   vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n\n//   if (useNormalTexture && vTangent.xyz != vec3(0)) {\n//     vec3 tangentNormal = sampleTexture(normalTexture, vUV).rgb * 2. - 1.;\n//     N = normalize(vTBN * tangentNormal);\n//   }\n\n//   if (!gl_FrontFacing) {\n//     N *= -1.;\n//   }\n\n//   vec3 R = reflect(-V, N);\n\n//   float f0 = 0.04;\n\n//   vec3 col = vec3(0);\n//   col += IBL(N, V, R, currentAlbedo.rgb, _metallic, _roughness, f0) * _ao;\n//   if (sunIntensity != vec3(0)) {\n//     col += DirectionalLight(vPosition, N, V, sunDirection, sunIntensity, currentAlbedo.rgb, _metallic, _roughness, f0) * _ao * getShadowAmount();\n//   }\n\n//   if (useEmissiveTexture) {\n//     col += sampleTexture(emissiveTexture, vUV).rgb * emissiveFactor;\n//   }\n//   else {\n//     col += emissiveFactor;\n//   }\n\n//   gl_FragColor = vec4(col, currentAlbedo.a);\n//   return;\n// }\n";bt=bt.trim(),yt=yt.trim(),Tt=Tt.trim(),wt=wt.trim(),Et=Et.trim(),Mt=Mt.trim(),_t=_t.trim(),Rt=Rt.trim();var At={lit:{vertex:Ct=Ct.trim(),fragment:Ft=Ft.trim()}},Dt={lit:{vertex:bt,fragment:Et},litInstanced:{vertex:yt,fragment:Mt},litSkinned:{vertex:Tt,fragment:_t},litTrail:{vertex:wt,fragment:Rt}},Pt=Dt.lit.vertex,St=`\n${ft}\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform vec4 albedo;\n\nuniform float alphaCutoff; // uniform alphaCutoff = 0.5;\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec3 vTangent;\nin vec3 vColor;\nin vec2 vUV;\n\nconst int levels = 2;\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n${vt}\n\nvoid main() {\n  motionVector = vec2(0.5);\n\n  vec4 currentAlbedo = useTexture ? texture(albedoTexture, vUV) : vec4(1);\n  currentAlbedo *= albedo;\n  currentAlbedo.xyz *= vec3(1) - vColor.xyz;\n\n  if (currentAlbedo.a < alphaCutoff) {\n    discard;\n  }\n\n  #ifdef USEFOG\n    currentAlbedo = applyFog(currentAlbedo);\n  #endif\n\n  fragColor = currentAlbedo;\n}\n`,Nt=`\n${ft}\n\nin vec3 position;\nin vec3 normal;\nin vec3 tangent;\nin vec4 color;\nin vec2 uv;\nin mat4 modelMatrix;\n\n// uniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\n\nconst int levels = 2;\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec3 vTangent;\nout vec4 vColor;\nout vec2 vUV;\n\nvoid main() {\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n  vPosition = vec3(modelMatrix * vec4(position, 1.0));\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n`,Ut=`\n${ft}\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform vec4 albedo;\n\nuniform float alphaCutoff; // uniform alphaCutoff = 0.5;\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec3 vTangent;\nin vec4 vColor;\nin vec2 vUV;\n\nconst int levels = 2;\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n${vt}\n\nvoid main() {\n  motionVector = vec2(0.5);\n  \n  vec4 currentAlbedo = useTexture ? texture(albedoTexture, vUV) : vec4(1);\n  currentAlbedo *= albedo;\n  currentAlbedo.xyz *= vec3(1) - vColor.xyz;\n\n  if (currentAlbedo.a < alphaCutoff) {\n    discard;\n  }\n\n  #ifdef USEFOG\n    currentAlbedo = applyFog(currentAlbedo);\n  #endif\n\n  fragColor = currentAlbedo;\n}\n`,zt="\n",Lt="\n";Pt=Pt.trim(),St=St.trim(),Nt=Nt.trim(),Ut=Ut.trim();var Bt={vertex:zt=zt.trim(),fragment:Lt=Lt.trim()},It={unlit:{vertex:Pt,fragment:St},unlitInstanced:{vertex:Nt,fragment:Ut}};let Ot="\n#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec3 tangent;\nin vec3 color;\nin vec2 uv;\nuniform mat4 modelMatrix;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec3 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat4 vModelMatrix;\nout mat3 vTBN;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  // float biases[levels];\n};\n\nvoid main() {\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n  vModelMatrix = modelMatrix;\n\n  vec3 center = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);\n  vec3 cameraRight = vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]);\n  vec3 cameraUp = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n  vec4 worldPosition = vec4(center + (cameraRight * position.x + cameraUp * position.y) * 0.5, 1);\n\n  vPosition = vec3(worldPosition); \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n",kt="\n#version 300 es\nprecision highp float;\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\nuniform sampler2D albedoTexture;\n\nin vec2 vUV;\n\nvoid main() {\n  fragColor = texture(albedoTexture, vUV);\n  motionVector = vec2(0.5);\n}\n";Ot=Ot.trim(),kt=kt.trim();let Vt={billboard:{vertex:Ot,fragment:kt}};var Gt={webgl1:{particle:{vertex:"\n        attribute vec3 position;\n        attribute vec3 normal;\n        attribute vec3 tangent;\n        attribute vec4 color;\n        attribute vec2 uv;\n        attribute mat4 modelMatrix;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        varying vec3 vNormal;\n        varying vec3 vTangent;\n        varying vec4 vColor;\n        varying vec2 vUV;\n\n        void main() {\n          vNormal = normal;\n          vTangent = tangent;\n          vUV = uv;\n          vColor = color;\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        uniform sampler2D albedoTexture;\n        uniform bool useTexture;\n        uniform vec4 albedo;\n\n        varying vec3 vNormal;\n        varying vec3 vTangent;\n        varying vec4 vColor;\n        varying vec2 vUV;\n\n        void main() {\n          vec4 currentAlbedo = useTexture ? texture2D(albedoTexture, vUV) : vec4(1);\n          currentAlbedo *= albedo;\n          currentAlbedo *= vColor;\n\n          gl_FragColor = currentAlbedo;\n        }\n      "}},webgl2:{particle:{vertex:"\n        #version 300 es\n\n        in vec3 position;\n        in vec3 normal;\n        in vec3 tangent;\n        in vec4 color;\n        in vec2 uv;\n        in mat4 modelMatrix;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        out vec3 vNormal;\n        out vec3 vTangent;\n        out vec4 vColor;\n        out vec2 vUV;\n\n        void main() {\n          vNormal = normal;\n          vTangent = tangent;\n          vUV = uv;\n          vColor = color;\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        layout (location = 0) out vec4 fragColor;\n        layout (location = 1) out vec2 motionVector;\n\n        uniform sampler2D albedoTexture;\n        uniform bool useTexture;\n        uniform vec4 albedo;\n\n        in vec3 vNormal;\n        in vec3 vTangent;\n        in vec4 vColor;\n        in vec2 vUV;\n\n        void main() {\n          vec4 currentAlbedo = useTexture ? texture(albedoTexture, vUV) : vec4(1);\n          currentAlbedo *= albedo;\n          currentAlbedo *= vColor;\n\n          fragColor = currentAlbedo;\n          motionVector = vec2(0.5);\n        }\n      "}}};ht(Gt);var Xt=Gt.webgl1,jt=Gt.webgl2,Ht={webgl1:{skybox:{vertex:"\n        attribute vec4 position;\n\n        varying vec4 vPosition;\n        \n        void main() {\n          vPosition = position;\n        \n          gl_Position = position;\n          gl_Position.z = 1.;\n        }\n      ",fragment:"\n        precision mediump float;\n\n        varying vec4 vPosition;\n        \n        uniform samplerCube skybox;\n        uniform mat4 viewDirectionProjectionInverse;\n\n        // #define USEFOG\n        const vec4 fogColor = vec4(0.23, 0.24, 0.26, 1);\n        \n        void main() {\n          vec4 t = viewDirectionProjectionInverse * vPosition;\n          vec3 col = textureCube(skybox, normalize(t.xyz / t.w)).rgb;\n        \n          #ifdef USEFOG\n            gl_FragColor = fogColor;\n          #else\n            gl_FragColor = vec4(col, 1);\n          #endif\n        }\n      "}},webgl2:{skybox:{vertex:"\n        #version 300 es\n        \n        in vec4 position;\n        \n        out vec4 vPosition;\n        \n        void main() {\n          vPosition = position;\n        \n          gl_Position = position;\n          gl_Position.z = 1.;\n        }\n      ",fragment:"\n        #version 300 es\n        precision mediump float;\n        \n        layout (location = 0) out vec4 fragColor;\n        layout (location = 1) out vec2 motionVector;\n        \n        in vec4 vPosition;\n        \n        uniform float environmentIntensity;\n        uniform samplerCube skybox;\n        uniform mat4 viewDirectionProjectionInverse;\n\n        uniform vec4 fogColor;\n        uniform float fogIntensity;\n\n        float _SkyboxSpeed = 0.01;\n        vec3 _SkyboxDirection = vec3(1, -0.3, 0);\n        uniform float iTime;\n\n        vec4 flowUVW(vec3 dir, vec3 curl, float t, bool flowB) {\n          float phaseOffset = flowB ? 0.5f : 0.0f;\n          float progress = t + phaseOffset - floor(t + phaseOffset);\n          vec3 offset = curl * progress;\n\n          vec4 uvw = vec4(dir, 0.0f);\n          uvw.xz -= offset.xy;\n          uvw.w = 1. - abs(1.0f - 2.0f * progress);\n\n          return uvw;\n        }\n        \n        void main() {\n          motionVector = vec2(0.5);\n\n          vec4 proj = viewDirectionProjectionInverse * vPosition;\n          vec3 viewDir = normalize(proj.xyz / proj.w);\n\n          // vec3 col = texture(skybox, viewDir).rgb * environmentIntensity;\n\n          vec3 curl = normalize(_SkyboxDirection);\n          float t = iTime * _SkyboxSpeed;\n          vec4 uvw1 = flowUVW(viewDir, curl, t, false);\n          vec4 uvw2 = flowUVW(viewDir, curl, t, true);\n\n          vec3 sky = texture(skybox, uvw1.xyz).rgb * uvw1.w;\n          vec3 sky2 = texture(skybox, uvw2.xyz).rgb * uvw2.w;\n          vec3 col = (sky + sky2) * environmentIntensity;\n\n          // Fog\n          col = mix(col, fogColor.rgb, fogIntensity * clamp(1. - viewDir.y * 10., 0., 1.));\n\n          fragColor = vec4(col, 1);\n        }\n      "}}};ht(Ht);var Wt=Ht.webgl1,qt=Ht.webgl2,Yt={webgl2:{shadow:{vertex:"\n        attribute vec3 position;\n        attribute vec2 uv;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n        uniform mat4 modelMatrix;\n\n        varying vec2 vUV;\n\n        void main() {\n          vUV = uv;\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        varying vec2 vUV;\n\n        uniform sampler2D albedoTexture;\n        uniform bool useTexture;\n        uniform float alphaCutoff;\n\n        void main() {\n          if (useTexture && texture2D(albedoTexture, vUV).a < alphaCutoff) {\n            discard;\n          }\n\n          gl_FragColor = vec4(1, 0, 0, 1);\n        }\n      "},shadowInstanced:{vertex:"\n        attribute vec3 position;\n        attribute vec2 uv;\n        attribute mat4 modelMatrix;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        varying vec2 vUV;\n\n        void main() {\n          vUV = uv;\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n      ",fragment:null},shadowSkinned:{vertex:"\n        attribute vec3 position;\n        attribute vec2 uv;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n        uniform mat4 modelMatrix;\n\n        varying vec2 vUV;\n\n        //Skinning\n        attribute vec4 weights;\n        attribute vec4 joints;\n\n        uniform sampler2D u_jointTexture;\n        uniform float u_numJoints;\n\n        // these offsets assume the texture is 4 pixels across\n        #define ROW0_U ((0.5 + 0.0) / 4.)\n        #define ROW1_U ((0.5 + 1.0) / 4.)\n        #define ROW2_U ((0.5 + 2.0) / 4.)\n        #define ROW3_U ((0.5 + 3.0) / 4.)\n        \n        mat4 getBoneMatrix(float jointNdx) {\n          float v = (jointNdx + 0.5) / u_numJoints;\n          return mat4(\n            texture2D(u_jointTexture, vec2(ROW0_U, v)),\n            texture2D(u_jointTexture, vec2(ROW1_U, v)),\n            texture2D(u_jointTexture, vec2(ROW2_U, v)),\n            texture2D(u_jointTexture, vec2(ROW3_U, v))\n          );\n        }\n\n        void main() {\n          vUV = uv;\n\n          mat4 skinMatrix = getBoneMatrix(joints[0]) * weights[0] +\n                            getBoneMatrix(joints[1]) * weights[1] +\n                            getBoneMatrix(joints[2]) * weights[2] +\n                            getBoneMatrix(joints[3]) * weights[3];\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * skinMatrix * vec4(position, 1.0);\n        }\n      ",fragment:null}}};Yt.webgl2.shadowInstanced.fragment=Yt.webgl2.shadow.fragment,Yt.webgl2.shadowSkinned.fragment=Yt.webgl2.shadow.fragment,Yt.webgl1={shadow:{vertex:Yt.webgl2.shadow.vertex,fragment:Yt.webgl2.shadow.fragment}},ht(Yt);var Kt=Yt.webgl1,$t=Yt.webgl2,Qt={webgl2:{postprocessing:{vertex:"\n        #version 300 es\n\n        in vec2 position;\n\n        void main() {\n          gl_Position = vec4(position, 0.0, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        // #define DEBUG_COLOR\n        \n        out vec4 fragColor;\n\n        // uniform float iTime;\n        uniform vec2 SIZE;\n        uniform sampler2D mainTexture;\n        uniform sampler2D bloomTexture;\n        uniform sampler2D depthTexture;\n        uniform sampler2D motionBlurTexture;\n        uniform sampler2D downscaledTexture;\n        \n        uniform float bloomIntensity;\n        uniform float exposure;\n        uniform float gamma;\n        uniform float saturation;\n        uniform float contrast;\n        uniform float temperature;\n        uniform float tint;\n        uniform float vignetteFalloff;\n        uniform float vignetteAmount;\n        \n        #ifdef ENABLE_MOTIONBLUR\n        uniform float motionBlurStrength;\n        #endif\n\n        uniform sampler2D rainTexture;\n        \n        vec3 godrays(float density, float weight, float decay, float exposure, vec2 screenSpaceLightPos, vec2 uv);\n        vec3 ACESFilm(vec3 x);\n        float getHeight(vec2 uv);\n        vec3 adjustSaturation(vec3 color, float value);\n        vec3 adjustContrast(vec3 color, float value);\n\n        // White balance\n        vec3 whiteBalance(vec3 In, float Temperature, float Tint)\n        {\n          // Range ~[-1.67;1.67] works best\n          float t1 = Temperature * 10. / 6.;\n          float t2 = Tint * 10. / 6.;\n\n          // Get the CIE xy chromaticity of the reference white point.\n          // Note: 0.31271 = x value on the D65 white point\n          float x = 0.31271 - t1 * (t1 < 0. ? 0.1 : 0.05);\n          float standardIlluminantY = 2.87 * x - 3. * x * x - 0.27509507;\n          float y = standardIlluminantY + t2 * 0.05;\n\n          // Calculate the coefficients in the LMS space.\n          vec3 w1 = vec3(0.949237, 1.03542, 1.08728); // D65 white point\n\n          // CIExyToLMS\n          float Y = 1.;\n          float X = Y * x / y;\n          float Z = Y * (1. - x - y) / y;\n          float L = 0.7328 * X + 0.4296 * Y - 0.1624 * Z;\n          float M = -0.7036 * X + 1.6975 * Y + 0.0061 * Z;\n          float S = 0.0030 * X + 0.0136 * Y + 0.9834 * Z;\n          vec3 w2 = vec3(L, M, S);\n\n          vec3 balance = vec3(w1.x / w2.x, w1.y / w2.y, w1.z / w2.z);\n\n          mat3 LIN_2_LMS_MAT = mat3(\n            3.90405e-1, 5.49941e-1, 8.92632e-3,\n            7.08416e-2, 9.63172e-1, 1.35775e-3,\n            2.31082e-2, 1.28021e-1, 9.36245e-1\n          );\n\n          mat3 LMS_2_LIN_MAT = mat3(\n            2.85847e+0, -1.62879e+0, -2.48910e-2,\n            -2.10182e-1,  1.15820e+0,  3.24281e-4,\n            -4.18120e-2, -1.18169e-1,  1.06867e+0\n          );\n\n          vec3 lms = LIN_2_LMS_MAT * In;\n          lms *= balance;\n          vec3 Out = LMS_2_LIN_MAT * lms;\n\n          return Out;\n        }\n\n        // FXAA\n        #ifndef FXAA_REDUCE_MIN\n            #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n        #endif\n        #ifndef FXAA_REDUCE_MUL\n            #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n        #endif\n        #ifndef FXAA_SPAN_MAX\n            #define FXAA_SPAN_MAX     8.0\n        #endif\n\n        void texcoords(vec2 fragCoord, vec2 resolution,\n                       out vec2 v_rgbNW, out vec2 v_rgbNE,\n                       out vec2 v_rgbSW, out vec2 v_rgbSE,\n                       out vec2 v_rgbM);\n\n        vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n                  vec2 v_rgbNW, vec2 v_rgbNE, \n                  vec2 v_rgbSW, vec2 v_rgbSE, \n                  vec2 v_rgbM);\n\n        vec4 applyFXAA(sampler2D tex, vec2 fragCoord, vec2 resolution);\n\n        // DoF\n        #define MAX_BLUR 10.0\n\n        uniform float uFocusDistance;\n        uniform float uBlurCoefficient;\n        uniform float uPPM;\n        uniform vec2  uDepthRange;\n        uniform vec2 uResolution;\n        uniform vec2 uTexelOffset;\n        uniform sampler2D uDepth;\n\n        vec4 texture2D(sampler2D samp, vec2 uv) {\n          return texture(samp, uv);\n        }\n\n        // Raindrops\n\n        uniform float iTime;\n\n        #define S(x, y, z) smoothstep(x, y, z)\n        #define B(a, b, edge, t) S(a-edge, a+edge, t)*S(b+edge, b-edge, t)\n        #define sat(x) clamp(x,0.,1.)\n\n        #define streetLightCol vec3(1., .7, .3)\n        #define headLightCol vec3(.8, .8, 1.)\n        #define tailLightCol vec3(1., .1, .1)\n\n        #define HIGH_QUALITY\n        #define CAM_SHAKE 1.\n        #define LANE_BIAS .5\n        #define RAIN\n        //#define DROP_DEBUG\n\n        vec3 ro, rd;\n\n        float N(float t) {\n          return fract(sin(t*10234.324)*123423.23512);\n        }\n        vec3 N31(float p) {\n            //  3 out, 1 in... DAVE HOSKINS\n          vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n          p3 += dot(p3, p3.yzx + 19.19);\n          return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n        }\n        float N2(vec2 p)\n        {\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n          vec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n            p3 += dot(p3, p3.yzx + 19.19);\n            return fract((p3.x + p3.y) * p3.z);\n        }\n\n\n        float DistLine(vec3 ro, vec3 rd, vec3 p) {\n          return length(cross(p-ro, rd));\n        }\n        \n        vec3 ClosestPoint(vec3 ro, vec3 rd, vec3 p) {\n            // returns the closest point on ray r to point p\n            return ro + max(0., dot(p-ro, rd))*rd;\n        }\n\n        float Remap(float a, float b, float c, float d, float t) {\n          return ((t-a)/(b-a))*(d-c)+c;\n        }\n\n        float BokehMask(vec3 ro, vec3 rd, vec3 p, float size, float blur) {\n          float d = DistLine(ro, rd, p);\n            float m = S(size, size*(1.-blur), d);\n            \n            #ifdef HIGH_QUALITY\n            m *= mix(.7, 1., S(.8*size, size, d));\n            #endif\n            \n            return m;\n        }\n\n\n\n        float SawTooth(float t) {\n            return cos(t+cos(t))+sin(2.*t)*.2+sin(4.*t)*.02;\n        }\n\n        float DeltaSawTooth(float t) {\n            return 0.4*cos(2.*t)+0.08*cos(4.*t) - (1.-sin(t))*sin(t+cos(t));\n        }  \n\n        vec2 GetDrops(vec2 uv, float seed, float m) {\n            \n            float t = iTime+m*30.;\n            vec2 o = vec2(0.);\n            \n            #ifndef DROP_DEBUG\n            uv.y += t*.05;\n            #endif\n            \n            uv *= vec2(10., 2.5)*2.;\n            vec2 id = floor(uv);\n            vec3 n = N31(id.x + (id.y+seed)*546.3524);\n            vec2 bd = fract(uv);\n            \n            vec2 uv2 = bd;\n            \n            bd -= .5;\n            \n            bd.y*=4.;\n            \n            bd.x += (n.x-.5)*.6;\n            \n            t += n.z * 6.28;\n            float slide = SawTooth(t);\n            \n            float ts = 1.5;\n            vec2 trailPos = vec2(bd.x*ts, (fract(bd.y*ts*2.-t*2.)-.5)*.5);\n            \n            bd.y += slide*2.;\t\t\t\t\t\t\t\t// make drops slide down\n            \n            #ifdef HIGH_QUALITY\n            float dropShape = bd.x*bd.x;\n            dropShape *= DeltaSawTooth(t);\n            bd.y += dropShape;\t\t\t\t\t\t\t\t// change shape of drop when it is falling\n            #endif\n            \n            float d = length(bd);\t\t\t\t\t\t\t// distance to main drop\n            \n            float trailMask = S(-.2, .2, bd.y);\t\t\t\t// mask out drops that are below the main\n            trailMask *= bd.y;\t\t\t\t\t\t\t\t// fade dropsize\n            float td = length(trailPos*max(.5, trailMask));\t// distance to trail drops\n            \n            float mainDrop = S(.2, .1, d);\n            float dropTrail = S(.1, .02, td);\n            \n            dropTrail *= trailMask;\n            o = mix(bd*mainDrop, trailPos, dropTrail);\t\t// mix main drop and drop trail\n            \n            #ifdef DROP_DEBUG\n            if(uv2.x<.02 || uv2.y<.01) o = vec2(1.);\n            #endif\n            \n            return o;\n        }\n\n        vec2 rainEffect(vec2 uv) {\n          // vec3 f = normalize(lookat-ro);\n          // vec3 r = cross(vec3(0., 1., 0.), f);\n          // vec3 u = cross(f, r);\n\n          uv.x *= SIZE.x / SIZE.y;\n\n          float m = 0.;\n          float t = iTime;\n          vec2 offs = vec2(0.);\n\n          #ifdef RAIN\n          vec2 dropUv = uv;\n          \n          #ifdef HIGH_QUALITY\n          // float x = (sin(t*.1)*.5+.5)*.5;\n          // x = -x*x;\n          const float x = 0.2;\n          const float s = sin(x);\n          const float c = cos(x);\n          \n          const mat2 rot = mat2(c, -s, s, c);\n        \n          dropUv = uv*rot;\n          // dropUv.x += -sin(t*.1)*.5;\n          #endif\n          \n          offs = GetDrops(dropUv, 1., m);\n          \n          #ifndef DROP_DEBUG\n          offs += GetDrops(dropUv*1.4, 10., m);\n          #ifdef HIGH_QUALITY\n          // offs += GetDrops(dropUv*2.4, 25., m);\n          //offs += GetDrops(dropUv*3.4, 11.);\n          //offs += GetDrops(dropUv*3., 2.);\n          #endif\n          \n          // float ripple = sin(t+uv.y*3.1415*30.+uv.x*124.)*.5+.5;\n          // ripple *= .005;\n          // offs += vec2(ripple*ripple, ripple);\n          #endif\n          #endif\n\n          uv -= offs;\n          uv.x /= SIZE.x / SIZE.y;\n\n          return uv;\n        }\n        \n        void main() {\n          vec2 uv = gl_FragCoord.xy / SIZE;\n\n          #ifdef DEBUG_COLOR\n          fragColor = texture2D(mainTexture, uv);\n          return;\n          #endif\n        \n          // float stepSize = 0.02;\n          // float size = 2.; //?\n          // float s01 = getHeight(uv + vec2(-stepSize, 0));\n          // float s21 = getHeight(uv + vec2(stepSize, 0));\n          // float s10 = getHeight(uv + vec2(0, -stepSize));\n          // float s12 = getHeight(uv + vec2(0, stepSize));\n          // vec3 va = normalize(vec3(size, 0, s21 - s01));\n          // vec3 vb = normalize(vec3(0, size, s12 - s10));\n          // vec3 normal = cross(va, vb);\n        \n          // gl_FragColor = vec4(normal, 1);\n          // return;\n        \n          // Rain drops\n          // vec3 normal = texture(rainTexture, uv * 3.).rgb * 2. - 1.;\n          // float screenDistance = 0.07 * 0.5;\n          // vec2 uvOffset = normal.xy * screenDistance;\n          // uv += uvOffset;\n\n          // uv = rainEffect(uv);\n        \n          vec4 col = vec4(0);\n\n          // // DoF\n          // ivec2 fragCoord = ivec2(gl_FragCoord.xy);\n          // ivec2 resolution = ivec2(uResolution) - 1;\n\n          // // Convert to linear depth\n          // float ndc = 2.0 * texelFetch(uDepth, fragCoord, 0).r - 1.0;\n          // float depth = -(2.0 * uDepthRange.y * uDepthRange.x) / (ndc * (uDepthRange.y - uDepthRange.x) - uDepthRange.y - uDepthRange.x);\n          // float deltaDepth = abs(uFocusDistance - depth);\n          \n          // // Blur more quickly in the foreground.\n          // float xdd = depth < uFocusDistance ? abs(uFocusDistance - deltaDepth) : abs(uFocusDistance + deltaDepth);\n          // float blurRadius = min(floor(uBlurCoefficient * (deltaDepth / xdd) * uPPM), MAX_BLUR);\n          \n          // if (blurRadius > 1.0) {\n          //     float halfBlur = blurRadius * 0.5;\n\n          //     float count = 0.0;\n\n          //     // for (float i = 0.0; i <= MAX_BLUR; ++i) {\n          //     //     if (i > blurRadius) {\n          //     //         break;\n          //     //     }\n\n          //     //     // texelFetch outside texture gives vec4(0.0) (undefined in ES 3)\n          //     //     ivec2 sampleCoord = clamp(fragCoord + ivec2(((i - halfBlur) * uTexelOffset)), ivec2(0), resolution);\n          //     //     col += texelFetch(mainTexture, sampleCoord, 0);\n\n          //     //     ++count;\n          //     // }\n          //     for (float i = 0.0; i <= MAX_BLUR; ++i) {\n          //       if (i > blurRadius) {\n          //         break;\n          //       }\n\n          //       for (float j = 0.0; j <= MAX_BLUR; ++j) {\n          //         if (j > blurRadius) {\n          //           break;\n          //         }\n\n          //         // texelFetch outside texture gives vec4(0.0) (undefined in ES 3)\n          //         ivec2 sampleCoord = clamp(fragCoord + ivec2(i - halfBlur, j - halfBlur), ivec2(0), resolution);\n          //         col += texelFetch(mainTexture, sampleCoord, 0);\n          //         #ifdef ENABLE_BLOOM\n          //           vec4 bloom = texture2D(bloomTexture, vec2(sampleCoord) / vec2(resolution));\n          //           col.rgb += bloom.rgb * bloomIntensity;\n          //         #endif\n\n          //         ++count;\n          //       }\n          //     }\n\n          //     col /= count;\n          // } else {\n          //     col = texelFetch(mainTexture, fragCoord, 0);\n          // }\n\n          #ifdef ENABLE_MOTIONBLUR\n            const int nSamples = 32;\n            vec2 blurVec = motionBlurStrength * (texture2D(motionBlurTexture, uv).xy * 2. - 1.);\n            vec4 result = texture2D(mainTexture, uv);\n\n            for (int i = 1; i < nSamples; ++i) {\n              vec2 offset = blurVec * (float(i) / float(nSamples - 1) - 0.5);\n              result += texture2D(mainTexture, uv + offset);\n              // result += applyFXAA(mainTexture, (uv + offset) * SIZE, SIZE);\n            }\n            result /= float(nSamples);\n            col += result;\n          #else\n            vec4 samp = texture2D(mainTexture, uv);\n            // vec4 samp = applyFXAA(mainTexture, gl_FragCoord.xy, SIZE);\n            col += samp;\n          #endif\n\n          // Downscaled texture\n          vec4 downscaledCol = texture2D(downscaledTexture, uv);\n          col.rgb += downscaledCol.rgb;\n        \n          // Bloom\n          #ifdef ENABLE_BLOOM\n            vec4 bloom = texture2D(bloomTexture, uv);\n            col.rgb += bloom.rgb * bloomIntensity;\n          #endif\n        \n          // Godrays\n          #ifdef ENABLE_GODRAYS\n            col.rgb += godrays(1., 0.01, 0.97, 0.6, vec2(0.5, 0.5), uv);\n          #endif\n        \n          // Exposure correction\n          col.rgb = col.rgb * pow(2., exposure);\n        \n          // Tonemapping (HDR to LDR)\n          #ifdef TONEMAPPING\n            #if TONEMAPPING == 1\n              col.rgb = ACESFilm(col.rgb);\n            #elif TONEMAPPING == 2\n              col.rgb = col.rgb / (col.rgb + vec3(1.0));\n            #endif\n          #endif\n        \n          // // Gamma correction\n          // col.rgb = pow(col.rgb, vec3(1. / gamma));\n        \n          // Saturation, contrast\n          // #ifdef ENABLE_COLORGRADING\n          col.rgb = adjustSaturation(col.rgb, saturation);\n          col.rgb = adjustContrast(col.rgb, 1. + contrast);\n          // #endif\n\n          // White balance\n          col.rgb = whiteBalance(col.rgb, temperature, tint);\n\n          // Gamma correction\n          col.rgb = pow(col.rgb, vec3(1. / gamma));\n\n          // Vignette\n          float dist = distance(uv, vec2(0.5, 0.5));\n          col.rgb *= smoothstep(0.8, vignetteFalloff * 0.799, dist * (vignetteAmount + vignetteFalloff));\n        \n          fragColor = col;\n        }\n\n        vec4 applyFXAA(sampler2D tex, vec2 fragCoord, vec2 resolution) {\n          mediump vec2 v_rgbNW;\n          mediump vec2 v_rgbNE;\n          mediump vec2 v_rgbSW;\n          mediump vec2 v_rgbSE;\n          mediump vec2 v_rgbM;\n\n          //compute the texture coords\n          texcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n          \n          //compute FXAA\n          return fxaa(tex, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n        }\n\n        vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n                    vec2 v_rgbNW, vec2 v_rgbNE, \n                    vec2 v_rgbSW, vec2 v_rgbSE, \n                    vec2 v_rgbM) {\n            vec4 color;\n            mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n            vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n            vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n            vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n            vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n            vec4 texColor = texture2D(tex, v_rgbM);\n            vec3 rgbM  = texColor.xyz;\n            vec3 luma = vec3(0.299, 0.587, 0.114);\n            float lumaNW = dot(rgbNW, luma);\n            float lumaNE = dot(rgbNE, luma);\n            float lumaSW = dot(rgbSW, luma);\n            float lumaSE = dot(rgbSE, luma);\n            float lumaM  = dot(rgbM,  luma);\n            float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n            float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n            \n            mediump vec2 dir;\n            dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n            dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n            \n            float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                                  (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n            \n            float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n            dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n                      max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                      dir * rcpDirMin)) * inverseVP;\n            \n            vec3 rgbA = 0.5 * (\n                texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n            vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n            float lumaB = dot(rgbB, luma);\n            if ((lumaB < lumaMin) || (lumaB > lumaMax))\n                color = vec4(rgbA, texColor.a);\n            else\n                color = vec4(rgbB, texColor.a);\n            return color;\n        }\n\n        void texcoords(vec2 fragCoord, vec2 resolution,\n              out vec2 v_rgbNW, out vec2 v_rgbNE,\n              out vec2 v_rgbSW, out vec2 v_rgbSE,\n              out vec2 v_rgbM) {\n          vec2 inverseVP = 1.0 / resolution.xy;\n          v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n          v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n          v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n          v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n          v_rgbM = vec2(fragCoord * inverseVP);\n        }\n        \n        vec3 ACESFilm(vec3 x) {\n          float a = 2.51;\n          float b = 0.03;\n          float c = 2.43;\n          float d = 0.59;\n          float e = 0.14;\n          return clamp((x*(a*x+b))/(x*(c*x+d)+e), vec3(0.), vec3(1.));\n        }\n        \n        vec3 godrays(float density, float weight, float decay, float exposure, vec2 screenSpaceLightPos, vec2 uv) {\n          vec3 fragColor = vec3(0);\n        \n          vec2 deltaTextCoord = vec2(uv - screenSpaceLightPos.xy);\n          vec2 textCoo = uv.xy;\n          deltaTextCoord *= (1.0 /  float(100)) * density;\n          float illuminationDecay = 1.0;\n        \n          for (int i = 0; i < 100; i++){\n            textCoo -= deltaTextCoord;\n            vec3 samp = clamp(texture2D(depthTexture, textCoo).xyz, vec3(0.3), vec3(10)) - vec3(0.3);\n            samp *= illuminationDecay * weight;\n            fragColor += samp;\n            illuminationDecay *= decay;\n          }\n        \n          fragColor *= exposure;\n\n          return fragColor;\n        }\n        \n        float getHeight(vec2 uv) {\n          float y = 0.5 + 0.2 * sin(uv.x * 12.);\n          float d = abs(uv.y - y);\n          float falloff = 40.;\n          float thickness = 0.;\n          float height = 1. - clamp(d * falloff - thickness, 0., 1.);\n          return height;\n        }\n\n        vec4 sharpen(in sampler2D tex, in vec2 coords, in vec2 renderSize) {\n          float dx = 1.0 / renderSize.x;\n          float dy = 1.0 / renderSize.y;\n          vec4 sum = vec4(0.0);\n          sum += -1. * texture2D(tex, coords + vec2( -1.0 * dx , 0.0 * dy));\n          sum += -1. * texture2D(tex, coords + vec2( 0.0 * dx , -1.0 * dy));\n          sum += 5. * texture2D(tex, coords + vec2( 0.0 * dx , 0.0 * dy));\n          sum += -1. * texture2D(tex, coords + vec2( 0.0 * dx , 1.0 * dy));\n          sum += -1. * texture2D(tex, coords + vec2( 1.0 * dx , 0.0 * dy));\n          return sum;\n        }\n        \n        vec3 adjustSaturation(vec3 color, float value) {\n          // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance\n          const vec3 luminosityFactor = vec3(0.2126, 0.7152, 0.0722);\n          vec3 grayscale = vec3(dot(color, luminosityFactor));\n        \n          return mix(grayscale, color, 1.0 + value);\n        }\n\n        vec3 adjustContrast(vec3 color, float value) {\n          return 0.5 + value * (color - 0.5);\n        }\n      "}}};Qt.webgl1={postprocessing:{vertex:Qt.webgl2.postprocessing.vertex,fragment:Qt.webgl2.postprocessing.fragment}},ht(Qt);var Zt=Qt.webgl1,Jt=Qt.webgl2,en={webgl1:{bloom:{vertex:"\n        attribute vec2 position;\n\n        void main() {\n          gl_Position = vec4(position, 0.0, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        uniform vec2 screenSize;\n        uniform sampler2D mainTexture;\n        uniform vec2 mainTextureSize;\n        uniform sampler2D secondTexture;\n        uniform int stage;\n\n        #define EPSILON 1.0e-4\n\n        uniform float _SampleScale;\n        uniform float threshold;\n        uniform float knee;\n        uniform float _Clamp;\n\n        float Max3(float a, float b, float c)\n        {\n          return max(max(a, b), c);\n        }\n\n        vec4 QuadraticThreshold(vec4 color, float threshold, vec3 curve)\n        {\n            // Pixel brightness\n            float br = Max3(color.r, color.g, color.b);\n\n            // Under-threshold part: quadratic curve\n            float rq = clamp(br - curve.x, 0.0, curve.y);\n            rq = curve.z * rq * rq;\n\n            // Combine and apply the brightness response curve.\n            color *= max(rq, br - threshold) / max(br, EPSILON);\n\n            return color;\n        }\n\n        vec4 DownsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n        {\n            vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\n            vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\n            vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\n            vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\n            vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\n            vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\n            vec4 G = texture2D(tex, uv                               );\n            vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\n            vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\n            vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\n            vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\n            vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\n            vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\n\n            vec2 div = (1.0 / 4.0) * vec2(0.5, 0.125);\n\n            vec4 o = (D + E + I + J) * div.x;\n            o += (A + B + G + F) * div.y;\n            o += (B + C + H + G) * div.y;\n            o += (F + G + L + K) * div.y;\n            o += (G + H + M + L) * div.y;\n\n            return o;\n        }\n\n        // Standard box filtering\n        vec4 DownsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n        {\n            vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\n\n            vec4 s;\n            s =  (texture2D(tex, uv + d.xy));\n            s += (texture2D(tex, uv + d.zy));\n            s += (texture2D(tex, uv + d.xw));\n            s += (texture2D(tex, uv + d.zw));\n\n            return s * (1.0 / 4.0);\n        }\n\n        // 9-tap bilinear upsampler (tent filter)\n        vec4 UpsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n        {\n            vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\n\n            vec4 s;\n            s =  texture2D(tex, uv - d.xy);\n            s += texture2D(tex, uv - d.wy) * 2.0;\n            s += texture2D(tex, uv - d.zy);\n\n            s += texture2D(tex, uv + d.zw) * 2.0;\n            s += texture2D(tex, uv       ) * 4.0;\n            s += texture2D(tex, uv + d.xw) * 2.0;\n\n            s += texture2D(tex, uv + d.zy);\n            s += texture2D(tex, uv + d.wy) * 2.0;\n            s += texture2D(tex, uv + d.xy);\n\n            return s * (1.0 / 16.0);\n        }\n\n        // Standard box filtering\n        vec4 UpsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n        {\n            vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * (sampleScale * 0.5);\n\n            vec4 s;\n            s =  (texture2D(tex, uv + d.xy));\n            s += (texture2D(tex, uv + d.zy));\n            s += (texture2D(tex, uv + d.xw));\n            s += (texture2D(tex, uv + d.zw));\n\n            return s * (1.0 / 4.0);\n        }\n\n        vec4 SafeHDR(vec4 color) {\n          return color;\n        }\n\n        vec2 getTexelSize(sampler2D tex) {\n          return vec2(1.) / mainTextureSize;\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Prefilter\n\n        vec4 Prefilter(vec4 color, vec2 uv)\n        {\n            vec4 _Threshold = vec4(threshold, threshold - knee, knee * 2., 0.25 / knee); // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\n\n            color = min(vec4(_Clamp), color); // clamp to max\n            color = QuadraticThreshold(color, _Threshold.x, _Threshold.yzw);\n            return color;\n        }\n\n        vec4 FragPrefilter13(vec2 uv)\n        {\n            vec4 color = DownsampleBox13Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return Prefilter(SafeHDR(color), uv);\n        }\n\n        vec4 FragPrefilter4(vec2 uv)\n        {\n            vec4 color = DownsampleBox4Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return Prefilter(SafeHDR(color), uv);\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Downsample\n\n        vec4 FragDownsample13(vec2 uv)\n        {\n            vec4 color = DownsampleBox13Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return color;\n        }\n\n        vec4 FragDownsample4(vec2 uv)\n        {\n            vec4 color = DownsampleBox4Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return color;\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Upsample & combine\n\n        vec4 Combine(vec4 bloom, vec2 uv)\n        {\n            vec4 color = texture2D(secondTexture, uv);\n            return bloom + color;\n        }\n\n        vec4 FragUpsampleTent(vec2 uv)\n        {\n            vec4 bloom = UpsampleTent(mainTexture, uv, getTexelSize(mainTexture), vec4(_SampleScale));\n            return Combine(bloom, uv);\n        }\n\n        vec4 FragUpsampleBox(vec2 uv)\n        {\n            vec4 bloom = UpsampleBox(mainTexture, uv, getTexelSize(mainTexture), vec4(_SampleScale));\n            return Combine(bloom, uv);\n        }\n\n        void main() {\n          vec2 uv = gl_FragCoord.xy / screenSize;\n          vec3 col = texture2D(mainTexture, uv).rgb;\n          vec4 outCol = vec4(1, 0, 1, 1);\n\n          if (stage == 6) {\n            gl_FragColor = vec4(col, 1);\n            return;\n          }\n\n          if (stage == 0) {\n            outCol = FragPrefilter13(uv);\n          }\n          else if (stage == 1) {\n            outCol = FragDownsample13(uv);\n          }\n          else if (stage == 2) {\n            outCol = FragUpsampleTent(uv);\n          }\n\n          gl_FragColor = vec4(outCol.xyz, 1);\n        }\n      "}},webgl2:{bloom:{vertex:"\n        #version 300 es\n\n        in vec2 position;\n\n        void main() {\n          gl_Position = vec4(position, 0.0, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        layout (location = 0) out vec4 fragColor;\n\n        uniform vec2 screenSize;\n        uniform sampler2D mainTexture;\n        uniform sampler2D secondTexture;\n        uniform int stage;\n\n        #define EPSILON 1.0e-4\n\n        uniform float _SampleScale;\n        uniform float threshold;\n        uniform float knee;\n        uniform float _Clamp;\n\n        float Max3(float a, float b, float c)\n        {\n          return max(max(a, b), c);\n        }\n\n        vec4 QuadraticThreshold(vec4 color, float threshold, vec3 curve)\n        {\n            // Pixel brightness\n            float br = Max3(color.r, color.g, color.b);\n\n            // Under-threshold part: quadratic curve\n            float rq = clamp(br - curve.x, 0.0, curve.y);\n            rq = curve.z * rq * rq;\n\n            // Combine and apply the brightness response curve.\n            color *= max(rq, br - threshold) / max(br, EPSILON);\n\n            return color;\n        }\n\n        vec4 DownsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n        {\n            vec4 A = texture(tex, uv + texelSize * vec2(-1.0, -1.0));\n            vec4 B = texture(tex, uv + texelSize * vec2( 0.0, -1.0));\n            vec4 C = texture(tex, uv + texelSize * vec2( 1.0, -1.0));\n            vec4 D = texture(tex, uv + texelSize * vec2(-0.5, -0.5));\n            vec4 E = texture(tex, uv + texelSize * vec2( 0.5, -0.5));\n            vec4 F = texture(tex, uv + texelSize * vec2(-1.0,  0.0));\n            vec4 G = texture(tex, uv                               );\n            vec4 H = texture(tex, uv + texelSize * vec2( 1.0,  0.0));\n            vec4 I = texture(tex, uv + texelSize * vec2(-0.5,  0.5));\n            vec4 J = texture(tex, uv + texelSize * vec2( 0.5,  0.5));\n            vec4 K = texture(tex, uv + texelSize * vec2(-1.0,  1.0));\n            vec4 L = texture(tex, uv + texelSize * vec2( 0.0,  1.0));\n            vec4 M = texture(tex, uv + texelSize * vec2( 1.0,  1.0));\n\n            vec2 div = (1.0 / 4.0) * vec2(0.5, 0.125);\n\n            vec4 o = (D + E + I + J) * div.x;\n            o += (A + B + G + F) * div.y;\n            o += (B + C + H + G) * div.y;\n            o += (F + G + L + K) * div.y;\n            o += (G + H + M + L) * div.y;\n\n            return o;\n        }\n\n        // Standard box filtering\n        vec4 DownsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n        {\n            vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\n\n            vec4 s;\n            s =  (texture(tex, uv + d.xy));\n            s += (texture(tex, uv + d.zy));\n            s += (texture(tex, uv + d.xw));\n            s += (texture(tex, uv + d.zw));\n\n            return s * (1.0 / 4.0);\n        }\n\n        // 9-tap bilinear upsampler (tent filter)\n        vec4 UpsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n        {\n            vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\n\n            vec4 s;\n            s =  texture(tex, uv - d.xy);\n            s += texture(tex, uv - d.wy) * 2.0;\n            s += texture(tex, uv - d.zy);\n\n            s += texture(tex, uv + d.zw) * 2.0;\n            s += texture(tex, uv       ) * 4.0;\n            s += texture(tex, uv + d.xw) * 2.0;\n\n            s += texture(tex, uv + d.zy);\n            s += texture(tex, uv + d.wy) * 2.0;\n            s += texture(tex, uv + d.xy);\n\n            return s * (1.0 / 16.0);\n        }\n\n        // Standard box filtering\n        vec4 UpsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n        {\n            vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * (sampleScale * 0.5);\n\n            vec4 s;\n            s =  (texture(tex, uv + d.xy));\n            s += (texture(tex, uv + d.zy));\n            s += (texture(tex, uv + d.xw));\n            s += (texture(tex, uv + d.zw));\n\n            return s * (1.0 / 4.0);\n        }\n\n        vec4 SafeHDR(vec4 color) {\n          return color;\n        }\n\n        vec2 getTexelSize(sampler2D tex) {\n          return vec2(1.) / vec2(textureSize(tex, 0));\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Prefilter\n\n        vec4 Prefilter(vec4 color, vec2 uv)\n        {\n            vec4 _Threshold = vec4(threshold, threshold - knee, knee * 2., 0.25 / knee); // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\n\n            color = min(vec4(_Clamp), color); // clamp to max\n            color = QuadraticThreshold(color, _Threshold.x, _Threshold.yzw);\n            return color;\n        }\n\n        vec4 FragPrefilter13(vec2 uv)\n        {\n            vec4 color = DownsampleBox13Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return Prefilter(SafeHDR(color), uv);\n        }\n\n        vec4 FragPrefilter4(vec2 uv)\n        {\n            vec4 color = DownsampleBox4Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return Prefilter(SafeHDR(color), uv);\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Downsample\n\n        vec4 FragDownsample13(vec2 uv)\n        {\n            vec4 color = DownsampleBox13Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return color;\n        }\n\n        vec4 FragDownsample4(vec2 uv)\n        {\n            vec4 color = DownsampleBox4Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return color;\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Upsample & combine\n\n        vec4 Combine(vec4 bloom, vec2 uv)\n        {\n            vec4 color = texture(secondTexture, uv);\n            return bloom + color;\n        }\n\n        vec4 FragUpsampleTent(vec2 uv)\n        {\n            vec4 bloom = UpsampleTent(mainTexture, uv, getTexelSize(mainTexture), vec4(_SampleScale));\n            return Combine(bloom, uv);\n        }\n\n        vec4 FragUpsampleBox(vec2 uv)\n        {\n            vec4 bloom = UpsampleBox(mainTexture, uv, getTexelSize(mainTexture), vec4(_SampleScale));\n            return Combine(bloom, uv);\n        }\n\n        void main() {\n          vec2 uv = gl_FragCoord.xy / screenSize;\n          vec3 col = texture(mainTexture, uv).rgb;\n          vec4 outCol = vec4(1, 0, 1, 1);\n\n          if (stage == 6) {\n            fragColor = vec4(col, 1);\n            return;\n          }\n\n          // if (stage == 0) {\n          //   outCol = vec3(col.r, 0, 0);\n          // }\n          // else if (stage == 1) {\n          //   outCol = vec3(0, col.g, 0);\n          // }\n          // else if (stage == 2) {\n          //   outCol = vec3(0, 0, col.b);\n          // }\n          // else if (stage == 3) {\n          //   outCol = vec3(0, 0, 0);\n          // }\n\n          if (stage == 0) {\n            outCol = FragPrefilter13(uv);\n          }\n          // else if (stage == 1) {\n          //   outCol = FragPrefilter4(uv);\n          // }\n          else if (stage == 1) {\n            outCol = FragDownsample13(uv);\n          }\n          // else if (stage == 3) {\n          //   outCol = FragDownsample4(uv);\n          // }\n\n          else if (stage == 2) {\n            outCol = FragUpsampleTent(uv);\n          }\n          // else if (stage == 5) {\n          //   outCol = FragUpsampleBox(uv);\n          // }\n\n          fragColor = vec4(outCol.xyz, 1);\n        }\n      "}}};ht(en);var tn=en.webgl1,nn=en.webgl2,rn={webgl1:{equirectangularToCubemap:{vertex:"\n        attribute vec3 position;\n\n        varying vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main() {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        varying vec3 localPos;\n\n        uniform sampler2D equirectangularMap;\n\n        const vec2 invAtan = vec2(0.1591, 0.3183);\n        vec2 SampleSphericalMap(vec3 v) {\n            vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n\n        void main() {\n            vec2 uv = SampleSphericalMap(normalize(localPos)); // make sure to normalize localPos\n            vec3 color = texture2D(equirectangularMap, uv).rgb;\n            \n            gl_FragColor = vec4(color, 1.0);\n        }\n      "}},webgl2:{equirectangularToCubemap:{vertex:"\n        #version 300 es\n        layout (location = 0) in vec3 position;\n\n        out vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main()\n        {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        out vec4 FragColor;\n        in vec3 localPos;\n\n        uniform sampler2D equirectangularMap;\n\n        const vec2 invAtan = vec2(0.1591, 0.3183);\n        vec2 SampleSphericalMap(vec3 v)\n        {\n            vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n\n        void main()\n        {\n            vec2 uv = SampleSphericalMap(normalize(localPos)); // make sure to normalize localPos\n            vec4 color = texture(equirectangularMap, uv);\n            \n            color.rgb *= pow(2., color.a * 255. - (128. + 8.)) * 255.;\n\n            FragColor = vec4(color.rgb, 1.0);\n        }\n      "}}};ht(rn);var on=rn.webgl1,an=rn.webgl2,sn={webgl1:{diffuseCubemap:{vertex:"\n        attribute vec3 position;\n\n        varying vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main() {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        varying vec3 localPos;\n\n        uniform samplerCube environmentMap;\n\n        const float PI = 3.14159265359;\n\n        void main() {\t\t\n            // the sample direction equals the hemisphere's orientation \n            vec3 normal = normalize(localPos);\n          \n            vec3 irradiance = vec3(0.0);  \n\n            vec3 up = vec3(0.0, 1.0, 0.0);\n            vec3 right = normalize(cross(up, normal));\n            up = normalize(cross(normal, right));\n\n            const float sampleDelta = 0.025 / 3.;\n            float nrSamples = 0.0; \n            for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {\n                for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta) {\n                    // spherical to cartesian (in tangent space)\n                    vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n                    // tangent space to world\n                    vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal; \n\n                    irradiance += min(textureCube(environmentMap, sampleVec).rgb, vec3(3000)) * cos(theta) * sin(theta);\n                    nrSamples++;\n                }\n            }\n\n            irradiance = PI * irradiance * (1.0 / float(nrSamples));\n          \n            gl_FragColor = vec4(irradiance, 1.0);\n        }\n      "}},webgl2:{diffuseCubemap:{vertex:"\n        #version 300 es\n        layout (location = 0) in vec3 position;\n\n        out vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main()\n        {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        out vec4 FragColor;\n        in vec3 localPos;\n\n        uniform samplerCube environmentMap;\n        const vec3 maxBrightness = vec3(3000000);\n        const float sampleDelta = 0.025 / 3.;\n\n        const float PI = 3.14159265359;\n\n        void main() {\t\t\n            // the sample direction equals the hemisphere's orientation \n            vec3 normal = normalize(localPos);\n          \n            vec3 irradiance = vec3(0.0);  \n\n            vec3 up = vec3(0.0, 1.0, 0.0);\n            vec3 right = normalize(cross(up, normal));\n            up = normalize(cross(normal, right));\n\n            // FragColor = vec4(texture(environmentMap, normal).rgb, 1.0);\n            // return;\n\n            float nrSamples = 0.0; \n            for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {\n                for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta) {\n                    // spherical to cartesian (in tangent space)\n                    vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n                    // tangent space to world\n                    vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal; \n\n                    vec3 sampleColor = texture(environmentMap, sampleVec).rgb;\n                    // sampleColor = pow(sampleColor, vec3(2.2));\n\n                    irradiance += min(sampleColor, maxBrightness) * cos(theta) * sin(theta);\n                    nrSamples++;\n                }\n            }\n\n            irradiance = PI * irradiance * (1.0 / float(nrSamples));\n            // irradiance = pow(irradiance, vec3(1. / 2.2));\n          \n            FragColor = vec4(irradiance, 1.0);\n        }\n      "}}};ht(sn);var ln=sn.webgl1,cn=sn.webgl2,un={webgl1:{specularCubemap:{vertex:"\n        attribute vec3 position;\n\n        varying vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main() {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        #extension GL_EXT_shader_texture_lod : enable\n        precision highp float;\n\n        #ifndef GL_EXT_shader_texture_lod\n        vec4 textureCubeLodEXT(samplerCube t, vec3 n, float lod) {\n          return textureCube(t, n);\n        }\n        #endif\n\n        varying vec3 localPos;\n\n        uniform samplerCube environmentMap;\n        uniform float roughness;\n\n        const float PI = 3.14159265359;\n\n        float VanDerCorput(int n, int base);\n        vec2 Hammersley(int i, int N);\n        vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);\n        float DistributionGGX(float NdotH, float roughness);\n        float saturate(float x);\n          \n        void main()\n        {\t\t\n            vec3 N = normalize(localPos);    \n            vec3 R = N;\n            vec3 V = R;\n\n            const int SAMPLE_COUNT = 512;\n            // const int SAMPLE_COUNT = 4096;\n\n            float totalWeight = 0.0;\n            vec3 prefilteredColor = vec3(0.0);\n\n            float resolution = 1024.0; // resolution of source cubemap (per face)\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n\n            for(int i = 0; i < SAMPLE_COUNT; ++i)\n            {\n                vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n                vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n                vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n                float NdotL = max(dot(N, L), 0.0);\n                if(NdotL > 0.0)\n                {\n                    float NdotH = saturate(dot(N, H));\n                    float HdotV = saturate(dot(H, V));\n\n                    float D   = DistributionGGX(NdotH, roughness);\n                    float pdf = (D * NdotH / (4.0 * HdotV)) + 0.0001; \n                    float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n                    float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); \n\n                    prefilteredColor += min(textureCubeLodEXT(environmentMap, L, mipLevel).rgb, vec3(100)) * NdotL;\n                    totalWeight      += NdotL;\n                }\n            }\n            prefilteredColor = prefilteredColor / totalWeight;\n\n            gl_FragColor = vec4(prefilteredColor, 1.0);\n        }\n\n        float VanDerCorput(int n, int base)\n        {\n            float invBase = 1.0 / float(base);\n            float denom   = 1.0;\n            float result  = 0.0;\n\n            for(int i = 0; i < 32; ++i)\n            {\n                if(n > 0)\n                {\n                    denom   = mod(float(n), 2.0);\n                    result += denom * invBase;\n                    invBase = invBase / 2.0;\n                    n       = int(float(n) / 2.0);\n                }\n            }\n\n            return result;\n        }\n        // ----------------------------------------------------------------------------\n        vec2 Hammersley(int i, int N)\n        {\n            return vec2(float(i)/float(N), VanDerCorput(i, 2));\n        }\n\n        vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n        {\n            float a = roughness*roughness;\n          \n            float phi = 2.0 * PI * Xi.x;\n            float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n            float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n          \n            // from spherical coordinates to cartesian coordinates\n            vec3 H;\n            H.x = cos(phi) * sinTheta;\n            H.y = sin(phi) * sinTheta;\n            H.z = cosTheta;\n          \n            // from tangent-space vector to world-space sample vector\n            vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n            vec3 tangent   = normalize(cross(up, N));\n            vec3 bitangent = cross(N, tangent);\n          \n            vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n            return normalize(sampleVec);\n        }\n\n        float DistributionGGX(float NdotH, float roughness)\n        {\n            float a      = roughness*roughness;\n            float a2     = a*a;\n            float NdotH2 = NdotH*NdotH;\n          \n            float nom   = a2;\n            float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n            denom = PI * denom * denom;\n          \n            return nom / denom;\n        }\n\n        float saturate(float x) {\n            return max(0., min(1., x));\n        }\n      "}},webgl2:{specularCubemap:{vertex:"\n        #version 300 es\n        layout (location = 0) in vec3 position;\n\n        out vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main()\n        {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        out vec4 FragColor;\n        in vec3 localPos;\n\n        uniform samplerCube environmentMap;\n        uniform float roughness;\n\n        const float PI = 3.14159265359;\n\n        float RadicalInverse_VdC(uint bits);\n        vec2 Hammersley(uint i, uint N);\n        vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);\n        float DistributionGGX(float NdotH, float roughness);\n        float saturate(float x);\n\n        // Settings\n        const uint SAMPLE_COUNT = 1024u;//4096u * 4u;\n        const vec3 maxBrightness = vec3(50);\n        // --------\n          \n        void main()\n        {\t\t\n            vec3 N = normalize(localPos);    \n            vec3 R = N;\n            vec3 V = R;\n\n            float totalWeight = 0.0;\n            vec3 prefilteredColor = vec3(0.0);\n\n            float resolution = float(textureSize(environmentMap, 0).x);//1024.0; // resolution of source cubemap (per face)\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n\n            for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n            {\n                vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n                vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n                vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n                float NdotL = max(dot(N, L), 0.0);\n                if(NdotL > 0.0)\n                {\n                    float NdotH = saturate(dot(N, H));\n                    float HdotV = saturate(dot(H, V));\n\n                    float D   = DistributionGGX(NdotH, roughness);\n                    float pdf = (D * NdotH / (4.0 * HdotV)) + 0.0001; \n                    float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n                    float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); \n\n                    prefilteredColor += min(textureLod(environmentMap, L, mipLevel).rgb, maxBrightness) * NdotL;\n                    totalWeight      += NdotL;\n                }\n            }\n            prefilteredColor = prefilteredColor / totalWeight;\n\n            FragColor = vec4(prefilteredColor, 1.0);\n        }\n\n        float RadicalInverse_VdC(uint bits) \n        {\n            bits = (bits << 16u) | (bits >> 16u);\n            bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n            bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n            bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n            bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n            return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n        }\n        // ----------------------------------------------------------------------------\n        vec2 Hammersley(uint i, uint N)\n        {\n            return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n        }\n\n        vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n        {\n            float a = roughness*roughness;\n          \n            float phi = 2.0 * PI * Xi.x;\n            float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n            float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n          \n            // from spherical coordinates to cartesian coordinates\n            vec3 H;\n            H.x = cos(phi) * sinTheta;\n            H.y = sin(phi) * sinTheta;\n            H.z = cosTheta;\n          \n            // from tangent-space vector to world-space sample vector\n            vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n            vec3 tangent   = normalize(cross(up, N));\n            vec3 bitangent = cross(N, tangent);\n          \n            vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n            return normalize(sampleVec);\n        }\n\n        float DistributionGGX(float NdotH, float roughness)\n        {\n            float a      = roughness*roughness;\n            float a2     = a*a;\n            float NdotH2 = NdotH*NdotH;\n          \n            float nom   = a2;\n            float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n            denom = PI * denom * denom;\n          \n            return nom / denom;\n        }\n\n        float saturate(float x) {\n            return max(0., min(1., x));\n        }\n      "}}};ht(un);var hn=un.webgl1,fn=un.webgl2,dn=`\n${lt}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent;\nin vec3 color;\nin vec2 uv;\n\nout vec4 vPosition;\nout vec3 vNormal;\nout vec4 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvoid main() {\n  vNormal = mat3(modelMatrix) * normal; // in world-space\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(normal, vTangent.xyz) * vTangent.w, 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  vPosition = worldPosition;\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n`,mn=`\n${lt}\n\nlayout (location = 0) out vec4 gPosition;\nlayout (location = 1) out vec3 gNormal;\nlayout (location = 2) out vec3 gAlbedo;\nlayout (location = 3) out vec4 gProperties;\nlayout (location = 4) out vec4 gPositionViewSpace;\n\nin vec4 vPosition;\nin vec3 vNormal;\nin vec4 vTangent;\nin vec3 vColor;\nin vec2 vUV;\nin mat3 vTBN;\n\nuniform float enableMotionBlur;\n\n// Material properties\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform sampler2D normalTexture;\nuniform bool useNormalTexture;\nuniform sampler2D metallicRoughnessTexture;\nuniform bool useMetallicRoughnessTexture;\nuniform sampler2D emissiveTexture;\nuniform bool useEmissiveTexture;\nuniform sampler2D occlusionTexture;\nuniform bool useOcclusionTexture;\n\nuniform vec4 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform vec3 emissiveFactor;\nfloat ao = 1.;\n\nuniform float alphaCutoff;\nuniform float normalStrength;\n\nuniform mat4 viewMatrix;\n\nvec3 setNormalStrength(vec3 normal, float strength) {\n  return vec3(normal.xy * strength, mix(1., normal.z, clamp(strength, 0., 1.)));\n}\n\nvoid main() {\n  vec4 _albedo = albedo * (useTexture ? texture(albedoTexture, vUV) : vec4(1));\n  if (_albedo.a < alphaCutoff) {\n    discard;\n  }\n\n  gPosition = vec4(vPosition.xyz, 1);\n  gPositionViewSpace = viewMatrix * vPosition;\n\n  if (useNormalTexture) {\n    vec3 _tangentNormal = texture(normalTexture, vUV).rgb;\n    _tangentNormal = _tangentNormal * 2. - 1.;\n    _tangentNormal = setNormalStrength(_tangentNormal, normalStrength);\n    gNormal = normalize(vTBN * _tangentNormal);\n  }\n  else {\n    gNormal = normalize(vNormal);\n  }\n\n  if (!gl_FrontFacing) {\n    gNormal *= -1.;\n  }\n\n  gAlbedo = _albedo.rgb + emissiveFactor;\n\n  float _metallic = metallic;\n  float _roughness = roughness;\n  if (useMetallicRoughnessTexture) {\n    vec3 ts = texture(metallicRoughnessTexture, vUV).rgb;\n    _metallic *= ts.b;\n    _roughness *= ts.g;\n  }\n  gProperties = vec4(_roughness, _metallic, enableMotionBlur, 1);\n}\n`;dn=dn.trim(),mn=mn.trim();var vn=`\n${lt}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent;\nin vec3 color;\nin vec2 uv;\nin mat4 modelMatrix;\n\nout vec4 vPosition;\nout vec3 vNormal;\nout vec4 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\nout mat4 vModelMatrix;\n\n// const int levels = 2;\n\n// uniform sharedPerScene {\n//   mat4 projectionMatrix;\n//   mat4 viewMatrix;\n//   mat4 inverseViewMatrix;\n//   float biases[levels];\n// };\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\n\n// //Shadows\n// uniform mat4 textureMatrices[levels];\n// out vec4 projectedTexcoords[levels];\n\nvoid main() {\n  vNormal = mat3(modelMatrix) * normal; // in world-space\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n  vModelMatrix = modelMatrix;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(vNormal, vTangent.xyz) * vTangent.w, 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * vec4(vNormal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  // for (int i = 0; i < levels; i++) {\n  //   projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  // }\n\n  vPosition = worldPosition;\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n`,pn=mn;pn=(pn=pn.replace(/modelMatrix/g,"vModelMatrix")).replace(/uniform mat4 vModelMatrix/g,"in mat4 vModelMatrix"),vn=vn.trim(),pn=pn.trim();var gn=`\n${lt}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent;\nin vec3 color;\nin vec2 uv;\n\nout vec4 vPosition;\nout vec3 vNormal;\nout vec4 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n//Skinning\nin vec4 weights;\nin vec4 joints;\n\nuniform sampler2D u_jointTexture;\nuniform float u_numJoints;\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.)\n#define ROW1_U ((0.5 + 1.0) / 4.)\n#define ROW2_U ((0.5 + 2.0) / 4.)\n#define ROW3_U ((0.5 + 3.0) / 4.)\n\nmat4 getBoneMatrix(float jointNdx) {\n  float v = (jointNdx + 0.5) / u_numJoints;\n  return mat4(\n    texture(u_jointTexture, vec2(ROW0_U, v)),\n    texture(u_jointTexture, vec2(ROW1_U, v)),\n    texture(u_jointTexture, vec2(ROW2_U, v)),\n    texture(u_jointTexture, vec2(ROW3_U, v))\n  );\n}\n\nvoid main() {\n  mat4 skinMatrix = getBoneMatrix(joints[0]) * weights[0] +\n                    getBoneMatrix(joints[1]) * weights[1] +\n                    getBoneMatrix(joints[2]) * weights[2] +\n                    getBoneMatrix(joints[3]) * weights[3];\n\n  vNormal = mat3(modelMatrix * skinMatrix) * normal; // in world-space\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vec3 _T = normalize(vec3(modelMatrix * skinMatrix * modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * skinMatrix * modelMatrix * vec4(cross(normal, vTangent.xyz) * vTangent.w, 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * skinMatrix * modelMatrix * vec4(normal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * skinMatrix * vec4(position, 1.0);\n  vPosition = worldPosition;\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n`,xn=mn;gn=gn.trim(),xn=xn.trim();var bn=ct,yn=`\n${lt}\n\n// #define DEBUG_NORMAL\n// #define DEBUG_ALBEDO\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec4 motionVector;\n\nuniform vec2 SIZE;\n\nuniform sampler2D gPosition;\nuniform sampler2D gNormal;\nuniform sampler2D gAlbedo;\nuniform sampler2D gProperties;\n\nstruct LightInfo {\n  int type;\n  vec3 position;\n  vec3 direction;\n  float angle;\n  vec3 color;\n};\nconst int maxLights = 8;\nuniform LightInfo lights[maxLights];\nuniform int nrLights;\n\nuniform vec3 sunDirection;\nuniform vec3 sunIntensity;\nuniform float environmentIntensity;\nuniform vec3 ambientColor;\n\nuniform samplerCube u_diffuseIBL;\nuniform samplerCube u_specularIBL;\nuniform sampler2D u_splitSum;\n\nuniform mat4 inverseViewMatrix;\n\n// Motion blur\nuniform mat4 projectionMatrix;\nuniform mat4 prevViewMatrix;\nuniform mat4 viewMatrix;\n\n// FOG\n\n#define USEFOG\nuniform vec4 fogColor;\nuniform float fogDensity;\n\nvec3 applyFog(vec3 color, vec3 worldPosition) {\n  float distance = length(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - worldPosition);\n  float fogAmount = exp(-pow(distance * fogDensity, 2.));\n  \n  return mix(fogColor.rgb, color, fogAmount);\n}\n\n//\n\n\nbool doNoTiling = false;\n\nconst float PI = 3.141592;\n\n// No tiling\nvec4 hash4( vec2 p ) {\n  return fract(sin(vec4(1.0+dot(p,vec2(37.0,17.0)), \n                        2.0+dot(p,vec2(11.0,47.0)),\n                        3.0+dot(p,vec2(41.0,29.0)),\n                        4.0+dot(p,vec2(23.0,31.0))))*103.0);\n}\n\nvec3 textureNoTile( sampler2D samp, in vec2 uv, float v ) {\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n  \n    // derivatives (for correct mipmapping)\n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n    \n  vec3 va = vec3(0.0);\n  float w1 = 0.0;\n    float w2 = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n    vec4 o = hash4( p + g );\n    vec2 r = g - f + o.xy;\n    float d = dot(r,r);\n        float w = exp(-5.0*d );\n        vec3 c = textureGrad( samp, uv + v*o.zw, ddx, ddy ).xyz;\n    va += w*c;\n    w1 += w;\n        w2 += w*w;\n    }\n    \n    // normal averaging --\x3e lowers contrasts\n    return va/w1;\n\n    // contrast preserving average\n    float mean = 0.3;// textureGrad( samp, uv, ddx*16.0, ddy*16.0 ).x;\n    vec3 res = mean + (va-w1*mean)/sqrt(w2);\n    return mix( va/w1, res, v );\n}\n\n// Texture sampling\nvec4 sampleTexture(sampler2D samp, vec2 uv) {\n  if (doNoTiling) {\n    return vec4(textureNoTile(samp, uv, 1.), 1);\n  }\n  else {\n    return texture(samp, uv);\n  }\n}\n\n//Normal map\nvec3 setNormalStrength(vec3 normal, float strength) {\n  return vec3(normal.xy * strength, mix(1., normal.z, clamp(strength, 0., 1.)));\n}\n\n// vec3 sampleNormalTexture(sampler2D texture, vec2 uv) {\n//   return sampleTexture(texture, uv).rgb * 2. - 1.\n// }\n\n// PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0); // trying this\n  // return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n} \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n  float a      = roughness*roughness;\n  float a2     = a*a;\n  float NdotH  = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH*NdotH;\n\n  float num   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n\n  return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r*r) / 8.0;\n\n  float num   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 F0 = vec3(scalarF0);\n  F0 = mix(F0, albedo, metallic);\n  vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.), F0, roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - metallic;\t  \n    \n  vec3 irradiance = texture(u_diffuseIBL, N).rgb;\n  vec3 diffuse  = irradiance * albedo;\n    \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureLod(u_specularIBL, R, roughness * MAX_REFLECTION_LOD).rgb;\n\n  vec2 uv = vec2(max(dot(N, V), 0.), roughness);\n  uv.y = 1. - uv.y;\n  vec2 envBRDF = texture(u_splitSum, uv).rg;\n\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n  vec3 ambient = (kD * diffuse + specular) * environmentIntensity;\n\n  return ambient;\n}\n\nvec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 L = normalize(lightDir);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;\n  vec3 specular     = nominator / denominator;\n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n\n  kD *= 1.0 - metallic;\n  float NdotL = max(dot(N, L), 0.0);\n\n  vec3 finalColor = (kD * albedo / PI + specular) * radiance * NdotL;\n  return finalColor;\n}\n\nvec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec3 Spotlight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 dir, float angle, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 currentDir = normalize(worldPos - lightPos);\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n\n  float sharpness = 5.;\n  attenuation *= clamp((dot(currentDir, dir) - cos(angle)) * sharpness, 0., 1.);\n\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);\n  \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nconst int levels = 2;\n\nvec4 projectedTexcoords[levels];\nuniform float biases[levels];\nuniform sampler2D projectedTextures[levels];\nuniform mat4 textureMatrices[levels];\n\n${ut}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / SIZE;\n\n  vec3 position = texture(gPosition, uv).rgb;\n  vec3 normal = texture(gNormal, uv).rgb;\n  vec3 albedo = texture(gAlbedo, uv).rgb;\n  vec4 properties = texture(gProperties, uv);\n\n  float blurFactor = properties.b;\n\n  vec4 prevClipSpace = projectionMatrix * prevViewMatrix * vec4(position, 1.0);\n  vec4 clipSpace = projectionMatrix * viewMatrix * vec4(position, 1.0);\n\n  vec3 NDCPos = (clipSpace / clipSpace.w).xyz;\n  vec3 PrevNDCPos = (prevClipSpace / prevClipSpace.w).xyz;\n  vec2 mv = blurFactor * (NDCPos - PrevNDCPos).xy * 0.5 + 0.5;\n  motionVector = vec4(mv, 0, 1);\n\n  if (normal == vec3(0)) {\n    discard;\n  }\n\n  #ifdef DEBUG_ALBEDO\n  fragColor = vec4(albedo, 1);\n  return;\n  #endif\n\n  #ifdef DEBUG_NORMAL\n  fragColor = vec4(normal, 1);\n  return;\n  #endif\n\n  float _ao = 1.;\n  float _roughness = properties.r;\n  float _metallic = properties.g;\n  vec3 _emission = vec3(0);\n\n  _roughness = clamp(_roughness, 0.01, 0.99);\n\n  vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - position);\n  vec3 N = normal;\n  vec3 R = reflect(-V, N);\n\n  float f0 = 0.04;\n\n  vec3 col = vec3(0);\n  // col += ambientColor;\n\n  for (int i = 0; i < levels; i++) {\n    projectedTexcoords[i] = textureMatrices[i] * vec4(position, 1);\n  }\n  float shadowAmount = getShadowAmount(position, dot(N, sunDirection.xyz));\n\n  col += IBL(N, V, R, albedo, _metallic, _roughness, f0) * _ao * (environmentMinLight + shadowAmount * (1. - environmentMinLight));\n  \n  if (sunIntensity.xyz != vec3(0) && shadowAmount > 0.01) {\n    col += DirectionalLight(position, N, V, sunDirection.xyz, sunIntensity.xyz, albedo, _metallic, _roughness, f0) * _ao * shadowAmount;\n  }\n\n  for (int i = 0; i < int(nrLights); i++) {\n    LightInfo light = lights[i];\n    if (light.type == 0) {\n      col += PositionalLight(position, N, V, light.position, light.color, albedo.rgb, _metallic, _roughness, f0);\n    }\n    else if (light.type == 1) {\n      col += Spotlight(position, N, V, light.position, light.direction, light.angle, light.color, albedo.rgb, _metallic, _roughness, f0);\n    }\n    else if (light.type == 2) {\n      col += DirectionalLight(position, N, V, light.direction, light.color, albedo.rgb, _metallic, _roughness, f0);\n    }\n  }\n\n  col += _emission;\n\n  #ifdef USEFOG\n    col = applyFog(col, position);\n  #endif\n\n  fragColor = vec4(col, 1);\n}\n`;bn=bn.trim(),yn=yn.trim();var Tn=ct,wn=`\n${lt}\n\nuniform float scale;\n\nuniform mat4 lensProjection;\nuniform mat4 inverseViewMatrix;\nuniform mat4 viewMatrix;\n\nuniform sampler2D albedoTexture;\nuniform sampler2D positionTexture;\nuniform sampler2D normalTexture;\nuniform sampler2D propertiesTexture;\n\nuniform float maxRoughness;\nuniform float maxDistance;\nuniform float resolution;\nuniform int steps;\nuniform float thickness;\n\n// uniform sampler2D maskTexture;\n// uniform vec2 enabled;\n\nout vec4 fragColor;\n\nvec4 getSceneViewPos(vec2 uv) {\n  vec4 worldPos = texture(positionTexture, uv);\n  if (worldPos.xyz == vec3(0)) {\n    return vec4(0, 0, -1000, 0);\n  }\n\n  // return viewMatrix * vec4(worldPos.rgb, 1);\n  return worldPos;\n}\n\nbool isUVOutside(vec2 uv) {\n  return uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.;\n}\n\nfloat fadeOutUVBorder(vec2 uv, float falloffX, float falloffY) {\n  return smoothstep(0., falloffX, uv.x) * smoothstep(1., 1. - falloffX, uv.x) * smoothstep(0., falloffY, uv.y) * smoothstep(1., 1. - falloffY, uv.y);\n}\n\nfloat random(vec3 seed, int i){\n  vec4 seed4 = vec4(seed,i);\n  float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));\n  return fract(sin(dot_product) * 43758.5453);\n}\n\nvoid main() {\n  // vec2 texSize = vec2(textureSize(positionTexture, 0).xy) * scale;\n  // vec2 texCoord = gl_FragCoord.xy / texSize;\n\n  // if (texture(propertiesTexture, texCoord).r > 0.5) {\n  //   fragColor = vec4(0);\n  //   return;\n  // }\n\n  // vec3 worldNormal = texture(normalTexture, texCoord).xyz;\n  // if (worldNormal == vec3(0)) {\n  //   fragColor = vec4(0);\n  //   return;\n  // }\n\n  // const float maxDistance = 64.;\n\n  // vec3 origin = getSceneViewPos(texCoord).xyz;\n  // vec3 viewNormal = normalize(mat3(viewMatrix) * worldNormal);\n  // vec3 cameraToWorld = normalize(origin);\n  // vec3 rayDirection = normalize(reflect(cameraToWorld, viewNormal));\n  // vec3 end = origin + rayDirection * maxDistance;\n  // // origin += rayDirection * 15.1;\n  // // origin += viewNormal * 0.1;\n\n  // const int initialSteps = 200;\n\n  // // fragColor = vec4(rayDirection, 1);\n  // // return;\n\n  // for (int i = 0; i < initialSteps; i++) {\n  //   vec3 currentView = mix(origin, end, float(i) / float(initialSteps - 1));\n\n  //   vec4 currentScreen = vec4(currentView, 1);\n  //   currentScreen = lensProjection * currentScreen;\n  //   currentScreen.xyz /= currentScreen.w;\n  //   currentScreen.xy = currentScreen.xy * 0.5 + 0.5;\n  //   // currentScreen.xy *= texSize;\n\n  //   if (isUVOutside(currentScreen.xy)) {\n  //     break;\n  //   }\n\n  //   float sceneDepth = getSceneViewPos(currentScreen.xy).z;\n  //   float deltaDepth = (sceneDepth - currentView.z);\n\n  //   if (deltaDepth > 0. && deltaDepth < 10.) {\n  //     fragColor = vec4(texture(albedoTexture, currentScreen.xy).rgb, 1);\n  //     // fragColor = vec4(float(i) / float(initialSteps - 1), 0, 0, 1);\n  //     return;\n  //   }\n  // }\n\n  // fragColor = vec4(0, 0, 1, 1);\n  // return;\n\n\n\n\n\n\n\n\n  vec2 texSize  = vec2(textureSize(positionTexture, 0).xy) * scale;\n  vec2 texCoord = gl_FragCoord.xy / texSize;\n\n  vec4 uv = vec4(0.0);\n\n  vec4 positionFrom = getSceneViewPos(texCoord);\n  // vec4 positionFrom = texture(positionTexture, texCoord);\n  // positionFrom.y *= -1.;\n  // vec4 mask         = texture(maskTexture,     texCoord);\n\n  // fragColor = vec4(getSceneViewPos(texCoord).z * 0.01, 0, 0, 1);\n  // return;\n\n  // fragColor = vec4(texture(albedoTexture, texCoord).rgb, 1);\n  // return;\n\n  // fragColor = texture(positionTexture, texCoord);\n  // // fragColor = viewMatrix * vec4(texture(positionTexture, texCoord).rgb, 1);\n  // return;\n\n  // fragColor = vec4(texCoord, 0, 1);\n  // return;\n\n  // fragColor = vec4(texture(propertiesTexture, texCoord).rgb, 1);\n  // return;\n\n  float roughness = texture(propertiesTexture, texCoord).r;\n  if (\n    // positionFrom.w <= 0.0\n    //  || enabled.x      != 1.0\n    //  || mask.r         <= 0.0\n    roughness > maxRoughness || positionFrom.a == 0.\n  ) {\n    fragColor = vec4(0);\n    return;\n\n    // fragColor = uv;\n    fragColor = vec4(texture(albedoTexture, texCoord).rgb, 1);\n    return;\n  }\n\n  vec3 worldNormal = texture(normalTexture, texCoord).xyz;\n  if (worldNormal == vec3(0)) {\n    fragColor = vec4(0);\n    return;\n\n    fragColor = vec4(texture(albedoTexture, texCoord).rgb, 1);\n    return;\n  }\n\n  vec3 unitPositionFrom = normalize(positionFrom.xyz);\n  vec3 normal           = normalize(mat3(viewMatrix) * worldNormal);\n\n  // fragColor = vec4(normal, 1);\n  // return;\n\n  vec3 pivot            = normalize(reflect(unitPositionFrom, normal));\n  \n  vec4 positionTo = positionFrom;\n\n  vec4 startView = vec4(positionFrom.xyz + (pivot *         (0.01)), 1.0);\n  vec4 endView   = vec4(positionFrom.xyz + (pivot * maxDistance), 1.0);\n\n  // if (endView.z > 0.) {\n  //   fragColor = vec4(1, 0.5, 0, 1);\n  //   return;\n  // }\n\n  vec2 poissonDisk[16] = vec2[]( \n    vec2( -0.94201624, -0.39906216 ), \n    vec2( 0.94558609, -0.76890725 ), \n    vec2( -0.094184101, -0.92938870 ), \n    vec2( 0.34495938, 0.29387760 ), \n    vec2( -0.91588581, 0.45771432 ), \n    vec2( -0.81544232, -0.87912464 ), \n    vec2( -0.38277543, 0.27676845 ), \n    vec2( 0.97484398, 0.75648379 ), \n    vec2( 0.44323325, -0.97511554 ), \n    vec2( 0.53742981, -0.47373420 ), \n    vec2( -0.26496911, -0.41893023 ), \n    vec2( 0.79197514, 0.19090188 ), \n    vec2( -0.24188840, 0.99706507 ), \n    vec2( -0.81409955, 0.91437590 ), \n    vec2( 0.19984126, 0.78641367 ), \n    vec2( 0.14383161, -0.14100790 ) \n  );\n\n  // int index = int(16.0*random(floor(startView.xyz*1000.0), 0))%16;\n  // startView.xy += poissonDisk[index] * 0.05;\n\n  vec4 startFrag      = startView;\n       startFrag      = lensProjection * startFrag;\n       startFrag.xyz /= startFrag.w;\n       startFrag.xy   = startFrag.xy * 0.5 + 0.5;\n       startFrag.xy  *= texSize;\n\n  vec4 endFrag      = endView;\n       endFrag      = lensProjection * endFrag;\n       endFrag.xyz /= endFrag.w;\n       endFrag.xy   = endFrag.xy * 0.5 + 0.5;\n       endFrag.xy  *= texSize;\n\n  vec2 frag  = startFrag.xy;\n       uv.xy = frag / texSize;\n\n  float deltaX    = endFrag.x - startFrag.x;\n  float deltaY    = endFrag.y - startFrag.y;\n  float useX      = abs(deltaX) >= abs(deltaY) ? 1.0 : 0.0;\n  float delta     = mix(abs(deltaY), abs(deltaX), useX) * clamp(resolution, 0.0, 1.0);\n  vec2  increment = vec2(deltaX, deltaY) / max(delta, 0.001);\n\n  float search0 = 0.;\n  float search1 = 0.;\n\n  int hit0 = 0;\n  int hit1 = 0;\n\n  float viewDistance = startView.y;\n  float depth        = thickness;\n\n  int i = 0;\n\n  for (i = 0; i < int(min(delta, 1000.)); ++i) {\n    frag      += increment;\n    uv.xy      = frag / texSize;\n\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) {\n      fragColor = vec4(0);\n      return;\n      \n      fragColor = vec4(texture(albedoTexture, texCoord).rgb, 1);\n      // fragColor = vec4(0, 1, 0, 1);\n      return;\n    }\n\n    // vec4 worldPos = texture(positionTexture, uv.xy);\n    // positionTo = viewMatrix * vec4(worldPos.rgb, 1);\n    // // positionTo = texture(positionTexture, uv.xy);\n    // // positionTo.y *= -1.;\n\n    positionTo = getSceneViewPos(uv.xy);\n\n    search1 =\n      mix\n        ( (frag.y - startFrag.y) / deltaY\n        , (frag.x - startFrag.x) / deltaX\n        , useX\n        );\n\n    search1 = clamp(search1, 0.0, 1.0);\n\n    viewDistance = -sign(endView.z) * (startView.z * endView.z) / mix(endView.z, startView.z, search1);\n    depth        = -(viewDistance - positionTo.z);\n\n    if (viewDistance > 0.) {\n      break;\n    }\n\n    // viewDistance = (startView.y * endView.y) / mix(endView.y, startView.y, search1);\n    // depth        = viewDistance - positionTo.y;\n\n    if (depth > 0. && depth < thickness) {\n      hit0 = 1;\n\n      // // // fragColor = vec4(uv.xy, 0, 1);\n      // fragColor = vec4(0, 0, depth, 1);\n      // // fragColor = vec4(texture(albedoTexture, uv.xy).rgb * vec3(1, 0.5, 0.5), 1);\n      // return;\n\n      break;\n    } else {\n      search0 = search1;\n    }\n  }\n\n  // fragColor = vec4(uv.xy, 0, 1);\n  // return;\n\n  search1 = search0 + ((search1 - search0) / 2.0);\n\n  int currentSteps = steps;\n  currentSteps *= hit0;\n\n  for (i = 0; i < currentSteps; ++i) {\n    frag       = mix(startFrag.xy, endFrag.xy, search1);\n    uv.xy      = frag / texSize;\n\n    // // positionTo = viewMatrix * vec4(texture(positionTexture, uv.xy).rgb, 1);\n    // // // positionTo = texture(positionTexture, uv.xy);\n    // // // positionTo.y *= -1.;\n\n    // vec4 worldPos = texture(positionTexture, uv.xy);\n    // positionTo = viewMatrix * vec4(worldPos.rgb, 1);\n    // // positionTo = texture(positionTexture, uv.xy);\n\n    // if (worldPos.a < 0.01) {\n    //   positionTo = vec4(vec3(1000), 0);\n    // }\n\n    positionTo = getSceneViewPos(uv.xy);\n\n    viewDistance = (startView.z * endView.z) / mix(endView.z, startView.z, search1);\n    depth        = -(viewDistance - positionTo.z);\n\n    // viewDistance = (startView.y * endView.y) / mix(endView.y, startView.y, search1);\n    // depth        = viewDistance - positionTo.y;\n\n    float fineThickness = 0.1;\n    if (depth > -fineThickness * 0.05 && depth < fineThickness) {\n      hit1 = 1;\n      // break;\n    }\n\n    if (depth > 0. && depth < thickness) {\n      search1 = search0 + ((search1 - search0) / 2.);\n    } else {\n      float temp = search1;\n      search1 = search1 + ((search1 - search0) / 2.);\n      search0 = temp;\n    }\n  }\n\n  float visibility =\n    1.\n    * float(hit1)\n    * positionTo.w\n    * ( 1. - max(dot(-unitPositionFrom, pivot), 0.))\n    * ( 1. - clamp(depth / thickness, 0., 1.))\n    * ( 1. - clamp(length(positionTo.xyz - positionFrom.xyz) / maxDistance, 0., 1.))\n    * fadeOutUVBorder(uv.xy, 0.1, 0.1)\n    * (1. - roughness);\n\n  visibility = clamp(visibility, 0., 1.);\n\n  vec3 reflectedColor = texture(albedoTexture, uv.xy).rgb;\n  fragColor = vec4(mix(vec3(0), reflectedColor, visibility), visibility);\n\n  // uv.ba = vec2(visibility);\n  // uv.ba = vec2(1);\n\n  // fragColor = uv;\n\n  // vec3 baseColor = texture(albedoTexture, texCoord.xy).rgb;\n  // vec3 reflectedColor = texture(albedoTexture, uv.xy).rgb;\n\n  // fragColor = vec4(mix(baseColor, reflectedColor, visibility), 1);\n\n  // fragColor = vec4(baseColor, 1);\n}\n`;Tn=Tn.trim(),wn=wn.trim();var En=ct,Mn=`\n${lt}\n\nuniform sampler2D combinedTexture;\nuniform sampler2D ssrTexture;\nuniform vec2 SIZE;\nuniform float scale;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / SIZE;\n  \n  vec3 combinedColor = texture(combinedTexture, uv).rgb;\n  vec4 ssrColor = texture(ssrTexture, uv * scale);\n\n  fragColor = vec4(mix(combinedColor, ssrColor.rgb, ssrColor.a), 1);\n}\n`;En=En.trim(),Mn=Mn.trim();var _n=ct,Rn=`\n${lt}\nout vec4 fragColor;\n\nuniform vec2 SIZE;\nuniform sampler2D imageTexture;\nuniform bool horizontal;\nuniform int radius;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / SIZE;\n  vec2 texelSize = 1. / vec2(textureSize(imageTexture, 0));\n\n  vec4 col = vec4(0);\n\n  for (int i = -radius; i <= radius; i++) {\n    col += texture(imageTexture, uv + texelSize * float(i) * vec2(horizontal, 1 - int(horizontal)));\n  }\n\n  col /= float(radius * 2 + 1);\n\n  fragColor = col;\n  // fragColor = vec4(col.rgb, texture(imageTexture, uv).a);\n}\n`;_n=_n.trim(),Rn=Rn.trim();let Cn=new X,Fn=new X,An=new X;function Dn(e,t){function n(t,n){return(n=n||new X).x=e[3*t],n.y=e[3*t+1],n.z=e[3*t+2],n}if(t){var r=new Array(e.length/3);for(let e=0;e<r.length;e++)r[e]=[];var i=t;for(let e=0;e<i.length;e+=3){n(i[e],Cn),n(i[e+1],Fn),n(i[e+2],An);let t=he([Cn,Fn,An]);r[i[e]].push(t),r[i[e+1]].push(t),r[i[e+2]].push(t)}var o=[];for(let e=0;e<r.length;e++){let t=X.divide(r[e].reduce(((e,t)=>X.add(e,t)),X.zero()),r[e].length);o.push(t.x,t.y,t.z)}return new Float32Array(o)}var a=new Float32Array(e.length);for(let t=0;t<e.length/3;t+=3){n(t,Cn),n(t+1,Fn),n(t+2,An);let e=he([Cn,Fn,An]);a[3*t]=e.x,a[3*t+1]=e.y,a[3*t+2]=e.z,a[3*(t+1)]=e.x,a[3*(t+1)+1]=e.y,a[3*(t+1)+2]=e.z,a[3*(t+2)]=e.x,a[3*(t+2)+1]=e.y,a[3*(t+2)+2]=e.z}return a}function Pn(e,t,n){function r(t){return[e[3*t],e[3*t+1],e[3*t+2]]}function i(e){return[n[2*e],n[2*e+1]]}function o(e,t){for(var n=new Array(e.length),r=0;r<e.length;r++)n[r]=e[r]-t[r];return n}function a(e,t,n,a){var l,c=r(t),u=r(n),h=r(a),f=i(t),d=i(n),m=i(a),v=o(u,c),p=o(h,c),g=o(d,f),x=o(m,f),b=1/(g[0]*x[1]-g[1]*x[0]);if(isNaN(b)||!isFinite(b)){s++;var y=he([X.fromArray(c),X.fromArray(u),X.fromArray(h)]);l=X.toArray(X.findOrthogonal(y))}else l=[(v[0]*x[1]-p[0]*g[1])*b,(v[1]*x[1]-p[1]*g[1])*b,(v[2]*x[1]-p[2]*g[1])*b];var T=.01;return l[0]+=T,l[1]+=T,l[2]+=T,e[4*t]=l[0],e[4*t+1]=l[1],e[4*t+2]=l[2],e[4*t+3]=1,e[4*n]=l[0],e[4*n+1]=l[1],e[4*n+2]=l[2],e[4*n+3]=1,e[4*a]=l[0],e[4*a+1]=l[1],e[4*a+2]=l[2],e[4*a+3]=1,l}var s=0,l=new Float32Array(e.length/3*4);if(t){var c=t;for(let e=0;e<c.length;e+=3)a(l,c[e],c[e+1],c[e+2])}else for(let t=0;t<e.length/3;t+=3)a(l,t,t+1,t+2);return s.length>0&&console.warn(s+" tangents generated without UVs"),l}function Sn(e,t,n=!1,r=[]){if(t.meshRenderer)for(var i of t.meshRenderer.materials)(!n&&-1!==i.name.indexOf(e)||n&&i.name==e)&&r.push(i);for(var o of t.children)Sn(e,o,n,r);return r}function Nn(e,t,n){var r=document.createElement("canvas");return r.width=t,r.height=n,r.getContext("2d").drawImage(e,0,0,t,n),r}const Un=function h(f={}){var d,m=this,v=f.renderScale??1;this.debugMode=f.debug??!0,this.catchProgramErrors=f.catchProgramErrors??!!this.debugMode;var x,T=0,w=0;this.startTime=new Date,this.eventHandler=new Ue,this.mouse={x:0,y:0,any:!1,left:!1,right:!1,middle:!1,movement:{x:0,y:0}};var R=[],C=[],F=[];this.currentScene=0,this.scenes=[],this.godrays=null,this.postprocessing=null,this.bloom=null,this.skybox=null,this.shadowCascades=null,this.UBOLocationCounter=0,this.currentBoundLitPrograms=new WeakMap,this.currentBoundMaterials=new WeakMap;var N={};this.programContainers={get skybox(){return oe("skybox",i)},get shadow(){return oe("shadow",o)},get shadowInstanced(){return oe("shadowInstanced",o)},get shadowSkinned(){return oe("shadowSkinned",o)},get postprocessing(){return oe("postprocessing",a)},get bloom(){return oe("bloom",s)},get equirectangularToCubemap(){return oe("equirectangularToCubemap",l)},get diffuseCubemap(){return oe("diffuseCubemap",c)},get specularCubemap(){return oe("specularCubemap",u)},get lit(){return oe("lit",e)},get litSkinned(){return oe("litSkinned",e)},get litInstanced(){return oe("litInstanced",e)},get litTrail(){return oe("litTrail",e)},get unlit(){return oe("unlit",t)},get unlitInstanced(){return oe("unlitInstanced",t)},get particle(){return oe("particle",r)},get billboard(){return oe("billboard",n)}};var U,L,B=null,I=!0,O={enableShadows:!0,enableBloom:!0,enablePostProcessing:!0,loadTextures:!0};this.settings={get enableShadows(){return O.enableShadows},set enableShadows(e){O.enableShadows=e,e||m.shadowCascades.clearShadowmaps()},get enableBloom(){return O.enableBloom},set enableBloom(e){O.enableBloom=e,e||m.bloom.clearBloom()},get enablePostProcessing(){return O.enablePostProcessing},set enablePostProcessing(e){O.enablePostProcessing=e},get loadTextures(){return O.loadTextures},set loadTextures(e){O.loadTextures=e}},this.setupSettings=null,this.renderpipeline=null;let k=0;function V(){var e,t,n=(t=((e=performance.now())-x)/1e3,x=e,t);w+=n,k=0,m.eventHandler.fireEvent("renderloop",n,w,T);let r=document.querySelector("#debug_drawCalls");r&&(r.textContent=k),T++,requestAnimationFrame(V)}function G(){H(),m.postprocessing&&m.postprocessing.resizeFramebuffers(),m.bloom&&m.bloom.resizeFramebuffers(),m.eventHandler.fireEvent("resize")}function H(){var e=m.setupSettings,t=v*(window.devicePixelRatio||1);m.canvas.width=(e.width??innerWidth)*t,m.canvas.height=(e.height??innerHeight)*t,m.canvas.style.width=(e.width??innerWidth)+"px",m.canvas.style.height=(e.height??innerHeight)+"px"}function W(e){if(m.catchProgramErrors&&!d.getProgramParameter(e,d.LINK_STATUS)){var t="\nCould not compile WebGL program\n\nLink failed: "+d.getProgramInfoLog(e),n=d.getAttachedShaders(e);for(var r of n){var i=d.getShaderInfoLog(r),o=ie(d.getShaderParameter(r,d.SHADER_TYPE));i&&(t+="\n"+o+":\n"+i),console.log(o,d.getShaderSource(r))}throw new Error(t)}}function q(e,t){var n=d.createShader(t);return d.shaderSource(n,e),d.compileShader(n),n}function Y(){return m.floatTextures?d.FLOAT:m.textureHalfFloatExt?m.textureHalfFloatExt.HALF_FLOAT_OES:d.UNSIGNED_BYTE}function Z(e,t,n={}){var r=d.createFramebuffer();d.bindFramebuffer(d.FRAMEBUFFER,r);var i=d.createTexture();d.bindTexture(d.TEXTURE_2D,i),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,e,t,0,d.RGBA,Y(),null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,i,0);var o=d.createRenderbuffer();return d.bindRenderbuffer(d.RENDERBUFFER,o),d.renderbufferStorage(d.RENDERBUFFER,n.depthComponent??d.DEPTH_COMPONENT16,e,t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,o),{framebuffer:r,colorBuffer:i,depthBuffer:o,width:e,height:t}}function J(e,t=d.ARRAY_BUFFER,n=d.STATIC_DRAW){var r=d.createBuffer();return d.bindBuffer(t,r),d.bufferData(t,e,n),r}function ee(e){return e!==B&&(d.useProgram(e),B=e,!0)}function te(e,t,n,r){U=[e,t,n,r],d.clearColor(e,t,n,r)}function ne(e){if("FLOAT"==e)return"1f";var t=e.match(/FLOAT_VEC([0-9])/);if(t)return t[1]+"f";if("INT"==e||"UNSIGNED_INT"==e||"BOOL"==e||-1!==e.indexOf("SAMPLER"))return"1i";if(t=e.match(/(?:INT|BOOL)_VEC([0-9])/))return t[1]+"i";if(t=e.match(/FLOAT_MAT([0-9]x?[0-9]?)/))return"Matrix"+t[1]+"fv";throw new Error("Invalid uniform type string: "+e)}this.setup=function(e={}){if(this.setupSettings=e,this.path=e.path??"./",this.canvas=e.canvas??document.body.appendChild(document.createElement("canvas")),H(),this.version=e.version??2,1!==this.version&&2!==this.version)throw new Error("Invalid WebGL version: "+this.version);var t="webgl"+(2==this.version?"2":""),n={antialias:!1,premultipliedAlpha:!1};if(d=this.gl=this.canvas.getContext(t,n),!this.gl){if(2!=this.version||"version"in e)throw this.eventHandler.fireEvent("error"),new Error("WebGL "+this.version+" is not supported!");if(this.eventHandler.fireEvent("fallbackVersion"),this.version=1,d=this.gl=this.canvas.getContext("webgl",n),!this.gl)throw this.eventHandler.fireEvent("error"),new Error("WebGL "+this.version+" is not supported!")}console.log("Using Webgl version "+this.version);let r=function(){k++};function i(e,t,n){var r=e[t];return e[t]=function(){return n(...arguments),r.call(e,...arguments)},r}if(i(d,"drawElements",r),i(d,"drawArrays",r),i(d,"drawElementsInstanced",r),i(d,"drawArraysInstanced",r),this.canvas.addEventListener("webglcontextlost",(()=>{console.error("WebGL context lost!"),this.eventHandler.fireEvent("contextlost")})),this.canvas.addEventListener("mousedown",(e=>{this.mouse.any=!0,this.mouse[["left","middle","right"][e.button]]=!0,this.eventHandler.fireEvent("mousedown",e)})),document.addEventListener("mouseup",(e=>{this.mouse.any=0!==e.buttons,this.mouse[["left","middle","right"][e.button]]=!1,this.eventHandler.fireEvent("mouseup",e)})),this.canvas.onmousemove=e=>{var t,n,r,i,o,a=(n=e,r=(t=this.canvas).getBoundingClientRect(),i=t.width/r.width,o=t.height/r.height,{x:(n.clientX-r.left)*i,y:(n.clientY-r.top)*o});this.mouse.x=a.x,this.mouse.y=a.y,this.mouse.movement.x=e.movementX,this.mouse.movement.y=e.movementY,this.eventHandler.fireEvent("mousemove",e)},document.addEventListener("keydown",(e=>{R[e.keyCode]=!0,R[e.code]=!0,this.eventHandler.fireEvent("keydown",e)})),document.addEventListener("keyup",(e=>{R[e.keyCode]=!1,R[e.code]=!1,this.eventHandler.fireEvent("keyup",e)})),window.addEventListener("resize",(()=>{G()})),(L={})[d.NO_ERROR]="No error",L[d.INVALID_ENUM]="Invalid enum",L[d.INVALID_VALUE]="Invalid value",L[d.INVALID_OPERATION]="Invalid operation",L[d.INVALID_FRAMEBUFFER_OPERATION]="Invalid framebuffer operation",L[d.OUT_OF_MEMORY]="Out of memory",L[d.CONTEXT_LOST_WEBGL]="Context lost webgl",this.indexTypeLookup={5121:d.UNSIGNED_BYTE,5123:d.UNSIGNED_SHORT,5125:d.UNSIGNED_INT},d.getParameter(d.MAX_COMBINED_TEXTURE_IMAGE_UNITS)<32&&console.warn("Max texture units: ",d.getParameter(d.MAX_COMBINED_TEXTURE_IMAGE_UNITS)),this.EXT_texture_filter_anisotropic=this.getExtension("EXT_texture_filter_anisotropic")||this.getExtension("MOZ_EXT_texture_filter_anisotropic")||this.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),this.MAX_ANISOTROPY=d.getParameter(this.EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT),2==this.version?(this.getExtension("OES_texture_float_linear"),this.getExtension("EXT_color_buffer_float"),this.getExtension("EXT_float_blend"),this.floatTextures=!0):1==this.version&&(this.getExtension("OES_element_index_uint"),this.getExtension("OES_standard_derivatives"),this.getExtension("EXT_shader_texture_lod"),this.floatTextures=this.getExtension("OES_texture_float"),this.floatTextures=this.floatTextures&&this.getExtension("WEBGL_color_buffer_float"),this.getExtension("OES_texture_float_linear"),this.getExtension("EXT_float_blend"),this.colorBufferHalfFloatExt=this.getExtension("EXT_color_buffer_half_float"),this.textureHalfFloatExt=this.getExtension("OES_texture_half_float"),this.getExtension("WEBGL_depth_texture"),this.sRGBExt=this.getExtension("EXT_sRGB"),this.VAOExt=this.getExtension("OES_vertex_array_object"),this.instanceExt=this.getExtension("ANGLE_instanced_arrays")),this.gl.enable(this.gl.DEPTH_TEST),I=!0,this.gl.enable(this.gl.CULL_FACE),this.gl.cullFace(this.gl.BACK),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),te(...e.clearColor??[0,0,0,1]),d.getError(),null!=e.renderpipeline)if(0==e.renderpipeline)this.renderpipeline=new je(this);else{if(1!=e.renderpipeline)throw new Error("Unknown renderpipeline: "+e.renderpipeline);this.renderpipeline=new qe(this)}else this.renderpipeline=new qe(this);this.shadowCascades=new ge({basic:this.programContainers.shadow,instanced:this.programContainers.shadowInstanced,skinned:this.programContainers.shadowSkinned},e.shadowSizes??[4,16],e.shadowBiases??[-3e-4,-5e-4],e.shadowResolution??1024),ue("Shadow cascades"),this.bloom=new me(this.programContainers.bloom),ue("Bloom"),this.postprocessing=new de,ue("Post processing"),e.enableGodrays&&this.createProgramFromFile(this.path+`assets/shaders/built-in/webgl${this.version}/godrays`).then((e=>{var t=new ye(e);this.godrays=new ve(t),console.log(this.godrays)})),this.gizmos=new he,this.skybox=new be(this.programContainers.skybox),ue("Skybox"),this.splitsumTexture=this.loadSplitsum(this.path+"assets/pbr/splitsum.png"),ue("Splitsum"),x=performance.now(),requestAnimationFrame(V)},this.getTime=function(){return w},this.setRenderScale=function(e){v=e,G()},this.getRenderScale=function(){return v},this.setCanvasSize=function(e,t){-1===e?delete this.setupSettings.width:this.setupSettings.width=e,-1===t?delete this.setupSettings.height:this.setupSettings.height=t,G()},this.update=function(e){this.getActiveScene().update(e)},this.render=function(e,t=null,n={}){let r=this.getActiveScene();this.postprocessing.exposure.value=r.postprocessing.exposure,this.postprocessing.gamma.value=r.postprocessing.gamma,this.postprocessing.tonemapping.value=r.postprocessing.tonemapping,this.postprocessing.motionBlurStrength.value=r.postprocessing.motionBlurStrength,this.postprocessing.saturation.value=r.postprocessing.saturation,this.postprocessing.contrast.value=r.postprocessing.contrast,this.postprocessing.vignette.amount.value=r.postprocessing.vignette.amount,this.postprocessing.vignette.falloff.value=r.postprocessing.vignette.falloff,this.postprocessing.whiteBalance.temperature.value=r.postprocessing.whiteBalance.temperature,this.postprocessing.whiteBalance.tint.value=r.postprocessing.whiteBalance.tint,this.bloom.setProperties(r.bloom),this.renderpipeline.render(e,t,r,n)},Object.defineProperty(this,"aspect",{get:function(){return d.canvas.clientWidth/d.canvas.clientHeight}}),this.add=function(e){return this.scenes.push(e),e.renderer=this,e.setupUBO(),e},this.on=function(e,t){this.eventHandler.addEvent(e,t)},this.getActiveScene=function(){return this.scenes[this.currentScene]},this.setActiveScene=function(e){if(this.shadowCascades.clearShadowmaps(),"number"==typeof e){if(e<0||e>=this.scenes.length)throw new Error("Scene index outside valid range (0-"+(this.scenes.length-1)+"): "+e);this.currentScene=e}else{if(!(e instanceof Ye))throw new Error("Scene not valid");var t=this.scenes.indexOf(e);if(-1==t)throw console.error(e),new Error("Scene has not been added to renderer");this.currentScene=t}},this.disableContextMenu=function(){m.canvas.addEventListener("contextmenu",(function(e){e.preventDefault()}))},this.disablePinchToZoom=function(){document.addEventListener("touchmove",(function(e){1!==e.scale&&e.preventDefault()}),{passive:!1})},this.isPointerLocked=function(){return document.pointerLockElement===this.canvas||document.mozPointerLockElement===this.canvas},this.lockPointer=function(){this.canvas.requestPointerLock=this.canvas.requestPointerLock||this.canvas.mozRequestPointerLock,this.canvas.requestPointerLock()},this.unlockPointer=function(){document.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock,document.exitPointerLock()},this.getKey=function(e){return!!R[e]},this.getKeyDown=function(e,t=""){if(this.getKey(e)){if(C[e+t])return C[e+t]=!1,!0}else C[e+t]=!0;return!1},this.getKeyUp=function(e,t=""){if(this.getKey(e))F[e+t]=!0;else if(F[e+t])return F[e+t]=!1,!0;return!1},this.saveCanvasAsImage=function(e){z(this.canvas,e)},this.createCubemapFromHDR=async function(e,t=1024,n=1){var r=await Q(e),i=r.data;if(!this.floatTextures)throw new Error("Half float not currently supported");var o=d.createTexture();d.bindTexture(d.TEXTURE_2D,o),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,0),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,r.width,r.height,0,d.RGBA,d.UNSIGNED_BYTE,i),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE);var a=new He(this.programContainers.equirectangularToCubemap,{equirectangularMap:o});a.doubleSided=!0;var s=new Oe("Cubemap",{meshRenderer:new Se([a],[new Ne(Ge())]),castShadows:!1}),l=K.orthographic({size:1}),c=[K.identity(),K.inverse(K.transform([["ry",Math.PI]])),K.inverse(K.transform([["ry",Math.PI/2],["rx",-Math.PI/2]])),K.inverse(K.transform([["ry",Math.PI/2],["rx",Math.PI/2]])),K.inverse(K.transform([["ry",Math.PI/2]])),K.inverse(K.transform([["ry",-Math.PI/2]]))],u=d.createFramebuffer();d.bindFramebuffer(d.FRAMEBUFFER,u);const h=d.createRenderbuffer();d.bindRenderbuffer(d.RENDERBUFFER,h),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,t,t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,h);var f=d.createTexture();d.bindTexture(d.TEXTURE_CUBE_MAP,f);for(let e=0;e<6;e++)d.bindTexture(d.TEXTURE_CUBE_MAP,f),d.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,1==this.version?d.RGBA:d.RGBA32F,t,t,0,d.RGBA,Y(),null);d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.TEXTURE_WRAP_R&&d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_R,d.CLAMP_TO_EDGE),m.disableCulling(),d.viewport(0,0,t,t);for(let e=0;e<6;e++)d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_CUBE_MAP_POSITIVE_X+e,f,0),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap,s.render({projectionMatrix:l,viewMatrix:c[e],inverseViewMatrix:K.inverse(c[e])});return d.bindTexture(d.TEXTURE_CUBE_MAP,f),d.generateMipmap(d.TEXTURE_CUBE_MAP),m.enableCulling(),f},this.createSpecularCubemapFromHDR=async function(e,t=1024,n=1){var r=[],i=[];for(let t=0;t<5;t++){var o=await Q(e+"/specular_mip_"+t+".hdr"),a=o.data;if(!this.floatTextures)if(m.textureHalfFloatExt)a=_(a);else{a=new Uint8Array(o.data.length);for(let e=0;e<o.data.length;e++)a[e]=Math.min(255,255*Math.pow(o.data[e]/(o.data[e]+1)*2,1/2.2))}var s=d.createTexture();d.bindTexture(d.TEXTURE_2D,s),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,0),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,o.width,o.height,0,d.RGBA,d.UNSIGNED_BYTE,a),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),r.push({hdr:o,pixelData:a,hdrTexture:s})}var l=new He(this.programContainers.equirectangularToCubemap,{equirectangularMap:s});l.doubleSided=!0;var c,u,h=new Oe("Cubemap",{meshRenderer:new Se([l],[new Ne(Ge())]),castShadows:!1}),f=K.orthographic({size:1}),v=[K.identity(),K.inverse(K.transform([["ry",Math.PI]])),K.inverse(K.transform([["ry",Math.PI/2],["rx",-Math.PI/2]])),K.inverse(K.transform([["ry",Math.PI/2],["rx",Math.PI/2]])),K.inverse(K.transform([["ry",Math.PI/2]])),K.inverse(K.transform([["ry",-Math.PI/2]]))];1!=this.version&&(c=d.createFramebuffer(),d.bindFramebuffer(d.FRAMEBUFFER,c),u=d.createRenderbuffer(),d.bindRenderbuffer(d.RENDERBUFFER,u),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,t,t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,u));var p=d.createTexture();d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_CUBE_MAP,p);for(let e=0;e<6;e++)d.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,1==this.version?d.RGBA:d.RGBA32F,t,t,0,d.RGBA,Y(),null);d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MIN_FILTER,d.LINEAR_MIPMAP_LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.TEXTURE_WRAP_R&&d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_R,d.CLAMP_TO_EDGE),d.generateMipmap(d.TEXTURE_CUBE_MAP),m.disableCulling();for(var g=0;g<5;g++){var x=t*Math.pow(.5,g);1==this.version?i.push(Z(x,x)):(d.bindRenderbuffer(d.RENDERBUFFER,u),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,x,x)),d.viewport(0,0,x,x),l.setUniform("equirectangularMap",r[g].hdrTexture);for(var b=0;b<6;b++)1!=this.version&&d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_CUBE_MAP_POSITIVE_X+b,p,g),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap,h.render({projectionMatrix:f,viewMatrix:v[b],inverseViewMatrix:K.inverse(v[b])}),1==this.version&&(d.bindTexture(d.TEXTURE_CUBE_MAP,p),d.copyTexSubImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+b,g,0,0,0,0,x,x))}for(var y of i)d.deleteFramebuffer(y.framebuffer);return m.enableCulling(),p},this.getSpecularCubemap=async function(e,t=128){if(!m.floatTextures&&!m.textureHalfFloatExt)return e;var n=new He(this.programContainers.specularCubemap,{environmentMap:e,roughness:0});n.doubleSided=!0;var r,i,o=new Oe("Cubemap",{meshRenderer:new Se([n],[new Ne(Ge())]),castShadows:!1}),a=K.orthographic({size:1}),s=[K.inverse(K.transform([["ry",-Math.PI/2],["rz",Math.PI]])),K.inverse(K.transform([["ry",Math.PI/2],["rz",Math.PI]])),K.inverse(K.transform([["rx",Math.PI/2]])),K.inverse(K.transform([["rx",-Math.PI/2]])),K.inverse(K.transform([["ry",Math.PI],["rz",Math.PI]])),K.inverse(K.transform([["rz",Math.PI]]))],l=[];1!=this.version&&(r=d.createFramebuffer(),d.bindFramebuffer(d.FRAMEBUFFER,r),i=d.createRenderbuffer(),d.bindRenderbuffer(d.RENDERBUFFER,i),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,t,t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,i));var c=d.createTexture();d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_CUBE_MAP,c);for(let e=0;e<6;e++)d.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,1==this.version?d.RGBA:d.RGBA16F,t,t,0,d.RGBA,Y(),null);d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MIN_FILTER,d.LINEAR_MIPMAP_LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.TEXTURE_WRAP_R&&d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_R,d.CLAMP_TO_EDGE),d.generateMipmap(d.TEXTURE_CUBE_MAP),m.disableCulling();for(var u=0;u<5;u++){var h=t*Math.pow(.5,u);1==this.version?l.push(Z(h,h)):(d.bindRenderbuffer(d.RENDERBUFFER,i),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,h,h)),d.viewport(0,0,h,h);var f=u/4;n.setUniform("roughness",f);for(let e=0;e<6;e++){1!=this.version&&d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_CUBE_MAP_POSITIVE_X+e,c,u),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap;var v=s[e];o.render({projectionMatrix:a,viewMatrix:v,inverseViewMatrix:K.inverse(v)}),1==this.version&&(d.bindTexture(d.TEXTURE_CUBE_MAP,c),d.copyTexSubImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+e,u,0,0,0,0,h,h))}}for(var p of l)d.deleteFramebuffer(p.framebuffer);return m.enableCulling(),c},this.getDiffuseCubemap=async function(e){var t=new He(this.programContainers.diffuseCubemap,{environmentMap:e});return await this.createCubemapFromCube(t,32)},this.createCubemapFromCube=async function(e,t){e.doubleSided=!0;var n=new Oe("Cubemap",{meshRenderer:new Se([e],[new Ne(Ge())]),castShadows:!1}),r=K.orthographic({size:1}),i=[K.inverse(K.transform([["ry",-Math.PI/2],["rz",Math.PI]])),K.inverse(K.transform([["ry",Math.PI/2],["rz",Math.PI]])),K.inverse(K.transform([["rx",Math.PI/2]])),K.inverse(K.transform([["rx",-Math.PI/2]])),K.inverse(K.transform([["ry",Math.PI],["rz",Math.PI]])),K.inverse(K.transform([["rz",Math.PI]]))],o=d.createFramebuffer();d.bindFramebuffer(d.FRAMEBUFFER,o);const a=d.createRenderbuffer();d.bindRenderbuffer(d.RENDERBUFFER,a),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,t,t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,a);var s=d.createTexture();d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_CUBE_MAP,s);var l=1==this.version?d.RGBA:d.RGBA32F,c=d.RGBA;for(let e=0;e<6;e++)d.bindTexture(d.TEXTURE_CUBE_MAP,s),d.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,l,t,t,0,c,Y(),null);d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.TEXTURE_WRAP_R&&d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_R,d.CLAMP_TO_EDGE),m.disableCulling(),d.viewport(0,0,t,t);for(let e=0;e<6;e++)d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_CUBE_MAP_POSITIVE_X+e,s,0),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap,n.render({projectionMatrix:r,viewMatrix:i[e],inverseViewMatrix:K.inverse(i[e])}),await D(200);return m.enableCulling(),d.deleteFramebuffer(o),s},this.captureReflectionCubemap=function(e=X.zero(),t=512){var n=K.perspective({fov:Math.PI/4,aspect:1,near:.001,far:100}),r=[K.inverse(K.transform([["translate",e],["ry",-Math.PI/2],["rz",Math.PI]])),K.inverse(K.transform([["translate",e],["ry",Math.PI/2],["rz",Math.PI]])),K.inverse(K.transform([["translate",e],["rx",Math.PI/2]])),K.inverse(K.transform([["translate",e],["rx",-Math.PI/2]])),K.inverse(K.transform([["translate",e],["ry",Math.PI],["rz",Math.PI]])),K.inverse(K.transform([["translate",e],["rz",Math.PI]]))],i=d.createFramebuffer();d.bindFramebuffer(d.FRAMEBUFFER,i);const o=d.createRenderbuffer();d.bindRenderbuffer(d.RENDERBUFFER,o),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,t,t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,o);var a=d.createTexture();d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_CUBE_MAP,a);for(let e=0;e<6;e++)d.bindTexture(d.TEXTURE_CUBE_MAP,a),d.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,d.RGBA32F,t,t,0,d.RGBA,Y(),null);d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.TEXTURE_WRAP_R&&d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_R,d.CLAMP_TO_EDGE),d.viewport(0,0,t,t);for(let e=0;e<6;e++){d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_CUBE_MAP_POSITIVE_X+e,a,0),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT);var s={projectionMatrix:n,viewMatrix:r[e],inverseViewMatrix:K.inverse(r[e]),cameraMatrix:K.inverse(r[e])},l=this.scenes[this.currentScene];l.skyboxVisible&&this.skybox.render(s,l.skyboxCubemap),l.updateUniformBuffers(s.projectionMatrix,s.viewMatrix,s.inverseViewMatrix),d.activeTexture(d.TEXTURE0+2),d.bindTexture(d.TEXTURE_CUBE_MAP,l.diffuseCubemap),d.activeTexture(d.TEXTURE0+1),d.bindTexture(d.TEXTURE_CUBE_MAP,l.specularCubemap),d.activeTexture(d.TEXTURE0+0),d.bindTexture(d.TEXTURE_2D,this.splitsumTexture),d.colorMask(!0,!0,!0,!1),d.disable(d.BLEND),l.render(s,{renderPass:p.OPAQUE}),d.enable(d.BLEND),d.depthMask(!1),l.render(s,{renderPass:p.ALPHA}),d.depthMask(!0),d.colorMask(!0,!0,!0,!0),se(null)}return a},this.saveSpecularCubemapAsHDR=async function(e,t=5,n=128){for(var r=0;r<t;r++){var i=n*Math.pow(.5,r);await this.saveCubemapAsHDR(e,i,r,"specular_mip_"+r)}},this.saveCubemapAsHDR=async function(e,t=512,n=0,r="cubemap"){var i=t,o=t/2,a=Z(i,o),s=await this.createProgramFromFile(this.path+"assets/shaders/built-in/webgl2/equirectangularFromCubemap"),l=J(new Float32Array([-1,1,-1,-1,1,1,1,-1])),c=d.getAttribLocation(s,"position"),u=J(new Float32Array([0,0,0,1,1,0,1,1])),h=d.getAttribLocation(s,"uv");d.bindFramebuffer(d.FRAMEBUFFER,a.framebuffer),m.disableCulling(),d.viewport(0,0,i,o),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),ee(s),se(null),d.bindBuffer(d.ARRAY_BUFFER,l),d.enableVertexAttribArray(c),d.vertexAttribPointer(c,2,d.FLOAT,!1,8,0),d.bindBuffer(d.ARRAY_BUFFER,u),d.enableVertexAttribArray(h),d.vertexAttribPointer(h,2,d.FLOAT,!1,8,0),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_CUBE_MAP,e),d.uniform1i(d.getUniformLocation(s,"cubemap"),0),d.uniform1f(d.getUniformLocation(s,"mipmapLevel"),n),d.drawArrays(d.TRIANGLE_STRIP,0,4);var f=new Float32Array(i*o*4);return d.readPixels(0,0,i,o,d.RGBA,d.FLOAT,f),function(e,t=1024,n=512,r="new"){for(var i=`#?RADIANCE\nFORMAT=32-bit_rle_rgbe\n\n-Y ${n} +X ${t}\n`,o=(new TextEncoder).encode(i),a=[],s=0;s<e.length;s+=4){var l=e[s],c=e[s+1],u=e[s+2];a.push(...$(l,c,u))}var h=new Uint8Array(o.length+a.length);h.set(o,0),h.set(a,o.length),function(e,t,n){const r=new Blob([e],{type:"application/octet-stream"}),i=window.URL.createObjectURL(r);(function(e,t){const n=document.createElement("a");n.href=e,n.download=t,document.body.appendChild(n),n.style.display="none",n.click(),n.remove()})(i,t),setTimeout((()=>window.URL.revokeObjectURL(i)),1e3)}(h,r+".hdr")}(f,i,o,r),!0},this.saveCubemapAsImages=async function(e,t=512){var n=new ye(await this.createProgramFromFile("../assets/shaders/built-in/webgl2/cubemapVis")),r=new He(n,{environmentMap:e});r.doubleSided=!0;var i=new Oe("Cubemap",{meshRenderer:new Se([r],[new Ne(Ge())]),castShadows:!1}),o=K.orthographic({size:1}),a=[K.inverse(K.transform([["ry",-Math.PI/2],["rz",Math.PI]])),K.inverse(K.transform([["ry",Math.PI/2],["rz",Math.PI]])),K.inverse(K.transform([["rx",Math.PI/2]])),K.inverse(K.transform([["rx",-Math.PI/2]])),K.inverse(K.transform([["ry",Math.PI],["rz",Math.PI]])),K.inverse(K.transform([["rz",Math.PI]]))],s=this.canvas.width,l=this.canvas.height;this.canvas.width=t,this.canvas.height=t,d.bindFramebuffer(d.FRAMEBUFFER,null),m.disableCulling(),d.viewport(0,0,t,t);for(var c=0;c<6;c++)d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap,i.render({projectionMatrix:o,viewMatrix:a[c],inverseViewMatrix:K.inverse(a[c])}),z(m.canvas,"cubemap"+c);return m.enableCulling(),this.canvas.width=s,this.canvas.height=l,!0},this.loadSplitsum=function(e){return ze(e,{TEXTURE_MIN_FILTER:d.LINEAR,TEXTURE_WRAP_S:d.CLAMP_TO_EDGE,TEXTURE_WRAP_T:d.CLAMP_TO_EDGE})},this.loadTextFile=async function(e){return await(await fetch(e,{mode:"cors",headers:{"Access-Control-Allow-Origin":"*"}})).text()},this.createProgramFromFile=async function(e,t){var n=e+"/vertex.glsl",r=e+"/fragment.glsl";null!=t&&(n=e,r=t);var i=await this.loadTextFile(n),o=await this.loadTextFile(r);return this.createProgram(i,o)},this.createProgram=function(e,t){var n=q(e,d.VERTEX_SHADER),r=q(t,d.FRAGMENT_SHADER),i=d.createProgram();return d.attachShader(i,n),d.attachShader(i,r),d.linkProgram(i),W(i),i},this.updateVertexShader=function(e,t){var n=d.getAttachedShaders(e.program)[0];this.updateShader(n,e,t)},this.updateFragmentShader=function(e,t){var n=d.getAttachedShaders(e.program)[1];this.updateShader(n,e,t)},this.updateShader=function(e,t,n){d.shaderSource(e,n),d.compileShader(e),d.linkProgram(t.program),W(t.program),t.updateUniformLocations()},this.CustomProgram=class{constructor(e){var t=e["webgl"+m.version]??e;if(t.vertex&&t.fragment){var n=m.createProgram(t.vertex,t.fragment);return new m.ProgramContainer(n)}console.error("Custom program does not have a vertex/fragment shader for version "+m.version)}},this.enableCulling=function(){!0!==I&&(this.gl.enable(this.gl.CULL_FACE),I=!0)},this.disableCulling=function(){!1!==I&&(this.gl.disable(this.gl.CULL_FACE),I=!1)},this.getExtension=function(e){return this.gl.getExtension(e)||(console.error("Could not get extension: "+e),!1)},this.getSRGBFormats=function(){return{internalFormat:1==m.version?m.sRGBExt&&(m.floatTextures||m.textureHalfFloatExt)?m.sRGBExt.SRGB_ALPHA_EXT:d.RGBA:d.SRGB8_ALPHA8,format:1==m.version&&m.sRGBExt&&(m.floatTextures||m.textureHalfFloatExt)?m.sRGBExt.SRGB_ALPHA_EXT:d.RGBA}},this.setClearColor=te;var re={};function ie(e){var t=re[e];if(t)return t;for(const t in d)if(d[t]===e)return re[e]=t,t;return""}function oe(t,n=e){if(!(t in N)){console.log("Loading program:",t);var r=n["webgl"+m.version][t];if(!r||!r.vertex||!r.fragment)return console.error(`Program ${t} not found for version ${m.version}!`),void(N[t]=void 0);var i=m.createProgram(r.vertex,r.fragment);N[t]=new ye(i)}return N[t]}function ae(e){return 1==m.version?m.VAOExt.deleteVertexArrayOES(e):d.deleteVertexArray(e)}function se(e){1==m.version?m.VAOExt.bindVertexArrayOES(e):2==m.version&&d.bindVertexArray(e)}function le(e,t){1==m.version?m.instanceExt.vertexAttribDivisorANGLE(e,t):2==m.version&&d.vertexAttribDivisor(e,t)}function ce(e,t,n,r,i){1==m.version?m.instanceExt.drawElementsInstancedANGLE(e,t,n,r,i):2==m.version&&d.drawElementsInstanced(e,t,n,r,i)}function ue(e="",t=!1){var n=d.getError();t?console[n?"error":"log"]("("+e+") "+L[n]):0!==n&&console.error("("+e+") "+L[n])}function he(){var e;this.gameObject=new Oe("Gizmos");var t=!1,n=()=>{var t=we({},m.programContainers.unlitInstanced),n=function(){const e=new Float32Array([0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1]),t=new Uint32Array([0,1,2,3,4,5]),n=new Float32Array([0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0]);return new Ne({indices:{bufferData:t,target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:e,size:3},color:{bufferData:n,size:3}})}();(e=new Pe(t,n)).drawMode=d.LINES,this.gameObject.meshRenderer=e};this.visualize=function(r){t||(n(),t=!0);var i=e.addInstance(r.transform.worldMatrix);setInterval((function(){var t=r.transform.worldMatrix;K.setScale(t,X.fill(.3)),e.updateInstance(i,t)}),16)}}function fe(){var e=new Float32Array([-1,1,-1,-1,1,1,1,-1]);this.vertexBuffer=J(e),this.bindBuffers=function(e){d.bindBuffer(d.ARRAY_BUFFER,this.vertexBuffer),d.enableVertexAttribArray(e),d.vertexAttribPointer(e,2,d.FLOAT,!1,8,0)},this.render=function(){d.drawArrays(d.TRIANGLE_STRIP,0,4)}}function de(){var e=this;function t(e,t=(()=>{})){this.value=e;var n=e;this.onChange=t;var r=!1;this.update=function(){this.value==n&&r||(this.onChange(this.value,n),n=this.value,r=!0)}}this.TONEMAPPING={NONE:0,ACES:1,REINHARD:2},this.exposure=new t(0,(e=>{d.uniform1f(this.programContainer.getUniformLocation("exposure"),e)})),this.gamma=new t(2.2,(e=>{d.uniform1f(this.programContainer.getUniformLocation("gamma"),e)})),this.tonemapping=new t(this.TONEMAPPING.ACES,(e=>{d.uniform1i(this.programContainer.getUniformLocation("tonemapping"),e)})),this.motionBlurStrength=new t(.2,((e,t)=>{i(e,t)||d.uniform1f(this.programContainer.getUniformLocation("motionBlurStrength"),e)})),this.saturation=new t(0,(e=>{d.uniform1f(this.programContainer.getUniformLocation("saturation"),e)})),this.contrast=new t(0,(e=>{d.uniform1f(this.programContainer.getUniformLocation("contrast"),e)})),this.vignette={amount:new t(0,(e=>{d.uniform1f(this.programContainer.getUniformLocation("vignetteAmount"),e)})),falloff:new t(0,(e=>{d.uniform1f(this.programContainer.getUniformLocation("vignetteFalloff"),e)}))},this.whiteBalance={temperature:new t(0,(e=>{d.uniform1f(this.programContainer.getUniformLocation("temperature"),e)})),tint:new t(0,(e=>{d.uniform1f(this.programContainer.getUniformLocation("tint"),e)}))};var n,r,i=(e,t)=>{if(e>0&&0==t||0==e&&t>0){for(var n of(m.updateFragmentShader(this.programContainer,p().fragment),o))n.onChange(n.value,n.value);return v(),console.log("Recompiling postprocessing"),!0}return!1},o=[this.exposure,this.gamma,this.tonemapping,this.motionBlurStrength,this.saturation,this.contrast,this.vignette.amount,this.vignette.falloff,this.whiteBalance.temperature,this.whiteBalance.tint],s=p(),l=m.createProgram(s.vertex,s.fragment);this.programContainer=new ye(l);var c,u=d.canvas.width,h=d.canvas.height;m.version,this.framebuffer=d.createFramebuffer(),d.bindFramebuffer(d.FRAMEBUFFER,this.framebuffer),this.colorBuffer=d.createTexture(),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,this.colorBuffer),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,u,h,0,d.RGBA,Y(),null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,this.colorBuffer,0),m.version>1&&(this.motionBlurColorBuffer=d.createTexture(),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,this.motionBlurColorBuffer),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,u,h,0,d.RGBA,Y(),null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT1,d.TEXTURE_2D,this.motionBlurColorBuffer,0)),c=d.createRenderbuffer(),d.bindRenderbuffer(d.RENDERBUFFER,c),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,u,h),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,c),this.downscaledFramebuffer=Z(u/4,h/4);var f=new fe,v=()=>{ee(this.programContainer.program),d.uniform1i(this.programContainer.getUniformLocation("mainTexture"),0),d.uniform1i(this.programContainer.getUniformLocation("bloomTexture"),1),this.depthTexture||m.godrays?d.uniform1i(this.programContainer.getUniformLocation("depthTexture"),2):d.uniform1i(this.programContainer.getUniformLocation("enableGodrays"),0),d.uniform1i(this.programContainer.getUniformLocation("motionBlurTexture"),3),this.motionBlurColorBuffer&&d.uniform1i(this.programContainer.getUniformLocation("motionBlurTexture"),16),d.uniform2f(this.programContainer.getUniformLocation("SIZE"),d.canvas.width,d.canvas.height)};function p(){var t=a["webgl"+m.version].postprocessing;if(t&&t.vertex&&t.fragment){var n="#version 300 es\n";return m.version>1&&e.motionBlurStrength.value>1e-6&&(n+="#define ENABLE_MOTIONBLUR\n"),n+="#define TONEMAPPING "+e.tonemapping.value+"\n",m.godrays&&(n+="#define ENABLE_GODRAYS\n"),m.bloom.getIntensity()>1e-6&&(n+="#define ENABLE_BLOOM\n"),n+=t.fragment,{vertex:t.vertex,fragment:n}}console.error(`Program postprocessing not found for version ${m.version}!`)}v(),this.getFramebuffer=function(){return this.preFramebuffer?this.preFramebuffer:this.framebuffer},this.bindFramebuffer=function(){d.bindFramebuffer(d.FRAMEBUFFER,this.getFramebuffer())},this.blitAA=function(){this.preFramebuffer&&(d.bindFramebuffer(d.READ_FRAMEBUFFER,this.preFramebuffer),d.bindFramebuffer(d.DRAW_FRAMEBUFFER,this.framebuffer),d.clearBufferfv(d.COLOR,0,[1,1,1,1]),d.blitFramebuffer(0,0,u,h,0,0,u,h,d.COLOR_BUFFER_BIT,d.LINEAR),d.bindFramebuffer(d.FRAMEBUFFER,this.preFramebuffer))},this.resizeFramebuffers=function(){u=d.canvas.width,h=d.canvas.height,d.bindTexture(d.TEXTURE_2D,this.downscaledFramebuffer.colorBuffer),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,u/4,h/4,0,d.RGBA,Y(),null),d.bindTexture(d.TEXTURE_2D,this.colorBuffer),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,d.canvas.width,d.canvas.height,0,d.RGBA,Y(),null),this.motionBlurColorBuffer&&(d.bindTexture(d.TEXTURE_2D,this.motionBlurColorBuffer),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,d.canvas.width,d.canvas.height,0,d.RGBA,Y(),null)),this.depthTexture?(d.bindTexture(d.TEXTURE_2D,this.depthTexture),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.DEPTH_COMPONENT:d.DEPTH_COMPONENT16,d.canvas.width,d.canvas.height,0,d.DEPTH_COMPONENT,d.UNSIGNED_INT,null)):this.preFramebuffer?(d.bindRenderbuffer(d.RENDERBUFFER,c),d.renderbufferStorageMultisample(d.RENDERBUFFER,d.getParameter(d.MAX_SAMPLES),d.DEPTH_COMPONENT16,d.canvas.width,d.canvas.height)):(d.bindRenderbuffer(d.RENDERBUFFER,c),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,d.canvas.width,d.canvas.height)),this.preFramebuffer&&(d.bindRenderbuffer(d.RENDERBUFFER,void 0),d.renderbufferStorageMultisample(d.RENDERBUFFER,d.getParameter(d.MAX_SAMPLES),d.RGBA16F,d.canvas.width,d.canvas.height)),d.bindTexture(d.TEXTURE_2D,null)},this.render=function(){d.bindFramebuffer(d.FRAMEBUFFER,null),d.viewport(0,0,d.canvas.width,d.canvas.height),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),ee(this.programContainer.program),se(null),d.bindBuffer(d.ARRAY_BUFFER,f.vertexBuffer);var e=this.programContainer.getAttribLocation("position");for(var t of(d.enableVertexAttribArray(e),d.vertexAttribPointer(e,2,d.FLOAT,!1,8,0),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,this.colorBuffer),d.activeTexture(d.TEXTURE1),d.bindTexture(d.TEXTURE_2D,m.bloom.upsampleFramebuffers[m.bloom.upsampleFramebuffers.length-1].colorBuffer),this.depthTexture?(d.activeTexture(d.TEXTURE2),d.bindTexture(d.TEXTURE_2D,this.depthTexture)):m.godrays&&(d.activeTexture(d.TEXTURE2),d.bindTexture(d.TEXTURE_2D,m.godrays.framebufferData.colorBuffer)),this.motionBlurColorBuffer&&(d.activeTexture(d.TEXTURE25),d.bindTexture(d.TEXTURE_2D,this.motionBlurColorBuffer),d.uniform1i(this.programContainer.getUniformLocation("motionBlurTexture"),25)),this.rainTexture&&(d.activeTexture(d.TEXTURE17),d.bindTexture(d.TEXTURE_2D,this.rainTexture),d.uniform1i(this.programContainer.getUniformLocation("rainTexture"),17)),d.activeTexture(d.TEXTURE18),d.bindTexture(d.TEXTURE_2D,this.downscaledFramebuffer.colorBuffer),d.uniform1i(this.programContainer.getUniformLocation("downscaledTexture"),18),d.uniform1f(this.programContainer.getUniformLocation("iTime"),(new Date-m.startTime)/1e3),d.canvas.width===n&&d.canvas.height===r||(n=d.canvas.width,r=d.canvas.height,d.uniform2f(this.programContainer.getUniformLocation("SIZE"),d.canvas.width,d.canvas.height)),d.uniform1f(this.programContainer.getUniformLocation("bloomIntensity"),m.bloom.getIntensity()),o))t.update();f.render()}}function me(e){this.programContainer=e;var t=!0,n=1,r=1,i=.5,o=10,a=.05,s={enabled:t};this.downsampleFramebuffers=[],this.upsampleFramebuffers=[];var l=J(new Float32Array([-1,1,-1,-1,1,1,1,-1]));ee(this.programContainer.program),d.uniform1i(this.programContainer.getUniformLocation("mainTexture"),0),d.uniform1i(this.programContainer.getUniformLocation("secondTexture"),1),this.resizeFramebuffers=function(){for(let e=0;e<this.downsampleFramebuffers.length;e++)d.deleteFramebuffer(this.downsampleFramebuffers[e].framebuffer);for(let e=0;e<this.upsampleFramebuffers.length;e++)d.deleteFramebuffer(this.upsampleFramebuffers[e].framebuffer);this.downsampleFramebuffers=[],this.upsampleFramebuffers=[];let e=(()=>{let e=Math.min(d.canvas.width,d.canvas.height),t=Math.floor(Math.log(e)/Math.log(2));return Math.min(7,t)})();for(let t=0;t<e;t++){let e=Math.pow(.5,t+1);this.downsampleFramebuffers.push(Z(Math.floor(d.canvas.width*e),Math.floor(d.canvas.height*e)))}for(let t=0;t<e-1;t++){let n=Math.pow(.5,e-1-t);this.upsampleFramebuffers.push(Z(Math.floor(d.canvas.width*n),Math.floor(d.canvas.height*n)))}},this.resizeFramebuffers(),this.render=function(){if(!t&&s.enabled&&this.clearBloom(),s.enabled=t,!t)return;ee(this.programContainer.program),d.uniform1f(this.programContainer.getUniformLocation("_SampleScale"),n),d.uniform1f(this.programContainer.getUniformLocation("threshold"),r),d.uniform1f(this.programContainer.getUniformLocation("knee"),i),d.uniform1f(this.programContainer.getUniformLocation("_Clamp"),o);let e=this.programContainer.getAttribLocation("position");d.bindBuffer(d.ARRAY_BUFFER,l),d.enableVertexAttribArray(e),d.vertexAttribPointer(e,2,d.FLOAT,!1,8,0),d.activeTexture(d.TEXTURE0);for(var a=0;a<this.downsampleFramebuffers.length;a++){var c=this.downsampleFramebuffers[a];d.bindFramebuffer(d.FRAMEBUFFER,c.framebuffer),d.viewport(0,0,c.width,c.height),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),d.bindTexture(d.TEXTURE_2D,a<1?m.postprocessing.colorBuffer:this.downsampleFramebuffers[a-1].colorBuffer),this.programContainer.getUniformLocation("mainTextureSize")&&d.uniform2fv(this.programContainer.getUniformLocation("mainTextureSize"),a<1?[d.canvas.width,d.canvas.height]:[this.downsampleFramebuffers[a-1].width,this.downsampleFramebuffers[a-1].height]),d.uniform2f(this.programContainer.getUniformLocation("screenSize"),c.width,c.height),d.uniform1i(this.programContainer.getUniformLocation("stage"),0==a?0:1),d.drawArrays(d.TRIANGLE_STRIP,0,4)}d.uniform1i(this.programContainer.getUniformLocation("stage"),2);for(let e=0;e<this.upsampleFramebuffers.length;e++){let t=this.upsampleFramebuffers[e];if(d.bindFramebuffer(d.FRAMEBUFFER,t.framebuffer),d.viewport(0,0,t.width,t.height),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,e<1?this.downsampleFramebuffers[this.downsampleFramebuffers.length-1].colorBuffer:this.upsampleFramebuffers[e-1].colorBuffer),d.activeTexture(d.TEXTURE1),d.bindTexture(d.TEXTURE_2D,this.downsampleFramebuffers[this.downsampleFramebuffers.length-2-e].colorBuffer),this.programContainer.getUniformLocation("mainTextureSize")){let t=e<1?this.downsampleFramebuffers[this.downsampleFramebuffers.length-1]:this.upsampleFramebuffers[e-1];d.uniform2f(this.programContainer.getUniformLocation("mainTextureSize"),t.width,t.height)}d.uniform2f(this.programContainer.getUniformLocation("screenSize"),t.width,t.height),d.drawArrays(d.TRIANGLE_STRIP,0,4)}},this.clearBloom=function(){d.bindFramebuffer(d.FRAMEBUFFER,this.upsampleFramebuffers[this.upsampleFramebuffers.length-1].framebuffer);var e=U;te(0,0,0,1),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),te(...e)},this.setProperties=function(e){t=e.enabled,n=e.sampleScale,r=e.threshold,i=e.knee,o=e.clamp,a=e.intensity},this.getIntensity=function(){return a}}function ve(e){this.material=new He(e);var t=.2;this.framebufferData=Z(d.canvas.width*t,d.canvas.height*t);var n=d.createRenderbuffer();d.bindRenderbuffer(d.RENDERBUFFER,n),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,d.canvas.width*t,d.canvas.height*t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,n),this.render=function(e,t){d.bindFramebuffer(d.FRAMEBUFFER,this.framebufferData.framebuffer),d.viewport(0,0,this.framebufferData.width,this.framebufferData.height),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),e.render(t,{renderPass:p.OPAQUE,materialOverride:this.material}),m.skybox.render(t,e.skyboxCubemap)}}function ge(e,t=[50,8],n=[-.0025,-5e-4],r=1024){var i=this;t.reverse(),n.reverse(),this.levels=t.length,this.programContainers=e,this.programContainer=e.basic,Object.defineProperty(this,"program",{get:function(){return i.programContainer.program},set:e=>{i.programContainer.setProgram(e)}}),this.material=new He(this.programContainer),this.materialInstanced=new He(this.programContainers.instanced),this.materialSkinned=new He(this.programContainers.skinned);var o=new Float32Array(16*this.levels);this.shadowmaps=[];for(let e=0;e<this.levels;e++){var a=new xe(r,t[e],n[e],[d["TEXTURE"+(30-2*e)],d["TEXTURE"+(31-2*e)]]);a.textureMatrix=new Float32Array(o.buffer,16*Float32Array.BYTES_PER_ELEMENT*(1-e),16),this.shadowmaps.push(a)}var s=new Array(this.levels),l=new Array(this.levels);for(let e=0;e<this.levels;e++){var c=this.levels-1-e;s[e]=30-2*c,l[e]=this.shadowmaps[c].bias}this.clearShadowmaps=function(){for(var e=0;e<this.levels;e++)this.shadowmaps[e].clearShadowmap()};var u=0;this.refreshRate=0,this.renderShadowmaps=function(e){u++;let t=m.scenes[m.currentScene];t.root.traverseCondition((e=>{e.isCulled=!1}),(e=>e.active&&e.visible));for(let n=0;n<this.levels;n++){if(this.refreshRate>=1&&u%this.refreshRate!==Math.floor(n*this.refreshRate/this.levels))continue;let r=this.shadowmaps[n];r.updateModelMatrix(e),r.bind();let i={projectionMatrix:r.shadowPerspeciveMatrix,viewMatrix:r.shadowViewMatrix,inverseViewMatrix:r.shadowInverseViewMatrix,frustum:r.camera.frustum};t.updateUniformBuffers(i.projectionMatrix,i.viewMatrix,i.inverseViewMatrix),t.root.traverseCondition((e=>{e.isCulled||!e.meshRenderer||i.frustum&&e.getAABB()&&!e.getAABB().isInsideFrustum(i.frustum)?e.isCulled=!0:e.isCulled=!1}),(e=>e.active&&e.visible)),t.render(i,{materialOverride:this.material,materialOverrideInstanced:this.materialInstanced,materialOverrideSkinned:this.materialSkinned,renderPass:p.OPAQUE|p.SHADOWS})}},this.setUniforms=function(e){var t=e.getUniformLocation("textureMatrices[0]");null!=t&&(d.uniformMatrix4fv(t,!1,o),d.uniform1iv(e.getUniformLocation("projectedTextures[0]"),s),d.uniform1fv(e.getUniformLocation("biases[0]"),l))}}function xe(e=512,t=20,n=-.006,r=[d.TEXTURE31,d.TEXTURE30]){this.bias=n,this.textureNumbers=r,this.camera=new $e({type:$e.Type.Orthographic,size:t,near:1,far:300}),this.shadowPerspeciveMatrix=K.orthographic({size:t,near:1,far:300}),this.shadowModelMatrix=K.identity(),this.shadowViewMatrix=K.identity(),this.shadowInverseViewMatrix=K.identity(),this.textureMatrix=null,this.textureMatrixBase=K.transform([["translate",{x:.5,y:.5,z:.5}],["scale",X.fill(.5)]]),this.depthTexture=d.createTexture(),this.depthTextureSize=e,d.activeTexture(r[0]),d.bindTexture(d.TEXTURE_2D,this.depthTexture),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.DEPTH_COMPONENT:d.DEPTH_COMPONENT16,this.depthTextureSize,this.depthTextureSize,0,d.DEPTH_COMPONENT,d.UNSIGNED_INT,null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),this.depthFramebuffer=d.createFramebuffer(),d.bindFramebuffer(d.FRAMEBUFFER,this.depthFramebuffer),d.framebufferTexture2D(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.TEXTURE_2D,this.depthTexture,0),d.activeTexture(d.TEXTURE0);const i=X.zero(),o=new X,a=X.up(),s=new K,l=new X,c=new X;this.updateModelMatrix=function(n){const r=m.getActiveScene();X.negate(r.sunDirection,o),K.lookAt(i,o,a,this.shadowModelMatrix),K.inverse(this.shadowModelMatrix,s),K.transformVector(s,n,l);const u=t/e*2;c.x=E(l.x,u),c.y=E(l.y,u),c.z=l.z+100,K.applyTranslation(c,this.shadowModelMatrix),this.camera.transform.matrix=this.shadowModelMatrix,K.inverse(this.shadowModelMatrix,this.shadowViewMatrix),K.copy(this.shadowModelMatrix,this.shadowInverseViewMatrix),K.copy(this.textureMatrixBase,this.textureMatrix),K.multiply(this.textureMatrix,this.shadowPerspeciveMatrix,this.textureMatrix),K.multiply(this.textureMatrix,this.shadowViewMatrix,this.textureMatrix)},this.bind=function(){d.bindFramebuffer(d.FRAMEBUFFER,this.depthFramebuffer),d.viewport(0,0,this.depthTextureSize,this.depthTextureSize),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT)},this.clearShadowmap=function(){d.bindFramebuffer(d.FRAMEBUFFER,this.depthFramebuffer),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT)}}function be(e){this.programContainer=e;var t=this;Object.defineProperty(this,"program",{get:function(){return t.programContainer.program},set:e=>{t.programContainer.setProgram(e)}}),this.meshData=new Ne({position:{bufferData:new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),size:2}}),this.uniformLocations={viewDirectionProjectionInverse:d.getUniformLocation(this.program,"viewDirectionProjectionInverse"),environmentIntensity:d.getUniformLocation(this.program,"environmentIntensity"),skybox:d.getUniformLocation(this.program,"skybox")};var n=K.identity();this.render=function(e,t){if(!t)return;ee(this.program),this.meshData.bindBuffers(this.programContainer),K.copy(e.viewMatrix,n),K.removeTranslation(n),K.multiply(e.projectionMatrix,n,n),K.inverse(n,n);const r=m.getActiveScene();d.uniform1f(this.uniformLocations.environmentIntensity,r.environmentIntensity),d.uniformMatrix4fv(this.uniformLocations.viewDirectionProjectionInverse,!1,n),this.programContainer.setUniform("fogColor",r.fogColor),this.programContainer.setUniform("fogIntensity",r.skyboxFogIntensity),this.programContainer.setUniform("iTime",m.getTime()),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_CUBE_MAP,t),d.uniform1i(this.uniformLocations.skybox,0),d.depthFunc(d.LEQUAL),d.drawArrays(d.TRIANGLES,0,6),d.depthFunc(d.LESS)}}function ye(e){var t,n=this;this.activeAttributes={},this.activeUniforms={},this.uniformBuffers={},Object.defineProperty(this,"program",{get:function(){return t},set:function(e){n.setProgram(e)}}),this.setProgram=function(e){!function(e){e instanceof WebGLProgram||console.error("Not a program:",e)}(e),t=e,this.updateUniformLocations()},this.getUniformLocation=function(e){var t=this.activeUniforms[e];return t?t.location:null},this.setUniform=function(e,t,n=!0){var r=this.activeUniforms[e];if(r)if(-1===r.setType.indexOf("Matrix"))Array.isArray(t)?d["uniform"+r.setType+"v"](r.location,t):d["uniform"+r.setType](r.location,t);else{if(!ArrayBuffer.isView(t))throw console.error(t),new Error(`Cannot set matrix uniform: ${e}. Matrix must be Float32Array`);d["uniform"+r.setType](r.location,!1,t)}else n&&console.warn(`Cannot set uniform: ${e}. Uniform does not exist`)},this.bindTexture=function(e,t,n=0){d.activeTexture(d.TEXTURE0+n),d.bindTexture(d.TEXTURE_2D,e),d.uniform1i(this.getUniformLocation(t),n)},this.getAttribLocation=function(e){var t=this.activeAttributes[e];if(t)return t.location},this.updateUniformLocations=function(){this.activeAttributes={},this.activeUniforms={},this.uniformBuffers={};const e=d.getProgramParameter(t,d.ACTIVE_ATTRIBUTES);for(let n=0;n<e;n++){const e=d.getActiveAttrib(t,n),r=d.getAttribLocation(t,e.name),i=ie(e.type);this.activeAttributes[e.name]={location:r,size:e.size,type:e.type,typeString:i}}const n=d.getProgramParameter(t,d.ACTIVE_UNIFORMS);for(let e=0;e<n;e++){const n=d.getActiveUniform(t,e),r=d.getUniformLocation(t,n.name),i=ie(n.type),o=ne(i);this.activeUniforms[n.name]={location:r,size:n.size,type:n.type,typeString:i,setType:o}}if(m.version>1){const e=[...Array(n).keys()];var r=Math.max(...d.getActiveUniforms(t,e,d.UNIFORM_BLOCK_INDEX))+1;if(-1!=r)for(let e=0;e<r;e++){var i=d.getActiveUniformBlockName(t,e);if(null!=i){for(var o=d.getActiveUniformBlockParameter(t,e,d.UNIFORM_BLOCK_DATA_SIZE),a=d.getActiveUniformBlockParameter(t,e,d.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),s=new Array(a.length),l=0;l<s.length;l++)s[l]=d.getActiveUniform(t,a[l]).name;var c=d.getUniformIndices(t,s),u=d.getActiveUniforms(t,c,d.UNIFORM_OFFSET);this.uniformBuffers[i]={name:i,blockIndex:e,blockSize:o,subnames:s,offsets:u}}}}},this.setProgram(e)}function we(e={},t=m.programContainers.lit){return new We(t,e)}this.logGLError=ue,this.TrailRenderer=function(){this.gameObject=null;var e=X.up();Object.defineProperty(this,"emitNormal",{get:function(){return e},set:function(t){X.set(e,t)}});var t=X.zero(),n=!1;Object.defineProperty(this,"emitPosition",{get:function(){return t},set:function(e){X.set(t,e),n=!0}}),this.emit=!0,this.width=.13,this.maxVertices=500,this.minDistance=.05,this.uvOriginAtStart=!0;var r=0,i=new Array(this.maxVertices);for(let e=0;e<i.length;e++)i[e]={position:X.zero(),normal:X.up(),distance:0,alpha:1};var o=0,a=0,s=new Float32Array(2*this.maxVertices*3),l=new Float32Array(2*this.maxVertices*2),c=new Float32Array(2*this.maxVertices*1),u=new Ne({position:{bufferData:s,size:3},uv:{bufferData:l,size:2},alpha:{bufferData:c,size:1}}),h=we({metallic:1,albedo:[.003,.003,.003,1],albedoTexture:ze(m.path+"assets/textures/skidmarksSoft2.png"),alphaCutoff:0},m.programContainers.litTrail);h.opaque=!1,new Se(h,u).drawMode=d.TRIANGLE_STRIP;var f=K.identity(),v=new X,p=new j,g=X.zero(),x=()=>{n?X.set(g,t):K.getPosition(this.gameObject.transform.worldMatrix,g);var s=o<=0?i[i.length-1]:i[o-1],l=X.distanceSqr(s.position,g);if(l<this.minDistance*this.minDistance)return!1;var c=Math.sqrt(l);X.set(v,s.position),X.subtractTo(v,g),X.divideTo(v,c);var u=i[o],h=u.normal;return j.angleAxis(Math.PI/2,v,p),j.QxV(p,e,h),X.multiplyTo(h,this.width),X.set(u.position,g),u.distance=s.distance+c,u.alpha=this.emit,r+=c,++o>=i.length&&(o=0),a++,a=Math.min(a,this.maxVertices),!0};const T=(e,t=1)=>(e.set(e.subarray(t)),e.fill(0,-t),e);this.update=function(){if(x()){T(s,6),T(l,4),T(c,2);let e=b(o-1,i.length),t=i[e],n=t.position,a=t.normal,u=this.maxVertices-1;s[6*u+0]=n.x+a.x,s[6*u+1]=n.y+a.y,s[6*u+2]=n.z+a.z,s[6*u+3]=n.x-a.x,s[6*u+4]=n.y-a.y,s[6*u+5]=n.z-a.z;let h=t.distance,f=this.uvOriginAtStart?h:r-h;l[4*u+0]=f,l[4*u+1]=1,l[4*u+2]=f,l[4*u+3]=0;for(let e=this.maxVertices-1;e>=0;e--){let t=b(o-this.maxVertices+e,i.length),n=i[t].alpha;n=y(n,0,1),n*=e/(this.maxVertices-1);let r=e;c[2*r+0]=n,c[2*r+1]=n}}let e=d.STREAM_DRAW;d.bindBuffer(d.ARRAY_BUFFER,u.buffers[0].buffer),d.bufferData(d.ARRAY_BUFFER,s,e,6*(this.maxVertices-a)),d.bindBuffer(d.ARRAY_BUFFER,u.buffers[1].buffer),d.bufferData(d.ARRAY_BUFFER,l,e,4*(this.maxVertices-a)),d.bindBuffer(d.ARRAY_BUFFER,u.buffers[2].buffer),d.bufferData(d.ARRAY_BUFFER,c,e,2*(this.maxVertices-a))},this.render=function(e,t,n=!1,r=!0){if(!n){if(null===h.programContainer)return;if(h.isOpaque()!=r)return;ee(h.programContainer.program),u.bindBuffers(h.programContainer),Me(h,{camera:e,modelMatrix:f,prevViewMatrix:e.prevViewMatrix,shadowPass:n}),!n&&m.shadowCascades&&m.shadowCascades.setUniforms(h),Ee(h,n),d.drawArrays(d.TRIANGLE_STRIP,0,2*a)}}},this.ParticleSystem=function(e=200,t){var n=this;this.maxParticles=e,this.drawOnDownscaledFramebuffer=!1,this.drawMode=d.TRIANGLES,this.material=null,this.meshData=t??Xe(),this.particles=new Array(this.maxParticles);for(let e=0;e<this.particles.length;e++)this.particles[e]=new a(new X(0,-1e3,0));var r=[];this.matrixData=new Float32Array(16*this.maxParticles);for(let e=0;e<this.maxParticles;e++)this.matrixData.set(this.particles[e].matrix,16*e);this.colorData=new Float32Array(4*this.maxParticles);for(let e=0;e<this.colorData.length;e++)this.colorData[e]=1;this.matrixBuffer=d.createBuffer(),d.bindBuffer(d.ARRAY_BUFFER,this.matrixBuffer),d.bufferData(d.ARRAY_BUFFER,this.matrixData,d.DYNAMIC_DRAW),this.colorBuffer=d.createBuffer(),d.bindBuffer(d.ARRAY_BUFFER,this.colorBuffer),d.bufferData(d.ARRAY_BUFFER,this.colorData,d.DYNAMIC_DRAW);var i=X.zero();this.orientation="faceVelocity",this.localParticles=!0,this.alpha=1,this.startSize=e=>(e.x=.6*(.8*Math.random()+.2),e.y=.15*(.4*Math.random()+.6),e.z=1,e),this.endSize=e=>X.zero(e),this.emitPosition=e=>X.zero(e),this.emitVelocity=e=>X.zero(e),this.emitHealth=.5,this.alphaCurve=new pe,this.alphaCurve.addStage(0,1),this.alphaCurve.addStage(.8,1),this.alphaCurve.addStage(1,0),this.wind=e=>(e.x=10*(Math.random()-.45),e.y=0,e.z=10*(Math.random()-.45),e),this.drag=1,this.gravityScale=1;var o=new X;function a(e){this.position=e,this.matrix=K.translate(this.position),this.velocity=X.zero(),this.startSize=X.one(),this.endSize=X.one(),this.health=.5,this.maxHealth=.5,this.alpha=n.alpha,this.active=!0;var t=X.up(),o=X.zero(),a=K.identity(),s=X.zero(),l=new X;this.matrix=K.identity(),this.getAlpha=function(){return this.alpha*n.alphaCurve.getValue(1-this.health/this.maxHealth)},this.getMatrix=function(){if(i){var e,r;if(n.localParticles?(K.copy(n.gameObject.transform.matrix,a),e=K.transformVector(a,this.position),r=K.transformDirection(a,this.velocity)):(e=this.position,r=this.velocity),"faceVelocity"==n.orientation){var l=X.normalize(r),c=X.projectOnPlane(X.subtract(i,e),l);K.lookInDirection(e,c,l,this.matrix)}else{if("faceCamera"!=n.orientation)throw new Error("Unknown orientation mode: "+n.orientation);X.set(o,i),X.subtractTo(o,e),K.lookInDirection(e,o,t,this.matrix)}X.lerp(this.endSize,this.startSize,this.health/this.maxHealth,s),K.scaleWithVector(this.matrix,s)}return this.matrix},this.update=function(e){this.active&&(n.wind(l),X.multiplyTo(l,e),X.addTo(this.velocity,l),this.velocity.x-=n.drag*Math.abs(this.velocity.x)*this.velocity.x*e,this.velocity.y-=n.drag*Math.abs(this.velocity.y)*this.velocity.y*e,this.velocity.z-=n.drag*Math.abs(this.velocity.z)*this.velocity.z*e,this.velocity.y-=9.82*n.gravityScale*e,this.position.x+=this.velocity.x*e,this.position.y+=this.velocity.y*e,this.position.z+=this.velocity.z*e,this.health-=e,this.health<=0&&(this.active=!1,r.push(this)))}}this.emit=function(e=1){for(var t=0;t<e&&r.length>0;t++){var i=r.shift();i.active=!0,i.health=i.maxHealth=this.emitHealth,i.alpha=this.alpha,n.emitPosition(o),X.set(i.position,o),n.emitVelocity(o),X.set(i.velocity,o),n.startSize(o),X.set(i.startSize,o),n.endSize(o),X.set(i.endSize,o)}},this.update=function(e){for(var t of this.particles)t.update(e);for(var n=0;n<this.maxParticles;n++){var r=this.particles[n];r.active?(this.matrixData.set(r.getMatrix(),16*n),this.colorData[4*n+3]=r.getAlpha()):this.colorData[4*n+3]=0}d.bindBuffer(d.ARRAY_BUFFER,this.matrixBuffer),d.bufferData(d.ARRAY_BUFFER,this.matrixData,d.DYNAMIC_DRAW),d.bindBuffer(d.ARRAY_BUFFER,this.colorBuffer),d.bufferData(d.ARRAY_BUFFER,this.colorData,d.DYNAMIC_DRAW)},this.render=function(e,t,n=!1,r=!0,o,a={}){if(a.downscaledPass==this.drawOnDownscaledFramebuffer&&!r){K.getPosition(e.cameraMatrix,i),null==this.material&&(this.material=we({albedoTexture:ze(m.path+"assets/textures/bulletTrail.png"),albedo:[40,10,5,1]},m.programContainers.particle),this.material.doubleSided=!0),ee(this.material.programContainer.program),this.meshData.bindBuffers(this.material.programContainer),d.bindBuffer(d.ARRAY_BUFFER,this.matrixBuffer);const t=this.material.programContainer.getAttribLocation("modelMatrix");for(var s=0;s<4;s++){const e=t+s;d.enableVertexAttribArray(e),d.vertexAttribPointer(e,4,d.FLOAT,!1,64,16*s),le(e,1)}d.bindBuffer(d.ARRAY_BUFFER,this.colorBuffer);const r=this.material.programContainer.getAttribLocation("color");d.enableVertexAttribArray(r),d.vertexAttribPointer(r,4,d.FLOAT,!1,0,0),le(r,1),this.material instanceof He?Me(this.material,{camera:e,prevViewMatrix:e.prevViewMatrix,shadowPass:n}):this.material.bindUniforms(e),Ee(this.material,n),ce(this.drawMode,this.meshData.indices.length,this.meshData.indexType,0,this.maxParticles)}}},this.RenderTexture=function(e=512,t=512,n={}){this.width=e,this.height=t,this.clearFlags=n.clearFlags??d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT,this.framebuffer=d.createFramebuffer(),d.bindFramebuffer(d.FRAMEBUFFER,this.framebuffer),this.colorTexture=d.createTexture(),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,this.colorTexture),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,this.width,this.height,0,d.RGBA,Y(),null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,this.colorTexture,0),this.depthTexture=d.createTexture(),d.bindTexture(d.TEXTURE_2D,this.depthTexture),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.DEPTH_COMPONENT:d.DEPTH_COMPONENT16,this.width,this.height,0,d.DEPTH_COMPONENT,d.UNSIGNED_INT,null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.framebufferTexture2D(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.TEXTURE_2D,this.depthTexture,0),this.bind=function(){d.bindFramebuffer(d.FRAMEBUFFER,this.framebuffer)},this.resize=function(e,t){this.width=e,this.height=t,d.bindTexture(d.TEXTURE_2D,this.colorTexture),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,this.width,this.height,0,d.RGBA,Y(),null),d.bindTexture(d.TEXTURE_2D,this.depthTexture),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.DEPTH_COMPONENT:d.DEPTH_COMPONENT16,this.width,this.height,0,d.DEPTH_COMPONENT,d.UNSIGNED_INT,null)}},this.UniformBuffer=function(e,t){this.data=new Float32Array,this.location=e,this.buffer=d.createBuffer(),d.bindBuffer(d.UNIFORM_BUFFER,this.buffer),d.bufferData(d.UNIFORM_BUFFER,t,d.DYNAMIC_DRAW),d.bindBuffer(d.UNIFORM_BUFFER,null),d.bindBufferBase(d.UNIFORM_BUFFER,this.location,this.buffer),this.update=function(e){this.data=e,d.bindBuffer(d.UNIFORM_BUFFER,this.buffer),d.bufferData(d.UNIFORM_BUFFER,this.data,d.DYNAMIC_DRAW),d.bindBuffer(d.UNIFORM_BUFFER,null),d.bindBufferBase(d.UNIFORM_BUFFER,this.location,this.buffer)}},h.ProgramContainer=ye,this.ProgramContainer=ye,this.LitMaterial=class{constructor(e={},t=m.programContainers.lit){return m.CreateLitMaterial(e,t)}},this.CreateLitMaterial=we;let Ee=(e,t=!1)=>{t?e.doubleSidedShadows?m.disableCulling():m.enableCulling():e.doubleSided?m.disableCulling():m.enableCulling()},Me=(e,t={})=>{Ce(e,e.programContainer,t)},_e=[0,0,0],Re=[0,0,0],Ce=(e,t,n={})=>{let r=m.getActiveScene(),i=0,o=(e,n)=>{if(!t.activeUniforms[n])return;let r=(e=>{let t=null;if(-1!==(e=e.toUpperCase()).indexOf("SAMPLER_2D_ARRAY"))t=d.TEXTURE_2D_ARRAY;else if(-1!==e.indexOf("SAMPLER_CUBE"))t=d.TEXTURE_CUBE_MAP;else if(-1!==e.indexOf("SAMPLER_3D"))t=d.TEXTURE_3D;else{if(-1===e.indexOf("SAMPLER_2D"))throw new Error("Unknown texture target: ",e);t=d.TEXTURE_2D}return t})(t.activeUniforms[n].typeString);if(Array.isArray(e)){var o=Array.from({length:e.length},((e,t)=>i+t));d.uniform1iv(t.getUniformLocation(n),o);for(var a=0;a<e.length;a++)d.activeTexture(d.TEXTURE0+i),d.bindTexture(r,e[a]),i++}else d.activeTexture(d.TEXTURE0+i),d.bindTexture(r,e),d.uniform1i(t.getUniformLocation(n),i),i++},a=e=>t.getUniformLocation(e);if(n.modelMatrix&&t.setUniform("modelMatrix",n.modelMatrix,!1),n.prevModelMatrix&&t.setUniform("prevModelMatrix",n.prevModelMatrix,!1),e.isLit&&!n.shadowPass&&(o(m.splitsumTexture,"u_splitSum"),o(r.diffuseCubemap,"u_diffuseIBL"),o(r.specularCubemap,"u_specularIBL")),!this.currentBoundLitPrograms.has(t)){((e,t)=>{let n=e=>t.getUniformLocation(e);n("iTime")&&d.uniform1f(n("iTime"),w);var r=e.getLights();n("nrLights")&&d.uniform1i(n("nrLights"),r.length);for(let e=0;e<r.length;e++){let t=r[e];n(`lights[${e}].type`)&&d.uniform1i(n(`lights[${e}].type`),t.type),n(`lights[${e}].position`)&&d.uniform3f(n(`lights[${e}].position`),t.position.x,t.position.y,t.position.z),n(`lights[${e}].direction`)&&t.direction&&d.uniform3f(n(`lights[${e}].direction`),t.direction.x,t.direction.y,t.direction.z),n(`lights[${e}].angle`)&&"angle"in t&&d.uniform1f(n(`lights[${e}].angle`),t.angle),n(`lights[${e}].color`)&&d.uniform3f(n(`lights[${e}].color`),t.color[0],t.color[1],t.color[2])}null!=n("sunDirection")&&d.uniform3fv(n("sunDirection"),X.toArray(e.sunDirection,_e)),null!=n("sunIntensity")&&d.uniform3fv(n("sunIntensity"),X.toArray(e.sunIntensity,Re)),null!=n("environmentIntensity")&&d.uniform1f(n("environmentIntensity"),e.environmentIntensity),null!=n("environmentMinLight")&&d.uniform1f(n("environmentMinLight"),e.environmentMinLight),null!=n("ambientColor")&&d.uniform3fv(n("ambientColor"),e.ambientColor),null!=n("fogDensity")&&d.uniform1f(n("fogDensity"),e.fogDensity),null!=n("fogColor")&&d.uniform4fv(n("fogColor"),e.fogColor)})(r,t);let i=t.uniformBuffers.sharedPerScene;if(i&&r.sharedUBO)d.uniformBlockBinding(t.program,i.blockIndex,r.sharedUBO.location);else{let e=n.camera;e&&(null!=a("projectionMatrix")&&d.uniformMatrix4fv(a("projectionMatrix"),!1,e.projectionMatrix),null!=a("inverseViewMatrix")&&d.uniformMatrix4fv(a("inverseViewMatrix"),!1,e.inverseViewMatrix),null!=a("viewMatrix")&&d.uniformMatrix4fv(a("viewMatrix"),!1,e.viewMatrix))}n.prevViewMatrix&&t.setUniform("prevViewMatrix",n.prevViewMatrix,!1),n.shadowPass||(d.uniform1i(t.getUniformLocation("shadowQuality"),n.shadowQuality??0),m.shadowCascades&&m.shadowCascades.setUniforms(e)),this.currentBoundLitPrograms.set(t,1)}t.setUniform("opaque",e.opaque,!1);for(let n in e.uniforms)t.activeUniforms[n]&&((s=e.uniforms[n])instanceof WebGLTexture||Array.isArray(s)&&s.every((e=>e instanceof WebGLTexture))?o(e.uniforms[n],n):t.setUniform(n,e.uniforms[n]));var s};function Fe(e,t){this.joints=e,this.inverseBindMatrixData=t,this.inverseBindMatrices=[],this.jointMatrices=[],this.jointData=new Float32Array(16*e.length),this.textureIndex=25,this.parentNode=null;for(var n=0;n<e.length;n++)this.inverseBindMatrices.push(new Float32Array(t.buffer,t.byteOffset+16*Float32Array.BYTES_PER_ELEMENT*n,16)),this.jointMatrices.push(new Float32Array(this.jointData.buffer,16*Float32Array.BYTES_PER_ELEMENT*n,16));this.jointTexture=d.createTexture(),d.activeTexture(d.TEXTURE0+this.textureIndex),d.bindTexture(d.TEXTURE_2D,this.jointTexture),d.texImage2D(d.TEXTURE_2D,0,d.RGBA32F,4,this.joints.length,0,d.RGBA,Y(),null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),this.copy=function(){var e=new Fe([...this.joints],new Float32Array(t));return e.parentNode=this.parentNode,e},this.update=function(){this.updateMatrixTexture()},this.bindTexture=function(e){d.uniform1i(e.programContainer.getUniformLocation("u_jointTexture"),this.textureIndex),d.uniform1f(e.programContainer.getUniformLocation("u_numJoints"),this.joints.length),d.activeTexture(d.TEXTURE0+this.textureIndex),d.bindTexture(d.TEXTURE_2D,this.jointTexture)},this.updateMatrixTexture=function(){for(let e=0;e<this.joints.length;e++)K.copy(K.multiply(this.joints[e].transform.getWorldMatrix(this.parentNode),this.inverseBindMatrices[e]),this.jointMatrices[e]);d.activeTexture(d.TEXTURE0+this.textureIndex),d.bindTexture(d.TEXTURE_2D,this.jointTexture),d.texSubImage2D(d.TEXTURE_2D,0,0,0,4,this.joints.length,d.RGBA,Y(),this.jointData)}}this.Skin=Fe;class Ae{drawOnDownscaledFramebuffer=!1;constructor(){this.eventHandler=new Ue,this.on=this.eventHandler.on.bind(this.eventHandler),this.off=this.eventHandler.off.bind(this.eventHandler)}cleanup(){for(let e of this.meshData)e.cleanup()}setShadowQuality(e,t=!1){for(var n of this.materials)n.isOpaque()==t&&null!==n.programContainer&&(ee(n.programContainer.program),d.uniform1i(n.programContainer.getUniformLocation("shadowQuality"),e))}isFullyOpaque(){for(let e of this.materials)if(!e.isOpaque())return!1;return!0}}class De extends Ae{constructor(e,t,n,r={}){super(),this.materials=Array.isArray(t)?t:[t],this.meshData=Array.isArray(n)?n:[n],this.drawMode=r.drawMode??d.TRIANGLES,this.skin=e}update(){this.skin.update()}render(e,t,n=!1,r=!0,i,o={}){if((o.downscaledPass??!1)==this.drawOnDownscaledFramebuffer)for(var a=0;a<this.meshData.length;a++){var s=this.meshData[a],l=this.materials[a];null!==l.programContainer&&(o.submeshCondition&&!o.submeshCondition(s,l)||l.isOpaque()==r&&(ee(l.programContainer.program),s.bindBuffers(l.programContainer),l instanceof He?Me(l,{camera:e,modelMatrix:t,prevModelMatrix:i,prevViewMatrix:e.prevViewMatrix,shadowPass:n}):(l.bindModelMatrixUniform(t,i,e.prevViewMatrix),l.bindUniforms(e)),this.skin.bindTexture(l),n&&d.uniform1iv(l.programContainer.getUniformLocation("projectedTextures[0]"),[0,0]),Ee(l,n),s.drawCall(this.drawMode)))}}copy(){var e=[];for(var t of this.materials)e.push(t.copy());var n=[];for(var r of this.meshData)n.push(r.copy());var i=new De(this.skin.copy(),e,n);return i.drawMode=this.drawMode,i}}h.SkinnedMeshRenderer=De;class Pe extends Ae{constructor(e,t,n={}){super(),this.materials=Array.isArray(e)?e:[e],this.meshData=Array.isArray(t)?t:[t],this.drawMode=n.drawMode??d.TRIANGLES,this.matrixBuffer=d.createBuffer(),this.needsBufferUpdate=!1,this.matrices=[]}getAABB(e){(e=e||new Te).isEmpty=!0,X.zero(e.bl),X.zero(e.tr);const t=new Te;for(let n of this.meshData)for(let r of this.matrices)n.aabb.copy(t).approxTransform(r),e.extend(t);return e}addInstance(e){var t=K.copy(e);return this.matrices.push(t),this.needsBufferUpdate=!0,t}addInstanceDontCopy(e){return this.matrices.push(e),this.needsBufferUpdate=!0,e}updateInstance(e,t,n=!0){this.needsBufferUpdate&&(this.updateMatrixData(),this.needsBufferUpdate=!1),K.copy(t,e),this.matrixData.set(e,16*this.matrices.indexOf(e)),n&&(d.bindBuffer(d.ARRAY_BUFFER,this.matrixBuffer),d.bufferSubData(d.ARRAY_BUFFER,0,this.matrixData))}removeInstance(e){var t=this.matrices.indexOf(e);-1!=t&&(this.matrices.splice(t,1),this.needsBufferUpdate=!0)}removeAllInstances(){this.matrices=[],this.needsBufferUpdate=!0}updateMatrixData(){this.matrixData=new Float32Array(16*this.matrices.length);for(var e=0;e<this.matrices.length;e++)this.matrixData.set(this.matrices[e],16*e);d.bindBuffer(d.ARRAY_BUFFER,this.matrixBuffer),d.bufferData(d.ARRAY_BUFFER,this.matrixData,d.DYNAMIC_DRAW)}render(e,t,n=!1,r=!0,i,o={}){if((o.downscaledPass??!1)==this.drawOnDownscaledFramebuffer&&(this.needsBufferUpdate&&(this.updateMatrixData(),this.needsBufferUpdate=!1),this.matrices.length>0))for(var a=0;a<this.meshData.length;a++){var s=this.meshData[a],l=this.materials[a];if(null!==l.programContainer&&(!o.submeshCondition||o.submeshCondition(s,l))&&l.isOpaque()==r){ee(l.programContainer.program),s.bindBuffers(l.programContainer),d.bindBuffer(d.ARRAY_BUFFER,this.matrixBuffer);for(var c=l.programContainer.getAttribLocation("modelMatrix"),u=0;u<4;u++){const e=c+u;d.enableVertexAttribArray(e),d.vertexAttribPointer(e,4,d.FLOAT,!1,64,16*u),le(e,1)}l instanceof He?Me(l,{camera:e,prevModelMatrix:i,prevViewMatrix:e.prevViewMatrix,shadowPass:n}):l.bindUniforms(e),Ee(l,n),ce(this.drawMode,s.indices.length,s.indexType,0,this.matrices.length)}}}copy(){var e=[];for(var t of this.materials)e.push(t.copy());var n=[];for(var r of this.meshData)n.push(r.copy());var i=new Pe(e,n);return i.drawMode=this.drawMode,i}}h.MeshInstanceRenderer=Pe,this.MeshInstanceRenderer=Pe;class Se extends Ae{constructor(e,t,n={}){if(super(),this.materials=Array.isArray(e)?e:[e],this.meshData=Array.isArray(t)?t:[t],this.drawMode=n.drawMode??d.TRIANGLES,this.materials.some((e=>!(e instanceof He))))throw console.error(this.materials),new Error("Not a valid Material!");if(this.meshData.some((e=>!(e instanceof Ne))))throw console.error(this.meshData),new Error("Not a valid MeshData!");for(let e of this.meshData)e.on("updateAABB",(()=>{this.eventHandler.fireEvent("updateAABB")}))}getAABB(e){for(var t of((e=e||new Te).isEmpty=!0,X.zero(e.bl),X.zero(e.tr),this.meshData))e.extend(t.aabb);return e}render(e,t,n=!1,r=!0,i,o={}){if((o.downscaledPass??!1)==this.drawOnDownscaledFramebuffer)for(var a=0;a<this.meshData.length;a++){var s=this.meshData[a],l=this.materials[a];if(null!==l.programContainer&&(!o.submeshCondition||o.submeshCondition(s,l))&&l.isOpaque()==r){if(ee(l.programContainer.program),s.bindBuffers(l.programContainer),l instanceof He?Me(l,{camera:e,modelMatrix:t,prevModelMatrix:i,prevViewMatrix:e.prevViewMatrix,shadowPass:n,shadowQuality:o.shadowQuality}):(l.bindModelMatrixUniform(t,i,e.prevViewMatrix),l.bindUniforms(e)),n){let e=l.programContainer.getUniformLocation("projectedTextures[0]");e&&d.uniform1iv(e,[0,0])}Ee(l,n),s.drawCall(this.drawMode)}}}getInstanceMeshRenderer(e=m.programContainers.litInstanced){var t=[];for(var n of this.materials){var r=n.copy();r.programContainer=e,t.push(r)}return new Pe(t,this.meshData,{drawMode:this.drawMode})}copy(){var e=this.materials.map((e=>e.copy())),t=this.meshData.map((e=>e.copy())),n=new Se(e,t);return n.drawMode=this.drawMode,n}}function Ne(e){for(var t of(this.eventHandler=new Ue,this.on=this.eventHandler.on.bind(this.eventHandler),this.data=e,Object.defineProperty(this,"indices",{get:()=>this.data?.indices?.bufferData}),Object.defineProperty(this,"indexType",{get:()=>this.data?.indices?.type??d.UNSIGNED_INT}),this.buffers=[],Object.keys(this.data))){var n=this.data[t];this.buffers.push({attribute:t,buffer:J(n.bufferData,n.target??d.ARRAY_BUFFER),size:n.size,target:n.target??d.ARRAY_BUFFER,type:n.type??d.FLOAT,stride:n.stride??0})}var r=[];this.vaos=new WeakMap;const i=new Te,o=new X;let a=()=>{if(i.isEmpty=!0,X.zero(i.bl),X.zero(i.tr),this.data.position)for(var e=0;e<this.data.position.bufferData.length;e+=3)o.x=this.data.position.bufferData[e],o.y=this.data.position.bufferData[e+1],o.z=this.data.position.bufferData[e+2],i.extend(o);this.eventHandler.fireEvent("updateAABB")};a(),Object.defineProperty(this,"aabb",{get:()=>i,set:()=>{throw new Error("Set MeshData aabb")}}),this.updateData=function(e,t=d.DYNAMIC_DRAW){this.data=e;for(let r of Object.keys(e)){var n=this.buffers.find((e=>e.attribute==r));n&&n.size==e[r].size&&n.target==(e[r].target??d.ARRAY_BUFFER)&&n.type==(e[r].type??d.FLOAT)&&n.stride==(e[r].stride??0)?(d.bindBuffer(n.target,n.buffer),d.bufferData(n.target,e[r].bufferData,t)):console.warn("New attribute or missmatching size, target, type or stride: "+r)}a()},this.setAttribute=function(e,t,n=d.DYNAMIC_DRAW){var r=this.buffers.find((t=>t.attribute==e));r?(d.bindBuffer(r.target,r.buffer),d.bufferData(r.target,t.bufferData,n),"size"in t&&(r.size=t.size),"target"in t&&(r.target=t.target),"type"in t&&(r.type=t.type),"stride"in t&&(r.stride=t.stride),this.data[e]=t):this.buffers.push({attribute:e,buffer:J(t.bufferData,t.target??d.ARRAY_BUFFER),size:t.size,target:t.target??d.ARRAY_BUFFER,type:t.type??d.FLOAT,stride:t.stride??0}),"position"===e&&a()},this.recalculateNormals=function(){if(!this.data.position||!this.data.indices)throw new Error("Can't generate normals! Missing positions or indicies");var e=Dn(this.data.position.bufferData,this.data.indices.bufferData);this.setAttribute("normal",{bufferData:e,size:3})},this.recalculateTangents=function(){if(!(this.data.position&&this.data.indices&&this.data.uv))throw new Error("Can't generate tangents! Missing positions, indicies or uvs");var e=Pn(this.data.position.bufferData,this.data.indices.bufferData,this.data.uv.bufferData);this.setAttribute("tangent",{bufferData:e,size:4})},this.applyTransform=function(e){if(!(this.data&&this.data.position&&this.data.indices))throw new Error("Can't transform MeshData. MeshData is missing 'position' or 'indices' attribute");for(let t=0;t<this.data.position.bufferData.length;t+=3){let n={x:this.data.position.bufferData[t+0],y:this.data.position.bufferData[t+1],z:this.data.position.bufferData[t+2]};n=K.transformVector(e,n),this.data.position.bufferData[t+0]=n.x,this.data.position.bufferData[t+1]=n.y,this.data.position.bufferData[t+2]=n.z}this.setAttribute("position",this.data.position)},this.getSubdivision=function(e=1,t=!1){let n=this.data.position.bufferData,r=this.data.indices.bufferData;function i(e,t,n,r){this.a=e,this.b=t,this.v=n,this.last=r}let o=(e,t)=>((t=t||new X).x=n[3*e+0],t.y=n[3*e+1],t.z=n[3*e+2],t),a=[],s=[];a=[...n];let l=new Map,c=e=>l.get(`${e[0]}-${e[1]}`),u=e=>{let t=[];for(let n=0;n<r.length;n+=3){let i=r[n+0],o=r[n+1],a=r[n+2],s=[[i,o],[o,a],[a,i]],l=[a,i,o];for(let n=0;n<s.length;n++){let r=s[n];(r[0]==e[0]&&r[1]==e[1]||r[0]==e[1]&&r[1]==e[0])&&t.push({a:e[0],b:e[1],last:l[n]})}}return t},h=new Array(n.length/3);for(let e=0;e<h.length;e++)h[e]=[];for(let e=0;e<r.length;e+=3){let t=r[e+0],n=r[e+1],i=r[e+2],o=[[t,n],[n,i],[i,t]],a=[i,t,n];for(let e=0;e<a.length;e++)h[a[e]].push(...o[e])}for(let e=0;e<h.length;e++)h[e]=Array.from(new Set(h[e]));for(let e=0;e<n.length/3;e++){let t=h[e],n=t.length,r=2==n?1/8:3==n?3/16:3/8/n,i=n>=3?1-n*r:3/4,s=X.zero();for(let e of t)X.addTo(s,X.multiply(o(e),r));X.addTo(s,X.multiply(o(e),i)),a[3*e+0]=s.x,a[3*e+1]=s.y,a[3*e+2]=s.z}for(let e=0;e<r.length;e+=3){let n=r[e+0],h=r[e+1],f=r[e+2],d=[[n,h],[h,f],[f,n]],m=[f,n,h],v=[];for(let e=0;e<d.length;e++){let n=d[e];if(t){let t=c(n);if(t){let n=X.multiply(o(m[e]),1/8);a[3*t.v+0]+=n.x,a[3*t.v+1]+=n.y,a[3*t.v+2]+=n.z,v.push(t.v)}else{let r=o(n[0]),s=o(n[1]),c=X.add(X.multiply(r,3/8),X.multiply(s,3/8));X.addTo(c,X.multiply(o(m[e]),1/8)),a.push(c.x,c.y,c.z),v.push(a.length/3-1),t=new i(n[0],n[1],a.length/3-1,m[e]),l.set(`${n[0]}-${n[1]}`,t),l.set(`${n[1]}-${n[0]}`,t)}}else{let e=c(n);if(e)v.push(e.v);else{let e=u(n);if(2==e.length){let t=X.zero();X.addTo(t,X.multiply(o(e[0].a),3/8)),X.addTo(t,X.multiply(o(e[0].b),3/8)),X.addTo(t,X.multiply(o(e[0].last),1/8)),X.addTo(t,X.multiply(o(e[1].last),1/8)),a.push(t.x,t.y,t.z),v.push(a.length/3-1)}else if(1==e.length){let t=X.zero();X.addTo(t,X.multiply(o(e[0].a),.5)),X.addTo(t,X.multiply(o(e[0].b),.5)),a.push(t.x,t.y,t.z),v.push(a.length/3-1)}else console.warn(e.length);let t=new i(n[0],n[1],a.length/3-1,null);l.set(`${n[0]}-${n[1]}`,t),l.set(`${n[1]}-${n[0]}`,t)}}}s.push(n,v[0],v[2]),s.push(v[0],h,v[1]),s.push(v[1],f,v[2]),s.push(v[0],v[1],v[2])}return{indices:{bufferData:new Uint32Array(s),type:5125,target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(a),size:3}}},this.subdivide=function(e=1){let t=this.getSubdivision(e);this.setAttribute("indices",t.indices),this.setAttribute("position",t.position),this.recalculateNormals()},this.copy=function(){return this},this.bindBuffers=function(e){var t=e.program,n=this.vaos.get(t);if(null==n){n=1==m.version?m.VAOExt.createVertexArrayOES():2==m.version?d.createVertexArray():void 0,r.push(n),this.vaos.set(t,n),se(n);for(var i=e.activeAttributes,o=0;o<this.buffers.length;o++){var a=this.buffers[o];if(a.target==d.ELEMENT_ARRAY_BUFFER)d.bindBuffer(d.ELEMENT_ARRAY_BUFFER,a.buffer);else{var s=i[a.attribute];void 0!==s&&-1!=(s=s.location)&&(d.bindBuffer(a.target,a.buffer),d.enableVertexAttribArray(s),le(s,0),d.vertexAttribPointer(s,a.size,a.type,!1,a.stride,0))}}}else se(n)},this.drawCall=function(e){this.indices?d.drawElements(e,this.indices.length,this.indexType,0):this.data.position?e==d.TRIANGLE_STRIP?d.drawArrays(e,0,this.data.position.bufferData.length/3):d.drawArrays(e,0,this.data.position.bufferData.length):console.warn("Can't render meshData")},this.cleanup=function(){for(var e of r)ae(e);for(var t of this.buffers)d.deleteBuffer(t.buffer)}}function ze(e,t={}){var n=d.createTexture();if(d.bindTexture(d.TEXTURE_2D,n),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,1,1,0,d.RGBA,d.UNSIGNED_BYTE,new Uint8Array([0,0,255,255])),"string"==typeof e){var r=new Image;r.crossOrigin="Anonymous",r.src=e,r.onload=function(){Be(n,r,t)}}else Be(n,e,t);return n}async function Le(e,t={}){var n;return n="string"==typeof e?await P(e):e,Be(d.createTexture(),n,t)}function Be(e,t,n){if(Object.prototype.hasOwnProperty.call(n,"anisotropicFiltering")||(n.anisotropicFiltering=!0),Object.prototype.hasOwnProperty.call(n,"generateMipmap")||(n.generateMipmap=!0),Object.prototype.hasOwnProperty.call(n,"maxTextureSize")&&t.width>n.maxTextureSize){var r=t.width/t.height;t=Nn(t,n.maxTextureSize,n.maxTextureSize/r)}if(1==m.version){var i=Math.pow(2,Math.floor(Math.log2(t.width)));t=Nn(t,i,i)}if(d.bindTexture(d.TEXTURE_2D,e),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,0),d.texImage2D(d.TEXTURE_2D,n.level??0,n.internalFormat??d.RGBA,n.format??d.RGBA,d.UNSIGNED_BYTE,t),n.generateMipmap&&(1!=m.version||1==m.version&&M(t.width)&&M(t.height))&&35906!=n.format?d.generateMipmap(d.TEXTURE_2D):d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),n.TEXTURE_WRAP_R&&d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_R,n.TEXTURE_WRAP_R),n.TEXTURE_WRAP_S&&d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,n.TEXTURE_WRAP_S),n.TEXTURE_WRAP_T&&d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,n.TEXTURE_WRAP_T),n.TEXTURE_MIN_FILTER&&d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,n.TEXTURE_MIN_FILTER),n.TEXTURE_MAG_FILTER&&d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,n.TEXTURE_MAG_FILTER),n.anisotropicFiltering&&m.EXT_texture_filter_anisotropic){const e=m.EXT_texture_filter_anisotropic,t=m.MAX_ANISOTROPY;d.texParameterf(d.TEXTURE_2D,e.TEXTURE_MAX_ANISOTROPY_EXT,t)}return e}this.MeshRenderer=Se,this.MeshData=Ne,this.loadMetalRoughness=function(e,t){var n=d.createTexture();return d.bindTexture(d.TEXTURE_2D,n),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,1,1,0,d.RGBA,d.UNSIGNED_BYTE,new Uint8Array([0,255,0,255])),Promise.all([P(e),P(t)]).then((([e,t])=>{if(e.width!=t.width||e.height!=t.height)throw new Error("Dimension mismatch!");for(var r=S(e),i=S(t),o=new Uint8Array(e.width*e.height*4),a=0;a<o.length;a+=4)o[a]=0,o[a+1]=i[a+1],o[a+2]=r[a+2],o[a+3]=255;d.bindTexture(d.TEXTURE_2D,n),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,e.width,e.height,0,d.RGBA,d.UNSIGNED_BYTE,o),d.generateMipmap(d.TEXTURE_2D)})).catch((e=>{throw e})),n},this.loadTexture=ze,this.loadTextureAsync=Le,this.loadGLTF=async function(e,t={}){console.groupCollapsed("Load GLTF: "+e);var n=await this.getGLTFData(e),r=await this.createGameObjectFromGLTFData(n,t);return console.groupEnd(),r},this.getGLTFData=async function(e){return new Promise(((t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=async function(){if(200==r.status){var i=r.response;if(i){let n=new TextDecoder;for(var o,a=new Uint8Array(i),s=[],l=12;l<a.byteLength;){var c=A(a.slice(l,l+4)),u=A(a.slice(l+4,l+8)),h=a.slice(l+8,l+8+c);if(1313821514==u){var f=n.decode(h);o=JSON.parse(f)}else{if(5130562!=u)throw new Error("Invalid chunk type: "+u.toString(16));s.push(h)}l+=c+8}t({json:o,buffers:s,path:e})}}else n("Could not load GLTF model: "+r.statusText)},r.send(null)}))};var Ie={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},ke={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Ve={5120:8,5121:8,5122:16,5123:16,5125:32,5126:32};function Ge(){var e=new Float32Array([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1]),t=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),n=new Uint32Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),r=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0]),i=Pn(e,n,r);return{indices:{bufferData:n,target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:e,size:3},normal:{bufferData:t,size:3},tangent:{bufferData:i,size:4},uv:{bufferData:r,size:2}}}function Xe(e=1){var t=new Float32Array([e,e,0,-e,e,0,-e,-e,0,e,-e,0]),n=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1]),r=new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0]),i=new Uint32Array([0,1,2,0,2,3]),o=new Float32Array([1,1,0,1,0,0,1,0]);return new Ne({indices:{bufferData:i,target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:t,size:3},normal:{bufferData:n,size:3},tangent:{bufferData:r,size:3},uv:{bufferData:o,size:2}})}function je(e){if(!(e instanceof h))throw new Error("Renderer is not of class 'Renderer'");console.log("Using %cforward%c renderpipeline","color: green; text-transform: uppercase; font-weight: bold;",""),this.renderer=e;var t=this.renderer.gl;this.render=function(n,r,i,o){if(this.renderer.currentBoundMaterials=new WeakMap,this.renderer.shadowCascades&&O.enableShadows&&(0!=i.sunIntensity.x||0!=i.sunIntensity.y||0!=i.sunIntensity.z)&&!1!==o.shadows&&this.renderer.shadowCascades.renderShadowmaps(n.transform.position),i.updateUniformBuffers(n.projectionMatrix,n.viewMatrix,n.inverseViewMatrix),this.renderer.postprocessing&&O.enablePostProcessing?this.renderer.postprocessing.bindFramebuffer():t.bindFramebuffer(t.FRAMEBUFFER,null),e.version>1&&t.drawBuffers([t.COLOR_ATTACHMENT0,t.COLOR_ATTACHMENT1]),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),t.disable(t.BLEND),i.skyboxVisible&&this.renderer.skybox.render(n,i.skyboxCubemap),i.root.traverseCondition((e=>{e.meshRenderer&&(!n.frustum||!e.getAABB()||e.getAABB().isInsideFrustum(n.frustum))||e.disableFrustumCulling?e.isCulled=!1:e.isCulled=!0}),(e=>e.active&&e.visible)),1==U[3]&&t.colorMask(!0,!0,!0,!1),t.disable(t.BLEND),i.render(n,{renderPass:p.OPAQUE}),this.renderer.gizmos.gameObject.render(n),t.enable(t.BLEND),t.depthMask(!1),i.render(n,{renderPass:p.ALPHA}),t.depthMask(!0),e.version>1&&t.drawBuffers([t.COLOR_ATTACHMENT0]),r)for(var a of r)i.updateUniformBuffers(a.projectionMatrix,a.viewMatrix,a.inverseViewMatrix),a.renderTexture?(a.renderTexture.bind(),t.viewport(0,0,a.renderTexture.width,a.renderTexture.height),t.clear(a.renderTexture.clearFlags)):(this.renderer.postprocessing&&O.enablePostProcessing?this.renderer.postprocessing.bindFramebuffer():t.bindFramebuffer(t.FRAMEBUFFER,null),t.clear(t.DEPTH_BUFFER_BIT)),i.render(a,{renderPass:p.OPAQUE}),t.depthMask(!1),i.render(a,{renderPass:p.ALPHA}),t.depthMask(!0);t.colorMask(!0,!0,!0,!0),this.renderer.godrays&&this.renderer.godrays.render(i,n),se(null),this.renderer.postprocessing&&O.enablePostProcessing&&this.renderer.postprocessing.blitAA(),this.renderer.bloom&&O.enableBloom&&this.renderer.bloom.render(),this.renderer.postprocessing&&O.enablePostProcessing&&this.renderer.postprocessing.render(),K.copy(n.viewMatrix,n.prevViewMatrix)}}function qe(e){if(!(e instanceof h))throw new Error("Renderer is not of class 'Renderer'");if(e.version<2)throw new Error("Deferred rendering is only available with WebGL2");console.log("Using %cdeferred%c renderpipeline","color: red; text-transform: uppercase; font-weight: bold;",""),this.renderer=e;var t=this.renderer.gl,n=t.canvas.width,r=t.canvas.height;const i=Y();for(var o={basic:new ye(this.renderer.createProgram(dn,mn)),instanced:new ye(this.renderer.createProgram(vn,pn)),skinned:new ye(this.renderer.createProgram(gn,xn))},a=new ye(this.renderer.createProgram(bn,yn)),s=new fe,l=M(n,r),c=E(n,r),u=[],f=0;f<Object.keys(l.colorBuffers).length;f++)u.push(t.COLOR_ATTACHMENT0+f);var d=new function(){this.scale=.5,this.blur=5,this.blurHMultiplier=1,this.blurVMultiplier=1,this.maxRoughness=.5,this.maxDistance=64,this.stepResolution=.1,this.refinementSteps=10,this.thickness=10;var i=new fe,o=new ye(e.createProgram(Tn,wn)),a=new ye(e.createProgram(En,Mn));this.framebuffer=Z(n,r),this.resizeFramebuffers=function(){t.deleteFramebuffer(this.framebuffer.framebuffer),this.framebuffer=Z(t.canvas.width,t.canvas.height)},this.pass=function(e,n,r,a){t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer.framebuffer),t.viewport(0,0,t.canvas.width*this.scale,t.canvas.height*this.scale),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),ee(o.program),se(null),i.bindBuffers(o.getAttribLocation("position")),o.setUniform("scale",this.scale),o.setUniform("maxRoughness",this.maxRoughness),o.setUniform("maxDistance",this.maxDistance),o.setUniform("resolution",this.stepResolution),o.setUniform("steps",this.refinementSteps),o.setUniform("thickness",this.thickness),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.positionViewSpace),t.uniform1i(o.getUniformLocation("positionTexture"),0),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.normal),t.uniform1i(o.getUniformLocation("normalTexture"),1),t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.properties),t.uniform1i(o.getUniformLocation("propertiesTexture"),2),t.activeTexture(t.TEXTURE3),t.bindTexture(t.TEXTURE_2D,c.colorBuffer),t.uniform1i(o.getUniformLocation("albedoTexture"),3),t.uniformMatrix4fv(o.getUniformLocation("lensProjection"),!1,e.projectionMatrix),t.uniformMatrix4fv(o.getUniformLocation("inverseViewMatrix"),!1,e.inverseViewMatrix),t.uniformMatrix4fv(o.getUniformLocation("viewMatrix"),!1,e.viewMatrix),i.render()},this.combinePass=function(e){t.bindFramebuffer(t.FRAMEBUFFER,e),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),ee(a.program),se(null),i.bindBuffers(a.getAttribLocation("position")),t.uniform2f(a.getUniformLocation("SIZE"),t.canvas.width,t.canvas.height),t.uniform1f(a.getUniformLocation("scale"),this.scale),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,c.colorBuffer),t.uniform1i(a.getUniformLocation("combinedTexture"),0),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,this.framebuffer.colorBuffer),t.uniform1i(a.getUniformLocation("ssrTexture"),1),i.render()}};this.ssr=d;var m=new function(){var n=new fe,r=new ye(e.createProgram(_n,Rn)),i=Z(t.canvas.width,t.canvas.height);this.resizeFramebuffers=function(){t.deleteFramebuffer(i.framebuffer),i=Z(t.canvas.width,t.canvas.height)},this.pass=function(e,o=null,a=20,s=1,l=1){ee(r.program),se(null),n.bindBuffers(r.getAttribLocation("position")),t.uniform2f(r.getUniformLocation("SIZE"),t.canvas.width,t.canvas.height),t.bindFramebuffer(t.FRAMEBUFFER,i.framebuffer),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e),t.uniform1i(r.getUniformLocation("imageTexture"),0),t.uniform1i(r.getUniformLocation("horizontal"),0),t.uniform1i(r.getUniformLocation("radius"),a*s),n.render(),t.bindFramebuffer(t.FRAMEBUFFER,o),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,i.colorBuffer),t.uniform1i(r.getUniformLocation("imageTexture"),0),t.uniform1i(r.getUniformLocation("horizontal"),1),t.uniform1i(r.getUniformLocation("radius"),a*l),n.render()}};this.enableSSR=!1,this.renderer.on("resize",(()=>{this.resizeFramebuffers(),d.resizeFramebuffers(),m.resizeFramebuffers()})),this.resizeFramebuffers=function(){t.deleteFramebuffer(l.framebuffer),l=M(t.canvas.width,t.canvas.height),t.deleteFramebuffer(c.framebuffer),c=E(t.canvas.width,t.canvas.height)},this.render=function(e,i,o,a){n=t.canvas.width,r=t.canvas.height,t.viewport(0,0,t.canvas.width,t.canvas.height),p(e,i,o,a),v(e,i,o,a);var s=this.enableSSR?c.framebuffer:this.renderer.postprocessing.getFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),se(null),this.renderer.skybox.render(e,o.skyboxCubemap),se(null),b(e,i,o,a),se(null),x(s,e,i,o,a),se(null),_(e,i,o,a),se(null),g(),se(null),this.renderer.postprocessing.render(),K.copy(e.viewMatrix,e.prevViewMatrix)};var v=(e,n,r,i)=>{t.bindFramebuffer(t.FRAMEBUFFER,l.framebuffer),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),t.drawBuffers(u);for(var a=0;a<32;a++)t.activeTexture(t.TEXTURE0+a),t.bindTexture(t.TEXTURE_2D,null);for(let n in o){let r=o[n];ee(r.program),t.uniformMatrix4fv(r.getUniformLocation("projectionMatrix"),!1,e.projectionMatrix),t.uniformMatrix4fv(r.getUniformLocation("inverseViewMatrix"),!1,e.inverseViewMatrix),t.uniformMatrix4fv(r.getUniformLocation("viewMatrix"),!1,e.viewMatrix)}se(null),r.root.traverseCondition((n=>{if(n.meshRenderer){if(e.frustum&&n.getAABB()&&!n.getAABB().isInsideFrustum(e.frustum))return;var r=n.meshRenderer;if(r instanceof Pe){let e=o.instanced;if(ee(e.program),r.needsBufferUpdate&&(r.updateMatrixData(),r.needsBufferUpdate=!1),r.matrices.length>0)for(let i=0;i<r.meshData.length;i++){let o=r.meshData[i],a=r.materials[i];if(null!==a.programContainer&&a.programContainer!=this.renderer.programContainers.litInstanced)continue;if(!a.isOpaque())continue;o.bindBuffers(e),t.bindBuffer(t.ARRAY_BUFFER,r.matrixBuffer);let s=e.getAttribLocation("modelMatrix");for(let e=0;e<4;e++){const n=s+e;t.enableVertexAttribArray(n),t.vertexAttribPointer(n,4,t.FLOAT,!1,64,16*e),le(n,1)}T(e,a,n.transform.worldMatrix),ce(r.drawMode,o.indices.length,o.indexType,0,r.matrices.length)}}else if(r instanceof Se){let e=o.basic;ee(e.program);for(let t=0;t<r.meshData.length;t++){let i=r.meshData[t],o=r.materials[t];null!==o.programContainer&&o.programContainer!=this.renderer.programContainers.lit||o.isOpaque()&&(i.bindBuffers(e),T(e,o,n.transform.worldMatrix),i.drawCall(r.drawMode))}}else if(r instanceof De){let e=o.skinned;ee(e.program);for(var i=0;i<r.meshData.length;i++){var a=r.meshData[i],s=r.materials[i];null!==s.programContainer&&s.programContainer!=this.renderer.programContainers.litSkinned||s.isOpaque()&&(a.bindBuffers(e),T(e,s,n.transform.worldMatrix),r.skin.bindTexture({programContainer:e}),a.drawCall(r.drawMode))}}}}),(e=>e.active&&e.visible))},p=(e,t,n,r)=>{se(null),this.renderer.shadowCascades&&O.enableShadows&&(0!=n.sunIntensity.x||0!=n.sunIntensity.y||0!=n.sunIntensity.z)&&!1!==r.shadows&&n.shadowQuality>0&&this.renderer.shadowCascades.renderShadowmaps(e.transform.position)},g=()=>{this.renderer.bloom?.render()},x=(e,i,o,a,s)=>{t.bindFramebuffer(t.DRAW_FRAMEBUFFER,e),t.bindFramebuffer(t.READ_FRAMEBUFFER,l.framebuffer),t.blitFramebuffer(0,0,n,r,0,0,n,r,t.DEPTH_BUFFER_BIT,t.NEAREST),t.bindFramebuffer(t.FRAMEBUFFER,e),a.updateUniformBuffers(i.projectionMatrix,i.viewMatrix,i.inverseViewMatrix),t.activeTexture(t.TEXTURE0+2),t.bindTexture(t.TEXTURE_CUBE_MAP,a.diffuseCubemap),t.activeTexture(t.TEXTURE0+1),t.bindTexture(t.TEXTURE_CUBE_MAP,a.specularCubemap),t.activeTexture(t.TEXTURE0+0),t.bindTexture(t.TEXTURE_2D,this.renderer.splitsumTexture),1==U[3]&&t.colorMask(!0,!0,!0,!1),t.disable(t.BLEND),a.root.traverseCondition((e=>{let t=!0;if(e.meshRenderer){let n=e.transform.worldMatrix;e.meshRenderer.setShadowQuality?.(e.receiveShadows?2:0,t),e.meshRenderer.render(i,n,!1,t,e.prevModelMatrix,{submeshCondition:(e,t)=>null!==t.programContainer&&!(N.lit&&t.programContainer==this.renderer.programContainers.lit||N.litInstanced&&t.programContainer==this.renderer.programContainers.litInstanced||N.litSkinned&&t.programContainer==this.renderer.programContainers.litSkinned)}),e.updatePrevModelMatrix()}for(var n of e.getComponents())if("function"==typeof n.render){let r=e.transform.worldMatrix;n.render(i,r,!1,t)}}),(e=>e.active&&e.visible)),t.enable(t.BLEND),t.depthMask(!1),a.root.traverseCondition((e=>{let t=!1;if(e.meshRenderer){let n=e.transform.worldMatrix;e.meshRenderer.setShadowQuality?.(e.receiveShadows?2:0,t),e.meshRenderer.render(i,n,!1,t,e.prevModelMatrix)}for(var n of e.getComponents())if("function"==typeof n.render){let r=e.transform.worldMatrix;n.render(i,r,!1,t)}}),(e=>e.active&&e.visible)),t.disable(t.BLEND),t.depthMask(!0),t.colorMask(!0,!0,!0,!0)},b=(e,n,r,i)=>{ee(a.program),t.drawBuffers([t.COLOR_ATTACHMENT0,t.COLOR_ATTACHMENT1]),t.bindBuffer(t.ARRAY_BUFFER,s.vertexBuffer);var o=a.getAttribLocation("position");t.enableVertexAttribArray(o),t.vertexAttribPointer(o,2,t.FLOAT,!1,8,0),t.uniform2f(a.getUniformLocation("SIZE"),t.canvas.width,t.canvas.height),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.position),t.uniform1i(a.getUniformLocation("gPosition"),0),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.normal),t.uniform1i(a.getUniformLocation("gNormal"),1),t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.albedo),t.uniform1i(a.getUniformLocation("gAlbedo"),2),t.activeTexture(t.TEXTURE6),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.properties),t.uniform1i(a.getUniformLocation("gProperties"),6),t.activeTexture(t.TEXTURE3),t.bindTexture(t.TEXTURE_CUBE_MAP,r.diffuseCubemap),t.uniform1i(a.getUniformLocation("u_diffuseIBL"),3),t.activeTexture(t.TEXTURE4),t.bindTexture(t.TEXTURE_CUBE_MAP,r.specularCubemap),t.uniform1i(a.getUniformLocation("u_specularIBL"),4),t.activeTexture(t.TEXTURE5),t.bindTexture(t.TEXTURE_2D,this.renderer.splitsumTexture),t.uniform1i(a.getUniformLocation("u_splitSum"),5);var c=r.getLights();t.uniform1i(a.getUniformLocation("nrLights"),c.length);for(let e=0;e<c.length;e++){let n=c[e];t.uniform1i(a.getUniformLocation(`lights[${e}].type`),n.type),t.uniform3f(a.getUniformLocation(`lights[${e}].position`),n.position.x,n.position.y,n.position.z),n.direction&&t.uniform3f(a.getUniformLocation(`lights[${e}].direction`),n.direction.x,n.direction.y,n.direction.z),"angle"in n&&t.uniform1f(a.getUniformLocation(`lights[${e}].angle`),n.angle),t.uniform3f(a.getUniformLocation(`lights[${e}].color`),n.color[0],n.color[1],n.color[2])}t.uniformMatrix4fv(a.getUniformLocation("projectionMatrix"),!1,e.projectionMatrix),t.uniformMatrix4fv(a.getUniformLocation("viewMatrix"),!1,e.viewMatrix),t.uniformMatrix4fv(a.getUniformLocation("prevViewMatrix"),!1,e.prevViewMatrix),t.uniformMatrix4fv(a.getUniformLocation("inverseViewMatrix"),!1,e.inverseViewMatrix),t.uniform3fv(a.getUniformLocation("sunDirection"),X.toArray(r.sunDirection)),t.uniform3fv(a.getUniformLocation("sunIntensity"),X.toArray(r.sunIntensity)),t.uniform3fv(a.getUniformLocation("ambientColor"),X.toArray(r.ambientColor)),t.uniform1f(a.getUniformLocation("environmentIntensity"),r.environmentIntensity),t.uniform1f(a.getUniformLocation("environmentMinLight"),r.environmentMinLight),null!=a.getUniformLocation("fogDensity")&&t.uniform1f(a.getUniformLocation("fogDensity"),r.fogDensity),a.setUniform("fogColor",r.fogColor),t.uniform1i(a.getUniformLocation("shadowQuality"),r.shadowQuality),w(a),s.render()},y={modelMatrix:null,shadowPass:!1},T=(e,n,r)=>{y.modelMatrix=r,Ce(n,e,y),e.setUniform("enableMotionBlur",n.uniforms.enableMotionBlur??1),t.uniformMatrix4fv(e.getUniformLocation("modelMatrix"),!1,r),Ee(n,!1)},w=n=>{var r=e.shadowCascades;r.setUniforms(n);var i=Array.from({length:r.levels},((e,t)=>30-2*t)).reverse();t.uniform1iv(n.getUniformLocation("projectedTextures[0]"),i);for(let e=0;e<r.levels;e++){let n=30-2*e;t.activeTexture(t.TEXTURE0+n),t.bindTexture(t.TEXTURE_2D,r.shadowmaps[e].depthTexture)}};function E(n,r){var o=Z(n,r);return o.motionBlurColorBuffer=t.createTexture(),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,o.motionBlurColorBuffer),t.texImage2D(t.TEXTURE_2D,0,1==e.version?t.RGBA:t.RGBA16F,n,r,0,t.RGBA,i,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT1,t.TEXTURE_2D,o.motionBlurColorBuffer,0),o}function M(e,n){var r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r);var o={position:{internalFormat:t.RGBA32F,type:i,filter:t.NEAREST},albedo:{internalFormat:t.RGBA16F,type:i,filter:t.LINEAR},normal:{internalFormat:t.RGBA16F,type:i,filter:t.LINEAR},properties:{internalFormat:t.RGBA,type:t.UNSIGNED_BYTE,filter:t.LINEAR},positionViewSpace:{internalFormat:t.RGBA32F,type:i,filter:t.NEAREST}},a={position:null,normal:null,albedo:null,properties:null,positionViewSpace:null};t.activeTexture(t.TEXTURE0);var s=0;for(var l in a){var c=t.createTexture();t.bindTexture(t.TEXTURE_2D,c);var u=o[l],h=u?.internalFormat??t.RGBA32F,f=u?.type??i;t.texImage2D(t.TEXTURE_2D,0,h,e,n,0,t.RGBA,f,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,u?.filter??t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,u?.filter??t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+s,t.TEXTURE_2D,c,0),a[l]=c,s++}var d=t.createRenderbuffer();return t.bindRenderbuffer(t.RENDERBUFFER,d),t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_COMPONENT16,e,n),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.RENDERBUFFER,d),{framebuffer:r,colorBuffers:a,depthBuffer:d}}var _=(e,t,n,r)=>{this.enableSSR&&(d.pass(e,t,n,r),d.blur>0&&m.pass(d.framebuffer.colorBuffer,d.framebuffer.framebuffer,d.blur,d.blurVMultiplier,d.blurHMultiplier),d.combinePass(this.renderer.postprocessing.getFramebuffer()))}}this.createGameObjectFromGLTFData=async function(e,t={}){var{json:n,buffers:r,path:i}=e,o=[],a=[];console.time("Loading "+i),console.log(n);var s,l=i.indexOf(".glb")+4,c=i.lastIndexOf("/",l)+1,u=new Oe(i.slice(c,l)),h=[],f=[],v=[],p=n.scene??0,g=n.scenes[p];for(let e=0;e<g.nodes.length;e++)f=f.concat(await D(g.nodes[e]));if(u.addChildren(f),!t.disableAnimations&&(s=n.animations)&&0!==Object.keys(s).length)for(var x of(u.animationController=new st,n.animations)){var b=[];for(var y of x.channels){var T,w,E=x.samplers[y.sampler],M=N(E.input).buffer,_=N(E.output),R=_.accessor,C=_.buffer,F=C;if("VEC3"==R.type){let e=[];for(let t=0;t<C.byteLength/4;t+=3)e.push({x:C[t],y:C[t+1],z:C[t+2]});F=e}else if("VEC4"==R.type){let e=[];for(let t=0;t<C.byteLength/4;t+=4)e.push({x:C[t],y:C[t+1],z:C[t+2],w:C[t+3]});F=e}"CUBICSPLINE"==E.interpolation&&(T=F.filter(((e,t)=>t%3==0)),w=F.filter(((e,t)=>t%3==0)),F=F.filter(((e,t)=>t%3==1))),b.push({target:h[y.target.node],path:y.target.path,interpolation:E.interpolation,inputBuffer:M,outputBuffer:F,inputTangents:T,outputTangents:w})}var A=new at(x.name,b);u.animationController.animations.push(A)}for(let e=0;e<v.length;e++){let t=v[e],n=[];for(let e=0;e<t.joints.length;e++){let r=h[t.joints[e]];r?n[e]=r:console.warn("Invalid joint index!")}let r=[];for(let e=0;e<t.obj.meshRenderer.materials.length;e++){let n=null;m.renderpipeline instanceof je&&(n=m.programContainers.litSkinned);let i=t.obj.meshRenderer.materials[e],o=new We(n,i.uniforms);r.push(o)}t.obj.meshRenderer=new De(new Fe(n,t.inverseBindMatrixData),r,t.obj.meshRenderer.meshData),t.obj.meshRenderer.skin.parentNode=t.obj.parent}return u.traverse((e=>{e.transform.matrix=e.transform.matrix})),console.timeEnd("Loading "+i),u;async function D(e,r=0){var i=n.nodes[e],o=K.identity();i.matrix?K.copy(i.matrix,o):(i.translation&&K.translate(X.fromArray(i.translation),o),i.rotation&&K.multiply(o,K.fromQuaternion(X.fromArray(i.rotation)),o),i.scale&&K.transform([["scale",X.fromArray(i.scale)]],o));var s=new Oe(i.name,{matrix:o,...t.gameObjectOptions});if(s.nodeIndex=e,h[e]=s,i.extensions&&i.extensions.KHR_lights_punctual){var l=n.extensions.KHR_lights_punctual.lights[i.extensions.KHR_lights_punctual.light],c=l.intensity??1,u=l.color??[1,1,1],f=l.type,p=s.addComponent(new Ke);p.color=[u[0]*c,u[1]*c,u[2]*c],p.type={point:0,spot:1,directional:2}[f],l.spot&&"spot"==f&&(p.angle=l.spot.outerConeAngle)}var g=i.extras;if(g&&(console.log("Custom data:",g),s.customData={...g}),null!=i.mesh){var x=n.meshes[i.mesh],b=x.extras;b&&(console.log("Custom mesh data:",b),s.customData={...s.customData,...b});for(var y=t.loadNormals??!0,T=t.loadTangents??!0,w=[],E=[],M=0;M<x.primitives.length;M++){var _=x.primitives[M],R={},C=N(_.attributes.POSITION);R.position={bufferData:C.buffer,size:C.size,stride:C.stride};var F=N(_.indices);F&&(R.indices={bufferData:F.buffer,type:m.indexTypeLookup[F.type],target:d.ELEMENT_ARRAY_BUFFER,stride:F.stride});var A=N(_.attributes.COLOR_0);A&&(R.color={bufferData:P(A.buffer),size:A.size,stride:A.stride});var U=N(_.attributes.TEXCOORD_0);if(U&&(R.uv={bufferData:U.buffer,size:U.size,stride:U.stride}),y){var z=N(_.attributes.NORMAL);z?R.normal={bufferData:z.buffer,size:z.size,stride:z.stride}:(console.warn("Generating normals"),R.normal={bufferData:Dn(C.buffer,F.buffer),size:3})}if(T){var L=N(_.attributes.TANGENT);L?R.tangent={bufferData:L.buffer,size:L.size,stride:L.stride}:U&&(console.warn("Generating tangents"),R.tangent={bufferData:Pn(C.buffer,F.buffer,U.buffer),size:4})}if(_.attributes.JOINTS_0){let e=N(_.attributes.JOINTS_0);R.joints={bufferData:e.buffer,size:e.size,type:e.type,stride:e.stride}}if(_.attributes.WEIGHTS_0){let e=N(_.attributes.WEIGHTS_0);R.weights={bufferData:e.buffer,size:e.size,type:e.type,stride:e.stride}}var B=t.loadMaterials??!0,I=void 0,k=_.material;if(B&&null!=k)if(null!=a[k])I=a[k];else{var V=[0,0,0],G=[1,1,1,1],j=void 0,H=void 0,W=void 0,q=void 0,Y=void 0,$=1,Q=1,Z=.5,J=1,ee=!1,te=n.materials[k],ne=te.pbrMetallicRoughness;if(te.doubleSided&&(ee=!0),"BLEND"==te.alphaMode?(Z=0,J=0):"MASK"==te.alphaMode?(Z=te.alphaCutoff??.5,J=1):"OPAQUE"!=te.alphaMode&&"alphaMode"in te||(Z=-1,J=1),null!=ne){if(G=ne.baseColorFactor??[1,1,1,1],ne.metallicRoughnessTexture||($=0,Q=1),O.loadTextures){var re=1==m.version?m.sRGBExt&&(m.floatTextures||m.textureHalfFloatExt)?m.sRGBExt.SRGB_ALPHA_EXT:d.RGBA:d.SRGB8_ALPHA8,ie=1==m.version&&m.sRGBExt&&(m.floatTextures||m.textureHalfFloatExt)?m.sRGBExt.SRGB_ALPHA_EXT:d.RGBA;ne.baseColorTexture&&(j=await S(ne.baseColorTexture.index,{internalFormat:re,format:ie})),ne.metallicRoughnessTexture&&(W=await S(ne.metallicRoughnessTexture.index)),te.normalTexture&&(H=await S(te.normalTexture.index,t.sRGBNormalMap?{internalFormat:re,format:ie}:{})),null!=te.emissiveTexture&&(q=await S(te.emissiveTexture.index,{internalFormat:re,format:ie})),null!=te.occlusionTexture&&(Y=await S(te.occlusionTexture.index))}null!=te.emissiveFactor&&(V=te.emissiveFactor),null!=ne.metallicFactor&&($=ne.metallicFactor),null!=ne.roughnessFactor&&(Q=ne.roughnessFactor)}(I=we({alphaCutoff:Z,albedo:G,albedoTexture:j,normalTexture:H,metallicRoughnessTexture:W,roughness:Q,metallic:$,emissiveFactor:V,emissiveTexture:q,occlusionTexture:Y})).opaque=!!J,I.doubleSided=ee,I.name=te.name||"No name!",a[k]=I}w.push(I??we()),E.push(new Ne(R))}s.meshRenderer=new Se(w,E)}if(null!=i.skin){var oe=n.skins[i.skin],ae=N(oe.inverseBindMatrices).buffer;0!=N(oe.inverseBindMatrices).stride&&console.warn("Stride in skin ibm data");var se=oe.joints;v.push({obj:s,joints:se,inverseBindMatrixData:ae})}var le=[];if(null!=i.children)for(var ce=0;ce<i.children.length;ce++)le=le.concat(await D(i.children[ce],r+1));return s.addChildren(le),[s]}function P(e){for(var t=0;t<e.length;t++)e[t]=1-e[t];return e}async function S(e,i){if(null==o[e]){var a=await async function(e,i={}){var o=n.textures[e],a=o.source,s=n.bufferViews[n.images[a].bufferView],l=r[s.buffer].slice(s.byteOffset??0,(s.byteOffset??0)+s.byteLength);const c=new Blob([l],{type:n.images[a].mimeType});var u=URL.createObjectURL(c);if(t.downloadTextures&&function(e,t="download"){var n=document.createElement("a");n.download=t+".png",n.href=e,n.click()}(u,"texture"),Object.prototype.hasOwnProperty.call(t,"maxTextureSize")&&(i.maxTextureSize=t.maxTextureSize),o.sampler){var h=n.samplers[o.sampler];i.TEXTURE_WRAP_S=h.wrapS,i.TEXTURE_WRAP_T=h.wrapT,i.TEXTURE_MIN_FILTER=h.minFilter,i.TEXTURE_MAG_FILTER=h.magFilter}return await Le(u,i)}(e,i);return o[e]=a,a}return o[e]}function N(e){if(null!=e&&e>=0){var t=n.accessors[e],i=n.bufferViews[t.bufferView],o=i.byteStride??0,a=o?o/(Ve[t.componentType]/8)/ke[t.type]:1,s=(i.byteOffset??0)+(t.byteOffset??0),l=r[i.buffer].slice(s,s+t.count*ke[t.type]*Ve[t.componentType]/8*a);return{buffer:new Ie[t.componentType](l.buffer),size:ke[t.type],type:t.componentType,stride:o,accessor:t}}}},this.getLineCubeData=function(){const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]);return{indices:{bufferData:new Uint32Array([0,1,1,3,3,2,2,0,4,5,5,7,7,6,6,4,0,4,1,5,3,7,2,6]),target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:e,size:3}}},this.getCubeData=Ge,this.getPlaneData=function(){var e=new Float32Array([1,1,0,-1,1,0,-1,-1,0,1,-1,0]),t=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1]),n=new Float32Array([1,0,0,-1,1,0,0,-1,1,0,0,-1,1,0,0,-1]),r=new Uint32Array([0,1,2,0,2,3]),i=new Float32Array([1,1,0,1,0,0,1,0]);return{indices:{bufferData:r,target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:e,size:3},normal:{bufferData:t,size:3},tangent:{bufferData:n,size:4},uv:{bufferData:i,size:2}}},this.getSphereData=function(e=3){var t=.5257311121191336,n=.8506508083520399,r=[-t,0,n,t,0,n,-t,0,-n,t,0,-n,0,n,t,0,n,-t,0,-n,t,0,-n,-t,n,t,0,-n,t,0,n,-t,0,-n,-t,0],i=[0,1,4,0,4,9,9,4,5,4,8,5,4,1,8,8,1,10,8,10,3,5,8,3,5,3,2,2,3,7,7,3,10,7,10,6,7,6,11,11,6,0,0,6,1,6,10,1,9,11,0,9,2,11,9,5,2,7,11,2];for(let t=0;t<e;t++){let e=[],t=[];for(let n=0;n<i.length;n+=3){let o=[];for(let e=0;e<3;e++){let a=i[n+e],l=i[n+(e+1)%3],c=s(t,a,l);if(c)o.push(c);else{let e=X.fromArray(r.slice(3*a,3*a+3)),n=X.fromArray(r.slice(3*l,3*l+3)),i=X.normalize(X.lerp(e,n,.5));r.push(i.x,i.y,i.z),o.push(r.length/3-1),t.push({edge:[a,l],index:o[o.length-1]})}}e.push(i[n],o[0],o[2]),e.push(i[n+1],o[1],o[0]),e.push(i[n+2],o[2],o[1]),e.push(o[0],o[1],o[2])}i=e}var o=[];for(let e=0;e<r.length;e+=3){let t=X.normalize(X.fromArray(r.slice(e,e+3)));o.push(t.x,t.y,t.z)}let a=[];for(let e=0;e<r.length;e+=3){let t=X.normalize(X.fromArray(r.slice(e,e+3))),n=Math.atan2(t.x,t.z)/(2*Math.PI)+.5,i=Math.asin(t.y)/Math.PI+.5;a.push(n,i)}return new this.MeshData({indices:{bufferData:new Uint32Array(i),target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(r),size:3},normal:{bufferData:new Float32Array(o),size:3},uv:{bufferData:new Float32Array(a),size:2}});function s(e,t,n){return e.find((e=>e.edge[0]==t&&e.edge[1]==n||e.edge[0]==n&&e.edge[1]==t))?.index}},this.getParticleMeshData=Xe,this.loadObj=async function(e,t=!1){var n="No name",r={},i=[],o=[],a=[],s=(await(await fetch(e)).text()).split("\n");for(let e=0;e<s.length;e++){let t=s[e].split(" ");switch(t[0]){case"o":r[n=t[1]+" #"+Math.floor(1e4*Math.random())]=[[],[],[]];break;case"v":i.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]));break;case"vn":o.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]));break;case"vt":a.push(parseFloat(t[1]),parseFloat(t[2]));break;case"f":if(4==t.length)for(let e=0;e<3;e++)r[n][e].push(parseInt(t[1].split("/")[e])-1,parseInt(t[2].split("/")[e])-1,parseInt(t[3].split("/")[e])-1);else if(5==t.length)for(let e=0;e<3;e++)r[n][e].push(parseInt(t[1].split("/")[e])-1,parseInt(t[2].split("/")[e])-1,parseInt(t[3].split("/")[e])-1,parseInt(t[1].split("/")[e])-1,parseInt(t[3].split("/")[e])-1,parseInt(t[4].split("/")[e])-1)}}var l={},c=[],u=[],h=[],f=[c,h,u],m=[i,a,o],v=0;for(let e in r){let t=r[e];l[e]=[];for(let n=0;n<t[0].length;n++){for(let e=0;e<3;e+=2)f[e].push(m[e][3*t[e][n]],m[e][3*t[e][n]+1],m[e][3*t[e][n]+2]);l[e].push(v),v++}l[e]=new Uint32Array(l[e]);for(let e=0;e<t[0].length;e++){let n=1;f[n].push(m[n][2*t[n][e]],m[n][2*t[n][e]+1])}}let p=l;if(!t){p=[];for(let e in l)p=p.concat(Array.from(l[e]));p=new Uint32Array(p)}return new Ne({indices:{bufferData:p,target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(c),size:3},normal:{bufferData:new Float32Array(u),size:3},uv:{bufferData:new Float32Array(h),size:2}})},this.CreateShape=function(e=g,t=null,n=3){var r;if("plane"==(e=e.toLowerCase()))r=new this.MeshData(this.getPlaneData());else if(e==g)r=new this.MeshData(this.getCubeData());else{if("sphere"!=e)throw new Error("Invalid shape: "+e);r=this.getSphereData(n)}t=t??this.CreateLitMaterial();var i=new Se(t,r),o=new Oe("Shape");return o.meshRenderer=i,o},this.CreatePBRGrid=async function(e,t=10,n=10,r="sphere"){for(var i="cube"==r?(await this.loadGLTF(this.path+"assets/models/primitives/cube.glb")).children[0].meshRenderer.meshData[0]:(await this.loadGLTF(this.path+"assets/models/primitives/uvSphere.glb")).children[0].meshRenderer.meshData[0],o=0;o<n;o++)for(var a=0;a<t;a++){var s=we({roughness:a/(t-1),metallic:o/(n-1)}),l=new Se(s,i),c=new Oe;c.transform.position=new X(2.1*(a-(t-1)/2),2.1*(o-(n-1)/2),0),c.meshRenderer=l,"cube"==r&&(c.transform.scale=new X(.5,.5,100)),e.add(c)}},this.BatchGameObject=function(e){var t=new Oe(e.name+" (Batched)"),n=[];e.traverse((e=>{var r=e.findComponents("Light");if(r.length>0){var i=new Oe(e.name+" (Copy)");for(var o of(i.transform.matrix=e.transform.worldMatrix,r))i.addComponent(o.copy());t.addChild(i)}if(e.meshRenderer){var a=K.copy(e.transform.worldMatrix);K.removeTranslation(a);for(let t=0;t<e.meshRenderer.meshData.length;t++){let r=e.meshRenderer.materials[t],i=e.meshRenderer.meshData[t],o=n.find((e=>e.material==r));if(o||(o={material:r,vertices:[],indices:[],tangent:[],normal:[],uv:[],indexOffset:0},n.push(o)),i.data.position&&i.data.indices){let t=function(e,t=3){if(i.data[e])for(var n=i.data[e].bufferData,r=i.data[e].size,s=0,l=0;l<n.length;l+=r){var c=X.fromArray(n,l,1,3);c=X.normalize(K.transformVector(a,c)),o[e][o.indexOffset*t+s]=c.x,o[e][o.indexOffset*t+s+1]=c.y,o[e][o.indexOffset*t+s+2]=c.z,4==t&&(o[e][o.indexOffset*t+s+3]=4==r?n[l+3]:1),s+=t}};for(let t=0;t<i.data.position.bufferData.length;t+=3){let n={x:i.data.position.bufferData[t],y:i.data.position.bufferData[t+1],z:i.data.position.bufferData[t+2]};n=K.transformVector(e.transform.worldMatrix,n),o.vertices.push(n.x,n.y,n.z)}for(let e=0;e<i.data.indices.bufferData.length;e++)o.indices.push(i.data.indices.bufferData[e]+o.indexOffset);if(i.data.uv)for(let e=0;e<i.data.uv.bufferData.length;e++)o.uv[2*o.indexOffset+e]=i.data.uv.bufferData[e];t("normal"),t("tangent",4),o.indexOffset+=i.data.position.bufferData.length/3}i.cleanup()}}}));var r=[],i=[];for(var o of n){for(let e=0;e<o.uv.length;e++)void 0===o.uv[e]&&(o.uv[e]=0);for(let e=0;e<o.normal.length;e++)void 0===o.normal[e]&&(o.normal[e]=0);for(let e=0;e<o.tangent.length;e++)void 0===o.tangent[e]&&(o.tangent[e]=0);r.push(o.material),i.push(new Ne({position:{bufferData:new Float32Array(o.vertices),size:3},indices:{bufferData:new Uint32Array(o.indices),target:m.gl.ELEMENT_ARRAY_BUFFER},tangent:{bufferData:new Float32Array(o.tangent),size:4},normal:{bufferData:new Float32Array(o.normal),size:3},uv:{bufferData:new Float32Array(o.uv),size:2}}))}return t.meshRenderer=new Se(r,i),t},f.dontCallSetup||this.setup(f),this.DeferredPBRRenderpipeline=qe},zn=function(){this.p=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],this.noise=function(e=0,t=0,n=0){var r,i,o,a,s,l,c,u,h,f,d,m,v=255&Math.floor(e),p=255&Math.floor(t),g=255&Math.floor(n),x=e-Math.floor(e),b=t-Math.floor(t),y=n-Math.floor(n),T=this.fade(x),w=this.fade(b),E=this.fade(y);return r=this.p[this.p[this.p[v]+p]+g],i=this.p[this.p[this.p[v]+p+1]+g],o=this.p[this.p[this.p[v]+p]+g+1],a=this.p[this.p[this.p[v]+p]+g+1],s=this.p[this.p[this.p[v+1]+p]+g],l=this.p[this.p[this.p[v+1]+p+1]+g],c=this.p[this.p[this.p[v+1]+p]+g+1],u=this.p[this.p[this.p[v+1]+p+1]+g+1],h=this.lerp(this.grad(r,x,b,y),this.grad(s,x-1,b,y),T),f=this.lerp(this.grad(i,x,b-1,y),this.grad(l,x-1,b-1,y),T),d=this.lerp(h,f,w),h=this.lerp(this.grad(o,x,b,y-1),this.grad(c,x-1,b,y-1),T),f=this.lerp(this.grad(a,x,b-1,y-1),this.grad(u,x-1,b-1,y-1),T),m=this.lerp(h,f,w),this.lerp(d,m,E)},this.fade=function(e){return e*e*e*(e*(6*e-15)+10)},this.grad=function(e,t,n,r){var i=15&e,o=i<8?t:n,a=i<4?n:12==i||14==i?t:r;return(0==(1&i)?o:-o)+(0==(2&i)?a:-a)},this.lerp=function(e,t,n){return e+n*(t-e)}},Ln=function(e,t,n={vertical:{keyboard:["KeyW","KeyS"],controller:"LSVertical"},horizontal:{keyboard:["KeyA","KeyD"],controller:"LSHorizontal"}}){this.gamepadManager=t;var r="none";this.setBindings=function(e={}){n=e},this.setBinding=function(e,t={}){n[e]=t},this.getInput=function(t){if(n[t]){var r=0;if(Array.isArray(n[t].keyboard)){var i=e.getKey(n[t].keyboard[0])?1:0;r=(e.getKey(n[t].keyboard[1])?1:0)-i}else r=e.getKey(n[t].keyboard)?1:0;var o=this.gamepadManager.getButton(n[t].controller)??this.gamepadManager.getAxis(n[t].controller)??0;return Math.abs(r)>Math.abs(o)?r:o}},this.getInputAndInputMethod=function(t){var i="none",o=0;if(n[t]){var a=0;if(Array.isArray(n[t].keyboard)){var s=e.getKey(n[t].keyboard[0])?1:0;a=(e.getKey(n[t].keyboard[1])?1:0)-s}else a=e.getKey(n[t].keyboard)?1:0;var l=this.gamepadManager.getButton(n[t].controller)??this.gamepadManager.getAxis(n[t].controller)??0;Math.abs(a)>Math.abs(l)?(i="keyboard",o=a):(i="controller",o=l),r=i}return{value:o,method:r}},this.getInputDown=function(t){if(n[t]){var r=0;if(Array.isArray(n[t].keyboard)){var i=e.getKeyDown(n[t].keyboard[0],t)?1:0;r=(e.getKeyDown(n[t].keyboard[1],t)?1:0)-i}else r=e.getKeyDown(n[t].keyboard)?1:0;var o=this.gamepadManager.getButtonDown(n[t].controller,void 0)??this.gamepadManager.getAxis(n[t].controller)??0;return Math.abs(r)>Math.abs(o)?r:o}},this.getInputUp=function(t){if(n[t]){var r=0;if(Array.isArray(n[t].keyboard)){var i=e.getKeyUp(n[t].keyboard[0],t)?1:0;r=(e.getKeyUp(n[t].keyboard[1],t)?1:0)-i}else r=e.getKeyUp(n[t].keyboard)?1:0;var o=this.gamepadManager.getButtonUp(n[t].controller,void 0)??this.gamepadManager.getAxis(n[t].controller)??0;return Math.abs(r)>Math.abs(o)?r:o}}};function Bn(e,t=.1){return Math.abs(e)<t?0:e}const In=function(){this.gamepads={};var e=[],t=[];this.buttonNames={A:0,B:1,X:2,Y:3,LB:4,RB:5,LT:6,RT:7,Back:8,Menu:9,LS:10,RS:11,DPUp:12,DPDown:13,DPLeft:14,DPRight:15},this.axesNames={LSHorizontal:0,LSVertical:1,RSHorizontal:2,RSVertical:3},window.addEventListener("gamepadconnected",(e=>{console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",e.gamepad.index,e.gamepad.id,e.gamepad.buttons.length,e.gamepad.axes.length,e.gamepad),this.gamepads[e.gamepad.index]=e.gamepad})),window.addEventListener("gamepaddisconnected",(e=>{console.log("Gamepad disconnected from index %d: %s",e.gamepad.index,e.gamepad.id),delete this.gamepads[e.gamepad.index]})),this.getGamepad=function(e){var t=e??this.gamepads[Object.keys(this.gamepads)[0]]?.index;return null!=t&&navigator.getGamepads()[t]},this.nameToIndex=function(e,t){return t[e]??e},this.getButtonName=function(e){return Object.keys(this.buttonNames).find((t=>this.buttonNames[t]===e))},this.getButton=function(e,t){var n=this.getGamepad(t);if(n){var r=this.nameToIndex(e,this.buttonNames);return n.buttons[r]?.value}return null},this.getButtons=function(e){var t=this.getGamepad(e);if(t){for(var n=[],r=0;r<t.buttons.length;r++)t.buttons[r].value&&n.push(r);return n}return[]},this.getButtonDown=function(t,n,r=""){var i=this.getButton(t,n),o=this.nameToIndex(t,this.buttonNames);if(i){if(e[o+r])return e[o+r]=!1,i}else e[o+r]=!0},this.getButtonUp=function(e,n,r=""){var i=this.getButton(e,n),o=this.nameToIndex(e,this.buttonNames);if(i)t[o+r]=!0;else if(t[o+r])return t[o+r]=!1,1-i},this.getAxis=function(e,t){var n=this.getGamepad(t);if(n){var r=this.nameToIndex(e,this.axesNames);return n.axes[r]}return null},this.vibrate=function(e,t=.5,n=.5,r){var i=this.getGamepad(r);i&&i.vibrationActuator?.playEffect?.("dual-rumble",{duration:e,strongMagnitude:n,weakMagnitude:t}).then((()=>{})).catch((e=>console.log(e)))}};function On(e){const t=window.AudioContext||window.webkitAudioContext;this.audioContext=e||new t;const n=this.audioContext.listener;this.setPosition=function(e){n.positionX&&n.positionY&&n.positionZ?(n.positionX.value=e.x,n.positionY.value=e.y,n.positionZ.value=e.z):n.setPosition(e.x,e.y,e.z)},this.setPosition({x:0,y:0,z:0}),this.setDirection=function(e,t){n.forwardX?(n.forwardX.value=e.x,n.forwardY.value=e.y,n.forwardZ.value=e.z,n.upX.value=t.x,n.upY.value=t.y,n.upZ.value=t.z):n.setOrientation(e.x,e.y,e.z,t.x,t.y,t.z)},this.setDirection({x:0,y:0,z:1},{x:0,y:1,z:0})}const kn=30/Math.PI;function Vn(e,t,n={}){if(!(e instanceof Ye))throw new Error("Scene is not of class 'Scene'");if(!(t instanceof Ee))throw new Error("physicsEngine is not of class 'PhysicsEngine'");var r=this,i=e.renderer;this.path=n.path??i.path??"./",this.renderer=i,this.physicsEngine=t;var o=new zn,a=this.keybindings=n.keybindings??new Ln(i,new In,{resetGame:{keyboard:"Escape",controller:"Menu"},resetCar:{keyboard:"KeyR",controller:"Menu"},drive:{keyboard:"KeyW",controller:"RT"},brake:{keyboard:"KeyS",controller:"LT"},ebrake:{keyboard:"Space",controller:"A"},clutch:{keyboard:"KeyC",controller:"Y"},steer:{keyboard:["KeyA","KeyD"],controller:"LSHorizontal"},gearDown:{keyboard:"KeyQ",controller:"X"},gearUp:{keyboard:"KeyE",controller:"B"},cameraMode:{keyboard:"KeyC",controller:"RB"},turnCamera:{keyboard:["ArrowLeft","ArrowRight"],controller:"RSHorizontal"}});this.haptics=n.haptics??!0,this.canMove=!0,this.frozen=!1,this.simulateFriction=!0,this.resetPosition=X.zero(),this.resetRotation=j.identity(),this.bottomOffset=X.zero(),this.mainCamera=new $e({position:new X(0,0,-3),near:.1,far:1e3,fov:35});var s=()=>{this.mainCamera.setAspect(i.aspect)};i.on("resize",s),s();var l=n.camera??{};this.followCamera=new qn(this),this.followCamera.followDistance=l.followDistance??5,this.followCamera.followHeight=l.followHeight??.4,this.followCamera.followSpeed=l.followSpeed??.05,this.followCamera.pitch=l.pitch??.15,this.followCamera.accelerationSpeed=l.accelerationSpeed??.05,this.followCamera.accelerationEffect=l.accelerationEffect??.3;var c=[this.followCamera,new $n(this),new Yn(this)],u=0;this.engine=new function(e={}){this.torque=e.torque??300,this.minRPM=800,this.maxRPM=8e3,this.rpmLimiterDelay=50,this.angularVelocity=this.minRPM/kn,this.inertia=.15,this.friction=50,this.canThrottle=!0;var t=null,n=1,i=r.path+"cargame/engineSound/i6/",o=1.4,a=[{baseRPM:750,from:-5e3,to:1e3,on:i+"idle.wav",off:i+"idle.wav",interior_on:i+"int_idle.wav",interior_off:i+"int_idle.wav"},{baseRPM:1125,from:1e3,to:2500,on:i+"low_on.wav",off:i+"low_off.wav",interior_on:i+"int_low_on.wav",interior_off:i+"int_low_off.wav"},{baseRPM:1900,from:2500,to:5e3,on:i+"med_on.wav",off:i+"med_off.wav",interior_on:i+"int_med_on.wav",interior_off:i+"int_med_off.wav"},{baseRPM:3500,from:1e3,to:15e3,on:i+"high_on.wav",off:i+"high_off.wav",interior_on:i+"int_high_on.wav",interior_off:i+"int_high_off.wav"}];this.setupAudio=async function(e,t){for(let n of a)n.on&&jn(e,n.on).then((r=>{let{source:i,gainNode:o}=Hn(e,r);n.onSource=i,n.onGain=o,o.connect(t),o.gain.value=0})),n.off&&jn(e,n.off).then((r=>{let{source:i,gainNode:o}=Hn(e,r);n.offSource=i,n.offGain=o,o.connect(t),o.gain.value=0})),n.interior_on&&jn(e,n.interior_on).then((r=>{let{source:i,gainNode:o}=Hn(e,r);n.interiorOnSource=i,n.interiorOnGain=o,o.connect(t),o.gain.value=0})),n.interior_off&&jn(e,n.interior_off).then((r=>{let{source:i,gainNode:o}=Hn(e,r);n.interiorOffSource=i,n.interiorOffGain=o,o.connect(t),o.gain.value=0}))},this.update=function(){this.getRPM()>=this.maxRPM&&(this.canThrottle=!1,clearTimeout(t),t=setTimeout((()=>{this.canThrottle=!0}),this.rpmLimiterDelay)),this.handleAudio()},this.fixedUpdate=function(e){let t=this.torqueLookup(this.getRPM())*this.torque;if(this.canThrottle){var i=p;i=y(i,0,R),this.getRPM()<this.minRPM&&(i=y(y((this.minRPM-this.getRPM())/100,0,.4)+i,0,1)),r.limitReverseSpeed&&0===r.currentGear&&this.getRPM()>=1600&&(i*=.3),this.angularVelocity+=i*t/this.inertia*e,i&&this.getRPM()>this.maxRPM&&(this.angularVelocity=this.maxRPM/kn+10),n-=.11*(n-i)}else n-=.11*(n-0);this.angularVelocity+=Math.min(Math.abs(this.angularVelocity),this.friction/this.inertia*e)*-Math.sign(this.angularVelocity)},this.handleAudio=function(){var e=y(this.getRPM(),0,this.maxRPM);const t=X.normalize(X.subtract(r.mainCamera.transform.position,r.rb.position)),i=r.rb.velocity,s=X.dot(t,i),l=Math.max(0,343/(343-s));for(let t of a){var c=e,u=t.from,h=t.to,f=(h-u)/2,d=(u+h)/2,m=Math.max(0,Math.min(1,f/2250-Math.abs((c-d)/2250)+.5)),v=e/(t.baseRPM*o);isFinite(m)&&isFinite(v)&&(r.getCurrentCameraController()instanceof Kn?(t.interiorOnGain&&(t.interiorOnGain.gain.value=.3*m*n,t.interiorOnSource.playbackRate.value=e/(t.baseRPM*o)*l),t.interiorOffGain&&(t.interiorOffGain.gain.value=.4*m*(1-n),t.interiorOffSource.playbackRate.value=e/(t.baseRPM*o)*l),t.onGain&&(t.onGain.gain.value=0),t.offGain&&(t.offGain.gain.value=0)):(t.onGain&&(t.onGain.gain.value=.3*m*n,t.onSource.playbackRate.value=e/(t.baseRPM*o)*l),t.offGain&&(t.offGain.gain.value=.4*m*(1-n),t.offSource.playbackRate.value=e/(t.baseRPM*o)*l),t.interiorOnGain&&(t.interiorOnGain.gain.value=0),t.interiorOffGain&&(t.interiorOffGain.gain.value=0)))}},this.getRPM=function(){return this.angularVelocity*kn},this.torqueLookup=function(e){return(309-Math.pow(Math.abs((e-4600)/145),1.4))/309}}({torque:n.torque}),this.clutch=new function(){this.angularVelocity=0,this.inertia=.05,this.impulseCapacity=50},this.frontDiffConnector=new H,this.rearDiffConnector=new H,this.wheels=[],this.wings=n.wings??[],this.drivetrain=n.drivetrain??"RWD";var h,f=!1;this.limitReverseSpeed=n.limitReverseSpeed??!0,this.canDriveWhenChangingGear=n.canDriveWhenChangingGear??!1,this.gearChangeTime=n.gearChangeTime??.35,this.currentGear=1,this.gearRatios=n.gearRatios??[2.66,1.78,1.3,1,.74],this.reverseGearRatio=n.reverseGearRatio??2.9,this.allGearRatios=[this.reverseGearRatio,...this.gearRatios],this.differentialRatio=n.differentialRatio??3.42,this.differentialType=n.differential??Vn.ENUMS.DIFFERENTIAL.OPEN,this.LSDFactor=n.LSDFactor??.05,this.activateAutoCountersteer=n.activateAutoCountersteer??!0,this.autoCountersteerMinVel=2,this.autoCountersteer=.6,this.autoCountersteerVelocityMultiplier=.2,this.steerSpeed=.05,this.steerVelocity=n.steerVelocity??50,this.steerGamma=2,this.ackermannSteering=n.ackermannSteering??!0,this.maxSteerAngle=n.maxSteerAngle??35,this.steeringWheelModelMaxRotation=1.5*Math.PI;var d=n.ebrakeTorque??4e3;this.brakeTorque=n.brakeTorque??1500,this.ABS=n.ABS??!0,this.TCS=n.TCS??!1,this.antiRoll=n.antiRoll??7e3;var m=n.rideHeightOffset??0;this.controlScheme=n.controlScheme??Vn.ControlScheme.Keyboard;let v=0,p=0,g=1,b=0,T=1,w=0,E=1,M=1,_=0,R=1;var C=K.identity(),F=K.identity(),A=new X,D=new X,P=new X,S=new K,N=new X,U=new X;let z=new j,L=new X;this.ebrakeIconPath=this.path+"assets/textures/parkingBrakeIcon.png",this.smokeTexture=this.path+"assets/textures/smoke.png",this.skidAudioSource=this.path+"cargame/skid.wav",this.offroadAudioSource=this.path+"assets/sound/gravelRoad.wav",this.bottomOutAudioSource=this.path+"assets/sound/bottomOut.wav",this.ebrakeImage=new Image(this.ebrakeIconPath);var B=!1,I=()=>{this.audioContext.suspend()},O=()=>{this.audioContext.resume()};(()=>{const e=window.AudioContext||window.webkitAudioContext;this.audioContext=new e,this.audioListener3D=new On(this.audioContext),this.mainGainNode=this.audioContext.createGain(),this.mainGainNode.connect(this.audioContext.destination);const t=X.zero();this.panner=new PannerNode(this.audioContext,{panningModel:"HRTF",distanceModel:"exponential",positionX:t.x,positionY:t.y,positionZ:t.z,orientationX:0,orientationY:0,orientationZ:-1,refDistance:1,rolloffFactor:.25,coneInnerAngle:360,coneOuterAngle:360,coneOuterGain:0}),this.panner.connect(this.mainGainNode),jn(this.audioContext,this.skidAudioSource).then((e=>{var{source:t,gainNode:n}=Hn(this.audioContext,e);this.skidSource=t,this.skidGain=n,this.skidGain.connect(this.panner),n.gain.value=0})),jn(this.audioContext,this.offroadAudioSource).then((e=>{var{source:t,gainNode:n}=Hn(this.audioContext,e);this.offroadSource=t,this.offroadGain=n,this.offroadGain.connect(this.panner),n.gain.value=0})),jn(this.audioContext,this.bottomOutAudioSource).then((e=>{this.bottomOutSample=e})),this.engine.setupAudio(this.audioContext,this.panner),this.horn=new Qn(this.audioContext)})(),window.addEventListener("click",O,{once:!0});var k={},V=!1;this.brakeLightTurnonTime=.1;var G=0;function H(){this.angularVelocity=0,this.inertia=.05}function W(e,n,r,i=1,o=1,a=1/0){var s=[1/i,-1/o],l=[e.angularVelocity,n.angularVelocity],c=[e.inertia,n.inertia],u=0/r*0,h=t.getEffectiveMass(s,c),f=t.getLambda(h,s,l,u);f=y(f,-a,a);for(var d=[],m=0;m<s.length;m++)d[m]=s[m]*f;e.angularVelocity+=d[0]/e.inertia,n.angularVelocity+=d[1]/n.inertia}function q(e,n,r,i=1,o=1){var a=e.angle/i-n.angle/o,s=[1/i,-1/o],l=[e.angularVelocity,n.angularVelocity],c=[e.inertia,n.inertia],{impulses:u}=t.getConstraintImpulse(s,l,c,a,r,0);e.angularVelocity+=u[0]/e.inertia,n.angularVelocity+=u[1]/n.inertia}function Y(e,n,r,i,o,a=0){var s=(n.angularVelocity-r.angularVelocity)*a,l=[.5,.5,-1/o],c=[n.angularVelocity,r.angularVelocity,e.angularVelocity],u=[n.inertia,r.inertia,e.inertia],{impulses:h}=t.getConstraintImpulse(l,c,u,0,i,0);h[0]-=s,h[1]+=s,n.angularVelocity+=h[0]/n.inertia,r.angularVelocity+=h[1]/r.inertia,e.angularVelocity+=h[2]/e.inertia}this.fixedUpdateFunction=e=>{this.fixedUpdate(e)},t.on("fixedUpdate",this.fixedUpdateFunction),this.freeze=function(){this.frozen=!0,this.rb.frozen=!0,I()},this.unfreeze=function(){this.frozen=!1,this.rb.frozen=!1,O()},this.getWheel=function(e){return"rr"==e.toLowerCase()?this.wheels[0]:"rl"==e.toLowerCase()?this.wheels[1]:"fr"==e.toLowerCase()?this.wheels[2]:"fl"==e.toLowerCase()?this.wheels[3]:void 0},this.getCurrentCameraController=function(){return c[u]},this.setup=async function(t){"string"==typeof t?this.gameObject=e.add(await i.loadGLTF(t)):t instanceof Oe&&(this.gameObject=t);var r,o=[(r=this.gameObject).getChild(/(wheel_*rr)|(rr_*wheel)|(^rr$)/gim,!0)||r.getChild("RearRightWheel",!0),r.getChild(/(wheel_*rl)|(rl_*wheel)|(^rl$)/gim,!0)||r.getChild("RearLeftWheel",!0),r.getChild(/(wheel_*fr)|(fr_*wheel)|(^fr$)/gim,!0)||r.getChild("FrontRightWheel",!0),r.getChild(/(wheel_*fl)|(fl_*wheel)|(^fl$)/gim,!0)||r.getChild("FrontLeftWheel",!0)];if(4!=o.length||o.some((e=>null==e)))throw console.log(o),new Error("Vehicle does not have 4 wheels");var a=we(this.gameObject,0,o),s=a.getCenter(),l=X.subtract(a.getSize(),X.fill(.2));for(var f of this.gameObject.children)if(!o.includes(f)){var d=f.transform;d.position=X.subtract(d.position,s)}this.rb=new Ae,this.rb.position=X.copy(this.resetPosition),this.rb.mass=n.mass??1500,X.addTo(this.rb.COMOffset,n.COMOffset??X.zero()),this.rb.inertia=new X(this.rb.mass/12*(l.y**2+l.z**2),this.rb.mass/12*(l.x**2+l.z**2),this.rb.mass/12*(l.y**2+l.x**2)),this.gameObject.addComponent(this.rb),this.gameObject.addComponent(new Re(new Te(X.divide(l,-2),X.divide(l,2)),-1e3));for(var v=0;v<o.length;v++){var p=o[v],g=we(p),x=g.getCenter();(x=X.subtract(x,s)).y+=m;var b=Math.max(...X.toArray(g.getSize()))/2,y=p.addComponent(new i.TrailRenderer);y.width=.5*Math.min(...X.toArray(g.getSize()));var T=this.gameObject.addChild(new Oe(p.name+"-Parent"));T.transform.position=x;var w=T.addChild(new Oe("WheelModel"));p.setParent(w),p.transform.position=X.subtract(p.transform.position,g.getCenter()),this.wheels[v]=new Gn(this,x,T,{...n,radius:b}),this.wheels[v].wheelModel=w,this.wheels[v].skidmarks=y,this.bottomOffset.y=x.y-b-this.wheels[v].suspensionTravel-this.gameObject.transform.position.y}this.track=X.distance(this.wheels[0].position,this.wheels[1].position),this.wheelBase=X.distance(this.wheels[0].position,this.wheels[2].position),this.wheels[0].turn=!1,this.wheels[1].turn=!1,this.wheels[2].drive=!1,this.wheels[3].drive=!1,this.wheels[2].ebrake=!1,this.wheels[3].ebrake=!1,this.wheels[1].side=-1,this.wheels[3].side=-1;let E=n.rearCamber??0;this.wheels[0].camberAngle=E*-this.wheels[0].side,this.wheels[1].camberAngle=E*-this.wheels[1].side;let M=n.frontCamber??0;this.wheels[2].camberAngle=M*-this.wheels[2].side,this.wheels[3].camberAngle=M*-this.wheels[3].side,this.rollbars=[{a:this.wheels[0],b:this.wheels[1]},{a:this.wheels[2],b:this.wheels[3]}],k.mainFront=Sn("LampWhite",this.gameObject,!0)[0],k.mainRear=Sn("LampRedLight",this.gameObject,!0)[0],k.brake=Sn("LampRed",this.gameObject,!0)[0],k.turnSignal=Sn("LampOrange",this.gameObject,!0)[0],k.reverseRear=Sn("Reverse",this.gameObject,!0)[0],this.setLightEmission("mainRear",[1,0,0]);var _=!1;setInterval((()=>{_=!_,this.setLightEmission("turnSignal",_?[50,5,0]:[0,0,0])}),400),this.lamps={brightsLeft:this.gameObject.getChild("BrightsLeft",!0)?.children[0]?.getComponent("Light"),brightsRight:this.gameObject.getChild("BrightsRight",!0)?.children[0]?.getComponent("Light")},this.lamps.brightsLeft&&(this.lamps.brightsLeft.color=[0,0,0]),this.lamps.brightsRight&&(this.lamps.brightsRight.color=[0,0,0]);var R=new Oe("Smoke");this.gameObject.addChild(R);var C=R.addComponent(new i.ParticleSystem(300));C.material=i.CreateLitMaterial({albedoTexture:i.loadTexture(this.smokeTexture),albedo:[2,2,2,1]},i.programContainers.particle),C.material.doubleSided=!0,C.emitPosition=e=>{e.x=0,e.y=2,e.z=0},C.emitVelocity=e=>{e.x=Math.random()-.5,e.y=Math.random()-.5+.5,e.z=-2},C.startSize=e=>{X.fill(.4*Math.random()+.2,e)},C.endSize=e=>X.fill(3,e),C.emitHealth=2.5,C.gravityScale=0,C.drag=.1,C.orientation="faceCamera",C.localParticles=!1,this.smoke=C;const F=new Oe("Grass particles");this.gameObject.addChild(F);const A=F.addComponent(new i.ParticleSystem(300)),D=i.CreateLitMaterial({albedoTexture:await i.loadTexture("leaves5.png")},i.programContainers.particle);A.material=D,A.startSize=e=>X.fill(.23*Math.random(),e),A.orientation="faceCamera",A.localParticles=!1,this.grassParticles=A,this.steeringWheelModel=this.gameObject.getChild("SteeringWheel",!0),this.steeringWheelModel&&(h=K.copy(this.steeringWheelModel.transform.matrix));var P=new Oe("InteriorCamera");P.transform.position=new X(-.3,.35,-.5),P.transform.rotation=j.euler(0,Math.PI,0),this.gameObject.addChild(P);var S=new Oe("HoodCamera");S.transform.position=new X(0,.5,.8),S.transform.rotation=j.euler(0,Math.PI,0),this.gameObject.addChild(S),c[u].onReset()},this.destroy=function(){this.audioContext.close(),window.removeEventListener("click",O),t.eventHandler.removeEvent("fixedUpdate",this.fixedUpdateFunction),this.gameObject.delete()},this.reset=function(){for(var e of(this.rb.position.y+=2,this.rb.rotation=j.euler(0,0*Math.PI/2,0),this.gameObject.transform.position=this.rb.position,this.gameObject.transform.rotation=this.rb.rotation,this.rb.velocity=X.zero(),this.rb.angularVelocity=X.zero(),this.rb.rotation=j.identity(),this.rb.inverseWorldInertia=K.identity(),this.rb._worldCOMOffset=X.zero(),this.rb.torque=X.zero(),this.currentGear=1,this.engine.angularVelocity=0,this.clutch.angularVelocity=0,this.wheels))e.angle=0,e.angularVelocity=0,e.normalForce=0,e.isGrounded=!1;w=0,this.mainCamera.transform.matrix=K.identity(),c[u].onReset()},this.resetGame=function(){this.reset(),this.rb.position=X.copy(this.resetPosition),this.rb.rotation=j.copy(this.resetRotation),this.gameObject.transform.position=this.rb.position,this.gameObject.transform.rotation=this.rb.rotation,c[u].onReset(this.mainCamera)},this.renderUI=function(e){const t=this.engine.getRPM(),n={x:e.width-140,y:e.height-120},r="rgba(255, 255, 255, 0.3)";e.font="Oswald";const i=e.ctx.createLinearGradient(n.x,n.y-104,n.x,n.y+104);i.addColorStop(.4,"rgba(10, 10, 10, 0.4)"),i.addColorStop(.9,"transparent"),e.circle(n.x,n.y,104,i),function(e,t,n,r,i,o,a=100){t=y(t,n,r);const s=(270/r*1e3*7+135)*Math.PI/180,l="rgba(255, 0, 0, 0.25)";e.beginPath(),e.arc(i,o,a-.125*a/2,.75*Math.PI,e.mapValue(t,n,r,.75*Math.PI,2.25*Math.PI)),e.lineWidth(.125*a),e.strokeStyle("white"),e.stroke(),e.beginPath(),e.arc(i,o,a-.125*a/2,s,2.25*Math.PI),e.lineWidth(.125*a),e.strokeStyle(l),e.stroke();var c="lightgray";e.setTextXAlign("center"),e.setTextYAlign("center");var u=r/1e3,h=.9;for(let t=0;t<=270;t+=270/u){let n=(t+135)*Math.PI/180;const r=n>=s?l:c;e.line(i+Math.cos(n)*a*.99,o+Math.sin(n)*a*.99,i+Math.cos(n)*(a*h),o+Math.sin(n)*(a*h),r,1)}e.resetTextXAlign(),e.resetTextYAlign(),h=.94;for(let t=0;t<=270;t+=270/u/5){let n=(t+135)*Math.PI/180;const r=n>=s?l:c;t%(270/u)!=0&&e.line(i+Math.cos(n)*a*.96,o+Math.sin(n)*a*.96,i+Math.cos(n)*(a*h),o+Math.sin(n)*(a*h),r,1)}}(e,t,0,this.engine.maxRPM,n.x,n.y,100),e.setTextXAlign("center"),e.setTextYAlign("middle"),e.font="monospace";let o=Math.floor(t).toString();e.text(o.padStart(4,"0"),n.x,n.y-60,20,r),e.text(o.padStart(4," "),n.x,n.y-60,20,"white"),e.font="Oswald",e.roundedRectangle(n.x-25,n.y-10-30,50,55,"rgba(0, 0, 0, 0.25)",10);var s=.9*this.engine.maxRPM;e.text(f?"N":0==this.currentGear?"R":this.currentGear,n.x,n.y-10,50,t>s?"red":f?r:"white");let l=Math.abs(Math.floor(3.6*this.forwardVelocity)).toString();e.text(l,n.x,n.y+40,35,"white"),e.text("km/h",n.x,n.y+65,15,r),e.fontWeight="bold";const c=Math.floor(performance.now()/100)%2==0?1:0;if(this.ABS){const t=`rgba(255, 0, 0, ${c})`,i=g>Math.min(...this.wheels.map((e=>e.brakeLimit)))?t:r;if(e.text("ABS",n.x-50,n.y-12-10,15,i),this.haptics){const e=a.getInputAndInputMethod("brake");if(i===t&&"controller"==e.method){const e=Math.abs(g-Math.min(...this.wheels.map((e=>e.brakeLimit))));a.gamepadManager.vibrate(50,.2*e,.3*e)}}}if(this.TCS){const t=p>R?`rgba(40, 40, 255, ${c})`:r;e.text("TCS",n.x-50,n.y-12+14,15,t)}e.fontWeight="normal",e.resetTextXAlign(),e.resetTextYAlign(),b>.05&&e.picture(this.ebrakeIconPath,n.x+50-14,n.y-12.5-14,28,28)},this.update=function(e){if(this.frozen)return;this.audioListener3D.setPosition(this.mainCamera.transform.position),this.audioListener3D.setDirection(this.mainCamera.transform.forward,this.mainCamera.transform.up);const t=this.rb.position;if(this.panner.positionX.value=t.x,this.panner.positionY.value=t.y,this.panner.positionZ.value=t.z,this.horn&&(a.getInputDown("horn")&&this.horn.start(),a.getInputUp("horn")&&this.horn.stop()),a.getInputDown("brights")&&(V=!V,this.lamps.brightsLeft&&(this.lamps.brightsLeft.color=V?[3e3,3e3,3e3]:[200,200,200]),this.lamps.brightsRight&&(this.lamps.brightsRight.color=V?[3e3,3e3,3e3]:[200,200,200]),this.setLightEmission("mainFront",V?[200,200,200]:[1,1,1])),a.getInputDown("cameraMode")&&(c[u].onDeactivate(this.mainCamera),u++,u%=c.length,c[u].onActivate(this.mainCamera)),a.getInputDown("resetGame")&&this.resetGame(),this.canMove){var n=X.negate(K.getForward(C)),r=X.dot(this.rb.velocity,n);if(v=-Bn(a.getInput("steer"),.1),this.controlScheme==Vn.ControlScheme.Controller){let e=a.getInputAndInputMethod("drive"),t=y(e.value,0,1);if("keyboard"==e.method?p+=.1*(t-p):"controller"==e.method&&(p=t),X.lengthSqr(this.rb.velocity)<.1&&(g>.1||b>.1)&&p<.01)b=1,g=1;else{let e=a.getInputAndInputMethod("brake"),t=Math.pow(e.value,3);"keyboard"==e.method?g+=.1*(t-g):"controller"==e.method&&(g=t),b+=.2*(a.getInput("ebrake")-b)}}else if(this.controlScheme==Vn.ControlScheme.Keyboard){var i=y(a.getInput("drive"),0,1)-a.getInput("brake"),o=y(Math.abs(i),0,1);p=o,g=0,(r>1&&i<-.1||r<-1&&i>.1)&&(g=1,p=0),i>.1&&r>-1.1&&0==this.currentGear&&(this.currentGear=1),i<-.1&&r<1.1&&(this.currentGear=0),b+=.2*(a.getInput("ebrake")-b)}var s=(e=1)=>{this.currentGear+=e,this.currentGear=y(this.currentGear,0,this.allGearRatios.length-1)};f||(a.getInputDown("gearDown")&&this.currentGear>0&&(f=!0,setTimeout((()=>{s(-1),f=!1}),1e3*this.gearChangeTime)),a.getInputDown("gearUp")&&this.currentGear<this.allGearRatios.length-1&&(f=!0,setTimeout((()=>{s(1),f=!1}),1e3*this.gearChangeTime))),f&&!this.canDriveWhenChangingGear&&a.getInput("clutch")<.05&&(p=0),a.getInputDown("resetCar")&&this.reset()}else p=0,g=0,b=1,T=1;G=y(G+=Math.sign((g>1e-6?1:0)-G)/this.brakeLightTurnonTime*e,0,1),this.setLightEmission("reverseRear",0==this.currentGear?[50,50,50]:[0,0,0]),this.setLightEmission("brake",[50*Math.pow(G,5),0,0]),this.engine.update()},this.fixedUpdate=function(e){if(this.frozen)return;this.cameraControls(e),K.copy(this.gameObject.transform.worldMatrix,C),K.inverse(C,F),K.removeTranslation(F),K.transformVector(F,this.rb.angularVelocity,A),K.getForward(C,D),X.negate(D,D),K.getRight(C,P);var n=X.dot(this.rb.velocity,D);this.forwardVelocity=n;var r=X.dot(this.rb.velocity,P),i=-Math.atan2(r,Math.abs(n));!isNaN(i)&&isFinite(i)||(i=0);var s=v;s=y(s=Math.pow(Math.abs(s),this.steerGamma)*Math.sign(s),-1,1),s*=Math.exp(-Math.abs(n)/this.steerVelocity),w+=(s-w)*this.steerSpeed;var l=this.activateAutoCountersteer&&(Math.abs(r)>.5||n>this.autoCountersteerMinVel)?-i/(this.maxSteerAngle/180*Math.PI)*this.autoCountersteer-A.y*this.autoCountersteerVelocityMultiplier*Math.sign(n):0,c=y(w+l,-1,1);this.steeringWheelModel&&(K.copy(h,S),K.transform([["rz",-c*this.steeringWheelModelMaxRotation]],S),this.steeringWheelModel.transform.matrix=S);for(let n=0;n<this.wheels.length;n++){let r=this.wheels[n],i=r.turn?c*this.maxSteerAngle*Math.PI/180:0;this.ackermannSteering&&(2==n&&c>0||3==n&&c<0)&&(i=Math.sign(c)*Math.atan(this.wheelBase/(this.track+this.wheelBase/Math.tan(Math.abs(i))))),K.identity(S),K.transform([["translate",r.position],["ry",i]],S),r.model.transform.matrix=S;let a=r.model.transform.worldMatrix;K.getUp(a,r.up);let s=r.up;X.negate(s,U),K.transformVector(C,r.position,r.worldPos);let l=r.worldPos;this.rb.GetPointVelocity(l,N),X.multiplyTo(N,e);let u={origin:l,direction:U},h=t.Raycast(u.origin,u.direction);if(h&&h.gameObject?.customData.bumpiness){let e=h.gameObject?.customData.bumpinessNoiseScale??3;if(isNaN(e))throw console.error(e),new Error("Bumpiness noise scale is NaN");let t=h.gameObject?.customData.bumpiness;if(isNaN(t))throw console.error(t),new Error("Bumpiness value is NaN");h.distance-=.5*(o.noise(h.point.x*e,h.point.z*e)+1)*t}if(r.isGrounded=h&&h.distance<r.suspensionTravel+r.radius,r.wheelModel){let e=r.wheelModel.transform;e.position.x=r.camberAngle/100,e.position.y=-(r.isGrounded?h.distance-r.radius:r.suspensionTravel),e.position.z=0,e.rotation=j.euler(r.angle,0,r.camberAngle*Math.PI/180)}if(r.staticWheelModel){let e=r.staticWheelModel.transform;e.position.x=r.camberAngle/100,e.position.y=-(r.isGrounded?h.distance-r.radius:r.suspensionTravel),e.position.z=0,e.rotation=j.euler(0,1==r.side?Math.PI:0,r.camberAngle*Math.PI/180)}r.skidmarks&&(r.isGrounded?(r.skidmarks.emitPosition=X.add(X.add(h.point,new X(0,.01,0)),N),r.skidmarks.emitNormal=h.normal):(r.skidmarks.emitPosition=X.add(X.add(l,X.multiply(s,-r.radius)),N),r.skidmarks.emit=0)),r.ray=u,r.worldPos=l,r.isGrounded&&(r.groundHit=h,r.contactPoint=h.point)}M=1,_=0;var u=this.engine.getRPM();let d=a.getInput("clutch");var m=new Array(this.wheels.length).fill(0),p=e/20;for(let t=0;t<20;t++){var g=(this.engine.getRPM()-u)*p;E=Math.max(b,d,T-.002*(this.engine.getRPM()-(this.engine.minRPM+800))-20*g),E=y(E,0,1),T+=.3*(E-T),f&&(T=1,E=1),u=this.engine.getRPM(),this.engine.fixedUpdate(p),W(this.engine,this.clutch,p,1,1,Math.pow(1-T,4)*this.clutch.impulseCapacity);let t=(0==this.currentGear?-1:1)*this.allGearRatios[this.currentGear]*this.differentialRatio;if(this.differentialType==Vn.ENUMS.DIFFERENTIAL.OPEN||this.differentialType==Vn.ENUMS.DIFFERENTIAL.LSD){let e=this.differentialType==Vn.ENUMS.DIFFERENTIAL.LSD?this.LSDFactor:0;"RWD"==this.drivetrain?Y(this.clutch,this.wheels[0],this.wheels[1],p,t,e):"FWD"==this.drivetrain?Y(this.clutch,this.wheels[2],this.wheels[3],p,t,e):"AWD"==this.drivetrain&&(Y(this.rearDiffConnector,this.wheels[0],this.wheels[1],p,t,e),Y(this.frontDiffConnector,this.wheels[2],this.wheels[3],p,t,e),Y(this.clutch,this.rearDiffConnector,this.frontDiffConnector,p,1))}else this.differentialType==Vn.ENUMS.DIFFERENTIAL.LOCKED&&("RWD"!=this.drivetrain&&"AWD"!=this.drivetrain||(q(this.clutch,this.wheels[0],p,1,1/t),q(this.clutch,this.wheels[1],p,1,1/t)),"FWD"!=this.drivetrain&&"AWD"!=this.drivetrain||(q(this.clutch,this.wheels[2],p,1,1/t),q(this.clutch,this.wheels[3],p,1,1/t)));for(var x of this.wheels)x.normalForce=0;$(e,m),Q(p),Z(p),this.simulateFriction&&J(p,r)}for(let t of this.wheels)if(t.angle+=t.angularVelocity*e,t.isGrounded&&!t.groundHit.gameObject?.customData.offroad){let e=t.model.transform.worldMatrix,n=X.negate(K.getForward(e)),r=X.dot(this.rb.velocity,n),i=t.angularVelocity*t.radius-r;if(i*=t.roadFriction*t.forwardFriction*t.friction,Math.abs(i)>5){let n=K.getUp(e),r=K.transformVector(C,t.position);X.addTo(r,X.multiply(n,-t.radius)),this.smoke.emitPosition=e=>X.set(e,r);let o=K.getRight(e),a=j.QxV(j.angleAxis(-Math.PI/2,o),t.groundHit.normal),s=K.basis(o,X.cross(o,a),a);this.smoke.emitVelocity=e=>{new X(Math.random()-.5,.5*Math.random(),3.5,e),K.transformVector(s,e,e)},this.smoke.alpha=.1*y((Math.abs(i)-5)/10,0,1),this.smoke.emit()}}for(let e of this.wheels)if(e.isGrounded&&e.groundHit.gameObject?.customData.offroad){const t=this.rb.GetPointVelocity(e.groundHit.point),n=e.model.transform.worldMatrix,r=K.getForward(n),i=K.getRight(n),o=-X.dot(t,r),a=X.dot(t,i),s=e.angularVelocity*e.radius-o;if(Math.abs(s)>1||Math.abs(a)>5){this.grassParticles.emitPosition=t=>X.set(t,e.groundHit.point);const t=K.basis(X.cross(r,X.up()),X.up(),r),n=y(Math.abs(s)/10,0,1);this.grassParticles.emitVelocity=e=>{new X(3*(Math.random()-.5),.5*Math.random()*20,10.5*Math.sign(s),e),X.multiplyTo(e,n),K.transformVector(t,e,e),X.addTo(e,this.rb.velocity)},this.grassParticles.emit(1)}}for(let e of this.wings)e.applyForce(this.rb,n);if(this.rb.angularVelocity.x*=.995,this.rb.angularVelocity.y*=.995,this.rb.angularVelocity.z*=.995,this.skidSource&&this.skidGain&&(this.skidGain.gain.value+=.1*(.5*_-this.skidGain.gain.value),this.skidSource.playbackRate.value=M),this.offroadSource&&this.offroadGain)if(this.wheels.some((e=>e.isGrounded&&e.groundHit.gameObject?.customData.offroad))){let e=y(X.length(this.rb.velocity)/3,0,.7);isFinite(e)&&(this.offroadGain.gain.value=e);let t=y(.8+X.length(this.rb.velocity)/15,1,1.4);isFinite(t)&&(this.offroadSource.playbackRate.value=t)}else this.offroadGain.gain.value=0;let R=Math.max(...this.wheels.map((e=>e.bottomOutStrength)));if(R>0&&this.bottomOutSample&&!B){let{source:e,gainNode:t}=Hn(this.audioContext,this.bottomOutSample);e.loop=!1,e.playbackRate.value=.9+.2*Math.random(),t.gain.value=y(R/3e3,0,1.5),t.connect(this.panner),B=!0,setTimeout((()=>{B=!1}),100)}},this.setRawSteerInput=function(e){v=y(e,-1,1)},this.getRawSteerInput=function(){return v},this.setDriveInput=function(e){p=y(e,0,1)},this.getDriveInput=function(){return p},this.setBrakeInput=function(e){g=y(e,0,1)},this.getBrakeInput=function(){return g},this.setClutchInput=function(e){T=y(e,0,1)},this.getClutchInput=function(){return T},this.setEbrakeInput=function(e){b=y(e,0,1)},this.getEbrakeInput=function(){return b},this.setLightEmission=function(e,t=[0,0,0]){var n=k[e];n&&(Array.isArray(t)||(t=[t,t,t]),n.setUniform("emissiveFactor",t))},this.cameraControls=function(e){c[u].update(this.mainCamera,e)};{let e=new X,t=new X;var $=(n,r)=>{let i=0;for(let o of this.wheels){o.bottomOutStrength=0;let a=o.ray,s=o.groundHit;if(o.isGrounded&&s&&s.distance<o.suspensionTravel+o.radius){X.multiply(a.direction,o.radius+o.stopLength,L),X.add(a.origin,L,t),X.subtract(s.point,t,L);let l=-X.dot(L,s.normal);if(l<0){o.isGrounded=!0,X.subtract(t,this.rb.position,L),X.cross(L,s.normal,e);let a=[s.normal.x,s.normal.y,s.normal.z,e.x,e.y,e.z],c=this.rb.inverseWorldInertia,u=.15/n*l,h=tr([a[0]/this.rb.mass,a[1]/this.rb.mass,a[2]/this.rb.mass,a[3]*c[0],a[4]*c[5],a[5]*c[10]],a),f=-(tr(a,[this.rb.velocity.x,this.rb.velocity.y,this.rb.velocity.z,this.rb.angularVelocity.x,this.rb.angularVelocity.y,this.rb.angularVelocity.z])+u)/h;r[i]+f<0&&(f=-r[i]),r[i]+=f,X.addTo(this.rb.velocity,X.multiply(new X(a[0],a[1],a[2]),f/this.rb.mass)),X.addTo(this.rb.angularVelocity,K.transformVector(this.rb.inverseWorldInertia,X.multiply(new X(a[3],a[4],a[5]),f))),o.normalForce=Math.abs(r[i]/n),o.bottomOutStrength=Math.max(o.bottomOutStrength,Math.abs(r[i]))}}i++}}}{let e=new X,t=new X,n=new X,r=new X;var Q=i=>{for(let o of this.wheels){let a=o.ray,s=o.groundHit,l=o.worldPos,c=o.up;if(this.rb.GetPointVelocity(l,e),o.isGrounded){let u=s.distance,h=o.suspensionTravel-(u-o.radius);X.multiply(a.direction,h*-o.suspensionForce,t),X.projectOnPlane(this.rb.velocity,s.normal,L),X.subtract(e,L,L),X.project(L,c,L),X.multiply(L,-o.suspensionDamping,n),X.add(t,n,r),X.multiply(r,i,L),this.rb.AddImpulseAtPosition(L,l),o.normalForce+=X.length(r),o.compressionAmount=y(h/o.suspensionTravel,0,1)}}}}var Z=e=>{for(let t of this.rollbars){let n=((t.a.compressionAmount??0)-(t.b.compressionAmount??0))*this.antiRoll;t.a.isGrounded&&(X.multiply(t.a.up,(t.b.isGrounded?1:2)*n*e,L),this.rb.AddImpulseAtPosition(L,t.a.worldPos)),t.b.isGrounded&&(X.multiply(t.b.up,(t.a.isGrounded?1:2)*-n*e,L),this.rb.AddImpulseAtPosition(L,t.b.worldPos))}};{let e=new X,t=new X,n=new X,r=new X,i=new X,o=new X;var J=(a,s)=>{for(let E of this.wheels){let F=0,A=0,D=E.model.transform.worldMatrix;if(K.getForward(D,e),K.getRight(D,t),K.transformVector(C,E.position,n),this.rb.GetPointVelocity(n,r),b>.1&&E.ebrake&&(E.angularVelocity+=-Math.sign(E.angularVelocity)*Math.min(b*d,Math.abs(E.angularVelocity)/a)*a),0!=g){const e=y(g,0,E.brakeLimit);E.angularVelocity+=-Math.sign(E.angularVelocity)*Math.min(e*this.brakeTorque/E.inertia,Math.abs(E.angularVelocity)/a)*a}if(E.isGrounded){A=X.dot(r,e);let n=X.dot(r,t);const s=E.groundHit.gameObject?.customData?.offroad,d=s?E.offroadFriction:E.friction;let g=E.groundHit.gameObject?.customData?.friction??1;E.roadFriction=g,F=-Math.atan(n/Math.abs(A)),!isNaN(F)&&isFinite(F)||(F=0);let x=F/E.slipAnglePeak;E.lastA=x;var l=-(E.angularVelocity*E.radius+A)/Math.abs(A)*Math.min(Math.abs(A)/2,1);isNaN(l)&&(l=0),isFinite(l)||(l=Math.sign(l));var c=l/E.slipRatioPeak;if(this.ABS&&X.lengthSqr(r)>.2){const e=(E.slipRatioPeak*Math.sqrt(Math.max(.01,1-x*x))*Math.sign(A)*Math.abs(A)-A)/E.radius,t=E.angularVelocity-(E.lastAngularVelocity??0);E.brakeLimit-=(e-E.angularVelocity)*Math.sign(E.angularVelocity)*.15-.05*t,E.brakeLimit=y(E.brakeLimit,0,1)}else E.brakeLimit=1;this.TCS?(E.throttleLimit-=Math.abs(E.angularVelocity*E.radius+A)-1,E.throttleLimit=y(E.throttleLimit,0,1)):E.throttleLimit=1;var u=Math.sqrt(c*c+x*x),h=c/u*(er(u*E.slipRatioPeak,E.slipRatioCoeffs)*g*d*E.forwardFriction)*E.normalForce,f=x/u*(Jn(u*E.slipAnglePeak*180/Math.PI,E.normalForce,E.camberAngle,E.advancedSlipAngleCoeffs)*g*d*E.sidewaysFriction);if(!isNaN(h)){var m=E.angularVelocity*E.radius+A,v=Math.abs(m/(E.radius*E.radius)*E.inertia/a),p=Math.abs(h),T=Math.min(p,v)*-Math.sign(h);E.angularVelocity-=T*E.radius/E.inertia*a}X.projectOnPlane(t,E.groundHit.normal,i),j.angleAxis(-Math.PI/2,i,z),j.QxV(z,E.groundHit.normal,o),isNaN(h)||(X.multiply(o,h*a,L),this.rb.AddImpulseAtPosition(L,E.contactPoint)),isNaN(f)||(X.multiply(i,f*a,L),this.rb.AddImpulseAtPosition(L,E.contactPoint))}else E.brakeLimit=1,E.throttleLimit=1;R=Math.min(...this.wheels.map((e=>e.throttleLimit)));var w=.8+y(.7*(Math.abs(l)-.2),0,.8);w>M&&(M=w);let P=0;E.isGrounded&&!E.groundHit.gameObject?.customData.offroad&&(P=x(u,1,1.1),P*=x((E.angularVelocity*E.radius+A)**2+s**2,0,2),P>_&&(_=P)),E.skidmarks&&(E.skidmarks.emit=y(y(20*P*(E.isGrounded?1:0),0,.7)*(E.isGrounded?y(E.normalForce/5e3,0,1)*E.friction*E.forwardFriction*E.roadFriction:0),0,1)),E.slipRatio=l,E.lastAngularVelocity=E.angularVelocity}}}}function Gn(e,t=X.zero(),n,r={}){this.position=t,this.model=n,this.side=1,this.offroadFriction=r.offroadFriction??.5,this.friction=r.friction??1,this.forwardFriction=r.forwardFriction??1,this.sidewaysFriction=r.sidewaysFriction??1,this.radius=r.radius??.35,this.camberAngle=0,this.camberAngleCoeff=r.camberAngleCoeff??1,this.stopLength=r.stopLength??.01,this.suspensionTravel=r.suspensionTravel??.15,this.suspensionDamping=r.suspensionDamping??2500,this.suspensionForce=r.suspensionForce??5e4,this.angle=0,this.angularVelocity=0,this.mass=r.wheelMass??20,this.inertia=this.mass*this.radius*this.radius/2,this.slipRatioCoeffs=r.slipRatioCoeffs??[16,1.5,1.1,-1.4],this.slipAngleCoeffs=r.slipAngleCoeffs??[.2,1.5,1.1,-1.4],this.advancedSlipAngleCoeffs=[1.799,0,1688,1e3,6.026,0,-.3589,1,.8,-.006111,-3.224/100,0,0,0,0],this.slipRatioPeak=Zn((e=>er(e,this.slipRatioCoeffs))),this.slipAnglePeak=Zn((t=>Jn(180*t/Math.PI,9.82*e.rb.mass/4,this.camberAngle,this.advancedSlipAngleCoeffs))),this.drive=!0,this.turn=!0,this.ebrake=!0,this.brakeLimit=1,this.throttleLimit=1,this.isGrounded=!1,this.normalForce=0,this.up=new X,this.worldPos=new X}function Xn(e,t=.1){this.position=e,this.liftCoeff=t,this.applyForce=function(e,t){var n=X.multiply(X.down(),this.liftCoeff*t*t),r=K.transformVector(e.gameObject.transform.worldMatrix,this.position);e.AddForceAtPosition(n,r)}}function jn(e,t){return fetch(t).then((e=>e.arrayBuffer())).then((t=>e.decodeAudioData(t)))}function Hn(e,t){var n=e.createGain();const r=e.createBufferSource();return r.buffer=t,r.loop=!0,r.connect(n),r.start(0),{source:r,gainNode:n}}Vn.ENUMS={DIFFERENTIAL:{OPEN:0,LOCKED:1,LSD:2}},Vn.ControlScheme={Keyboard:0,Controller:1};class Wn{update(){}onActivate(){}onDeactivate(){}onReset(){}}class qn extends Wn{#r=new X;#a=0;#s=0;#l=0;#c=5;#u=X.zero();#h=0;#f=X.zero();#d=X.zero();CAMERA_FOLLOW_MODES={FOLLOW_VELOCITY:1,FOLLOW_DIRECTION:2,FOLLOW_INVERSE_DIRECTION:3};followMode=this.CAMERA_FOLLOW_MODES.FOLLOW_VELOCITY;followDistance=5;followHeight=.4;followSpeed=.05;pitch=.15;accelerationSpeed=.05;accelerationEffect=.3;constructor(e){super(),this.car=e}resetForward(){this.#u=K.getForward(this.car.gameObject.transform.worldMatrix),this.#s=0,this.#a=this.car.rb.position.y+.15+this.followHeight/Math.sqrt(1+this.followHeight**2)*this.followDistance}onReset(){this.resetForward()}onActivate(){this.resetForward()}update(e,t){var n=this.car.gameObject.transform.worldMatrix,r=X.negate(K.getForward(n)),i=X.dot(this.car.rb.acceleration,r);isNaN(i)||(this.#c-=(this.#c-this.followDistance*(1+i/t*this.accelerationEffect))*this.accelerationSpeed);var o=this.#c,a=this.followHeight,s=this.followSpeed,l=this.pitch,c=Bn(this.car.keybindings.getInput("turnCamera")||0,.09)*Math.PI/2*2;this.#l+=.27*(c-this.#l);var u,h=X.projectOnPlane(this.car.rb.velocity,X.up());this.followMode==this.CAMERA_FOLLOW_MODES.FOLLOW_VELOCITY?u=X.length(h)>1?X.negate(X.normalize(h)):X.negate(r):this.followMode==this.CAMERA_FOLLOW_MODES.FOLLOW_DIRECTION?u=X.negate(r):this.followMode==this.CAMERA_FOLLOW_MODES.FOLLOW_INVERSE_DIRECTION&&(u=X.slerp(this.car.gameObject.transform.forward,X.normalize(X.projectOnPlane(X.negate(this.car.rb.velocity),this.car.gameObject.transform.up)),-.5)),this.#u=X.slerp(this.#u,u,s);var f=X.copy(this.#u);f=j.QxV(j.angleAxis(this.#l,this.car.gameObject.transform.up),f);var d=null,m=X.add(this.car.rb.position,new X(0,.15,0));X.set(this.#r,this.car.rb.velocity),X.multiplyTo(this.#r,t),X.addTo(m,this.#r);var v=X.normalize(X.add(f,new X(0,a,0))),p=this.car.physicsEngine.Raycast(m,v);if(p&&p.distance<o){var g=p.distance,x=Math.sqrt(o*o-g*g+(a*g)**2)/g,b=X.normalize(X.add(f,new X(0,x,0)));d=(p=this.car.physicsEngine.Raycast(m,b))&&p.distance<o?X.multiply(b,p.distance-.5):X.multiply(b,o)}else d=X.multiply(v,o);var T=70*(m.y+d.y-this.#a);this.#s+=T*t,this.#s+=7*-this.#s*t,this.#s+=-9.82*t,this.#a+=this.#s*t,e.transform.position=X.add(m,d),e.transform.position.y=this.#a,e.transform.matrix=K.lookAt(e.transform.position,m),K.rotateX(e.transform.matrix,l,e.transform.matrix);var w=Math.abs(X.dot(this.car.rb.velocity,r));if(this.#h%3==0){var E=.02*y(.02*(w-100/3.6),0,1);this.#f=new X(2*(Math.random()-.5)*E,2*(Math.random()-.5)*E,0)}this.#d=X.lerp(this.#d,this.#f,.15),K.rotateX(e.transform.matrix,this.#d.x,e.transform.matrix),K.rotateY(e.transform.matrix,this.#d.y,e.transform.matrix),this.#h++,e.updateFrustum()}}class Yn extends Wn{#m=null;#v=new X;#p=45;constructor(e){super(),this.car=e}onActivate(e){this.#p=this.car.mainCamera.getFOV(),e.setFOV(30)}onDeactivate(){this.car.mainCamera.setFOV(this.#p)}update(e,t){this.#m?(e.transform.matrix=this.#m.transform.worldMatrix,X.set(this.#v,this.car.rb.velocity),X.multiplyTo(this.#v,t),X.addTo(e.transform.position,this.#v)):this.#m=this.car.gameObject.getChild("HoodCamera",!0)}}class Kn extends Wn{#u=X.zero();#p=45;velocityBias=.3;followSpeed=.15;constructor(e){super(),this.car=e}resetForward(){this.#u=K.getForward(this.car.gameObject.transform.worldMatrix)}onReset(){this.resetForward()}onActivate(){this.#p=this.car.mainCamera.getFOV(),this.car.mainCamera.setFOV(25),this.resetForward()}onDeactivate(){this.car.mainCamera.setFOV(this.#p)}update(e,t){var n=this.car.gameObject.getChild("InteriorCamera",!0);if(n){var r=-X.dot(this.car.gameObject.transform.forward,this.car.rb.velocity),i=0===this.car.currentGear?X.negate(this.car.gameObject.transform.forward):r<.2?this.car.gameObject.transform.forward:X.slerp(this.car.gameObject.transform.forward,X.normalize(X.projectOnPlane(X.negate(this.car.rb.velocity),this.car.gameObject.transform.up)),this.velocityBias);this.#u=X.slerp(this.#u,i,this.followSpeed),e.transform.matrix=K.lookInDirection(X.add(n.transform.worldPosition,X.multiply(this.car.rb.velocity,t)),this.#u,this.car.gameObject.transform.up)}}}class $n extends Wn{#p=45;#g=new X;constructor(e){super(),this.car=e}onActivate(e){this.#p=this.car.mainCamera.getFOV(),X.set(this.#g,e.transform.worldPosition)}onDeactivate(){this.car.mainCamera.setFOV(this.#p)}update(e){let t=X.distance(this.#g,this.car.rb.position),n=100/Math.max(0,t-5)**.7;n=y(n,6,35),e.setFOV(n),e.transform.matrix=K.lookAt(this.#g,this.car.rb.position)}}function Qn(e){let t=t=>{let n=e.createOscillator();return n.type="square",n.frequency.value=t,n.connect(e.destination),n},n=null,r=null;this.start=function(){n=t(500),r=t(405),n.start(),r.start()},this.stop=function(){n?.stop(),r?.stop()}}function Zn(e,t=10,n=.001){for(var r=0;r<t;r+=n){var i=e(r);if(i>e(r-n)&&i>e(r+n))return r}throw new Error("No peak found!")}function Jn(e,t,n,r){var i=n/180*Math.PI,o=t/1e3,a=(r[1]*o+r[2])*o,s=e+r[8]*n+r[9]*o+r[10],l=r[3]*Math.sin(2*Math.atan(o/r[4]))*(1-r[5]*Math.abs(i))/(r[0]*(r[1]*o+r[2])*o),c=r[6]*o+r[7],u=((r[11]*o+r[12])*n+r[13])*o+r[14];return a*Math.sin(r[0]*Math.atan(s*l+c*(Math.atan(s*l)-s*l)))+u}function er(e,t){var n=t[0],r=t[1],i=t[2],o=t[3];return i*Math.sin(r*Math.atan(n*e-o*(n*e-Math.atan(n*e))))}function tr(e,t){if(e.length!=t.length)throw new Error("Matrices have to be the same length!");for(var n=0,r=0;r<e.length;r++)n+=e[r]*t[r];return n}const nr={name:"Lamborghini Aventador",model:"../assets/models/aventador.glb",settings:{drivetrain:"RWD",torque:700,gearChangeTime:.15,friction:1.2,forwardFriction:1,sidewaysFriction:1.05,maxSteerAngle:40,steerVelocity:100,suspensionForce:9e4,suspensionDamping:3e3,suspensionTravel:.1,rideHeightOffset:.08,ABS:!0,differential:Vn.ENUMS.DIFFERENTIAL.LSD,wings:[new Xn(new X(0,.5,-2.3),.4),new Xn(new X(0,-.4,2.2),.42)],camera:{followDistance:4,followHeight:.25,pitch:.1}}},rr={name:"Toyota ae86",model:"../assets/models/toyota_ae86.glb",settings:{mass:1e3,drivetrain:"RWD",friction:.9,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:70,torque:400,suspensionForce:9e4,suspensionDamping:3e3,suspensionTravel:.1,rideHeightOffset:.08,antiRoll:16e3,ABS:!1,TCS:!1,differential:Vn.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},ir=JSON.parse(JSON.stringify(rr));ir.settings.maxSteerAngle=85,ir.model="../assets/models/FocE.glb";const or=JSON.parse(JSON.stringify(rr));or.model="../assets/models/nissanGTR.glb";const ar={name:"Ford Ranger",model:"../assets/models/ford_ranger_police.glb",settings:{mass:1900,drivetrain:"RWD",differentialRatio:7,friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:40,torque:500,suspensionForce:45e3,suspensionDamping:4e3,suspensionTravel:.3,rideHeightOffset:.3,antiRoll:15e3,TCS:!0,ABS:!0,camera:{followDistance:4,followHeight:.25,pitch:.1}}},sr={name:"Nissan Skyline R32 GT-R",model:"../assets/models/skyline.glb",settings:{mass:1400,gearRatios:[2.66,1.78,1.3,1,.74,.6],drivetrain:"RWD",friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:45,torque:600,suspensionForce:9e4,suspensionDamping:2e3,suspensionTravel:.1,rideHeightOffset:.08,antiRoll:1e4,ABS:!1,TCS:!1,differential:Vn.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},lr={name:"BMW M3 Coupe (E30) 1986",model:"../assets/models/M3_E30.glb",settings:{mass:1e3,drivetrain:"RWD",friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:50,torque:600,suspensionForce:9e4,suspensionDamping:4e3,suspensionTravel:.1,rideHeightOffset:.08,antiRoll:1e4,ABS:!1,TCS:!1,differential:Vn.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},cr={name:"Police car",model:"../assets/models/crownvic.glb",settings:{mass:1700,drivetrain:"RWD",friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:45,torque:600,suspensionForce:6e4,suspensionDamping:4e3,suspensionTravel:.15,rideHeightOffset:.1,antiRoll:9e3,ABS:!1,TCS:!1,differential:Vn.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},ur={name:"Nagoya City Bus",model:"../assets/models/bus.glb",settings:{mass:7e3,drivetrain:"RWD",maxSteerAngle:45,torque:3500,friction:.5,forwardFriction:1,sidewaysFriction:1,suspensionForce:2e5,suspensionDamping:8e3,suspensionTravel:.2,rideHeightOffset:.08,antiRoll:5e4,ABS:!0,TCS:!1,differential:Vn.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:7,followHeight:.25,pitch:.1}}},hr={name:"Audi RS6",model:"../assets/models/audi_rs6.glb",settings:{mass:2e3,drivetrain:"AWD",friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:45,torque:550,suspensionForce:13e4,suspensionDamping:5e3,suspensionTravel:.1,rideHeightOffset:.08,antiRoll:1e4,ABS:!0,TCS:!1,differential:Vn.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},fr={name:"Lowpoly Sports Car",model:"../assets/models/cars/lowpolySportsCar.glb",settings:{mass:1400,gearRatios:[2.66,1.78,1.3,1,.74,.6],drivetrain:"RWD",friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:40,torque:350,suspensionForce:12e4,suspensionDamping:4e3,suspensionTravel:.1,rideHeightOffset:.08,antiRoll:1e4,ABS:!1,TCS:!1,differential:Vn.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},dr={name:"Lowpoly Sports Car",model:"myLowpolyCar.glb",settings:{mass:1400,gearRatios:[2.66,1.78,1.3,1,.74,.6],drivetrain:"RWD",friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:40,torque:350,suspensionForce:12e4,suspensionDamping:4e3,suspensionTravel:.1,rideHeightOffset:.08,antiRoll:1e4,ABS:!1,TCS:!1,differential:Vn.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},mr={name:"Lowpoly Jeep",model:"../assets/models/cars/lowpolyJeep.glb",settings:{mass:1700,drivetrain:"RWD",offroadFriction:1,friction:.8,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:45,torque:400,COMOffset:new X(0,-.5,0),suspensionForce:6e4,suspensionDamping:4e3,suspensionTravel:.15,rideHeightOffset:.1,antiRoll:9e3,ABS:!1,TCS:!1,differential:Vn.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},vr={name:"Porsche Carrera GT Concept 2000",model:"../assets/models/cars/PorscheCarreraGTConcept2000.glb",settings:{mass:1400,gearRatios:[2.66,1.78,1.3,1,.74,.6],drivetrain:"RWD",friction:1.3,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:40,torque:700,suspensionForce:12e4,suspensionDamping:4e3,suspensionTravel:.1,rideHeightOffset:.08,antiRoll:1e4,ABS:!1,TCS:!1,differential:Vn.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4.4,followHeight:.29,pitch:.1}}};function pr(e,t,n={}){var r=this;{let e=new X,t=new X,n=new j;var i=function(){j.eulerVector(h,n),r.camera.transform.rotation=n,K.getForward(r.camera.transform.worldMatrix,e),X.multiplyTo(e,-r.distance),X.set(t,u),X.addTo(t,e),r.camera.transform.position=t}}var o=n.rotate??!0,a=n.translate??!0,s=n.scale??!0,l=n.stylePointer??!0,c=5;Object.defineProperty(this,"distance",{get:function(){return c},set:function(e){c=e,i()}});var u=X.zero();Object.defineProperty(this,"center",{get:function(){return u},set:function(e){u=e,i()}});var h=X.zero();Object.defineProperty(this,"rotation",{get:function(){return h},set:function(e){h=e,i()}});var f=K.identity();b(),this.camera=new $e(t),this.camera.setAspect(e.aspect),i(),l&&(e.canvas.style.cursor="grab",e.canvas.addEventListener("mousedown",(function(){e.canvas.style.cursor="grabbing"})),document.addEventListener("mouseup",(function(){e.canvas.style.cursor="grab"}))),e.canvas.addEventListener("contextmenu",(function(e){e.preventDefault()})),window.addEventListener("mousemove",(function(t){e.mouse.left&&o?(h.x+=.005*-t.movementY,h.y+=.005*-t.movementX,b()):e.mouse.right&&a&&x(t.movementX,t.movementY),i()}));var d={x:0,y:0},m=!0;e.canvas.addEventListener("touchstart",(function(e){d.x=e.touches[0].clientX,d.y=e.touches[0].clientY,m=!(e.touches.length>1),2==e.touches.length&&(d.x=(e.touches[0].clientX+e.touches[1].clientX)/2,d.y=(e.touches[0].clientY+e.touches[1].clientY)/2),i(),e.preventDefault()})),e.canvas.addEventListener("touchmove",(function(e){if(m){let t=e.touches[0].clientX-d.x,n=e.touches[0].clientY-d.y,r=.005;h.x+=-n*r,h.y+=-t*r,b(),d.x=e.touches[0].clientX,d.y=e.touches[0].clientY}if(2==e.touches.length){let t=(e.touches[0].clientX+e.touches[1].clientX)/2,n=(e.touches[0].clientY+e.touches[1].clientY)/2;x(t-d.x,n-d.y),d.x=t,d.y=n}i(),e.preventDefault()})),document.addEventListener("touchmove",(function(e){1!==e.scale&&e.preventDefault()}),{passive:!1}),e.canvas.addEventListener("wheel",(function(e){s&&(r.distance+=.001*e.deltaY*r.distance,r.distance=Math.max(0,r.distance),i(),e.preventDefault())}));var v=1;e.canvas.addEventListener("gesturestart",(function(e){v=e.scale}),!1),e.canvas.addEventListener("gesturechange",(function(e){var t=v/e.scale;v=e.scale,r.distance*=t,r.distance=Math.max(0,r.distance),i(),e.preventDefault()}),!1),e.on("resize",(function(){r.camera.setAspect(e.aspect)})),this.setCenter=function(e){u=e,i()};let p=new X,g=new X;function x(e,t){var n=6e-4*r.distance;g.x=-e*n,g.y=t*n,g.z=0,K.transformVector(f,g,p),X.addTo(u,p)}function b(){K.identity(f),K.applyRotationY(h.y,f),K.applyRotationX(h.x,f)}}function gr(e){const t=function(e,t,n,r){return function(){var i=(e>>>=0)+(t>>>=0)|0;return e=t^t>>>9,t=(n>>>=0)+(n<<3)|0,n=(n=n<<21|n>>>11)+(i=i+(r=1+(r>>>=0)|0)|0)|0,(i>>>0)/4294967296}}((e=function(e){let t=1779033703,n=3144134277,r=1013904242,i=2773480762;for(let o,a=0;a<e.length;a++)o=e.charCodeAt(a),t=n^Math.imul(t^o,597399067),n=r^Math.imul(n^o,2869860233),r=i^Math.imul(r^o,951274213),i=t^Math.imul(i^o,2716044179);return t=Math.imul(r^t>>>18,597399067),n=Math.imul(i^n>>>22,2869860233),r=Math.imul(t^r>>>17,951274213),i=Math.imul(n^i>>>19,2716044179),t^=n^r^i,n^=t,r^=t,i^=t,[t>>>0,n>>>0,r>>>0,i>>>0]}(e))[0],e[1],e[2],e[3]);this.getSeed=function(){return e},this.random=function(){return t()}}__webpack_require__(388),new zn;var xr={vertex:Dt.lit.vertex,fragment:`\n${ft}\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\n// Attributes\nin vec3 vPosition;\nin vec3 vNormal;\nin vec4 vTangent; //in vec3 vTangent;\nin vec3 vColor;\nin vec2 vUV;\nin mat3 vTBN;\n\n// Motion blur\nin vec4 clipSpace;\nin vec4 prevClipSpace;\n//#in\n\n// Custom\nuniform bool twoTone;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform bool useFlakes;\nuniform sampler2D flakesNormalTexture;\nuniform float flakeScale;\nuniform float clearcoatFactor;\nuniform float clearcoatRoughness;\n//\n\nuniform sampler2D albedoTexture;\nuniform sampler2D normalTexture;\n\nuniform vec4 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform vec3 emissiveFactor;\nfloat ao = 1.;\nuniform bool opaque;\nuniform float alphaCutoff;\nuniform float normalStrength;\nuniform bool doNoTiling;\n\n// bruh make shared uniform into uniform block\n// Light info\nstruct LightInfo {\n  int type;\n  vec3 position;\n  vec3 direction;\n  float angle;\n  vec3 color;\n};\nconst int maxLights = 16;\nuniform LightInfo lights[maxLights];\nuniform int nrLights;\nuniform vec3 sunDirection;\nuniform vec3 sunIntensity;\n\n// Environment\nuniform vec3 ambientColor;\nuniform float environmentIntensity;\nuniform samplerCube u_diffuseIBL;\nuniform samplerCube u_specularIBL;\nuniform sampler2D u_splitSum;\n\n// Shadows\nconst int levels = 2;\nin vec4 projectedTexcoords[levels];\n// uniform float biases[levels];\nuniform sampler2D projectedTextures[levels];\n\n// uniform mat4 inverseViewMatrix;\nuniform mat4 modelMatrix;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n${mt}\n\nvec3 getN(vec3 tangentNormal) {\n  vec3 N;\n  if (vTangent.xyz != vec3(0)) {\n    N = normalize(vTBN * tangentNormal);\n  }\n  else {\n    N = normalize(mat3(modelMatrix) * vNormal);\n  }\n\n  if (!gl_FrontFacing) {\n    N *= -1.;\n  }\n\n  return N;\n}\n\nvoid main() {\n  ${pt}\n\n  // vec4 baseAlbedo = vec4(0, 0, 1, 1);\n  float baseAO = 1.;\n\n  vec3 baseTangentNormal = vec3(0, 0, 1);\n  if (useFlakes) {\n    baseTangentNormal = textureNoTile(flakesNormalTexture, vUV * flakeScale, 1.).rgb * 2. - 1.;\n  }\n\n  float baseScalarF0 = 0.04;\n\n  vec3 clearcoatTangentNormal = vec3(0, 0, 1);\n  float clearcoatScalarF0 = 0.04;\n  //\n\n  float ccRough = clearcoatRoughness;\n  ccRough = clamp(ccRough, 0.01, 0.99);\n  float rough = roughness;\n  rough = clamp(rough, 0.01, 0.99);\n\n  // V, N, R\n  vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n  \n  vec3 baseN = getN(baseTangentNormal);\n  vec3 clearcoatN = getN(clearcoatTangentNormal);\n\n  vec3 baseR = reflect(-V, baseN);\n  vec3 clearcoatR = reflect(-V, clearcoatN);\n  //\n\n  vec4 baseAlbedo = vec4(color1, 1);\n  if (twoTone) {\n    float fresnelTerm = dot(V, baseN);\n    fresnelTerm = clamp(1.0 - fresnelTerm, 0., 1.);\n\n    baseAlbedo = vec4(mix(color1, color2, fresnelTerm), 1);\n    // baseAlbedo = vec4(fresnelTerm * color1 + pow(fresnelTerm, 2.) * color2, 1);\n  }\n\n  // Clear coat\n  // vec3 F0 = vec3(clearcoatScalarF0);\n  // F0 = mix(F0, clearcoatAlbedo, /*clearcoatMetallic = */0.);\n  // vec3 F = fresnelSchlickRoughness(max(dot(clearcoatN, V), 0.), F0, clearcoatRoughness);\n\n  // vec3 kS = F;\n  // vec3 kD = 1.0 - kS;\n  // kD *= 1.0 - /*clearcoatMetallic = */0.;\n    \n  // vec3 irradiance = texture(u_diffuseIBL, clearcoatN).rgb;\n  // vec3 diffuse  = irradiance * clearcoatAlbedo;\n    \n  // const float MAX_REFLECTION_LOD = 4.0;\n  // vec3 prefilteredColor = textureLod(u_specularIBL, clearcoatR, clearcoatRoughness * MAX_REFLECTION_LOD).rgb;\n\n  // vec2 uv = vec2(max(dot(clearcoatN, V), 0.), clearcoatRoughness);\n  // uv.y = 1. - uv.y;\n  // vec2 envBRDF = texture(u_splitSum, uv).rg;\n\n  // vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n  // vec3 clearcoatColor = (kD * diffuse * 0. + specular) * environmentIntensity;\n\n  vec3 F0 = vec3(clearcoatScalarF0);\n  vec3 F = fresnelSchlickRoughness(max(dot(clearcoatN, V), 0.), F0, ccRough);\n    \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureLod(u_specularIBL, clearcoatR, ccRough * MAX_REFLECTION_LOD).rgb;\n\n  vec2 uv = vec2(max(dot(clearcoatN, V), 0.), ccRough);\n  uv.y = 1. - uv.y;\n  vec2 envBRDF = texture(u_splitSum, uv).rg;\n\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n  vec3 clearcoatColor = specular * environmentIntensity;\n\n  // Base\n  vec3 baseIBL = IBL(baseN, V, baseR, baseAlbedo.rgb, metallic, rough, baseScalarF0) * baseAO;\n  vec3 baseSun = DirectionalLight(vPosition, baseN, V, sunDirection.xyz, sunIntensity.xyz, baseAlbedo.rgb, metallic, rough, baseScalarF0) * baseAO * getShadowAmount(vPosition, dot(sunDirection.xyz, baseN));\n  vec3 baseColor = baseIBL + baseSun;\n\n  // Final\n  vec3 finalColor = baseColor * (1. - F * clearcoatFactor) + clearcoatColor * clearcoatFactor;\n  fragColor = vec4(finalColor, 1);\n}\n`};ht(xr);var br={vertex:Dt.lit.vertex,fragment:`\n${ft}\n\n${dt}\n\nconst int nrTextures = 2;\nuniform sampler2D albedoTextures[nrTextures];\nuniform sampler2D normalTextures[nrTextures];\nuniform sampler2D metallicRoughnessTextures[nrTextures];\n\n${mt}\n\n${vt}\n\nvoid main() {\n  ${pt}\n\n  vec4 grassAlbedo = vec4(textureNoTile(albedoTextures[0], vUV, 1.), 1);\n  vec4 stoneAlbedo = vec4(textureNoTile(albedoTextures[1], vUV, 1.), 1);\n\n  vec3 grassNormal = textureNoTile(normalTextures[0], vUV, 1.) * 2. - 1.;\n  vec3 stoneNormal = textureNoTile(normalTextures[1], vUV, 1.) * 2. - 1.;\n\n  float mixFactor = clamp(noise(vUV / 40.), 0., 1.);\n\n  vec4 currentAlbedo = mix(grassAlbedo, stoneAlbedo, mixFactor);\n  currentAlbedo *= albedo;\n  currentAlbedo.rgb *= mix(vec3(0.3, 0.5, 0.1), vec3(0.5, 0.5, 0.3), mixFactor);\n  // currentAlbedo.rgb *= 0.7;\n\n  // vec4 currentAlbedo = vec4(textureNoTile(albedoTextures[0], vUV, 1.), 1);\n  // currentAlbedo *= albedo;\n  // currentAlbedo.rgb *= mix(vec3(1.0), vec3(0.5, 0.5, 0.6), clamp(LayeredNoise(vUV / 40.), 0., 1.));\n\n  vec3 _emission = vec3(0);\n  float _metallic = 0.;\n  float _roughness = 1.;\n  float _ao = 1.;\n\n  vec3 _tangentNormal = mix(grassNormal, stoneNormal, mixFactor);\n  _tangentNormal = setNormalStrength(_tangentNormal, 3.);\n\n  // vec3 _tangentNormal = textureNoTile(normalTextures[0], vUV, 1.) * 2. - 1.;\n  // _tangentNormal = setNormalStrength(_tangentNormal, 2.);\n\n  vec4 litColor = lit(currentAlbedo, 0.5, _emission, _tangentNormal, _metallic, _roughness, _ao);\n\n  #ifdef USEFOG\n    litColor = applyFog(litColor);\n  #endif\n\n  fragColor = litColor;\n}\n`};ht(br);class yr{#x="../assets/sound/menu tick.wav";#b=new Audio(this.#x);constructor(e){this.keybindings=e,this.selectedElement=null}update(){this.keybindings.getInputDown("UIup")?this.#y(0):this.keybindings.getInputDown("UIright")?this.#y(1):this.keybindings.getInputDown("UIdown")?this.#y(2):this.keybindings.getInputDown("UIleft")?this.#y(3):this.keybindings.getInputDown("UIselect")&&this.#T()}#T(){this.selectedElement&&null!==this.selectedElement.offsetParent&&(this.selectedElement.click(),this.#w())}#y(e){var t=document.querySelectorAll(".isSelectable:not([disabled]):not(.hidden):not(.selected)");if(0!=(t=[...t].filter((e=>null!==e.offsetParent))).length)if(this.selectedElement&&null==this.selectedElement.offsetParent&&this.deselectElement(),this.selectedElement){var n=this.selectedElement.getBoundingClientRect(),r=e*Math.PI/2-Math.PI/2,i=function(e){var t,r,i,o,a=e.getBoundingClientRect();return t=n.x,r=n.y,i=t-a.x,o=r-a.y,Math.sqrt(i*i+o*o)},o=t.reduce(((e,t)=>{return c=t.getBoundingClientRect(),o=n.x,a=n.y,s=c.x,l=c.y,u=Math.atan2(l-a,s-o)-r,Math.abs(Math.atan2(Math.sin(u),Math.cos(u)))<.4*Math.PI&&(!e||i(t)<i(e))?t:e;var o,a,s,l,c,u}),null);o&&this.selectElement(o)}else this.selectFirstElement(t);else this.deselectElement()}deselectElement(){this.selectedElement&&(this.selectedElement.classList.remove("selected"),this.selectedElement=null)}selectFirstElement(e){var t=e;e||(t=document.querySelectorAll(".isSelectable:not([disabled]):not(.hidden):not(.selected)"),t=[...t].filter((e=>null!==e.offsetParent)));var n=t.reduce(((e,t)=>e.getBoundingClientRect().y-t.getBoundingClientRect().y+.1*(e.getBoundingClientRect().x-t.getBoundingClientRect().x)>0?t:e));this.selectElement(n)}selectElement(e){this.selectedElement&&this.selectedElement.classList.remove("selected"),e.classList.contains("isSelectable")?(this.selectedElement=e,this.selectedElement.classList.add("selected"),this.selectedElement.scrollIntoView({behavior:"smooth"}),this.#w()):(console.warn("Element is not selectable"),console.log(e))}#w(){this.#b.currentTime=0,this.#b.play()}}class Tr{constructor(e,t,n={}){var r=new e.LitMaterial;return r.programContainer=t,n.flakesNormalTexture&&(r.setUniform("flakesNormalTexture",n.flakesNormalTexture),r.setUniform("useFlakes",1)),r.setUniform("metallic",n.metallic??1),r.setUniform("roughness",n.roughness??.4),r.setUniform("twoTone",n.twoTone??0),r.setUniform("color1",n.color1??[0,.3,1]),r.setUniform("color2",n.color2??[.4,.3,1]),r.setUniform("flakeScale",n.flakeScale??500),r.setUniform("clearcoatRoughness",n.clearcoatRoughness??.1),r.setUniform("clearcoatFactor",n.clearcoatFactor??1),r}}class wr{constructor(e=512,t=512){const n=document.createElement("canvas");n.width=e,n.height=t;const r=n.getContext("2d");r.fillStyle="rgb(127,127,255)",r.fillRect(0,0,e,t);for(let n=0;n<4e3;n++){const n=Math.random()*e,i=Math.random()*t,o=3*Math.random()+3;let a=2*Math.random()-1,s=2*Math.random()-1,l=7.5;const c=Math.sqrt(a*a+s*s+l*l);a/=c,s/=c,l/=c,r.fillStyle="rgb("+(127*a+127)+","+(127*s+127)+","+255*l+")",r.beginPath(),r.arc(n,i,o,0,2*Math.PI),r.fill()}return n}}document.addEventListener("DOMContentLoaded",(async function(){const e=document.querySelector(".pauseOverlay"),t=document.querySelector(".garage"),n=document.querySelector(".loading"),r=document.querySelector(".settings"),i=t.querySelector(".selectCar"),o=n.querySelector(".progressBar"),a=n.querySelector(".progressStatus");let s;const l=document.querySelector(".messages"),c=new gr("apples");let u;new zn;const d=new v({publicMethods:!1});d.canvas.classList.add("ingameUICanvas"),d.canvas.style.zIndex=2;var p=!1,g=!1;const x=new X(0,2,0),b=j.identity(),T=["myLowpolySportsCar","lowpolyJeep"];let w=0,E=0,M=0;const _=new In;var R,C,F;let A=0,D=10+T.length;se(A++,D,"Initializing renderer");const P=new Un({path:"../",renderScale:1,debug:!0,renderpipeline:0,shadowResolution:1024,shadowSizes:[6,64],shadowBiases:[-3e-4,-.001]});P.disableContextMenu(),P.canvas.style.position="fixed",window.isDay=ae;const S=new function(){const e="com.tc5550.cardemo.settings";class t{constructor(e){this.name=e}}class n{constructor(e="Setting",t=0,n=(()=>{}),r=0,i=1,o=.1,a=!1){this.name=e,this.value=t,this.defaultValue=t,this.onValueChange=n,this.min=r,this.max=i,this.step=o,this.displayAsPercent=a}formatValue(e){return this.displayAsPercent?`${Math.round(100*e)}%`:e.toString()}createDOM(){var e=document.createElement("div");return this.valueSpan=e.appendChild(document.createElement("span")),this.valueSpan.style.marginRight="2em",this.valueSpan.textContent=this.formatValue(this.value),e.appendChild(document.createElement("span")).textContent=this.min,this.slider=e.appendChild(document.createElement("input")),this.slider.type="range",this.slider.min=this.min,this.slider.max=this.max,this.slider.step=this.step,this.slider.value=this.value,e.appendChild(document.createElement("span")).textContent=this.max,this.slider.addEventListener("input",(()=>{this.value=this.slider.value,this.valueSpan.textContent=this.formatValue(this.value),this.onValueChange(this.value)})),e}setValue(e){this.value=e,this.onValueChange(this.value),this.slider.value=this.value,this.valueSpan.textContent=this.formatValue(this.value)}}class r{constructor(e="Setting",t=!1,n=(()=>{})){this.name=e,this.value=t,this.defaultValue=t,this.onValueChange=n}createDOM(){var e=document.createElement("div");return this.checkbox=e.appendChild(document.createElement("input")),this.checkbox.type="checkbox",this.checkbox.checked=this.value,this.checkbox.addEventListener("click",(()=>{this.value=this.checkbox.checked,this.onValueChange(this.value)})),e}setValue(e){this.value=e,this.onValueChange(this.value),this.checkbox.checked=e}onClick(){this.setValue(!this.value)}}var i={_soundGroup:new t("Sound"),masterVolume:new n("Master volume",1,(e=>{re&&re.mainGainNode&&(re.mainGainNode.gain.value=e),h()}),0,2,.01,!0),haptics:new r("Haptics",!0,(e=>{re.haptics=e,h()})),_displayGroup:new t("Graphics"),fps:new r("Show FPS",!1,(e=>{!u&&e&&(u=new m),e?document.body.appendChild(u.dom):u?.dom.remove(),h()})),renderScale:new n("Render scale",1,(e=>{P.setRenderScale(e),h()}),.2,2,.05),motionBlur:new n("Motion blur",.15,(e=>{z.postprocessing.motionBlurStrength=e,h()}),0,.5,.01),bloom:new r("Bloom",!0,(e=>{z.bloom.enabled=e,h()})),_gameplayGroup:new t("Gameplay"),day:new r("Daytime",!0,(e=>{h()})),cameraFollowMode:new class{constructor(e="Setting",t=0,n=(()=>{}),r,i){if(this.name=e,this.value=t,this.defaultValue=t,this.onValueChange=n,this.labels=r,this.values=i,this.labels.length!=this.values.length)throw console.error(this.labels,this.values),new Error("Labels and values must have same length!")}createDOM(){var e=document.createElement("div");this.select=e.appendChild(document.createElement("select"));for(var t=0;t<this.labels.length;t++){var n=this.labels[t],r=this.values[t],i=this.select.appendChild(document.createElement("option"));i.value=r,i.textContent=n}return this.select.addEventListener("input",(()=>{this.value=this.select.value,this.onValueChange(this.value)})),e}setValue(e){this.value=e,this.onValueChange(this.value),this.select.selectedIndex=[...this.select.options].findIndex((t=>t.value==e))}onClick(){let e=this.select.options.length;this.select.setAttribute("size",e);let t=this.select.selectedIndex;t++,t%=this.select.options.length,this.setValue(this.select.options[t].value)}}("Camera follow mode",1,(e=>{re&&(re.followCamera.followMode=e),h()}),["Follow velocity","Follow direction","Follow inverse direction"],[1,2,3]),_assistGroup:new t("Assists"),abs:new r("ABS",!0,(e=>{re&&(re.ABS=e),h()})),tcs:new r("TCS",!0,(e=>{re&&(re.TCS=e),h()})),steeringAssist:new r("Steering assist",!0,(e=>{re&&(re.activateAutoCountersteer=e),h()})),autoCountersteer:new n("Auto countersteer",.4,(e=>{re&&(re.autoCountersteer=e),h()}),0,1,.05),autoCountersteerVelocityMultiplier:new n("Auto countersteer velocity",.25,(e=>{re&&(re.autoCountersteerVelocityMultiplier=e),h()}),0,1,.05)},o=document.querySelector(".settings > .settingsContainer > .items"),a=document.createElement("div");a.classList.add("group");var s=a;for(let e in i){let n=i[e];if(n instanceof t){var l=o.appendChild(document.createElement("div"));l.classList.add("group");var c=l.appendChild(document.createElement("span"));c.classList.add("title"),c.textContent=n.name,s=l}else{let e=s.appendChild(document.createElement("div"));e.classList.add("item"),e.classList.add("isSelectable"),e.addEventListener("click",(function(){n.onClick?.()})),e.appendChild(document.createElement("span")).textContent=n.name,e.appendChild(n.createDOM()),s!=a||o.contains(a)||o.appendChild(a)}}function h(){var t={};for(let e in i)t[e]=i[e].value;localStorage.setItem(e,JSON.stringify(t))}this.getSettingValue=function(e){if(e in i)return i[e].value;console.warn("Setting not defined: "+e)},this.setSettingValue=function(e,t){e in i?i[e].setValue(t):console.warn("Setting not defined: "+e)},this.loadSaveData=function(){var t=function(){var t=localStorage.getItem(e);if(null==t)return{};try{var n=JSON.parse(t);for(let e in n)Object.prototype.hasOwnProperty.call(i,e)||delete n[e];return n}catch(e){console.warn("Could not load settings"),console.error(e)}return{}}();for(let e in t)i[e].setValue(t[e])}};R=new Ln(P,_,{brights:{keyboard:"KeyX",controller:"LB"},drive:{keyboard:"KeyW",controller:"RT"},brake:{keyboard:"KeyS",controller:"LT"},ebrake:{keyboard:"Space",controller:"A"},clutch:{keyboard:"KeyC",controller:"Y"},steer:{keyboard:["KeyA","KeyD"],controller:"LSHorizontal"},gearDown:{keyboard:"KeyQ",controller:"X"},gearUp:{keyboard:"KeyE",controller:"B"},cameraMode:{keyboard:"KeyC",controller:"RB"},turnCamera:{keyboard:["ArrowLeft","ArrowRight"],controller:"RSHorizontal"},horn:{keyboard:"KeyT",controller:"RS"},pause:{keyboard:"Escape",controller:"Menu"},back:{keyboard:"Escape",controller:"B"},menuDown:{keyboard:"ArrowDown",controller:"DPDown"},menuUp:{keyboard:"ArrowUp",controller:"DPUp"},menuSelect:{keyboard:"Enter",controller:"A"},garagePrev:{keyboard:"ArrowLeft",controller:"DPLeft"},garageNext:{keyboard:"ArrowRight",controller:"DPRight"},UIup:{keyboard:"ArrowUp",controller:"DPUp"},UIright:{keyboard:"ArrowRight",controller:"DPRight"},UIdown:{keyboard:"ArrowDown",controller:"DPDown"},UIleft:{keyboard:"ArrowLeft",controller:"DPLeft"},UIselect:{keyboard:"Enter",controller:"A"}}),C=new yr(R),se(A++,D,"Loading scene");const z=new Ye("Playground");P.add(z),z.fogColor=[.4,.4,.5,1],z.fogDensity=.001,z.skyboxFogIntensity=1,z.environmentMinLight=.5,z.postprocessing.exposure=-5,z.postprocessing.vignette.amount=.3,z.postprocessing.vignette.falloff=.3,P.shadowCascades.refreshRate=0,ae(!0),await z.loadEnvironment({hdrFolder:"cubemaps/lowpolyDesert"}),se(A++,D,"Generating garage"),console.time("Garage");const L=new Ye("Garage");P.add(L),L.sunIntensity=X.zero(),L.environmentIntensity=.2,await L.loadEnvironment({hdrFolder:"../assets/hdri/studio_small_09_1k_precomputed"}),console.timeEnd("Garage"),L.add(await P.loadGLTF("./garage.glb"));const B=new $e({fov:30});B.transform.matrix=K.lookAt(new X(0,1.5,6),new X(0,.5,0),X.up());var I=()=>{B.setAspect(P.aspect)};P.on("resize",I),I(),se(A++,D,"Initializing physics engine");const O=new Ee(z,{octreeLevels:7,multipleTimestepsPerFrame:!1});se(A++,D,"Initializing car paint material");const k=await P.loadTextureAsync(new wr),V=new P.CustomProgram(f),G={purple:new Tr(P,V,{flakesNormalTexture:k}),simplyRed:new Tr(P,V,{metallic:0,clearcoatRoughness:0,twoTone:0,color1:[1,0,0]}),darkgray:new Tr(P,V,{flakesNormalTexture:k,flakeScale:1e3,metallic:1,roughness:.5,clearcoatRoughness:0,clearcoatFactor:.5,twoTone:0,color1:[.05,.05,.05]})};se(A++,D,"Loading map");const{terrain:H,checkChunks:W}=await async function(){new X(0,0,0,x),z.postprocessing.exposure=-.5,z.environmentIntensity=1,z.environmentMinLight=.2,z.sunIntensity=X.fill(20);const e=new P.ProgramContainer(await P.createProgramFromFile("../assets/shaders/custom/webgl2/solidColor"));z.add(new Oe("AABB",{meshRenderer:new P.MeshInstanceRenderer([new He(e)],[new P.MeshData(P.getLineCubeData())],{drawMode:P.gl.LINES}),castShadows:!1})).disableFrustumCulling=!0;const t=await P.loadGLTF("lowpolyRock.glb"),n=await P.loadGLTF("lowpolyCactus.glb"),r=await P.loadGLTF("70sign.glb"),i=P.CreateLitMaterial({albedo:[.1225,.0692,.035,1],roughness:.5}),o=P.CreateLitMaterial({albedoTexture:await P.loadTextureAsync("lowpolyRoad.png",{...P.getSRGBFormats(),generateMipmap:!1}),albedo:[.3,.2,.2,1]}),a=300,s=[];let l=0,u=0;s.push(new X(0,l,-150)),s.push(new X(0,l,-60));for(var h=1;h<9;h++)s.push(new X(0,l,h*a/3-150));const f=new Worker("./generateLowpolyTerrainWorker.js",{type:"module"});f.onmessage=e=>{const r=e.data.id,o=e.data.meshData;o.indices.target=P.gl.ELEMENT_ARRAY_BUFFER;const s=new Oe("Lowpoly Terrain"),l=new P.MeshData(o);l.recalculateTangents(),s.meshRenderer=new P.MeshRenderer(i,l),s.addComponent(new _e);const c=d[r].container;c.add(s),s.transform.worldPosition=X.zero();{const e=c.add(t.copy()),n=e.children[0].meshRenderer=e.children[0].meshRenderer.getInstanceMeshRenderer();for(let e=0;e<100;e++){const e=new X((Math.random()-.5)*a,100,(Math.random()-.5)*a);X.addTo(e,c.transform.position);const t=O.Raycast(e,X.down());if(!t||t.gameObject==c.getChild("Road"))continue;const r=K.identity();K.applyTranslation(t.point,r),K.applyRotationY(2*Math.random()*Math.PI,r),K.applyScale(X.fill(.5*Math.random()+1),r),n.addInstance(r)}}{const e=c.add(n.copy()),t=e.children[0].meshRenderer=e.children[0].meshRenderer.getInstanceMeshRenderer();for(let e=0;e<100;e++){const e=new X((Math.random()-.5)*a,100,(Math.random()-.5)*a);X.addTo(e,c.transform.position);const n=O.Raycast(e,X.down());if(!n||n.gameObject==c.getChild("Road"))continue;const r=K.identity();K.applyTranslation(n.point,r),K.applyRotationY(2*Math.random()*Math.PI,r),K.applyScale(X.fill(.5*Math.random()+.5),r),t.addInstance(r)}}};const d=[];window.chunks=d,d.push(await v(s.slice(0,7))),d.push(await v(s.slice(3,10),new X(0,0,a)));const m=async function(){if(void 0!==re&&re&&re.rb){for(let e=0;e<d.length;e++)d[e].container.active=Math.abs(e*a-re.rb.position.z)<900;if(re.rb.position.z>(d.length-3)*a){for(let e=0;e<3;e++)u+=10.5*(c.random()-(.5+.02*u+.1*l)),l+=u,s.push(new X((c.random()-.5)*a*.3,l,(s.length-1)*a/3-150));d.push(await v(s.slice(3*d.length,3*d.length+7),new X(0,0,d.length*a),s.slice(3*d.length-3,3*d.length+7)))}}};return setInterval(m,400),{checkChunks:m,terrain:null};async function v(e,t=X.zero(),n){const i=new ge((n=n||e).map((e=>X.subtract(e,t)))),a=new ge(e.map((e=>X.subtract(e,t)))),s=await async function(e,t,n,i=12,a=100){var s=new Oe("Chunk");s.transform.position=X.copy(e);const l=s.add(r.copy()),c=l.children[0].meshRenderer=l.children[0].meshRenderer.getInstanceMeshRenderer();var u=new Oe("Road"),h=0,m=[],v=[],p=[],g=1/a;for(let n=0;n<a;n++){let r=n/(a-1)*.75,o=t.getPoint(r),s=X.subtract(t.getPoint(r+g),o),l=X.normalize(s),u=j.QxV(j.angleAxis(Math.PI/2,l),X.up());var x=X.multiply(u,i/2),b=X.multiply(u,i/2*1.4),y=X.add(o,x),T=X.add(o,b);T.y-=.06*i;var w=X.subtract(o,x),E=X.subtract(o,b);E.y-=.06*i,v.push(T.x,T.y,T.z),v.push(y.x,y.y,y.z),v.push(y.x,y.y,y.z),v.push(w.x,w.y,w.z),v.push(w.x,w.y,w.z),v.push(E.x,E.y,E.z);var M=h/i;if(p.push(-.4,1*M),p.push(0,1*M),p.push(0,1*M),p.push(1,1*M),p.push(1,1*M),p.push(1.4,1*M),h+=X.length(s),Math.random()<.02){{const t=K.identity();K.applyTranslation(T,t),K.applyTranslation(e,t),c.addInstance(t)}{const t=K.identity();K.applyTranslation(E,t),K.applyTranslation(e,t),c.addInstance(t)}}}for(var _=0;_<6*(v.length/3/6-1);_+=6){var R=1e10;m.push((_+0)%R,(_+6)%R,(_+1)%R,(_+1)%R,(_+6)%R,(_+7)%R,(_+2)%R,(_+8)%R,(_+3)%R,(_+3)%R,(_+8)%R,(_+9)%R,(_+4)%R,(_+10)%R,(_+5)%R,(_+5)%R,(_+10)%R,(_+11)%R)}var C=new P.MeshData({indices:{bufferData:new Uint32Array(m),target:P.gl.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(v),size:3},uv:{bufferData:new Float32Array(p),size:2}});return C.recalculateNormals(),C.recalculateTangents(),u.meshRenderer=new P.MeshRenderer(o,C),u.addComponent(new _e),u.transform.position.y=.04,s.addChild(u),z.add(s),f.postMessage({id:d.length,offset:e,curvePoints:n.points}),s}(t,a,i,10,100);return{container:s,roadCurve:a}}}();se(A++,D,"Loading car models");var q={},Y={},$=0;for(var Q of T){se(A++,D,`Loading car number ${$+1}: ${Q}`);var Z=h[Q],J=await P.loadGLTF(Z.model);q[Q]=J;var ee=we(J);Y[Q]=X.add(X.negate(ee.getCenter()),new X(0,ee.getSize().y/2,0)),J.transform.position=X.add(new X(5*$,.1,0),Y[Q]),L.add(J),$++}se(A++,D,"Setting up car");var te=T[0],ne=z.add(q[te].copy());let re;if(re=await fe(h[te].settings,ne),se(A++,D,"Finalizing physics colliders"),O.setupMeshCollider(),!re)var ie=new pr(P,{far:1e4});var oe={};function ae(e){e?(z.fogDensity=.001,z.environmentIntensity=1.25,z.sunIntensity={x:30,y:24,z:18}):(z.fogDensity=.005,z.environmentIntensity=.01,z.sunIntensity=X.fill(.25))}function se(e,t,n){s&&console.timeEnd(s),e<t&&console.time(n),s=n,o&&(o.querySelector(".progress").style.width=e/t*100+"%"),a.textContent=`${n} (${Math.floor(e/t*100)}%)`}function le(e=1){w+=e,w=y(w,0,Object.keys(q).length-1),i.disabled=E==w,he()}function ce(){g?(re.freeze(),U(e),C.deselectElement(),C.selectFirstElement()):(re.unfreeze(),N(e),re.mainGainNode&&(P.getActiveScene()!=z?re.mainGainNode.gain.value=0:re.mainGainNode.gain.value=S.getSettingValue("masterVolume")))}function ue(e){P.setActiveScene(e),document.querySelectorAll(".menu > div").forEach((e=>N(e))),U(document.querySelector(".menu > ."+e.name)),e==L?(U(t),he()):N(t)}function he(){let e=h[Object.keys(q)[w]],n=e.settings;t.querySelector(".carName").textContent=e.name,t.querySelectorAll(".stats .value")[0].textContent=`${n.torque} Nm`??0,t.querySelectorAll(".stats .value")[1].textContent=`${n.mass} kg`??0,t.querySelectorAll(".stats .value")[2].textContent=n.drivetrain??"UNKNOWN",t.querySelectorAll(".stats .value")[3].textContent=Object.keys(Vn.ENUMS.DIFFERENTIAL).find((e=>Vn.ENUMS.DIFFERENTIAL[e]===n.differential))??"UNKNOWN",t.querySelectorAll(".stats .value")[4].textContent=n.friction??"UNKNOWN"}async function fe(e,t){var n=new Vn(z,O,{path:P.path,keybindings:R,controlScheme:Vn.ControlScheme.Controller,...e});t.transform.matrix=K.identity(),await n.setup(t),n.gameObject.traverse((e=>{if(e.meshRenderer){var t=e.meshRenderer.materials;for(var n of t){if("carpaint"==n.name.toLowerCase()){var r=t.indexOf(n);t[r]=G.darkgray,t[r].setUniform("flakeScale",50)}n.uniforms.enableMotionBlur=0,n.doubleSided=!1,n.doubleSidedShadows=!1}}})),n.wheels.map((e=>{e.model.setLayer(2,!0)})),X.set(n.resetPosition,x),n.resetPosition.y-=n.bottomOffset.y;const r=Math.max(...n.wheels.map((e=>e.suspensionTravel)));return n.resetPosition.y+=.5*r,X.set(n.rb.position,n.resetPosition),n.gameObject.transform.position=X.copy(n.rb.position),j.set(n.resetRotation,b),j.set(n.rb.rotation,n.resetRotation),n.gameObject.transform.rotation=j.copy(n.rb.rotation),n.resetGame(),n.mainCamera=new $e({near:.1,far:15e3,fov:35}),n.mainCamera.setAspect(P.aspect),n.ABS=S.getSettingValue("abs"),n.TCS=S.getSettingValue("tcs"),n.activateAutoCountersteer=S.getSettingValue("steeringAssist"),n.autoCountersteer=S.getSettingValue("autoCountersteer"),n.autoCountersteerVelocityMultiplier=S.getSettingValue("autoCountersteerVelocityMultiplier"),n.followCamera.followMode=S.getSettingValue("cameraFollowMode"),n.mainGainNode.gain.value=S.getSettingValue("masterVolume"),n.haptics=S.getSettingValue("haptics"),n}function de(e,t=null){(function(e){return e&&e.readyState==e.OPEN})(F)&&F.send(JSON.stringify({type:e,data:t,clientSendTime:new Date}))}function me(e){var t=document.createElement("div");t.classList.add("message"),t.textContent=e,l.prepend(t)}(F=new WebSocket(`wss://${location.hostname}:8080`)).onerror=function(){me("Disconnected")},F.onopen=function(){console.log("Connected to server!"),me("Connected"),setInterval((function(){re&&re.rb&&(de("updatePlayer",{position:re.rb.position,rotation:re.rb.rotation,velocity:re.rb.velocity,angularVelocity:re.rb.angularVelocity,steerInput:re.getRawSteerInput(),driveInput:re.getDriveInput(),ebrakeInput:re.getEbrakeInput(),brakeInput:re.getBrakeInput(),clutchInput:re.getClutchInput()}),de("getAllPlayers"))}),100)},F.onmessage=async function(e){var t;try{t=JSON.parse(e.data)}catch(e){return void console.warn(e)}if(Object.prototype.hasOwnProperty.call(t,"type")&&Object.prototype.hasOwnProperty.call(t,"data"))if("ping"==t.type)console.log(t.data);else if("playerAction"==t.type)switch(t.data.action){case"join":console.log("Player has joined!",t.data.clientID),me(`${t.data.clientID} has joined`);break;case"leave":var n=oe[t.data.clientID];n&&n.model.remove(),delete oe[t.data.clientID],console.log("Player has left!",t.data.clientID),me(`${t.data.clientID} has left`)}else if("getAllPlayers"==t.type)for(let e of t.data){let t=oe[e.clientID];if(!t){let n=z.add(q[T[0]].copy()),r=await fe(h[T[0]].settings,n);r.update=()=>{},oe[e.clientID]=t={model:n,car:r}}const n=t.car,r=n.rb,i=e.data;r.position=i.position,r.rotation=i.rotation,r.velocity=i.velocity,r.angularVelocity=i.angularVelocity,n.setRawSteerInput(i.steerInput),n.setDriveInput(i.driveInput),n.setEbrakeInput(i.ebrakeInput),n.setBrakeInput(i.brakeInput),n.setClutchInput(i.clutchInput)}},document.addEventListener("visibilitychange",(function(){document.hidden&&(g=!0),ce()}),!1),S.loadSaveData(),S.getSettingValue("Show FPS")&&(u=new m,document.body.appendChild(u.dom)),se(A++,D,"Done!"),N(n),P.on("renderloop",(function(t){d.clearScreen(),function(t){return p&&R.getInputDown("back")?(N(r),U(e),C.selectFirstElement(),void(p=!1)):g&&R.getInputDown("back")?(g=!1,void ce()):R.getInputDown("pause")&&!p?(g=!g,void ce()):(g||P.getActiveScene()!=L||(R.getInputDown("back")&&window.gotoPlayground(),R.getInputDown("garagePrev")&&le(-1),R.getInputDown("garageNext")&&le(1),R.getInputDown("menuSelect")&&window.selectCar(),M+=5*(n=Bn(_.getAxis("RSHorizontal"),.08),-Math.abs(n)*n*t)),void C.update(t));var n}(t);const n=P.getActiveScene();n==z?function(e){if(!g){let t=re?re.mainCamera:ie.camera;H?.update(t.transform),O.update(),re&&(re.rb.position.y<-300&&re.resetGame(),re.update(e),re.renderUI(d)),P.update(e),P.render(t)}}(t):n==L&&function(e){const t=j.euler(0,M,0);L.root.getChild("spin",!0).transform.rotation=t;let n=0;for(const e in q){const r=q[e],i=X.add(new X(20*(n-w),.1,0),Y[e]);X.addTo(r.transform.position,X.multiply(X.subtract(i,r.transform.position),.3)),r.transform.rotation=t,r.visible=w==n,n++}M+=.1*e,P.update(e),g||P.render(B)}(t),u?.update()})),window.renderer=P,window.scene=z,window.physicsEngine=O,window.car=re,window.selectCar=async function(){if(E!==w){X.copy(re.rb.position).y=0,re.destroy();var e=Object.keys(q)[w],t=h[e],n=z.add(q[e].copy());re=await fe(t.settings,n),E=w}i.disabled=E==w},window.gotoPlayground=function(){ue(z),window.resume()},window.gotoGarage=function(){ue(L),window.resume()},window.resetCar=function(){re.resetGame(),W?.(),window.resume()},window.resume=function(){g=!1,ce()},window.openSettings=function(){p=!0,N(e),U(r),C.selectFirstElement()},window.goBack=function(){return p?(N(r),U(e),C.selectFirstElement(),void(p=!1)):g?(g=!1,void ce()):void 0}}))})()})();