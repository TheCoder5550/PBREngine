/*! For license information please see bundle.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={388:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z:()=>__WEBPACK_DEFAULT_EXPORT__});const JSONfn={};(function(exports){exports.stringify=function(e){return JSON.stringify(e,(function(e,t){var n;return t instanceof Function||"function"==typeof t?(n=t.toString()).length<8||"function"!==n.substring(0,8)?"_NuFrRa_"+n:n:t instanceof RegExp?"_PxEgEr_"+t:t}))},exports.parse=function(str,date2obj){var iso8061=!!date2obj&&/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;return JSON.parse(str,(function(key,value){var prefix;return"string"!=typeof value||value.length<8?value:(prefix=value.substring(0,8),iso8061&&value.match(iso8061)?new Date(value):"function"===prefix?eval("("+value+")"):"_PxEgEr_"===prefix||"_NuFrRa_"===prefix?eval(value.slice(8)):value)}))},exports.clone=function(e,t){return exports.parse(exports.stringify(e),t)}})(JSONfn);const __WEBPACK_DEFAULT_EXPORT__=JSONfn}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](n,n.exports,__webpack_require__),n.exports}__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__={};(()=>{var e={};__webpack_require__.r(e),__webpack_require__.d(e,{fogBase:()=>lt,litAttributesAndUniforms:()=>ot,litBase:()=>st,motionBlurMain:()=>ct,shaderBase:()=>at,trimStrings:()=>it,webgl1:()=>wt,webgl2:()=>Et});var t={};__webpack_require__.r(t),__webpack_require__.d(t,{webgl1:()=>Dt,webgl2:()=>Pt});var n={};__webpack_require__.r(n),__webpack_require__.d(n,{webgl2:()=>Ut});var r={};__webpack_require__.r(r),__webpack_require__.d(r,{webgl1:()=>Lt,webgl2:()=>Bt});var i={};__webpack_require__.r(i),__webpack_require__.d(i,{webgl1:()=>Ot,webgl2:()=>kt});var a={};__webpack_require__.r(a),__webpack_require__.d(a,{webgl1:()=>Gt,webgl2:()=>Xt});var o={};__webpack_require__.r(o),__webpack_require__.d(o,{webgl1:()=>Ht,webgl2:()=>Wt});var s={};__webpack_require__.r(s),__webpack_require__.d(s,{webgl1:()=>Yt,webgl2:()=>Kt});var l={};__webpack_require__.r(l),__webpack_require__.d(l,{webgl1:()=>Qt,webgl2:()=>Jt});var c={};__webpack_require__.r(c),__webpack_require__.d(c,{webgl1:()=>en,webgl2:()=>tn});var u={};__webpack_require__.r(u),__webpack_require__.d(u,{webgl1:()=>rn,webgl2:()=>an});var h={};__webpack_require__.r(h),__webpack_require__.d(h,{M3_E30:()=>nr,audiRS6:()=>ar,aventador:()=>$n,bus:()=>ir,crownVic:()=>rr,drift:()=>Qn,drift2:()=>Jn,gtr:()=>Zn,lowpolyJeep:()=>sr,lowpolySportsCar:()=>or,ranger:()=>er,skyline:()=>tr});var f={};__webpack_require__.r(f),__webpack_require__.d(f,{webgl2:()=>cr});var d={};__webpack_require__.r(d),__webpack_require__.d(d,{webgl2:()=>ur});var m=function(){var e=0,t=document.createElement("div");function n(e){return t.appendChild(e.dom),e}function r(n){for(var r=0;r<t.children.length;r++)t.children[r].style.display=r===n?"block":"none";e=n}t.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",t.addEventListener("click",(function(n){n.preventDefault(),r(++e%t.children.length)}),!1);var i=(performance||Date).now(),a=i,o=0,s=n(new m.Panel("FPS","#0ff","#002")),l=n(new m.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var c=n(new m.Panel("MB","#f08","#201"));return r(0),{REVISION:16,dom:t,addPanel:n,showPanel:r,begin:function(){i=(performance||Date).now()},end:function(){o++;var e=(performance||Date).now();if(l.update(e-i,200),e>=a+1e3&&(s.update(1e3*o/(e-a),100),a=e,o=0,c)){var t=performance.memory;c.update(t.usedJSHeapSize/1048576,t.jsHeapSizeLimit/1048576)}return e},update:function(){i=this.end()},domElement:t,setMode:r}};m.Panel=function(e,t,n){var r=1/0,i=0,a=Math.round,o=a(window.devicePixelRatio||1),s=80*o,l=48*o,c=3*o,u=2*o,h=3*o,f=15*o,d=74*o,m=30*o,v=document.createElement("canvas");v.width=s,v.height=l,v.style.cssText="width:80px;height:48px";var g=v.getContext("2d");return g.font="bold "+9*o+"px Helvetica,Arial,sans-serif",g.textBaseline="top",g.fillStyle=n,g.fillRect(0,0,s,l),g.fillStyle=t,g.fillText(e,c,u),g.fillRect(h,f,d,m),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h,f,d,m),{dom:v,update:function(l,p){r=Math.min(r,l),i=Math.max(i,l),g.fillStyle=n,g.globalAlpha=1,g.fillRect(0,0,s,f),g.fillStyle=t,g.fillText(a(l)+" "+e+" ("+a(r)+"-"+a(i)+")",c,u),g.drawImage(v,h+o,f,d-o,m,h,f,d-o,m),g.fillRect(h+d-o,f,o,m),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h+d-o,f,o,a((1-l/p)*m))}}};class v{constructor(e={}){if(e.hasOwnProperty("elementID")){if(null==(t=document.getElementById(e.elementID)))throw Error("No element with the id '"+e.elementID+"' was found!");if(!(t instanceof HTMLCanvasElement))throw Error("Element is not a canvas!");this.canvas=t}else if(e.hasOwnProperty("elementClass")){if(null==(t=document.getElementsByClassName(e.elementClass)[0]))throw Error("No element with the class '"+e.elementClass+"' was found!");if(!(t instanceof HTMLCanvasElement))throw Error("Element is not a canvas!");this.canvas=t}else if(e.hasOwnProperty("element")){var t;if(null==(t=e.element))throw Error("Element is null or undefined!");if(!(t instanceof HTMLCanvasElement))throw Error("Element '"+t+"' is not a canvas!");this.canvas=t}else this.canvas=document.createElement("canvas"),document.body.appendChild(this.canvas);if(e.hasOwnProperty("width")){if(isNaN(e.width))throw Error("Width is not a number: "+e.width);this.canvas.width=e.width}if(e.hasOwnProperty("height")){if(isNaN(e.height))throw Error("Height is not a number: "+e.height);this.canvas.height=e.height}if(e.hasOwnProperty("width")||e.hasOwnProperty("height")||e.hasOwnProperty("noFullscreen")&&(!e.hasOwnProperty("noFullscreen")||e.noFullscreen)?(this.disableContextMenu=!!e.hasOwnProperty("disableContextMenu")&&e.disableContextMenu,this.disableMiddleMouse=!!e.hasOwnProperty("disableMiddleMouse")&&e.disableMiddleMouse,this.disableScrollOnMobile=!!e.hasOwnProperty("disableScrollOnMobile")&&e.disableScrollOnMobile,this.disableKeyShortcuts=!!e.hasOwnProperty("disableKeyShortcuts")&&e.disableKeyShortcuts,this.updateCanvasSizeOnResize=!!e.hasOwnProperty("updateCanvasSizeOnResize")&&e.updateCanvasSizeOnResize,this.publicMethods=!e.hasOwnProperty("publicMethods")||e.publicMethods):(this.canvas.width=Math.ceil(window.innerWidth)+1,this.canvas.height=Math.ceil(window.innerHeight)+1,this.canvas.style.position="absolute",this.canvas.style.top="0",this.canvas.style.bottom="0",this.canvas.style.left="0",this.canvas.style.right="0",document.body.style.overflow="hidden",this.disableContextMenu=!e.hasOwnProperty("disableContextMenu")||e.disableContextMenu,this.disableMiddleMouse=!e.hasOwnProperty("disableMiddleMouse")||e.disableMiddleMouse,this.disableScrollOnMobile=!e.hasOwnProperty("disableScrollOnMobile")||e.disableScrollOnMobile,this.disableKeyShortcuts=!!e.hasOwnProperty("disableKeyShortcuts")&&e.disableKeyShortcuts,this.updateCanvasSizeOnResize=!e.hasOwnProperty("updateCanvasSizeOnResize")||e.updateCanvasSizeOnResize,this.publicMethods=!e.hasOwnProperty("publicMethods")||e.publicMethods),this.ctx=this.canvas.getContext("2d"),this.font="Arial",this.images=[],this.imageData=void 0,this.imageDataData=void 0,this.audioContext=new(window.AudioContext||window.webkitAudioContext),this.keys={keysDown:[],ctrlPressed:!1,shiftSPressed:!1,altPressed:!1},this.mouse={x:0,y:0,lastX:0,lastY:0,movementX:0,movementY:0,left:!1,right:!1,middle:!1,any:!1},this.mouseLookupTable=["left","middle","right"],this.touch={x:0,y:0,isTouching:!1,nrTouches:0,touches:[]},this.eventFunctions={mousedown:"undefined"!=typeof OnMouseDown,mouseup:"undefined"!=typeof OnMouseUp,mousemove:"undefined"!=typeof OnMouseMove,contextmenu:"undefined"!=typeof OnContextMenu,touchstart:"undefined"!=typeof OnTouchStart,touchend:"undefined"!=typeof OnTouchEnd,touchmove:"undefined"!=typeof OnTouchMove,keydown:"undefined"!=typeof OnKeyDown,keyup:"undefined"!=typeof OnKeyUp,resize:"undefined"!=typeof OnResize},this.ENUM={LINECAP:{DEFAULT:"butt",BUTT:"butt",ROUND:"round",SQUARE:"square"},TEXTALIGN:{X:{DEFAULT:"start",START:"start",END:"end",CENTER:"center",LEFT:"left",RIGHT:"right"},Y:{DEFAULT:"alphabetic",ALPHABETIC:"alphabetic",TOP:"top",HANGING:"hanging",MIDDLE:"middle",CENTER:"middle",IDEOGRAPHIC:"ideographic",BOTTOM:"bottom"}}},document.addEventListener("keydown",(e=>{if(this.keys.altPressed=e.altKey,this.keys.shiftPressed=e.shiftKey,this.keys.ctrlPressed=e.ctrlKey,this.keys.keysDown[e.key]=this.keys.keysDown[e.keyCode]=this.keys.keysDown[e.code]=!0,this.eventFunctions.keydown&&OnKeyDown(e),this.disableKeyShortcuts)return e.preventDefault(),!1})),document.addEventListener("keyup",(e=>{this.keys.altPressed=e.altKey,this.keys.shiftPressed=e.shiftKey,this.keys.ctrlPressed=e.ctrlKey,this.keys.keysDown[e.key]=this.keys.keysDown[e.keyCode]=this.keys.keysDown[e.code]=!1,this.eventFunctions.keyup&&OnKeyUp(e)})),this.canvas.addEventListener("mousemove",(e=>{let t=this.canvas.getBoundingClientRect();this.mouse.x=(e.clientX-t.left)/(t.width/this.width),this.mouse.y=(e.clientY-t.top)/(t.height/this.height),this.mouse.movementX=e.movementX,this.mouse.movementY=e.movementY,this.eventFunctions.mousemove&&OnMouseMove(e)})),this.canvas.addEventListener("mousedown",(e=>{let t=e.button;if(t<3&&(this.mouse[this.mouseLookupTable[t]]=!0),this.mouse.any=this.mouse.left||this.mouse.right||this.mouse.middle,this.eventFunctions.mousedown&&OnMouseDown(e),1==t&&this.disableMiddleMouse)return e.preventDefault(),!1})),this.canvas.addEventListener("mouseup",(e=>{let t=e.button;t<3&&(this.mouse[this.mouseLookupTable[t]]=!1),this.mouse.any=this.mouse.left||this.mouse.right||this.mouse.middle||this.touch.touches.length>0,this.eventFunctions.mouseup&&OnMouseUp(e)})),this.canvas.addEventListener("contextmenu",(e=>(this.eventFunctions.contextmenu&&OnContextMenu(e),!this.disableContextMenu||(e.preventDefault(),!1)))),this.updateTouches=function(e){let t=this.canvas.getBoundingClientRect();this.touch.touches=[];for(let a=0;a<e.touches.length;a++){var n=e.touches[a],r=(n.pageX-t.left)/(t.width/this.width),i=(n.pageY-t.top)/(t.height/this.height);this.touch.touches[a]={x:r,y:i,id:n.identifier,force:n.force,radiusX:n.radiusX,radiusY:n.radiusY,rotationAngle:n.rotationAngle}}},this.canvas.addEventListener("touchmove",(e=>{this.disableScrollOnMobile&&e.preventDefault(),this.updateTouches(e),this.touch.x=this.touch.touches[0].x,this.touch.y=this.touch.touches[0].y,this.eventFunctions.touchmove&&OnTouchMove(e)})),this.canvas.addEventListener("touchstart",(e=>{this.disableScrollOnMobile&&e.preventDefault(),this.updateTouches(e),this.touch.x=this.touch.touches[0].x,this.touch.y=this.touch.touches[0].y,this.touch.isTouching=!0,this.mouse.any=!0,this.eventFunctions.touchstart&&OnTouchStart(e)})),this.canvas.addEventListener("touchend",(e=>{this.disableScrollOnMobile&&e.preventDefault(),this.updateTouches(e),this.touch.isTouching=this.touch.touches.length>0,this.mouse.any=this.mouse.left||this.mouse.right||this.mouse.middle||this.touch.touches.length>0,this.eventFunctions.touchend&&OnTouchEnd(e)})),window.addEventListener("resize",(e=>{this.updateCanvasSizeOnResize&&(this.width=Math.ceil(window.innerWidth)+1,this.height=Math.ceil(window.innerHeight)+1),this.eventFunctions.resize&&OnResize(e)})),this.isPassed=function(e){return void 0!==e},this.publicMethods){var n=Object.getOwnPropertyNames(v.prototype);for(var r of n)["constructor","width","height"].includes(r)||(window[r]=this[r].bind(this));for(var i of["width","height"])Object.defineProperty(window,i,{get:function(e,t){return function(){return e[t]}}(this,i),set:function(e,t){return function(n){e[t]=n}}(this,i),configurable:!0});for(var a of["mouse","touch"])Object.defineProperty(window,a,{get:function(e,t){return function(){return e[t]}}(this,a),configurable:!0})}}get width(){return this.canvas.width}get height(){return this.canvas.height}set width(e){this.canvas.width=e}set height(e){this.canvas.height=e}requestFullscreen(){this.canvas.requestFullscreen?this.canvas.requestFullscreen():this.canvas.mozRequestFullScreen?this.canvas.mozRequestFullScreen():this.canvas.webkitRequestFullscreen?this.canvas.webkitRequestFullscreen():this.canvas.msRequestFullscreen&&this.canvas.msRequestFullscreen()}exitFullscreen(){document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen?document.webkitExitFullscreen():document.msExitFullscreen&&document.msExitFullscreen()}lockPointer(){this.canvas.requestPointerLock=this.canvas.requestPointerLock||this.canvas.mozRequestPointerLock,this.canvas.requestPointerLock()}unlockPointer(){document.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock,document.exitPointerLock()}clearScreen(){this.ctx.clearRect(0,0,this.width,this.height)}background(e){this.ctx.fillStyle=e,this.ctx.fillRect(0,0,this.width,this.height)}arc(e,t,n,r,i,a){this.ctx.arc(e,t,n,r,i,a)}circle(e,t,n,r,i,a){this.ctx.beginPath(),this.ctx.arc(e,t,n,0,2*Math.PI),this.ctx.fillStyle=r,i&&(this.ctx.strokeStyle=i),a&&(this.ctx.lineWidth=a),this.ctx.fill(),i&&this.ctx.stroke()}ring(e,t,n,r,i){this.ctx.beginPath(),this.ctx.arc(e,t,n,0,2*Math.PI),this.ctx.strokeStyle=r,i&&(this.ctx.lineWidth=i),this.ctx.stroke()}ellipse(e,t,n,r,i,a=0,o,s){this.ctx.beginPath(),this.ctx.ellipse(e,t,n,r,a,0,2*Math.PI),this.ctx.fillStyle=i,o&&(this.ctx.strokeStyle=o),s&&(this.ctx.lineWidth=s),this.ctx.fill(),o&&this.ctx.stroke()}rectangle(e,t,n,r,i,a,o){i&&(this.ctx.fillStyle=i),o&&(this.ctx.lineWidth=o),a?(this.ctx.beginPath(),this.ctx.strokeStyle=a,this.ctx.rect(e,t,n,r),i&&this.ctx.fill(),this.ctx.stroke()):this.ctx.fillRect(e,t,n,r)}roundedRectangle(e,t,n,r,i,a,o,s){"number"==typeof a&&(a=[a,a,a,a]),this.ctx.beginPath(),this.ctx.arc(e+a[0],t+a[0],a[0],Math.PI,1.5*Math.PI),this.ctx.lineTo(e+n-a[1],t),this.ctx.arc(e+n-a[1],t+a[1],a[1],1.5*Math.PI,2*Math.PI),this.ctx.lineTo(e+n,t+r-a[2]),this.ctx.arc(e+n-a[2],t+r-a[2],a[2],0,.5*Math.PI),this.ctx.lineTo(e+a[3],t+r),this.ctx.arc(e+a[3],t+r-a[3],a[3],.5*Math.PI,Math.PI),this.ctx.closePath(),o&&(s&&(this.ctx.lineWidth=s),this.ctx.strokeStyle=o,this.ctx.stroke()),this.ctx.fillStyle=i,this.ctx.fill()}triangle(e,t,n,r,i,a,o,s,l){this.ctx.beginPath(),this.ctx.moveTo(e,t),this.ctx.lineTo(n,r),this.ctx.lineTo(i,a),this.ctx.closePath(),this.ctx.fillStyle=o,l&&(this.ctx.lineWidth=l),this.ctx.fill(),s&&(this.ctx.strokeStyle=s,this.ctx.stroke())}line(e,t,n,r,i,a){this.ctx.beginPath(),this.ctx.moveTo(e,t),this.ctx.lineTo(n,r),i&&(this.ctx.strokeStyle=i),a&&(this.ctx.lineWidth=a),this.ctx.stroke()}clippedPicture(e,t,n,r,i,a,o,s,l){var c=this.images[e];if(c)c.complete&&0!==c.naturalWidth&&(s=s||c.width,l=l||c.height,this.ctx.drawImage(c,t,n,r,i,a,o,s,l));else{var u=new Image;u.src=e,u.onload=()=>{s=s||u.width,l=l||u.height,this.ctx.drawImage(u,t,n,r,i,a,o,s,l)},this.images[e]=u}}picture(e,t,n,r,i){var a=this.images[e];if(a)a.complete&&(r=r||a.width,i=i||a.height,this.ctx.drawImage(a,t,n,r,i));else{var o=new Image;o.src=e,o.onload=()=>{r=r||o.width,i=i||o.height,this.ctx.drawImage(o,t,n,r,i)},this.images[e]=o}}text(e,t,n,r,i,a,o){this.ctx.beginPath(),this.ctx.font=r+"px "+this.font,this.ctx.fillStyle=i,o&&(this.ctx.lineWidth=o),this.ctx.fillText(e,t,n),a&&(this.ctx.strokeStyle=a,this.ctx.strokeText(e,t,n))}drawVector(e,t,n,r=1,i="black"){var a=this.normalizeVector(n),o=-a.y,s=a.x,l=e+a.x*r,c=t+a.y*r;this.line(e,t,l,c,3,i),this.triangle(l,c,l-7*a.x+7*o,c-7*a.y+7*s,l-7*a.x-7*o,c-7*a.y-7*s,i)}polygon(e,t,n,r,i,a,o){this.ctx.beginPath(),this.ctx.moveTo(e[0].x+t,e[0].y+n);for(var s=1;s<e.length;s++){var l=e[s];this.ctx.lineTo(l.x+t,l.y+n)}r&&this.ctx.closePath(),i&&(this.ctx.fillStyle=i,this.ctx.fill()),a&&(o&&(this.ctx.lineWidth=o),this.ctx.strokeStyle=a,this.ctx.stroke())}rgb(e=0,t=0,n=0){return`rgb(${e}, ${t}, ${n})`}getPixelData(){this.imageData=this.ctx.getImageData(0,0,this.width,this.height),this.imageDataData=this.imageData.data}updatePixel(e,t,n,r,i,a=255){let o=4*(e+t*this.width);this.imageDataData[o]=n,this.imageDataData[o+1]=r,this.imageDataData[o+2]=i,this.imageDataData[o+3]=a}updatePixelIndex(e,t,n,r,i=255){var a=4*e;this.imageDataData[a]=t,this.imageDataData[a+1]=n,this.imageDataData[a+2]=r,this.imageDataData[a+3]=i}getPixel(e,t){let n=4*(e+t*this.width);return[this.imageDataData[n],this.imageDataData[n+1],this.imageDataData[n+2],this.imageDataData[n+3]]}getPixelIndex(e){let t=4*e;return[this.imageDataData[t],this.imageDataData[t+1],this.imageDataData[t+2],this.imageDataData[t+3]]}renderPixelData(){this.ctx.putImageData(this.imageData,0,0)}save(){this.ctx.save()}restore(){this.ctx.restore()}rotate(e){this.ctx.rotate(e)}translate(e,t){this.ctx.translate(e,t)}beginPath(){this.ctx.beginPath()}closePath(){this.ctx.closePath()}moveTo(e,t){this.ctx.moveTo(e,t)}lineTo(e,t){this.ctx.lineTo(e,t)}quadraticCurveTo(e,t,n,r){this.ctx.quadraticCurveTo(e,t,n,r)}quadraticTo(e,t,n,r){this.ctx.quadraticCurveTo(e,t,n,r)}bezierCurveTo(e,t,n,r,i,a){this.ctx.bezierCurveTo(e,t,n,r,i,a)}bezierTo(e,t,n,r,i,a){this.ctx.bezierCurveTo(e,t,n,r,i,a)}fill(){this.ctx.fill()}stroke(){this.ctx.stroke()}fillStyle(e){this.ctx.fillStyle=e}strokeStyle(e){this.ctx.strokeStyle=e}setLineWidth(e){this.ctx.lineWidth=e}lineWidth(e){this.ctx.lineWidth=e}strokeWeight(e){this.ctx.lineWidth=e}setLineCap(e){this.ctx.lineCap=e}resetLineCap(){this.ctx.lineCap="butt"}setFont(e){this.font=e}setTextAlign(e){this.ctx.textAlign=e}setTextXAlign(e){this.ctx.textAlign=e}setTextAlignX(e){this.ctx.textAlign=e}setTextYAlign(e){this.ctx.textBaseline=e}setTextAlignY(e){this.ctx.textBaseline=e}resetTextXAlign(){this.ctx.textAlign="left"}resetTextAlignX(){this.ctx.textAlign="left"}resetTextYAlign(){this.ctx.textBaseline="alphabetic"}resetTextAlignY(){this.ctx.textBaseline="alphabetic"}clip(){this.ctx.clip()}createSound(e,t=1,n=0,r=!1){var i=new Audio(e);return i.loop=r,i.currentTime=n,i.volume=t,{volume:t,startTime:n,audio:i}}playSound(e){e.audio.currentTime=e.startTime,e.audio.volume=e.volume,e.audio.play()}stopSound(e){e.audio.stop()}pauseSound(e){e.audio.pause()}backgroundMusic(e){var t=new Audio(e);return t.loop=!0,t.play(),t}fadeOutSound(e,t=1){var n=e.volume,r=0,i=setInterval((()=>{e.audio.volume=n/(20*t)*(20*t-r),++r>20*t&&(e.audio.pause(),clearInterval(i))}),50)}playTone(e=440,t=1,n=1,r="sine"){var i=this.audioContext.createOscillator(),a=this.audioContext.createGain();a.gain.value=n,a.connect(this.audioContext.destination),i.type=r,i.frequency.value=e,i.connect(a),i.start(),setTimeout((()=>{i.stop()}),1e3*t)}getDistanceSqr(e,t,n,r){var i=e-n,a=t-r;return i*i+a*a}getDistanceSqr3D(e,t,n,r,i,a){var o=e-n,s=t-r,l=i-a;return o*o+s*s+l*l}getDistance(e,t,n,r){return Math.sqrt(top.getDistanceSqr(e,t,n,r))}getDistance3D(e,t,n,r,i,a){return Math.sqrt(top.getDistanceSqr3D(e,t,n,r,i,a))}getAngle(e,t,n,r){return Math.atan2(r-t,n-e)}normalize(e,t){var n=Math.sqrt(e*e+t*t);return{x:e/n,y:t/n}}normalizeVector(e){var t=Math.sqrt(e.x*e.x+e.y*e.y);return{x:e.x/t,y:e.y/t}}normalize3D(e,t,n){var r=Math.sqrt(e*e+t*t+n*n);return{x:e/r,y:t/r,z:n/r}}normalize3DVector(e){var t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z);return{x:e.x/t,y:e.y/t,z:e.z/t}}lengthVector(e){return Math.sqrt(e.x*e.x+e.y*e.y)}length3DVector(e){return Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z)}dot(e,t){return e.x*t.x+e.y*t.y}dot3D(e,t){return e.x*t.x+e.y*t.y+e.z*t.z}crossProduct3D(e,t){return{x:e.y*t.z-e.z*t.y,y:e.z*t.x-e.x*t.z,z:e.x*t.y-e.y*t.x}}clamp(e,t,n){return Math.max(t,Math.min(n,e))}lerp(e,t,n){return e*(1-n)+t*n}rectanglesIntersect(e,t,n,r,i,a,o,s){return e+n>i&&e<i+o&&t+r>a&&t<a+s}circlesIntersect(e,t,n,r,i,a){return this.getDistance(e,t,r,i)<n+a}circleRectangleIntersect(e,t,n,r,i,a,o){var s=Math.abs(e-(r+a/2)),l=Math.abs(t-(i+o/2));if(s>a/2+n)return!1;if(l>o/2+n)return!1;if(s<=a/2)return!0;if(l<=o/2)return!0;var c=s-a/2,u=l-o/2;return c*c+u*u<=n*n}random(e){return Math.random()*e}randomInt(e){return Math.random()*e>>0}randomArray(e){return e[Math.floor(Math.random()*e.length)]}randomColor(e){if("number"!=typeof e||isNaN(e))return"rgb("+(256*Math.random()>>0)+","+(256*Math.random()>>0)+","+(256*Math.random()>>0)+")";if(0===e)throw Error("Colordepth cannot be 0");var t=256/e;return"rgb("+Math.ceil(Math.floor(256*Math.random())/t)*t+","+Math.ceil(Math.floor(256*Math.random())/t)*t+","+Math.ceil(Math.floor(256*Math.random())/t)*t+")"}canvasToURL(){return top.canvas.toDataURL()}canvasToImage(){var e=new Image;return e.src=top.canvas.toDataURL(),e}saveToFile(e="canvas.png"){var t=document.createElement("a");t.download=e,t.href=top.canvas.toDataURL(),t.click()}setCookie(e,t,n=36500){let r=new Date;r.setTime(r.getTime()+24*n*60*60*1e3);let i="expires="+r.toUTCString();document.cookie=e+"="+t+";"+i+";path=/"}getCookie(e){if(0==e.length)return!1;var t=e+"=",n=document.cookie.split(";");for(let e=0;e<n.length;e++){let i=n[e];var r=i.indexOf(t);if(r>0)return i.substr(r+t.length)}return!1}deleteCookie(e){document.cookie=e+"=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/"}isCtrlPressed(){return this.keys.ctrlPressed}isAltPressed(){return this.keys.AltPressed}isShiftPressed(){return this.keys.shiftPressed}key(e){return!!this.keys.keysDown[e]}create2DArray(e,t,n=((e,t)=>0)){for(var r=new Array(e),i=0;i<e;i++){r[i]=new Array(t);for(var a=0;a<t;a++)r[i][a]=n(i,a)}return r}mapValue(e,t,n,r,i){return(e-t)*(i-r)/(n-t)+r}gradient(e,t,n,r,i,a){var o=this.ctx.createLinearGradient(n,r,i,a);return o.addColorStop(0,e),o.addColorStop(1,t),o}prettyprint(e){"object"==typeof e&&console.log(JSON.stringify(e,null,2))}}const g={SHADOWS:1,OPAQUE:2,ALPHA:4,DOWNSCALED:8},p="cube";function x(e,t,n){return e<t?0:e>=n?1:(e=(e-t)/(n-t))*e*(3-2*e)}function b(e,t){return(e%t+t)%t}function y(e,t,n){return Math.max(t,Math.min(n,e))}function T(e,t,n){return e*(1-n)+t*n}function w(e,t,n){return Math.abs(e-t)<1e-6?0:(n-e)/(t-e)}function E(e,t){return Math.round(e/t)*t}function _(e){return 0==(e&e-1)}function M(e){for(var t=new Uint16Array(e.length),n=0;n<t.length;n++)t[n]=F(e[n]);return t}var R,C,F=(R=new Float32Array(1),C=new Int32Array(R.buffer),function(e){R[0]=e;var t=C[0],n=t>>16&32768,r=t>>12&2047,i=t>>23&255;return i<103?n:i>142?(n|=31744,n|=(255==i?0:1)&&8388607&t):i<113?n|=((r|=2048)>>114-i)+(r>>113-i&1):(n|=i-112<<10|r>>1,n+=1&r)});function A(e){return new DataView(Uint8Array.from(e).buffer).getInt32(0,!0)}function D(e){return new Promise((t=>setTimeout(t,e)))}function P(e){return new Promise(((t,n)=>{let r=new Image;r.addEventListener("load",(e=>t(r))),r.addEventListener("error",(()=>{n(new Error(`Failed to load image's URL: ${e}`))})),r.src=e}))}function S(e,t,n){var r=document.createElement("canvas");r.width=t??e.width,r.height=n??e.height;var i=r.getContext("2d");return i.drawImage(e,0,0),i.getImageData(0,0,r.width,r.height).data}function N(e){e.classList.add("hidden")}function U(e){e.classList.remove("hidden")}function z(e,t="download"){var n=document.createElement("a");n.download=t+".png",n.href=e.toDataURL(),n.click()}class L{constructor(e=0,t=0,n=0,r){return(r=r||{x:0,y:0,z:0}).x=e,r.y=t,r.z=n,r}static zero(e){return(e=e||new L).x=0,e.y=0,e.z=0,e}static one(e){return(e=e||new L).x=1,e.y=1,e.z=1,e}static up(e){return(e=e||new L).x=0,e.y=1,e.z=0,e}static down(e){return(e=e||new L).x=0,e.y=-1,e.z=0,e}static fill(e=0,t){return(t=t||new L).x=e,t.y=e,t.z=e,t}static set(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e}static copy(e,t){return(t=t||new L).x=e.x,t.y=e.y,t.z=e.z,t}static fromArray(e,t=0,n=1,r=4,i){return(i=i||{x:0,y:0,z:0,w:0}).x=r>=1?e[t]??0:0,i.y=r>=2?e[t+n]??0:0,i.z=r>=3?e[t+2*n]??0:0,i.w=r>=4?e[t+3*n]??0:0,i}static toArray(e,t){return(t=t||[0,0,0])[0]=e.x,t[1]=e.y,t[2]=e.z,t}static equal(e,t,n=1e-6){return Math.abs(e.x-t.x)<n&&Math.abs(e.y-t.y)<n&&Math.abs(e.z-t.z)<n}static isVectorIsh(e){return"object"==typeof e&&("x"in e||"y"in e||"z"in e)}static isNaN(e){return isNaN(e.x)||isNaN(e.y)||isNaN(e.z)}static add(e,t,n){return(n=n||new L).x=e.x+t.x,n.y=e.y+t.y,n.z=e.z+t.z,n}static addTo(e,t){return e.x+=t.x,e.y+=t.y,e.z+=t.z,e}static subtract(e,t,n){return(n=n||new L).x=e.x-t.x,n.y=e.y-t.y,n.z=e.z-t.z,n}static subtractTo(e,t){return e.x-=t.x,e.y-=t.y,e.z-=t.z,e}static multiply(e,t,n){return(n=n||new L).x=e.x*t,n.y=e.y*t,n.z=e.z*t,n}static multiplyTo(e,t){return e.x*=t,e.y*=t,e.z*=t,e}static negate(e,t){return(t=t||new L).x=-e.x,t.y=-e.y,t.z=-e.z,t}static negateTo(e){return e.x=-e.x,e.y=-e.y,e.z=-e.z,e}static compMultiply(e,t,n){return(n=n||new L).x=e.x*t.x,n.y=e.y*t.y,n.z=e.z*t.z,n}static compMultiplyTo(e,t){return e.x*=t.x,e.y*=t.y,e.z*=t.z,e}static divide(e,t,n){return(n=n||new L).x=e.x/t,n.y=e.y/t,n.z=e.z/t,n}static divideTo(e,t){return e.x/=t,e.y/=t,e.z/=t,e}static compDivide(e,t,n){return(n=n||new L).x=e.x/t.x,n.y=e.y/t.y,n.z=e.z/t.z,n}static compDivideTo(e,t){return e.x/=t.x,e.y/=t.y,e.z/=t.z,e}static average(e,t,n){return n=n||new L,L.add(e,t,n),L.divideTo(n,2),n}static applyFunc(e,t,n){return(n=n||new L).x=t(e.x),n.y=t(e.y),n.z=t(e.z),n}static compFunc(e,t,n,r){return(r=r||new L).x=n(e.x,t.x),r.y=n(e.y,t.y),r.z=n(e.z,t.z),r}static rotate2D(e,t,n){return(n=n||new L).x=e.x*Math.cos(t)-e.y*Math.sin(t),n.y=e.x*Math.sin(t)+e.y*Math.cos(t),n.z=0,n}static rotateAround(e,t,n,r){r=r||new L,L.multiply(t,L.dot(e,t)/L.dot(t,t),I),L.subtract(e,I,O),L.cross(t,O,k);let i=L.length(O);var a=Math.cos(n)/i,o=Math.sin(n)/L.length(k);return L.multiply(O,a,V),L.multiply(k,o,G),L.addTo(V,G),L.multiplyTo(V,i),L.add(V,I,r),r}static project(e,t,n){n=n||new L;const r=L.dot(t,e);return L.set(n,t),L.multiplyTo(n,r),n}static projectOnPlane(e,t,n){n=n||new L;const r=L.dot(t,e);return L.set(B,t),L.multiplyTo(B,r),L.set(n,e),L.subtractTo(n,B),n}static findOrthogonal(e,t){return t=t||new L,Math.abs(e.x)>=1/Math.sqrt(3)?(t.x=e.y,t.y=-e.x,t.z=0):(t.x=0,t.y=e.z,t.z=-e.y),L.normalizeTo(t),t}static formOrthogonalBasis(e){var t=L.findOrthogonal(e);return[t,L.cross(t,e)]}static lengthNonVector(e=0,t=0,n=0){return Math.sqrt(e*e+t*t+n*n)}static length(e){var t=e.x*e.x+e.y*e.y;return e.z&&(t+=e.z*e.z),Math.sqrt(t)}static lengthSqr(e){var t=e.x*e.x+e.y*e.y;return e.z&&(t+=e.z*e.z),t}static distance(e,t){return L.set(B,e),L.subtractTo(B,t),L.length(B)}static distanceSqr(e,t){return L.set(B,e),L.subtractTo(B,t),L.lengthSqr(B)}static normalize(e,t){t=t||new L;var n=L.lengthSqr(e);return n<1e-12?L.copy(e,t):L.divide(e,Math.sqrt(n),t),t}static normalizeTo(e){var t=L.length(e);return t<1e-6?e:L.divideTo(e,t)}static dot(e,t){var n=e.x*t.x+e.y*t.y;return e.z&&t.z&&(n+=e.z*t.z),n}static cross(e,t,n){n=n||new L;const r=e.x,i=e.y,a=e.z,o=t.x,s=t.y,l=t.z;return n.x=i*l-a*s,n.y=a*o-r*l,n.z=r*s-i*o,n}static lerp(e,t,n,r){return(r=r||new L).x=T(e.x,t.x,n),r.y=T(e.y,t.y,n),r.z=T(e.z,t.z,n),r}static inverseLerp(e,t,n,r){return(r=r||new L).x=w(e.x,t.x,n),r.y=w(e.y,t.y,n),r.z=w(e.z,t.z,n),r}static slerp(e,t,n,r){r=r||new L;var i=y(L.dot(e,t),-1,1),a=Math.acos(i)*n,o=L.normalize(L.subtract(t,L.multiply(e,i))),s=L.multiply(e,Math.cos(a)),l=L.multiply(o,Math.sin(a));return L.add(s,l,r),r}static clamp(e,t,n,r){r=r||new L;var i=L.isVectorIsh(t),a=L.isVectorIsh(n);return r.x=y(e.x,i?t.x:t,a?n.x:n),r.y=y(e.y,i?t.y:t,a?n.y:n),r.z=y(e.z,i?t.z:t,a?n.z:n),r}static map(e,t,n){return(n=n||new L).x=t(e.x),n.y=t(e.y),n.z=t(e.z),n}}const B=new L,I=new L,O=new L,k=new L,V=new L,G=new L,X=L;class j{constructor(e=0,t=0,n=0,r=0,i){return(i=i||{x:0,y:0,z:0,w:0}).x=e,i.y=t,i.z=n,i.w=r,i}static isQuaternionIsh(e){return"object"==typeof e&&"x"in e&&"y"in e&&"z"in e&&"w"in e}static zero(){return{x:0,y:0,z:0,w:0}}static identity(e){return(e=e||new j).x=0,e.y=0,e.z=0,e.w=1,e}static copy(e){return{x:e.x,y:e.y,z:e.z,w:e.w}}static set(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}static equal(e,t,n=1e-6){return Math.abs(e.x-t.x)<n&&Math.abs(e.y-t.y)<n&&Math.abs(e.z-t.z)<n&&Math.abs(e.w-t.w)<n}static isNaN(e){return isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||isNaN(e.w)}static normalize(e){var t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w);return{x:e.x/t,y:e.y/t,z:e.z/t,w:e.w/t}}static normalizeTo(e){const t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w);return e.x/=t,e.y/=t,e.z/=t,e.w/=t,e}static dot(e,t){return e.x*t.x+e.y*t.y+e.z*t.z+e.w*t.w}static add(e,t){return{x:e.x+t.x,y:e.y+t.y,z:e.z+t.z,w:e.w+t.w}}static multiply(e,t){return{x:e.x*t,y:e.y*t,z:e.z*t,w:e.w*t}}static QxQ(e,t){return new j(e.w*t.x+e.x*t.w+e.y*t.z-e.z*t.y,e.w*t.y-e.x*t.z+e.y*t.w+e.z*t.x,e.w*t.z+e.x*t.y-e.y*t.x+e.z*t.w,e.w*t.w-e.x*t.x-e.y*t.y-e.z*t.z)}static QxV(e,t,n){n=n||new X;var r=t.x,i=t.y,a=t.z,o=e.x,s=e.y,l=e.z,c=e.w,u=c*r+s*a-l*i,h=c*i+l*r-o*a,f=c*a+o*i-s*r,d=-o*r-s*i-l*a;return n.x=u*c+d*-o+h*-l-f*-s,n.y=h*c+d*-s+f*-o-u*-l,n.z=f*c+d*-l+u*-s-h*-o,n}static slerp(e,t,n){var r=j.dot(e,t);if(Math.abs(1-r)<1e-5)return e;var i=r>=0?e:j.multiply(e,-1),a=Math.acos(Math.abs(r)),o=j.add(j.multiply(i,Math.sin((1-n)*a)),j.multiply(t,Math.sin(n*a)));return j.multiply(o,1/Math.sin(a))}static lerp(e,t,n){return{x:T(e.x,t.x,n),y:T(e.y,t.y,n),z:T(e.z,t.z,n),w:T(e.w,t.w,n)}}static euler(e,t,n,r){r=r||new j;const i=e,a=t,o=n,s=Math.sin(i/2)*Math.cos(a/2)*Math.cos(o/2)-Math.cos(i/2)*Math.sin(a/2)*Math.sin(o/2),l=Math.cos(i/2)*Math.sin(a/2)*Math.cos(o/2)+Math.sin(i/2)*Math.cos(a/2)*Math.sin(o/2),c=Math.cos(i/2)*Math.cos(a/2)*Math.sin(o/2)-Math.sin(i/2)*Math.sin(a/2)*Math.cos(o/2),u=Math.cos(i/2)*Math.cos(a/2)*Math.cos(o/2)+Math.sin(i/2)*Math.sin(a/2)*Math.sin(o/2);return r.x=s,r.y=l,r.z=c,r.w=u,r}static eulerVector(e,t){return j.euler(e.x,e.y,e.z,t)}static toEulerAngles(e){var[t,n,r,i]=[e.x,e.y,e.z,e.w],a=2*(i*t+n*r),o=1-2*(t*t+n*n),s=2*(i*n-r*t);s=(s=s>1?1:s)<-1?-1:s;var l=2*(i*r+t*n),c=1-2*(n*n+r*r);return[Math.atan2(a,o),Math.asin(s),Math.atan2(l,c)]}static angleAxis(e,t,n){return(n=n||new j).x=t.x*Math.sin(e/2),n.y=t.y*Math.sin(e/2),n.z=t.z*Math.sin(e/2),n.w=Math.cos(e/2),n}static fromMatrix(e,t){t=t||new j;var n=W.get(e,0,0)+W.get(e,1,1)+W.get(e,2,2);if(n>0){let r=.5/Math.sqrt(n+1);t.x=(W.get(e,2,1)-W.get(e,1,2))*r,t.y=(W.get(e,0,2)-W.get(e,2,0))*r,t.z=(W.get(e,1,0)-W.get(e,0,1))*r,t.w=.25/r}else if(W.get(e,0,0)>W.get(e,1,1)&&W.get(e,0,0)>W.get(e,2,2)){let n=2*Math.sqrt(1+W.get(e,0,0)-W.get(e,1,1)-W.get(e,2,2));t.x=.25*n,t.y=(W.get(e,0,1)+W.get(e,1,0))/n,t.z=(W.get(e,0,2)+W.get(e,2,0))/n,t.w=(W.get(e,2,1)-W.get(e,1,2))/n}else if(W.get(e,1,1)>W.get(e,2,2)){let n=2*Math.sqrt(1+W.get(e,1,1)-W.get(e,0,0)-W.get(e,2,2));t.x=(W.get(e,0,1)+W.get(e,1,0))/n,t.y=.25*n,t.z=(W.get(e,1,2)+W.get(e,2,1))/n,t.w=(W.get(e,0,2)+W.get(e,2,0))/n}else{let n=2*Math.sqrt(1+W.get(e,2,2)-W.get(e,0,0)-W.get(e,1,1));t.x=(W.get(e,0,2)+W.get(e,2,0))/n,t.y=(W.get(e,1,2)+W.get(e,2,1))/n,t.z=.25*n,t.w=(W.get(e,1,0)+W.get(e,0,1))/n}return t}}function H(e,t,n,r,i,a,o,s,l,c,u,h,f,d,m,v,g){return e[0]=t,e[1]=n,e[2]=r,e[3]=i,e[4]=a,e[5]=o,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=h,e[11]=f,e[12]=d,e[13]=m,e[14]=v,e[15]=g,e}class W{constructor(e=0,t=0,n=0,r=0,i=0,a=0,o=0,s=0,l=0,c=0,u=0,h=0,f=0,d=0,m=0,v=0){var g=new Float32Array(16);return H(g,e,t,n,r,i,a,o,s,l,c,u,h,f,d,m,v),g}static identity(e){return H(e=e||new Float32Array(16),1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),e}static set(e,t,n,r,i,a,o,s,l,c,u,h,f,d,m,v,g){return H(e,t,n,r,i,a,o,s,l,c,u,h,f,d,m,v,g)}static copy(e,t){return(t=t||new Float32Array(16)).set(e),t}static isNaN(e){return isNaN(e[0])||isNaN(e[1])||isNaN(e[2])||isNaN(e[3])||isNaN(e[4])||isNaN(e[5])||isNaN(e[6])||isNaN(e[7])||isNaN(e[8])||isNaN(e[9])||isNaN(e[10])||isNaN(e[11])||isNaN(e[12])||isNaN(e[13])||isNaN(e[14])||isNaN(e[15])}static equal(e,t,n=1e-6){return Math.abs(e[0]-t[0])<n&&Math.abs(e[1]-t[1])<n&&Math.abs(e[2]-t[2])<n&&Math.abs(e[3]-t[3])<n&&Math.abs(e[4]-t[4])<n&&Math.abs(e[5]-t[5])<n&&Math.abs(e[6]-t[6])<n&&Math.abs(e[7]-t[7])<n&&Math.abs(e[8]-t[8])<n&&Math.abs(e[9]-t[9])<n&&Math.abs(e[10]-t[10])<n&&Math.abs(e[11]-t[11])<n&&Math.abs(e[12]-t[12])<n&&Math.abs(e[13]-t[13])<n&&Math.abs(e[14]-t[14])<n&&Math.abs(e[15]-t[15])<n}static add(e,t,n){return H(n=n||new Float32Array(16),e[0]+t[0],e[1]+t[1],e[2]+t[2],e[3]+t[3],e[4]+t[4],e[5]+t[5],e[6]+t[6],e[7]+t[7],e[8]+t[8],e[9]+t[9],e[10]+t[10],e[11]+t[11],e[12]+t[12],e[13]+t[13],e[14]+t[14],e[15]+t[15]),n}static subtract(e,t,n){return H(n=n||new Float32Array(16),e[0]-t[0],e[1]-t[1],e[2]-t[2],e[3]-t[3],e[4]-t[4],e[5]-t[5],e[6]-t[6],e[7]-t[7],e[8]-t[8],e[9]-t[9],e[10]-t[10],e[11]-t[11],e[12]-t[12],e[13]-t[13],e[14]-t[14],e[15]-t[15]),n}static lerp(e,t,n,r){return H(r=r||new Float32Array(16),T(e[0],t[0],n),T(e[1],t[1],n),T(e[2],t[2],n),T(e[3],t[3],n),T(e[4],t[4],n),T(e[5],t[5],n),T(e[6],t[6],n),T(e[7],t[7],n),T(e[8],t[8],n),T(e[9],t[9],n),T(e[10],t[10],n),T(e[11],t[11],n),T(e[12],t[12],n),T(e[13],t[13],n),T(e[14],t[14],n),T(e[15],t[15],n)),r}static transpose(e,t){return H(t=t||new Float32Array(16),e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],e[3],e[7],e[11],e[15]),t}static inverse(e,t){var n=new Float32Array(16);H(n,e[5]*e[10]*e[15]-e[5]*e[11]*e[14]-e[9]*e[6]*e[15]+e[9]*e[7]*e[14]+e[13]*e[6]*e[11]-e[13]*e[7]*e[10],-e[1]*e[10]*e[15]+e[1]*e[11]*e[14]+e[9]*e[2]*e[15]-e[9]*e[3]*e[14]-e[13]*e[2]*e[11]+e[13]*e[3]*e[10],e[1]*e[6]*e[15]-e[1]*e[7]*e[14]-e[5]*e[2]*e[15]+e[5]*e[3]*e[14]+e[13]*e[2]*e[7]-e[13]*e[3]*e[6],-e[1]*e[6]*e[11]+e[1]*e[7]*e[10]+e[5]*e[2]*e[11]-e[5]*e[3]*e[10]-e[9]*e[2]*e[7]+e[9]*e[3]*e[6],-e[4]*e[10]*e[15]+e[4]*e[11]*e[14]+e[8]*e[6]*e[15]-e[8]*e[7]*e[14]-e[12]*e[6]*e[11]+e[12]*e[7]*e[10],e[0]*e[10]*e[15]-e[0]*e[11]*e[14]-e[8]*e[2]*e[15]+e[8]*e[3]*e[14]+e[12]*e[2]*e[11]-e[12]*e[3]*e[10],-e[0]*e[6]*e[15]+e[0]*e[7]*e[14]+e[4]*e[2]*e[15]-e[4]*e[3]*e[14]-e[12]*e[2]*e[7]+e[12]*e[3]*e[6],e[0]*e[6]*e[11]-e[0]*e[7]*e[10]-e[4]*e[2]*e[11]+e[4]*e[3]*e[10]+e[8]*e[2]*e[7]-e[8]*e[3]*e[6],e[4]*e[9]*e[15]-e[4]*e[11]*e[13]-e[8]*e[5]*e[15]+e[8]*e[7]*e[13]+e[12]*e[5]*e[11]-e[12]*e[7]*e[9],-e[0]*e[9]*e[15]+e[0]*e[11]*e[13]+e[8]*e[1]*e[15]-e[8]*e[3]*e[13]-e[12]*e[1]*e[11]+e[12]*e[3]*e[9],e[0]*e[5]*e[15]-e[0]*e[7]*e[13]-e[4]*e[1]*e[15]+e[4]*e[3]*e[13]+e[12]*e[1]*e[7]-e[12]*e[3]*e[5],-e[0]*e[5]*e[11]+e[0]*e[7]*e[9]+e[4]*e[1]*e[11]-e[4]*e[3]*e[9]-e[8]*e[1]*e[7]+e[8]*e[3]*e[5],-e[4]*e[9]*e[14]+e[4]*e[10]*e[13]+e[8]*e[5]*e[14]-e[8]*e[6]*e[13]-e[12]*e[5]*e[10]+e[12]*e[6]*e[9],e[0]*e[9]*e[14]-e[0]*e[10]*e[13]-e[8]*e[1]*e[14]+e[8]*e[2]*e[13]+e[12]*e[1]*e[10]-e[12]*e[2]*e[9],-e[0]*e[5]*e[14]+e[0]*e[6]*e[13]+e[4]*e[1]*e[14]-e[4]*e[2]*e[13]-e[12]*e[1]*e[6]+e[12]*e[2]*e[5],e[0]*e[5]*e[10]-e[0]*e[6]*e[9]-e[4]*e[1]*e[10]+e[4]*e[2]*e[9]+e[8]*e[1]*e[6]-e[8]*e[2]*e[5]);var r=e[0]*n[0]+e[1]*n[4]+e[2]*n[8]+e[3]*n[12];if(!r)return e;r=1/r;for(var i=0;i<16;i++)n[i]*=r;return t||(t=new Float32Array(16)),W.copy(n,t),t}static multiply(e,t,n){const r=e,i=t,a=n=n||new Float32Array(16),o=r[0],s=r[4],l=r[8],c=r[12],u=r[1],h=r[5],f=r[9],d=r[13],m=r[2],v=r[6],g=r[10],p=r[14],x=r[3],b=r[7],y=r[11],T=r[15],w=i[0],E=i[4],_=i[8],M=i[12],R=i[1],C=i[5],F=i[9],A=i[13],D=i[2],P=i[6],S=i[10],N=i[14],U=i[3],z=i[7],L=i[11],B=i[15];return a[0]=o*w+s*R+l*D+c*U,a[4]=o*E+s*C+l*P+c*z,a[8]=o*_+s*F+l*S+c*L,a[12]=o*M+s*A+l*N+c*B,a[1]=u*w+h*R+f*D+d*U,a[5]=u*E+h*C+f*P+d*z,a[9]=u*_+h*F+f*S+d*L,a[13]=u*M+h*A+f*N+d*B,a[2]=m*w+v*R+g*D+p*U,a[6]=m*E+v*C+g*P+p*z,a[10]=m*_+v*F+g*S+p*L,a[14]=m*M+v*A+g*N+p*B,a[3]=x*w+b*R+y*D+T*U,a[7]=x*E+b*C+y*P+T*z,a[11]=x*_+b*F+y*S+T*L,a[15]=x*M+b*A+y*N+T*B,n}static basis(e,t,n,r){return H(r=r||new Float32Array(16),e.x,e.y,e.z,0,t.x,t.y,t.z,0,n.x,n.y,n.z,0,0,0,0,1),r}static getForward(e,t){return(t=t||new X).x=-e[8],t.y=-e[9],t.z=-e[10],X.normalizeTo(t),t}static getRight(e,t){return(t=t||new X).x=e[0],t.y=e[1],t.z=e[2],X.normalizeTo(t),t}static getUp(e,t){return(t=t||new X).x=e[4],t.y=e[5],t.z=e[6],X.normalizeTo(t),t}static forward(e,t){return W.getForward(e,t)}static right(e,t){return W.getRight(e,t)}static up(e,t){return W.getUp(e,t)}static translate(e={x:0,y:0,z:0},t){return H(t=t||new Float32Array(16),1,0,0,0,0,1,0,0,0,0,1,0,e.x,e.y,e.z,1),t}static getTranslationMatrix(e,t){return H(t=t||new Float32Array(16),1,0,0,0,0,1,0,0,0,0,1,0,e[12],e[13],e[14],1),t}static getPosition(e,t){return(t=t||X.zero()).x=e[12],t.y=e[13],t.z=e[14],t}static setPosition(e,t){e[12]=t.x,e[13]=t.y,e[14]=t.z}static removeTranslation(e){return e[12]=0,e[13]=0,e[14]=0,e}static setRotation(e,t){var n=X.length({x:e[4],y:e[5],z:e[6]}),r=X.length({x:e[0],y:e[1],z:e[2]}),i=X.length({x:e[8],y:e[9],z:e[10]});e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[8]=t[8]*i,e[9]=t[9]*i,e[10]=t[10]*i}static getRotationMatrix(e,t){t=t||new Float32Array(16);const n=X.lengthNonVector(e[0],e[1],e[2]),r=X.lengthNonVector(e[4],e[5],e[6]),i=X.lengthNonVector(e[8],e[9],e[10]);return H(t,e[0]/n,e[1]/n,e[2]/n,0,e[4]/r,e[5]/r,e[6]/r,0,e[8]/i,e[9]/i,e[10]/i,0,0,0,0,1),t}static rotateX(e,t,n){var r=new Float32Array([1,0,0,0,0,Math.cos(t),Math.sin(t),0,0,-Math.sin(t),Math.cos(t),0,0,0,0,1]);return W.multiply(e,r,n)}static rotateY(e,t,n){var r=new Float32Array([Math.cos(t),0,-Math.sin(t),0,0,1,0,0,Math.sin(t),0,Math.cos(t),0,0,0,0,1]);return W.multiply(e,r,n)}static rotateZ(e,t,n){var r=new Float32Array([Math.cos(t),Math.sin(t),0,0,-Math.sin(t),Math.cos(t),0,0,0,0,1,0,0,0,0,1]);return W.multiply(e,r,n)}static scale(e={x:1,y:1,z:1},t){return H(t=t||new Float32Array(16),e.x,0,0,0,0,e.y,0,0,0,0,e.z,0,0,0,0,1),t}static scaleWithScalar(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e[4]*=t,e[5]*=t,e[6]*=t,e[8]*=t,e[9]*=t,e[10]*=t,e}static scaleWithVector(e,t){return e[0]*=t.x,e[1]*=t.x,e[2]*=t.x,e[4]*=t.y,e[5]*=t.y,e[6]*=t.y,e[8]*=t.z,e[9]*=t.z,e[10]*=t.z,e}static setScale(e,t){var n=X.length({x:e[0],y:e[1],z:e[2]})/t.x,r=X.length({x:e[4],y:e[5],z:e[6]})/t.y,i=X.length({x:e[8],y:e[9],z:e[10]})/t.z;e[0]/=n,e[1]/=n,e[2]/=n,e[4]/=r,e[5]/=r,e[6]/=r,e[8]/=i,e[9]/=i,e[10]/=i}static getScale(e,t){return(t=t||new X).x=X.lengthNonVector(e[0],e[1],e[2]),t.y=X.lengthNonVector(e[4],e[5],e[6]),t.z=X.lengthNonVector(e[8],e[9],e[10]),t}static getScaleMatrix(e,t){return H(t=t||new Float32Array(16),X.lengthNonVector(e[0],e[1],e[2]),0,0,0,0,X.lengthNonVector(e[4],e[5],e[6]),0,0,0,0,X.lengthNonVector(e[8],e[9],e[10]),0,0,0,0,1),t}static transform(e=[],t){t=t||W.identity();for(var n=0;n<e.length;n++){var r=e[n];switch(r[0]){case"translate":var i=r[1].x||0,a=r[1].y||0,o=r[1].z||0;t[12]+=t[0]*i+t[4]*a+t[8]*o,t[13]+=t[1]*i+t[5]*a+t[9]*o,t[14]+=t[2]*i+t[6]*a+t[10]*o,t[15]+=t[3]*i+t[7]*a+t[11]*o;break;case"rx":var s=r[1];W.multiply(t,new Float32Array([1,0,0,0,0,Math.cos(s),Math.sin(s),0,0,-Math.sin(s),Math.cos(s),0,0,0,0,1]),t);break;case"ry":var l=r[1];W.multiply(t,new Float32Array([Math.cos(l),0,-Math.sin(l),0,0,1,0,0,Math.sin(l),0,Math.cos(l),0,0,0,0,1]),t);break;case"rz":var c=r[1];W.multiply(t,new Float32Array([Math.cos(c),Math.sin(c),0,0,-Math.sin(c),Math.cos(c),0,0,0,0,1,0,0,0,0,1]),t);break;case"sx":var u=r[1];t[0]*=u,t[1]*=u,t[2]*=u,t[3]*=u;break;case"sy":var h=r[1];t[4]*=h,t[5]*=h,t[6]*=h,t[7]*=h;break;case"sz":var f=r[1];t[8]*=f,t[9]*=f,t[10]*=f,t[11]*=f;break;case"scale":u=r[1].x??1,h=r[1].y??1,f=r[1].z??1,t[0]*=u,t[1]*=u,t[2]*=u,t[3]*=u,t[4]*=h,t[5]*=h,t[6]*=h,t[7]*=h,t[8]*=f,t[9]*=f,t[10]*=f,t[11]*=f}}return t}static lookAt(e,t,n=X.up(),r){r=r||new Float32Array(16);var i=X.normalize(X.subtract(e,t)),a=X.normalize(X.cross(n,i)),o=X.cross(i,a);return H(r,a.x,a.y,a.z,0,o.x,o.y,o.z,0,i.x,i.y,i.z,0,e.x,e.y,e.z,1),r}static lookInDirection(e,t,n=X.up(),r){r=r||new Float32Array(16);var i=X.normalize(t),a=X.cross(n,i),o=X.normalizeTo(a),s=X.cross(i,o);return H(r,o.x,o.y,o.z,0,s.x,s.y,s.z,0,i.x,i.y,i.z,0,e.x,e.y,e.z,1),r}static perspective(e={},t){t=t||new Float32Array(16);var n=e.fov||1.5,r=e.aspect||1,i=e.near||.1,a=e.far||100,o=Math.sin(n),s=1/(a-i),l=Math.cos(n)/o;return H(t,l/r,0,0,0,0,l,0,0,0,0,-(a+i)*s,-1,0,0,-2*i*a*s,0),t}static setPerspectiveFov(e,t,n){var r=Math.cos(n)/Math.sin(n);e[0]=r/t,e[5]=r}static orthographic(e={},t){t=t||new Float32Array(16);var n=e.top||e.size||5,r=e.bottom||-e.size||-5,i=e.left||-e.size||5,a=e.right||e.size||-5,o=e.far||100,s=e.near||1;return H(t,2/(a-i),0,0,0,0,2/(n-r),0,0,0,0,-2/(o-s),0,-(a+i)/(a-i),-(n+r)/(n-r),-(o+s)/(o-s),1),t}static transformVector(e,t,n){n=n||new X;const r=t.x,i=t.y,a=t.z;return n.x=e[0]*r+e[4]*i+e[8]*a+e[12],n.y=e[1]*r+e[5]*i+e[9]*a+e[13],n.z=e[2]*r+e[6]*i+e[10]*a+e[14],n}static transformDirection(e,t){for(var n=[],r=0;r<4;r++)n[r]=e[r]*t.x+e[r+4]*t.y+e[r+8]*t.z+0*e[r+12];return{x:n[0],y:n[1],z:n[2]}}static fromQuaternion(e,t){return t=t||new Float32Array(16),j.normalizeTo(e),H(t,1-2*e.y*e.y-2*e.z*e.z,2*e.x*e.y-2*e.z*e.w,2*e.x*e.z+2*e.y*e.w,0,2*e.x*e.y+2*e.z*e.w,1-2*e.x*e.x-2*e.z*e.z,2*e.y*e.z-2*e.x*e.w,0,2*e.x*e.z-2*e.y*e.w,2*e.y*e.z+2*e.x*e.w,1-2*e.x*e.x-2*e.y*e.y,0,0,0,0,1),W.transpose(t,t),t}static get(e,t,n){return e[t+4*n]}static isMatrix(e){return e instanceof Float32Array&&16==e.length}static pprint(e){e=W.transpose(e),console.table([[...e.slice(0,4)],[...e.slice(4,8)],[...e.slice(8,12)],[...e.slice(12,16)]])}}function q(e,t,n){var r=Math.max(e,t,n);if(r<1e-32)return[0,0,0,0];var[i,a]=function(e){const t=[e=Number(e),0];if(0!==e&&Number.isFinite(e)){const n=Math.abs(e),r=Math.log2||function(e){return Math.log(e)*Math.LOG2E};let i=Math.max(-1023,Math.floor(r(n))+1),a=n*Math.pow(2,-i);for(;a<.5;)a*=2,i--;for(;a>=1;)a*=.5,i++;e<0&&(a=-a),t[0]=a,t[1]=i}return t}(r);return r=256*i/r,[parseInt(e*r),parseInt(t*r),parseInt(n*r),parseInt(a+128)]}async function Y(e){const t=await fetch(e),n=await t.arrayBuffer();console.time("Load hdr");for(var r=0,i=new Uint8Array(n),a="";!a.match(/\n\n[^\n]+\n/g);)a+=String.fromCharCode(i[r++]);var o=a.match(/FORMAT=(.*)$/m)[1];if("32-bit_rle_rgbe"!=o)return this.onerror(),console.warn("unknown format : "+o);var s=a.split(/\n/).reverse()[1].split(" "),l=parseInt(s[3]),c=parseInt(s[1]);const u=new Uint8Array(l*c*4);let h=0;const f=new Uint8Array(4*l);for(let e=0;e<c;e++){const e=i.subarray(r,r+=4);if(2!=e[0]||2!=e[1]||128&e[2]){let e=l,t=0;for(r-=4;e>0;)if(u.set(i.slice(r,r+=4),h),1==u[h]&&1==u[h+1]&&1==u[h+2]){for(u[h+3];d>0;d--)u.set(u.slice(h-4,h),h),h+=4,e--;t+=8}else e--,h+=4,t=0}else{if((e[2]<<8)+e[3]!=l)return void console.warn("HDR line mismatch ..");for(var d=0;d<4;d++){let e,t=d*l,n=(d+1)*l;for(;t<n;){let n=i[r],a=i[r+1];if(r+=2,n>128)e=n-128,f.fill(a,t,t+e),t+=e;else for(e=n-1,f[t++]=a;e-- >0;)f[t++]=i[r++]}}for(d=0;d<l;d++)u[h++]=f[d],u[h++]=f[d+l],u[h++]=f[d+2*l],u[h++]=f[d+3*l]}}return console.timeEnd("Load hdr"),{data:u,width:l,height:c}}function K(e,t){let n=[];for(let r=0;r<3;r++){let i=e[r],a=X.subtract(e[(r+1)%3],e[r]),o=X.normalize(a),s=X.length(a),l=J(i,o,t[0],t[1],t[2]);l&&l.distance>=0&&l.distance<=s&&(n.push({hit:l,from:e[r],to:e[(r+1)%3]}),window.gldebug&&window.gldebug.Point(l.point,.02))}if(2==n.length){let n,r,i=-1/0,a=-1/0;for(let n of e){let e=X.dot(X.subtract(n,t[0]),le(t));Q(n,t[0],t[1],t[2])&&e<=0&&Math.abs(e)>a&&(a=Math.abs(e),r={point:n,normal:le(t),depth:-Math.abs(e)})}let o,s=1/0;if(console.log(n,r),n||r)return Math.min(i,a)<s?i<a&&n||!r?[n]:[r]:(console.log("test1",o),[o])}let r=[];for(let n=0;n<3;n++){let i=t[n],a=X.subtract(t[(n+1)%3],t[n]),o=X.normalize(a),s=X.length(a),l=J(i,o,e[0],e[1],e[2]);l&&l.distance>=0&&l.distance<=s&&r.push({hit:l,from:t[n],to:t[(n+1)%3]})}if(1==n.length&&1==r.length){let i=null,a=1/0;for(let t=0;t<3;t++){let n=he(e[t],e[(t+1)%3],r[0].hit.point);if(n<a){a=n;let o=fe(e[t],e[(t+1)%3],r[0].hit.point);i={edge:[e[t],e[(t+1)%3]],normal:X.normalize(X.subtract(r[0].hit.point,o)),point:o,depth:-X.distance(o,r[0].hit.point)}}}for(let e=0;e<3;e++){let r=he(t[e],t[(e+1)%3],n[0].hit.point);if(r<a){a=r;let o=fe(t[e],t[(e+1)%3],n[0].hit.point);i={edge:[t[e],t[(e+1)%3]],normal:X.negate(X.normalize(X.subtract(n[0].hit.point,o))),point:n[0].hit.point,depth:-X.distance(o,n[0].hit.point)}}}return[{depth:i.depth,point:i.point,normal:i.normal}]}if(2==r.length){console.info("2 b inters",e,t);const n=K(t,e);if(console.log(n),!n)return null;console.log("not null");const r=n[0],i=X.add(r.point,X.multiply(r.normal,r.depth)),a=X.negate(r.normal);return[{depth:r.depth,point:i,normal:a}]}return r.length>2&&console.error("hhhhm"),null}function $(e,t){return e.tr.x>=t.bl.x&&e.bl.x<=t.tr.x&&e.tr.y>=t.bl.y&&e.bl.y<=t.tr.y&&e.tr.z>=t.bl.z&&e.bl.z<=t.tr.z}function Q(e,t,n,r){var i=X.normalize(X.cross(X.subtract(n,t),X.subtract(r,t))),a=X.dot(e,i)-X.dot(t,i),o=X.add(e,X.multiply(i,-a)),s=r.x-t.x,l=r.y-t.y,c=r.z-t.z,u=n.x-t.x,h=n.y-t.y,f=n.z-t.z,d=o.x-t.x,m=o.y-t.y,v=o.z-t.z,g=s*s+l*l+c*c,p=s*u+l*h+c*f,x=s*d+l*m+c*v,b=u*u+h*h+f*f,y=u*d+h*m+f*v,T=g*b-p*p;if(Math.abs(T)<1e-30)return null;var w=1/T,E=(b*x-p*y)*w,_=(g*y-p*x)*w;return E>=0&&_>=0&&E+_<1?o:null}{let e=new X,t=new X,n=new X,r=new X,i=new X,a=new X;var J=function(o,s,l,c,u){X.subtract(c,l,e),X.subtract(u,l,t),X.cross(s,t,n);var h=X.dot(e,n);if(h>-1e-7&&h<1e-7)return!1;var f=1/h;X.subtract(o,l,r);var d=X.dot(r,n)*f;if(d<0||d>1)return!1;X.cross(r,e,i);var m=f*X.dot(s,i);if(m<0||d+m>1)return!1;var v=f*X.dot(t,i);return v>1e-7&&(X.set(a,s),X.multiplyTo(a,v),X.addTo(a,o),{point:X.copy(a),distance:v})}}var Z=[new X(1,0,0),new X(0,1,0),new X(0,0,1)],ee=["x","y","z"];function te(e,t){var n=1/0,r=-1/0;for(var i of e){var a=X.dot(t,i);a<n&&(n=a),a>r&&(r=a)}return[n,r]}function ne(e,t,n,r){return Math.max(e.x,t.x,n.x)>=r.bl.x&&Math.min(e.x,t.x,n.x)<=r.tr.x&&Math.max(e.y,t.y,n.y)>=r.bl.y&&Math.min(e.y,t.y,n.y)<=r.tr.y&&Math.max(e.z,t.z,n.z)>=r.bl.z&&Math.min(e.z,t.z,n.z)<=r.tr.z}function re(e,t,n,r,i,a){return Math.max(e.x,t.x,n.x)>=Math.min(r.x,i.x,a.x)&&Math.min(e.x,t.x,n.x)<=Math.max(r.x,i.x,a.x)&&Math.max(e.y,t.y,n.y)>=Math.min(r.y,i.y,a.y)&&Math.min(e.y,t.y,n.y)<=Math.max(r.y,i.y,a.y)&&Math.max(e.z,t.z,n.z)>=Math.min(r.z,i.z,a.z)&&Math.min(e.z,t.z,n.z)<=Math.max(r.z,i.z,a.z)}const ie={bl:new X,tr:new X};function ae(e,t,n,r,i){return ie.bl.x=Math.min(n.x,r.x,i.x),ie.bl.y=Math.min(n.y,r.y,i.y),ie.bl.z=Math.min(n.z,r.z,i.z),ie.tr.x=Math.max(n.x,r.x,i.x),ie.tr.y=Math.max(n.y,r.y,i.y),ie.tr.z=Math.max(n.z,r.z,i.z),se(e,t,ie)}const oe={min:0,max:0};function se(e,t,n){var r=(n.bl.x-e.x)/t.x,i=(n.tr.x-e.x)/t.x,a=(n.bl.y-e.y)/t.y,o=(n.tr.y-e.y)/t.y,s=(n.bl.z-e.z)/t.z,l=(n.tr.z-e.z)/t.z,c=Math.max(Math.max(Math.min(r,i),Math.min(a,o)),Math.min(s,l)),u=Math.min(Math.min(Math.max(r,i),Math.max(a,o)),Math.max(s,l));return!(u<0)&&!(c>u)&&(oe.min=c,oe.max=u,oe)}function le(e){return X.normalize(X.cross(X.subtract(e[1],e[0]),X.subtract(e[2],e[0])))}function ce(e,t,n,r,i,a=!1){var o=le([n,r,i]),s=X.dot(X.subtract(e,n),o);if(!a&&s<0)return!1;if(s<-t||s>t)return!1;var l=X.subtract(e,X.multiply(o,s)),c=X.cross(X.subtract(l,n),X.subtract(r,n)),u=X.cross(X.subtract(l,r),X.subtract(i,r)),h=X.cross(X.subtract(l,i),X.subtract(n,i)),f=X.dot(c,o)<=0&&X.dot(u,o)<=0&&X.dot(h,o)<=0,d=t*t,m=fe(n,r,e),v=X.subtract(e,m),g=X.dot(v,v)<d,p=fe(r,i,e),x=X.subtract(e,p);g|=X.dot(x,x)<d;var b=fe(i,n,e),y=X.subtract(e,b);if(g|=X.dot(y,y)<d,f||g){var T,w=l;if(f)T=X.subtract(e,l);else{var E=X.subtract(e,m),_=X.dot(E,E);w=m,T=E,E=X.subtract(e,p);var M=X.dot(E,E);M<_&&(_=M,w=p,T=E),E=X.subtract(e,b),(M=X.dot(E,E))<_&&(_=M,w=b,T=E)}var R=X.length(T),C=X.normalize(T);return X.lengthSqr(C)<1e-4&&(C=o),{normal:C,depth:t-R,point:w}}return!1}function ue(e,t,n,r,i,a,o=!1){var s,l=X.normalize(X.subtract(t,e)),c=X.multiply(l,n),u=X.subtract(e,c),h=(X.add(t,c),le([r,i,a])),f=X.dot(h,l);if(Math.abs(f)<1e-5)s=X.copy(e);else{var d=X.dot(h,X.divide(X.subtract(r,u),f));s=X.add(u,X.multiply(l,d))}var m,v=X.cross(X.subtract(s,r),X.subtract(i,r)),g=X.cross(X.subtract(s,i),X.subtract(a,i)),p=X.cross(X.subtract(s,a),X.subtract(r,a));if(X.dot(v,h)<=0&&X.dot(g,h)<=0&&X.dot(p,h)<=0)m=s;else{var x=fe(r,i,s),b=X.subtract(s,x),y=E=X.dot(b,b);m=x;var T=fe(i,a,s),w=X.subtract(s,T);(E=X.dot(w,w))<y&&(m=T,y=E);var E,_=fe(a,r,s),M=X.subtract(s,_);(E=X.dot(M,M))<y&&(m=_,y=E)}return ce(fe(e,t,m),n,r,i,a,o)}function he(e,t,n){return X.distance(fe(e,t,n),n)}function fe(e,t,n){var r=X.subtract(t,e),i=X.dot(X.subtract(n,e),r)/X.dot(r,r);return X.add(e,X.multiply(r,function(e){return y(e,0,1)}(i)))}function de(){this.wrapMode=de.WrapModes.Clamp;var e=[],t=1/0,n=-1/0;this.addStage=function(r,i){e.some((e=>e.t==r))?console.warn("Time "+r+" already has a value!"):(e.push({t:r,value:i}),e.sort(((e,t)=>e.t-t.t)),t=Math.min(t,e[0].t),n=Math.max(n,e[e.length-1].t))};var r=e=>{return this.wrapMode==de.WrapModes.Clamp?y(e,t,n):this.wrapMode==de.WrapModes.Repeat?((e-t)%(r=n-t)+r)%r+t:y(e,t,n);var r};this.getValue=function(t){if(0==e.length)return 0;t=r(t);for(var n=e[0],i=e[1],a=0;a<e.length;a++)t>=e[a].t&&(n=e[a],i=e[Math.min(e.length-1,a+1)]);var o=w(n.t,i.t,t);return T(n.value,i.value,o)}}function me(e,t=.5,n=!1){this.alpha=t,this.points=e,this.loop=n;for(var r=[],i=0;i<e.length-(this.loop?0:3);i++)r.push(new ve(e[(i+0)%e.length],e[(i+1)%e.length],e[(i+2)%e.length],e[(i+3)%e.length],this.alpha));this.distanceToPoint=function(e){var t=this.distanceSqrToPoint(e);return{distance:Math.sqrt(t.distance),point:t.point}},this.distanceSqrToPoint=function(e){var t,n=1/0;for(var i of r){var a=i.distanceSqrToPoint(e);a.distance<n&&(n=a.distance,t=a.point)}return{distance:n,point:t}},this.getPoint=function(e){if(this.loop)e=b(e,1);else{if(e<=0)return r[0].getPoint(e);if(e>=1)return r[r.length-1].getPoint(e)}var t=Math.floor(e*r.length);return r[t].getPoint(e*r.length%1)}}function ve(e,t,n,r,i=.5){function a(e,t,n,r,i){return X.lerp(n,r,(i-e)/(t-e))}function o(e,t){return Math.pow(X.distanceSqr(e,t),i/2)}this.p0=e,this.p1=t,this.p2=n,this.p3=r,this.alpha=i,this.distanceToPoint=function(e){var t=this.distanceSqrToPoint(e);return{distance:Math.sqrt(t.distance),point:t.point}},this.distanceSqrToPoint=function(e){var t,n=X.copy(e);n.y=0;for(var r=.5,i=0,a=1;r>=.095;)i=(t=this._getClosestDistanceInRange(n,i,a,r)).t-r,a=t.t+r,r/=2;return{distance:t.distance,point:t.point,t:t.t}},this._getClosestDistanceInRange=function(e,t,n,r){var i,a,o=1/0;t=Math.max(0,t),n=Math.min(1,n);for(var s=t;s<=n;s+=r){var l=this.getPoint(s),c=X.distanceSqr(e,new X(l.x,0,l.z));c<o&&(o=c,i=l,a=s)}return{distance:o,point:i,t:a}},this.getPoint=function(e){var t=o(this.p0,this.p1),n=o(this.p1,this.p2)+t,r=o(this.p2,this.p3)+n,i=T(t,n,e),s=a(0,t,this.p0,this.p1,i),l=a(t,n,this.p1,this.p2,i),c=a(n,r,this.p2,this.p3,i),u=a(0,n,s,l,i),h=a(t,r,l,c,i);return a(t,n,u,h,i)}}function ge(e,t=5){this.aabb=e,this.children=[],this.items=[],this.maxDepth=t,this.divided=!1,this.trianglesArray=null,this.gameObjectLookup=null,this.gameObjects=null,this.query=function(e,t){var n=this._query((n=>se(e,t,n)));if(!n)return!1;var r=new Array(n.length),i=new Array(n.length);for(let e=0;e<n.length;e++)r[e]=this.getTriangleFromIndex(this.trianglesArray,n[e]),this.gameObjectLookup&&(i[e]=this.gameObjectLookup[n[e]/9]);return{triangles:r,gameObjectIndices:i}},this.queryAABB=function(e){var t=this._query((t=>$(t,e)));if(!t)return!1;var n=new Array(t.length),r=new Array(t.length);for(let e=0;e<t.length;e++)n[e]=this.getTriangleFromIndex(this.trianglesArray,t[e]);return{triangles:n,nameIndices:r}},this._query=function(e,t=[]){if(e(this.aabb)){for(let e=0;e<this.items.length;e++)t.push(this.items[e]);for(let n=0;n<this.children.length;n++)this.children[n]._query(e,t);return t}},this.addTriangles=function(e,t,n){"undefined"!=typeof window&&(window.aabbcalls=0),this.trianglesArray=e,this.gameObjectLookup=t,this.gameObjects=n;for(var r=0;r<this.trianglesArray.length;r+=9){var i={x:this.trianglesArray[r+0],y:this.trianglesArray[r+1],z:this.trianglesArray[r+2]},a={x:this.trianglesArray[r+3],y:this.trianglesArray[r+4],z:this.trianglesArray[r+5]},o={x:this.trianglesArray[r+6],y:this.trianglesArray[r+7],z:this.trianglesArray[r+8]};this.addTriangle(r,[i,a,o])}},this.addTriangle=function(e,t,n=0){if(n>=this.maxDepth||!ne(t[0],t[1],t[2],this.aabb)||!function(e,t){for(var n=0;n<3;n++)if(r=e,(i=t[n]).x>=r.bl.x&&i.y>=r.bl.y&&i.z>=r.bl.z&&i.x<=r.tr.x&&i.y<=r.tr.y&&i.z<=r.tr.z)return!0;var r,i,a,o,s,l,c=function(e){return[{x:e.bl.x,y:e.bl.y,z:e.bl.z},{x:e.tr.x,y:e.bl.y,z:e.bl.z},{x:e.tr.x,y:e.bl.y,z:e.tr.z},{x:e.bl.x,y:e.bl.y,z:e.tr.z},{x:e.bl.x,y:e.tr.y,z:e.bl.z},{x:e.tr.x,y:e.tr.y,z:e.bl.z},{x:e.tr.x,y:e.tr.y,z:e.tr.z},{x:e.bl.x,y:e.tr.y,z:e.tr.z}]}(e);for(n=0;n<3;n++){var[a,o]=te(t,Z[n]);if(o<e.bl[ee[n]]||a>e.tr[ee[n]])return!1}var u=le(t),h=X.dot(u,t[0]),[s,l]=te(c,u);if(l<h||s>h)return!1;var f=[X.subtract(t[0],t[1]),X.subtract(t[1],t[2]),X.subtract(t[2],t[0])];for(n=0;n<3;n++)for(var d=0;d<3;d++){var m=X.cross(f[n],Z[n]),[s,l]=te(c,m),[a,o]=te(t,m);if(l<a||s>o)return!1}return!0}(this.aabb,t))return!1;this.divided||(this.subdivide(),this.divided=!0);for(var r=!1,i=0;i<this.children.length;i++)this.children[i].addTriangle(e,t,n+1)&&(r=!0);return r||this.items.push(e),!0},this.getTriangleFromIndex=function(e,t){return[{x:e[t+0],y:e[t+1],z:e[t+2]},{x:e[t+3],y:e[t+4],z:e[t+5]},{x:e[t+6],y:e[t+7],z:e[t+8]}]},this.getGameObjectFromIndex=function(e){return Array.isArray(this.gameObjects)?this.gameObjects[e]:null},this.subdivide=function(){this.children.push(new ge(new pe(this.aabb.bl,X.average(this.aabb.bl,this.aabb.tr)),this.maxDepth),new ge(new pe({x:(this.aabb.bl.x+this.aabb.tr.x)/2,y:this.aabb.bl.y,z:this.aabb.bl.z},{x:this.aabb.tr.x,y:(this.aabb.bl.y+this.aabb.tr.y)/2,z:(this.aabb.bl.z+this.aabb.tr.z)/2}),this.maxDepth),new ge(new pe({x:this.aabb.bl.x,y:this.aabb.bl.y,z:(this.aabb.bl.z+this.aabb.tr.z)/2},{x:(this.aabb.bl.x+this.aabb.tr.x)/2,y:(this.aabb.bl.y+this.aabb.tr.y)/2,z:this.aabb.tr.z}),this.maxDepth),new ge(new pe({x:(this.aabb.bl.x+this.aabb.tr.x)/2,y:this.aabb.bl.y,z:(this.aabb.bl.z+this.aabb.tr.z)/2},{x:this.aabb.tr.x,y:(this.aabb.bl.y+this.aabb.tr.y)/2,z:this.aabb.tr.z}),this.maxDepth),new ge(new pe({x:this.aabb.bl.x,y:(this.aabb.bl.y+this.aabb.tr.y)/2,z:this.aabb.bl.z},{x:(this.aabb.bl.x+this.aabb.tr.x)/2,y:this.aabb.tr.y,z:(this.aabb.bl.z+this.aabb.tr.z)/2}),this.maxDepth),new ge(new pe({x:(this.aabb.bl.x+this.aabb.tr.x)/2,y:(this.aabb.bl.y+this.aabb.tr.y)/2,z:this.aabb.bl.z},{x:this.aabb.tr.x,y:this.aabb.tr.y,z:(this.aabb.bl.z+this.aabb.tr.z)/2}),this.maxDepth),new ge(new pe({x:this.aabb.bl.x,y:(this.aabb.bl.y+this.aabb.tr.y)/2,z:(this.aabb.bl.z+this.aabb.tr.z)/2},{x:(this.aabb.bl.x+this.aabb.tr.x)/2,y:this.aabb.tr.y,z:this.aabb.tr.z}),this.maxDepth),new ge(new pe(X.average(this.aabb.bl,this.aabb.tr),this.aabb.tr),this.maxDepth))},this.render=function(e,t=!0){if(0==this.children.length){var n=this.aabb;e.root.getChild("AABB").meshRenderer.addInstance(W.transform([["translate",X.divide(X.add(n.bl,n.tr),2)],["sx",(n.tr.x-n.bl.x)/2],["sy",(n.tr.y-n.bl.y)/2],["sz",(n.tr.z-n.bl.z)/2]]),!1)}else for(var r=0;r<this.children.length;r++)this.children[r].render(e,!1);t&&e.root.getChild("AABB").meshRenderer.updateMatrixData()}}function pe(e,t){"undefined"!=typeof window&&window.aabbcalls++,this.bl=e,this.tr=t}function xe(e,t){this.isEmpty=!e&&!t,this.bl=e??X.zero(),this.tr=t??X.zero();var n=X.fill(1/0),r=X.fill(-1/0);this.copy=function(e){let t=e||new xe;return t.bl=X.copy(this.bl),t.tr=X.copy(this.tr),t.isEmpty=this.isEmpty,t},this.addPadding=function(e=0){this.bl.x-=e,this.bl.y-=e,this.bl.z-=e,this.tr.x+=e,this.tr.y+=e,this.tr.z+=e},this.extend=function(e){if(e instanceof xe){var t=e;X.compFunc(this.isEmpty?n:this.bl,t.bl,Math.min,this.bl),X.compFunc(this.isEmpty?r:this.tr,t.tr,Math.max,this.tr)}else if(X.isVectorIsh(e)){var i=e;X.compFunc(this.isEmpty?n:this.bl,i,Math.min,this.bl),X.compFunc(this.isEmpty?r:this.tr,i,Math.max,this.tr)}else this.addPadding(e);this.isEmpty=!1},this.pointInside=function(e){return e.x>=this.bl.x&&e.y>=this.bl.y&&e.z>=this.bl.z&&e.x<=this.tr.x&&e.y<=this.tr.y&&e.z<=this.tr.z},this.getVertices=function(){return[{x:this.bl.x,y:this.bl.y,z:this.bl.z},{x:this.tr.x,y:this.bl.y,z:this.bl.z},{x:this.tr.x,y:this.bl.y,z:this.tr.z},{x:this.bl.x,y:this.bl.y,z:this.tr.z},{x:this.bl.x,y:this.tr.y,z:this.bl.z},{x:this.tr.x,y:this.tr.y,z:this.bl.z},{x:this.tr.x,y:this.tr.y,z:this.tr.z},{x:this.bl.x,y:this.tr.y,z:this.tr.z}]},this.getEdges=function(){return[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]]};const i=new X;this.getCenter=function(){return X.average(this.tr,this.bl,i),X.copy(i)};const a=new X;this.getSize=function(){return X.subtract(this.tr,this.bl,a),X.copy(a)},this.translate=function(e){X.addTo(this.bl,e),X.addTo(this.tr,e)};const o=new X;this.approxTransform=function(e){var t=this.getVertices();for(var n of(this.isEmpty=!0,X.zero(this.bl),X.zero(this.tr),t))W.transformVector(e,n,o),this.extend(o);return this},this.isInsideFrustum=function(e){return this.isAbovePlane(e.leftPlane)&&this.isAbovePlane(e.rightPlane)&&this.isAbovePlane(e.nearPlane)&&this.isAbovePlane(e.farPlane)&&this.isAbovePlane(e.topPlane)&&this.isAbovePlane(e.bottomPlane)};const s=new X;this.isAbovePlane=function(e){return X.subtract(this.tr,this.bl,s),X.divideTo(s,2),X.average(this.tr,this.bl,i),-(s.x*Math.abs(e.normal.x)+s.y*Math.abs(e.normal.y)+s.z*Math.abs(e.normal.z))<=e.getSignedDistanceToPlane(i)}}function be(e,t,n){var r=new xe;return e.traverse((e=>{if((!n||!n.includes(e))&&e.meshRenderer&&!e.meshRenderer.skin)for(var t=0;t<e.meshRenderer.meshData.length;t++){var i=e.meshRenderer.meshData[t];if(i.data.position&&i.data.indices)for(var a=0;a<i.data.position.bufferData.length;a+=3){var o={x:i.data.position.bufferData[a],y:i.data.position.bufferData[a+1],z:i.data.position.bufferData[a+2]};o=W.transformVector(e.transform.worldMatrix,o),r.extend(o)}}})),t&&r.addPadding(t),r}function ye(e,t={}){if(void 0!==e&&!(e instanceof Ve))throw new Error("scene is not of class 'Scene'");var n=this;this.scene=e,this.gravity=new X(0,-9.82,0);var r=[];let i=[];this.constraintIterations=20,this.constraintBias=.4,this.dt=1/60;var a=performance.now(),o=0;this.time=0,this.multipleTimestepsPerFrame=t.multipleTimestepsPerFrame??!0,this.fixedUpdate=()=>{};var s=[];this.octree=new ge(new xe(X.fill(-1),X.fill(1)),t.octreeLevels??4),this.eventHandler=new Pe,this.on=this.eventHandler.on.bind(this.eventHandler),this.add=function(e){return r.push(e),e},this.Raycast=function(e,t){let n,r,i,a,o=1/0;var s=this.octree.query(e,t);if(s){let l=s.triangles;for(let c=0;c<l.length;c++){let u=J(e,t,l[c][0],l[c][1],l[c][2]);u&&u.distance<o&&(o=u.distance,n=l[c],r=u.point,i=s.gameObjectIndices[c],a=this.octree)}}if(this.scene&&this.scene.root.traverseCondition((function(s){var l=s.getComponents();for(var c of l)if("MeshCollider"==c.type){var u=c;if(u.octree){var h=u.octree.query(e,t);if(h){let s=h.triangles;for(var f=0;f<s.length;f++)if(ae(e,t,s[f][0],s[f][1],s[f][2])){var d=J(e,t,s[f][0],s[f][1],s[f][2]);d&&d.distance<o&&(o=d.distance,n=s[f],r=d.point,i=h.gameObjectIndices[f],a=u.octree)}}}}}),(e=>e.active&&e.visible)),r&&n){let e=le(n),t=a.getGameObjectFromIndex(i);return{firstHit:{distance:o,normal:e,point:r,gameObject:t}}}return null},this.RaycastAll=function(e,t,n){n=n||[];var r=this.octree.query(e,t);if(r){let i,a,o,s=1/0,l=r.triangles;for(let n=0;n<l.length;n++){let c=J(e,t,l[n][0],l[n][1],l[n][2]);c&&c.distance<s&&(s=c.distance,i=le(l[n]),a=c.point,o=r.gameObjectIndices[n])}if(a){let e={distance:s,normal:i,point:a,gameObject:this.octree.getGameObjectFromIndex(o)};n.push(e)}}this.scene&&this.scene.root.traverseCondition((function(r){var i=r.getComponents();for(var a of i)if("MeshCollider"==a.type){var o=a;if(o.octree){var s=o.octree.query(e,t);if(s){let r=s.triangles;for(var l=0;l<r.length;l++)if(ae(e,t,r[l][0],r[l][1],r[l][2])){var c=J(e,t,r[l][0],r[l][1],r[l][2]);c&&n.push({distance:c.distance,normal:le(r[l]),point:c.point,gameObject:o.octree.getGameObjectFromIndex(s.gameObjectIndices[l])})}}}}}),(e=>e.active&&e.visible));for(var i,a=1/0,o=0;o<n.length;o++){var s=n[o].distance;s<a&&(a=s,i=n[o])}return{firstHit:i,allHits:n}},this.addMeshCollider=function(e){s.push(e)},this.setupMeshCollider=function(){var e;if(t.bounds)e=t.bounds;else for(var n of(e=new xe(X.zero(),X.zero()),s))e.extend(be(n,.1));for(var n of(this.octree=new ge(e,t.octreeLevels??4),s))this._addMeshToOctree(n);s=[]},this._addMeshToOctree=function(e){var t=0;e.traverse((e=>{if(e.meshRenderer)for(var n=0;n<e.meshRenderer.meshData.length;n++){var r=e.meshRenderer.meshData[n].data;t+=r.indices.bufferData.length/3}}));var n=[],r=0,i=new Uint16Array(t),a=new Float32Array(3*t*3);e.traverse((e=>{if(e.meshRenderer){n.push(e);let d=n.length-1;for(var t=e.transform.worldMatrix,o=0;o<e.meshRenderer.meshData.length;o++)for(var s=e.meshRenderer.meshData[o].data,l=0;l<s.indices.bufferData.length;l+=3){for(var c=0;c<3;c++){var u=3*s.indices.bufferData[l+c],h=X.fromArray(s.position.bufferData,u);h={x:h.x,y:h.y,z:h.z};var f=W.transformVector(t,h);a[9*r+3*c+0]=f.x,a[9*r+3*c+1]=f.y,a[9*r+3*c+2]=f.z}i[r]=d,r++}}})),this.octree.addTriangles(a,i,n)};var l=()=>{i=[];var e=[],t=[];for(var a of(this.scene&&this.scene.root.traverseCondition((r=>{var a=r.findComponents("Rigidbody")[0];if(a){e.push(a),a.grounded=!1;let R=!1;var o=a.gameObject.findComponents("SphereCollider");for(let e of o){R=!0;var s=W.removeTranslation(W.copy(a.gameObject.transform.worldMatrix)),l=X.add(a.position,W.transformVector(s,e.offset)),c=X.fill(1.1*e.radius),u=n.octree.queryAABB(new xe(X.subtract(l,c),X.add(l,c)))?.triangles;if(u)for(var h=0;h<u.length;h++)if(x=ce(l,e.radius,u[h][0],u[h][1],u[h][2],!0)){var f=x.normal,d=X.add(l,X.multiply(f,-e.radius));i.push({C:-x.depth,bodies:[{collider:e,body:a,normal:f,p:d}]})}}var m=a.gameObject.findComponents("CapsuleCollider");for(let e of m){R=!0,s=W.removeTranslation(W.copy(a.gameObject.transform.worldMatrix));var v=X.add(a.position,W.transformVector(s,e.a)),g=X.add(a.position,W.transformVector(s,e.b)),p=(c=X.fill(10*e.radius),X.average(v,g));if(u=n.octree.queryAABB(new xe(X.subtract(p,c),X.add(p,c)))?.triangles,u)for(h=0;h<u.length;h++){var x;if(x=ue(v,g,e.radius,u[h][0],u[h][1],u[h][2],!0)){var b=X.dot(X.up(),x.normal),y=(f=X.length(X.projectOnPlane(a.velocity,x.normal))<2&&b>.8?new X(0,1,0):x.normal,f=x.normal,x.depth/X.dot(f,x.normal));d=X.add(x.point,X.multiply(x.normal,-x.depth)),i.push({C:-y,bodies:[{collider:e,body:a,normal:f,p:d}]}),X.dot(X.up(),f)>.5&&(a.grounded=!0,a.groundNormal=f),Debug.Vector(d,f,y)}}}var T=a.gameObject.findComponents("BoxCollider");for(let e of T){R=!0;var w=e.planeY,E=e.gameObject.transform.worldMatrix;for(var _ of e.aabb.getVertices()){var M=W.transformVector(E,_);M.y<w&&i.push({C:M.y-w,bodies:[{collider:e,body:a,normal:X.up(),p:M}]})}}let C=[],F=a.gameObject.findComponents("MeshCollider");for(let e of F){R=!0;let t=r.transform.worldMatrix,n=e.gameObject.meshRenderer.getAABB().approxTransform(t);this.scene.root.traverseCondition((i=>{if(i===r)return;let o=i.transform.worldMatrix,s=i.findComponents("MeshCollider");for(let r of s)if(r.gameObject&&r.gameObject.meshRenderer){let s=i.meshRenderer.getAABB().approxTransform(o);if(!s||!$(n,s))return;for(let n=0;n<r.gameObject.meshRenderer.meshData.length;n++){let i=r.gameObject.meshRenderer.meshData[n].data;for(let n=0;n<i.indices.bufferData.length;n+=3){let r=[];for(let e=0;e<3;e++){let t=3*i.indices.bufferData[n+e],a=X.fromArray(i.position.bufferData,t);a={x:a.x,y:a.y,z:a.z};let s=W.transformVector(o,a);r.push(s)}if(e.gameObject&&e.gameObject.meshRenderer)for(let n=0;n<e.gameObject.meshRenderer.meshData.length;n++){let i=e.gameObject.meshRenderer.meshData[n].data;for(let n=0;n<i.indices.bufferData.length;n+=3){let o=[];for(let e=0;e<3;e++){let r=3*i.indices.bufferData[n+e],a=X.fromArray(i.position.bufferData,r);a={x:a.x,y:a.y,z:a.z};let s=W.transformVector(t,a);o.push(s)}if(ne(o[0],o[1],o[2],s)&&re(o[0],o[1],o[2],r[0],r[1],r[2])){let t=K(o,r);if(t)for(let n of t)window.gldebug&&window.gldebug.Vector(n.point,n.normal,-1e3*n.depth),C.push({C:n.depth,bodies:[{collider:e,body:a,normal:n.normal,p:n.point}]})}}}}}}}))}i=i.concat(C),R&&t.push(a)}}),(e=>e.active&&e.visible)),t))for(var o of t)if(a!=o)for(var s of a.gameObject.findComponents("SphereCollider"))for(var l of o.gameObject.findComponents("SphereCollider"))if((p=X.distance(a.position,o.position)-(s.radius+l.radius))<0){var c=X.normalize(X.subtract(a.position,o.position)),u=X.add(a.position,X.multiply(c,s.radius)),h=X.add(o.position,X.multiply(c,-l.radius));i.push({C:p,bodies:[{collider:s,body:a,normal:c,p:u},{collider:l,body:o,normal:X.negate(c),p:h}]})}for(var f of e)f.applyForces(this.dt);this.fixedUpdate(this.dt),this.eventHandler.fireEvent("fixedUpdate",this.dt);for(let e of r)e.fixedUpdate?.(this.dt);var d=new Array(i.length).fill(0);let m=new Array(r.length).fill(0);for(var v=0;v<this.constraintIterations;v++){for(let e=0;e<r.length;e++){let t=r[e];t.solveConstraint?.(this.dt,m,e)}for(var g=0;g<i.length;g++){var p,x=i[g];if((p=x.C??0)<-0){var b=[],T=[],w=[],E=[],_=[];if(x.bodies.length>0){for(var M of x.bodies){var R=M.collider.disableRotationImpulse?0:1,C=X.cross(X.subtract(M.p,M.body.position),M.normal);b.push(M.normal.x,M.normal.y,M.normal.z,C.x*R,C.y*R,C.z*R);var[F,A]=X.formOrthogonalBasis(M.normal);C=X.cross(X.subtract(M.p,M.body.position),F),T.push(F.x,F.y,F.z,C.x*R,C.y*R,C.z*R),C=X.cross(X.subtract(M.p,M.body.position),A),w.push(A.x,A.y,A.z,C.x*R,C.y*R,C.z*R),E.push(M.body.velocity.x,M.body.velocity.y,M.body.velocity.z,M.body.angularVelocity.x,M.body.angularVelocity.y,M.body.angularVelocity.z);var D=M.body.inverseWorldInertia;_.push(M.body.mass,M.body.mass,M.body.mass,1/D[0],1/D[5],1/D[10])}var{impulses:P,lambda:S}=Ce(b,E,_,p,this.dt,this.constraintBias,d,g);if(!P.some((e=>isNaN(e)))){var N=0;for(var M of x.bodies)M.body.velocity.x+=P[N+0]/_[N+0],M.body.velocity.y+=P[N+1]/_[N+1],M.body.velocity.z+=P[N+2]/_[N+2],M.body.lockRotation||(M.body.angularVelocity.x+=P[N+3]/_[N+3],M.body.angularVelocity.y+=P[N+4]/_[N+4],M.body.angularVelocity.z+=P[N+5]/_[N+5]),N+=6}var U=De(x.bodies);if(U>1e-4){var z=[T,w];for(var b of z){var L=Fe(Ae(b,_),b,E,0);L=y(L,-U*S,U*S);for(var P=[],B=0;B<b.length;B++)P[B]=b[B]*L;if(!P.some((e=>isNaN(e))))for(var M of(N=0,x.bodies))M.body.velocity.x+=P[N+0]/_[N+0],M.body.velocity.y+=P[N+1]/_[N+1],M.body.velocity.z+=P[N+2]/_[N+2],M.body.lockRotation||(M.body.angularVelocity.x+=P[N+3]/_[N+3],M.body.angularVelocity.y+=P[N+4]/_[N+4],M.body.angularVelocity.z+=P[N+5]/_[N+5]),N+=6}}}}}}for(let t of e)t.integrate(this.dt)};this.update=function(){if(this.multipleTimestepsPerFrame){var e=performance.now(),t=(e-a)/1e3;for(t=Math.min(t,.4),a=e,o+=t;o>=this.dt;)l(),o-=this.dt,this.time+=this.dt}else l(),this.time+=this.dt},this.getConstraintImpulse=Ce,this.getLambda=Fe,this.getEffectiveMass=Ae}de.WrapModes={Clamp:0,Repeat:1},xe.bounds=function(e){for(var t=X.fill(1/0),n=X.fill(-1/0),r=0;r<e.length;r++){var i=e[r];t=X.compFunc(t,i,Math.min),n=X.compFunc(n,i,Math.max)}return new xe(t,n)};class Te{constructor(){this.componentType="Collider",this.gameObject=null,this.isStatic=!1,this.friction=.5,this.disableRotationImpulse=!1}}class we extends Te{#e=null;constructor(){super(),this.componentType="MeshCollider",this.type="MeshCollider"}get octree(){return this.#e||this.#t(),this.#e}clear(){this.#e=null,this.aabb=null}#t(){if(this.gameObject&&this.gameObject.meshRenderer){var e=new xe(X.fill(1/0),X.fill(-1/0)),t=0;for(let e=0;e<this.gameObject.meshRenderer.meshData.length;e++)t+=this.gameObject.meshRenderer.meshData[e].data.indices.bufferData.length/3;var n=[this.gameObject],r=new Uint16Array(t),i=new Float32Array(3*t*3),a=0,o=this.gameObject.transform.worldMatrix;for(let t=0;t<this.gameObject.meshRenderer.meshData.length;t++){let n=this.gameObject.meshRenderer.meshData[t].data;for(var s=0;s<n.indices.bufferData.length;s+=3){for(var l=0;l<3;l++){var c=3*n.indices.bufferData[s+l],u=X.fromArray(n.position.bufferData,c);u={x:u.x,y:u.y,z:u.z};var h=W.transformVector(o,u);h.x<e.bl.x&&(e.bl.x=h.x),h.y<e.bl.y&&(e.bl.y=h.y),h.z<e.bl.z&&(e.bl.z=h.z),h.x>e.tr.x&&(e.tr.x=h.x),h.y>e.tr.y&&(e.tr.y=h.y),h.z>e.tr.z&&(e.tr.z=h.z),i[9*a+3*l+0]=h.x,i[9*a+3*l+1]=h.y,i[9*a+3*l+2]=h.z}r[a]=0,a++}}e.addPadding(.1),this.#e=new ge(e,1),this.#e.addTriangles(i,r,n),this.aabb=e}else this.#e=null,this.aabb=null}}class Ee extends Te{constructor(e=new xe(X.fill(-1),X.fill(1)),t=-5){super(),this.componentType="BoxCollider",this.aabb=e,this.planeY=t}}var _e=new X,Me=new X;class Re{#n=new X;#r=new X;#i=new j;#a=new W;constructor(){this.componentType="Rigidbody",this.gameObject=null,this.COMOffset=X.zero(),this.mass=1,this.position=X.zero(),this.velocity=X.zero(),this.acceleration=X.zero(),this.force=X.zero(),this._inertia=X.one(),this._inverseLocalInertiaMatrix=W.identity(),this.inverseWorldInertia=W.identity(),this.rotation=j.identity(),this.angularVelocity=X.zero(),this.torque=X.zero(),this.frozen=!1,this.lockRotation=!1,this.gravity=new X(0,-9.82,0),this.gravityScale=1,this._worldCOMOffset=X.zero(),this.lastVelocity=new X}set inertia(e){X.set(this._inertia,e),W.set(this._inverseLocalInertiaMatrix,1/this.inertia.x,0,0,0,0,1/this.inertia.y,0,0,0,0,1/this.inertia.z,0,0,0,0,1)}get inertia(){return this._inertia}_updateInverseWorldInertiaMatrix(){this.gameObject&&(W.copy(this.gameObject.transform.worldMatrix,this.#a),W.removeTranslation(this.#a),W.identity(this.inverseWorldInertia),W.multiply(this.#a,this._inverseLocalInertiaMatrix,this.inverseWorldInertia),W.transpose(this.#a,this.#a),W.multiply(this.inverseWorldInertia,this.#a,this.inverseWorldInertia))}_updateWorldCOMOffset(){this.gameObject?(W.copy(this.gameObject.transform.worldMatrix,this.#a),W.removeTranslation(this.#a),W.transformVector(this.#a,this.COMOffset,this._worldCOMOffset)):X.set(this._worldCOMOffset,this.COMOffset)}getWorldCOMOffset(){return this._worldCOMOffset}GetPointVelocity(e,t){t=t||new X;let n=this.getWorldCOMOffset();return X.set(_e,e),X.subtractTo(_e,this.position),X.subtractTo(_e,n),X.set(t,this.velocity),X.cross(this.angularVelocity,_e,Me),X.addTo(t,Me),t}AddForceAtPosition(e,t){if(X.isNaN(e))console.error("Force is NaN: ",e);else if(X.isNaN(t))console.error("Position is NaN: ",t);else if(!this.frozen){this.AddForce(e);var n=this.getWorldCOMOffset();X.set(_e,t),X.subtractTo(_e,this.position),X.subtractTo(_e,n),X.cross(_e,e,_e),this.AddTorque(_e)}}AddImpulseAtPosition(e,t){if(X.isNaN(e))console.error("Impulse is NaN: ",e);else if(X.isNaN(t))console.error("Position is NaN: ",t);else if(!this.frozen){X.set(_e,e),X.multiplyTo(_e,1/this.mass),X.addTo(this.velocity,_e);var n=this.getWorldCOMOffset();X.set(_e,t),X.subtractTo(_e,this.position),X.subtractTo(_e,n),X.cross(_e,e,_e),W.transformVector(this.inverseWorldInertia,_e,_e),X.addTo(this.angularVelocity,_e)}}AddForce(e){X.isNaN(e)?console.error("Force is NaN: ",e):this.frozen||X.addTo(this.force,e)}AddTorque(e){X.isNaN(e)?console.error("Torque is NaN: ",e):this.frozen||X.addTo(this.torque,e)}applyForces(e){this.frozen||(X.set(this.lastVelocity,this.velocity),X.set(this.#r,this.force),X.multiplyTo(this.#r,e/this.mass),X.addTo(this.velocity,this.#r),X.zero(this.force),X.set(this.#n,this.gravity),X.multiplyTo(this.#n,e*this.gravityScale),X.addTo(this.velocity,this.#n),this.lockRotation||(W.transformVector(this.inverseWorldInertia,this.torque,this.#r),X.addTo(this.angularVelocity,this.#r)),X.zero(this.torque))}integrate(e){this.frozen||(X.set(this.#r,this.velocity),X.multiplyTo(this.#r,e),X.addTo(this.position,this.#r),this.lockRotation?j.identity(this.rotation):(new j(this.angularVelocity.x,this.angularVelocity.y,this.angularVelocity.z,0,this.#i),this.rotation=j.add(this.rotation,j.multiply(j.QxQ(this.#i,this.rotation),e/2))),X.set(this.acceleration,this.velocity),X.subtractTo(this.acceleration,this.lastVelocity),X.multiplyTo(this.acceleration,e),this.updateGameObject())}updateGameObject(){null!=this.gameObject&&(this.gameObject.transform.position=this.position,this.gameObject.transform.rotation=this.rotation),this._updateInverseWorldInertiaMatrix(),this._updateWorldCOMOffset()}}function Ce(e,t,n,r,i,a=.5,o,s,l=-.01){var c;c=isNaN(parseFloat(l))?a/i*r:r<l?a/i*(r-l):0;var u=Fe(Ae(e,n),e,t,c);Array.isArray(o)&&(o[s]+u<0&&(u=-o[s]),o[s]+=u);for(var h=[],f=0;f<e.length;f++)h[f]=e[f]*u;return{impulses:h,lambda:u}}function Fe(e,t,n,r){for(var i=0,a=0;a<t.length;a++)i+=t[a]*n[a];return-e*(i+r)}function Ae(e,t){for(var n=0,r=0;r<e.length;r++)n+=e[r]/t[r]*e[r];return 1/n}function De(e){var t=1;for(var n of e)t*=n.collider.friction;return t}function Pe(){this.events={},this.addEvent=this.on=function(e,t){if("function"!=typeof t)throw new Error("[EventHandler]: Not a function");this.events[e]?this.events[e].functions.push(t):this.events[e]={functions:[t]}},this.removeEvent=this.off=function(e,t){var n=this.events[e];if(n){var r=n.functions.indexOf(t);-1!==r&&n.functions.splice(r,1)}},this.fireEvent=function(e,...t){if(this.events[e]){for(var n of this.events[e].functions)n(...t);return!0}return!1}}function Se(e,t,n,r){var i=this;this.gameObject=null,this.eventHandler=new Pe,this.on=this.eventHandler.on.bind(this.eventHandler),this._hasChanged={matrix:!1,worldMatrix:!1};var a=W.identity(),o=W.identity(),s=W.identity(),l=W.identity(),c=W.identity(),u=W.identity(),h=t??X.zero(),f=n??j.identity(),d=r??X.one(),m=E(h,y),v=E(f,y),g=E(d,y),p=X.copy(h),x=j.copy(f),b=X.copy(d);function y(){i.gameObject?(i.gameObject.traverse((e=>{e.transform._hasChanged.matrix=!0,e.transform._hasChanged.worldMatrix=!0})),i.gameObject.traverse((e=>{e.transform.eventHandler.fireEvent("transformChange")}))):(i._hasChanged.matrix=!0,i._hasChanged.worldMatrix=!0,i.eventHandler.fireEvent("transformChange"))}function T(){W.translate(h,a),W.multiply(a,c,a),W.transform([["scale",d]],a),w(a,!1)}function w(e,t=!0){W.isNaN(e)?console.error("Matrix is NaN: ",e):(W.copy(e,o),W.getTranslationMatrix(o,l),W.getRotationMatrix(o,c),W.getScaleMatrix(o,u),t&&(W.getPosition(o,m),j.fromMatrix(o,v),W.getScale(o,g),X.set(p,m),j.set(x,v),X.set(b,g)),i.onUpdateMatrix?.(o))}function E(e,t=(()=>{})){return new Proxy(e,{set:function(e,n,r){if("x"==n||"y"==n||"z"==n||"w"==n){if(isNaN(r))return console.error("Proxy property "+n+" is NaN",e,n,r),!0;e[n]=r,t?.()}else e[n]=r;return!0},get:function(){return Reflect.get(...arguments)}})}null!=e?w(e):T(),this.set=function(e){this.matrix=e.matrix},Object.defineProperty(this,"position",{get:function(){return m},set:function(e){if(X.isVectorIsh(e)){if(X.equal(e,p))return;if(X.isNaN(e))return void console.error("Position is NaN: ",e);m.x=e.x,m.y=e.y,m.z=e.z,X.set(p,e)}else console.warn("Position is not vector",e)}}),Object.defineProperty(this,"worldPosition",{get:function(){return W.getPosition(i.worldMatrix)},set:function(){throw new Error("Can't set world position")}}),Object.defineProperty(this,"rotation",{get:function(){return v},set:function(e){if(j.isQuaternionIsh(e)){if(j.equal(e,x))return;if(j.isNaN(e))return void console.error("Rotation is NaN: ",e);v.x=e.x,v.y=e.y,v.z=e.z,v.w=e.w,W.fromQuaternion(f,c),j.set(x,e)}else console.warn("Rotation is not quaternion",e)}}),Object.defineProperty(this,"scale",{get:function(){return g},set:function(e){if(X.isVectorIsh(e)){if(X.equal(e,b))return;if(X.isNaN(e))return void console.error("Scale is NaN: ",e);g.x=e.x,g.y=e.y,g.z=e.z,X.set(b,e)}else console.warn("Scale is not vector",e)}}),Object.defineProperty(this,"matrix",{get:function(){return i._hasChanged.matrix&&(i._hasChanged.matrix=!1,T()),o},set:function(e){y(),w(e)}}),Object.defineProperty(this,"worldMatrix",{get:function(){return i._hasChanged.worldMatrix&&(i._hasChanged.worldMatrix=!1,i.gameObject&&i.gameObject.parent?W.multiply(i.gameObject.parent.transform.worldMatrix,i.matrix,s):W.copy(i.matrix,s)),s},set:function(e){if(W.isNaN(e))return void console.error("World matrix is NaN: ",e);const t=W.inverse(i.gameObject.parent.transform.worldMatrix);W.multiply(t,e,i.matrix)}}),Object.defineProperty(this,"translationMatrix",{get:function(){return l}}),Object.defineProperty(this,"rotationMatrix",{get:function(){return c},set:function(e){W.isNaN(e)?console.error("Rotation matrix is NaN: ",e):(y(),j.fromMatrix(e,f),W.copy(e,c))}}),Object.defineProperty(this,"scaleMatrix",{get:function(){return u}}),Object.defineProperty(this,"forward",{get:function(){return W.getForward(i.worldMatrix)}}),Object.defineProperty(this,"up",{get:function(){return W.getUp(i.worldMatrix)}}),this.getWorldMatrix=function(e){return this.gameObject&&this.gameObject.parent&&this.gameObject.parent!=e?W.multiply(this.gameObject.parent.transform.getWorldMatrix(e),this.matrix):this.matrix}}function Ne(e="Unnamed",t={}){var n=this;this.name=e,this.children=Ue(t.children,[]),this.parent=null,this.transform=new Se(t.matrix,t.position,t.rotation,t.scale),this.transform.gameObject=this,this.prevModelMatrix=W.copy(this.transform.worldMatrix),this.isCulled=!1;var r=null,i=!0;let a=()=>{i=!0};this.getAABB=function(){return r},this.transform.on("transformChange",a),this.customData={},this.layer=1,this.visible=Ue(t.visible,!0),this.castShadows=Ue(t.castShadows,!0),this.receiveShadows=Ue(t.receiveShadows,!0),this.runUpdate=Ue(t.runUpdate,!0),this.active=Ue(t.active,!0),this.animationController=null;var o,s,l=[];function c(e,t,n){e.parent&&e!=t&&(n.push(e.parent.children.indexOf(e)),c(e.parent,t,n))}Object.defineProperty(this,"meshRenderer",{get:function(){return s},set:function(e){s&&s.off("updateAABB",a),(s=e)&&s.materials&&(o=new Array(s.materials.length)),s&&s.on("updateAABB",a)}}),this.meshRenderer=Ue(t.meshRenderer,null),this.traverse=function(e){for(var t of(e(this),this.children))t.traverse(e)},this.traverseCondition=function(e,t=(()=>!0)){for(var n of(e(this),this.children))t(n)&&n.traverseCondition(e,t)},this.setReceiveShadows=function(e,t=!1){t?this.traverse((t=>{t.receiveShadows=e})):this.receiveShadows=e},this.setLayer=function(e,t=!1){t?this.traverse((t=>{t.layer=e})):this.layer=e},this.getComponents=function(){return l},this.addComponent=function(e){return e.gameObject=this,l.push(e),e.onAdd?.(),e},this.removeComponent=function(e){return l.splice(l.indexOf(e),1),delete e.gameObject,e},this.findComponents=function(e){return l.filter((t=>t.componentType===e))},this.getComponent=function(e){return l.find((t=>t.componentType===e))},this.copy=function(e=!0){var t=new Ne(this.name+(e?" (Copy)":""));for(var r of(t.layer=this.layer,t.visible=this.visible,t.castShadows=this.castShadows,t.transform.matrix=n.transform.matrix,this.meshRenderer&&(t.meshRenderer=this.meshRenderer.copy()),this.animationController&&(t.animationController=this.animationController.copy()),l))r.copy?t.addComponent(r.copy(t)):t.addComponent(r);for(var i of this.children)t.addChild(i.copy(!1));var a=this,o=t;if(o.traverse((e=>{if(e!=o&&e.meshRenderer&&e.meshRenderer.skin){var t=[];for(var n of e.meshRenderer.skin.joints){let e=n.getHierarchyPath(a);t.push(o.getChildFromHierarchyPath(e))}var r=e.meshRenderer.skin,i=new(0,r.constructor)(t,r.inverseBindMatrixData),s=r.parentNode.getHierarchyPath(a);i.parentNode=o.getChildFromHierarchyPath(s),e.meshRenderer.skin=i}})),a.animationController)for(var s=0;s<a.animationController.animations.length;s++)for(var c=a.animationController.animations[s],u=0;u<c.data.length;u++){var h=c.data[u].target.getHierarchyPath(a),f=o.getChildFromHierarchyPath(h);o.animationController.animations[s].data[u].target=f}return t},this.getChildrenWithCustomData=function(e){var t=[];return this.traverse((n=>{n.customData&&e in n.customData&&t.push(n)})),t},this.getChild=function(e,t=!1){var n;return t?(this.traverse((t=>{t.name.match(e)&&!n&&(n=t)})),n):this.children.find((t=>t.name.match(e)))},this.getChildren=function(e,t=!1,n=!0){if(t){var r=[];return this.traverse((t=>{(n&&t.name===e||!n&&-1!==t.name.indexOf(e))&&r.push(t)})),r}return this.children.every((t=>n&&t.name===e||!n&&-1!==t.name.indexOf(e)))},this.addChild=function(e){if(null==e.parent)return e.parent=this,this.children.push(e),e;throw new Error("Can't add child! Child already has parent")},this.add=this.addChild,this.addChildren=function(e){for(var t=0;t<e.length;t++)this.addChild(e[t]);return e},this.removeChild=function(e){var t=this.children.indexOf(e);-1!==t&&(e.parent=null,this.children.splice(t,1))},this.setParent=function(e){null!=this.parent&&this.parent.removeChild(this),this.parent=e,e.children.push(this)},this.delete=function(){this.parent.removeChild(this)},this.getChildFromHierarchyPath=function(e){var t=this;for(var n of e)t=t.children[n];return t},this.getHierarchyPath=function(e){var t=[];return c(this,e,t),t.reverse()},this.update=function(e){if(this.runUpdate&&this.active){for(var t of(i&&this.meshRenderer&&this.meshRenderer.getAABB&&(r||(r=new xe),this.meshRenderer.getAABB(r),this.meshRenderer instanceof Cn.MeshInstanceRenderer||r.approxTransform(this.transform.worldMatrix),i=!1),this.animationController&&this.animationController.update(e),this.meshRenderer?.update?.(e),l))t.update?.(e);for(var n=0;n<this.children.length;n++)this.children[n].update(e)}},this.render=function(e,t={}){if(this.visible&&this.active){var n=!!t.renderPass&&!!(g.SHADOWS&t.renderPass),r=!(t.renderPass&&g.ALPHA&t.renderPass),i=!!t.renderPass&&!!(g.DOWNSCALED&t.renderPass);if(n&&!this.castShadows)return;if((e.layer??65535)&this.layer){if(this.meshRenderer&&(!n||this.castShadows)&&!this.isCulled)if(t.materialOverride){var a=t.materialOverride;this.meshRenderer instanceof Cn.MeshInstanceRenderer?a=t.materialOverrideInstanced:this.meshRenderer instanceof Cn.SkinnedMeshRenderer&&(a=t.materialOverrideSkinned);for(let e=0;e<this.meshRenderer.materials.length;e++)o[e]=this.meshRenderer.materials[e].programContainer,this.meshRenderer.materials[e].programContainer=a.programContainer;this.meshRenderer.render(e,this.transform.worldMatrix,n,r,this.prevModelMatrix);for(let e=0;e<this.meshRenderer.materials.length;e++)this.meshRenderer.materials[e].programContainer=o[e]}else this.meshRenderer.render(e,this.transform.worldMatrix,n,r,this.prevModelMatrix,{downscaledPass:i,shadowQuality:this.receiveShadows?2:0});for(var s of l)s.render?.(e,this.transform.worldMatrix,n,r,this.prevModelMatrix,{downscaledPass:i})}for(var c=0;c<this.children.length;c++)this.children[c].render(e,t);n||this.updatePrevModelMatrix()}},this.updatePrevModelMatrix=function(){W.copy(this.transform.worldMatrix,this.prevModelMatrix)},this.getChildStructure=function(e=0,t=[]){var n=this.name;this.visible||(n+=" (Not visible)"),this.active||(n+=" (Not active)"),(this.children.length>0||this.getComponents().length>0)&&(n+="\n");var r=[];for(let e=0;e<this.getComponents().length;e++){var i=this.getComponents()[e],a=e==this.getComponents().length-1&&0==this.children.length;let n="";for(let e=0;e<t.length;e++)n+=t[e]?"   ":"|  ";n+=a?"└──":"├──";let o=n+"(COMPONENT) "+i.componentType??`No type: ${i.constructor.name}`;r.push(o)}for(let n=0;n<this.children.length;n++){var o=n==this.children.length-1,s="";for(let e=0;e<t.length;e++)s+=t[e]?"   ":"|  ";s+=o?"└──":"├──";var l=[...t];l.push(o),r.push(s+this.children[n].getChildStructure(e+1,l))}return n+=r.join("\n"),1!=e||t[t.length-1]||(n+="\n|"),n}}function Ue(e,t){return void 0===e?t:e}function ze(e={}){this.exposure=e.exposure??0,this.gamma=e.gamma??2.2,this.tonemapping=e.tonemapping??ze.TONEMAPPING.ACES,this.motionBlurStrength=e.motionBlurStrength??.2,this.saturation=e.saturation??0,this.contrast=e.contrast??0,this.vignette=e.vignette??new Le}function Le(e={}){this.amount=e.amount??.2,this.falloff=e.falloff??.3}function Be(e={}){this.enabled=e.enabled??!0,this.sampleScale=e.sampleScale??1,this.threshold=e.threshold??1,this.knee=e.knee??.5,this.clamp=e.clamp??100,this.intensity=e.intensity??.05}ze.TONEMAPPING={NONE:0,ACES:1,REINHARD:2};class Ie{constructor(e,t={}){if("object"!=typeof t||null===t||Array.isArray(t))throw new Error("Uniforms is not a dictionary (object)");if(null!==e&&!(e instanceof Cn.ProgramContainer))throw new Error("Could not create material. Not a program container: "+e);this.programContainer=e,null===e&&console.warn("Program container is null"),this.name="No name",this.doubleSided=!1,this.doubleSidedShadows=!0,this.uniforms=t,this.opaque=!0}setUniform(e,t){this.programContainer&&!this.programContainer.activeUniforms[e]&&console.warn("[setUniform] Uniform does not exist on current shader-program: "+e),this.uniforms[e]=t}getUniform(e){return this.uniforms[e]}isOpaque(){return this.opaque}getUniformLocation(e){if(!this.programContainer)throw new Error("Material does not have a program container associated with it");return this.programContainer.getUniformLocation(e)}copy(){return ke.call(this,Ie)}}class Oe extends Ie{constructor(e,t={}){super(e,t),this.isLit=!0,this.uniforms.albedo=this.uniforms.albedo??[1,1,1,1],this.uniforms.emissiveFactor=this.uniforms.emissiveFactor??[0,0,0],this.uniforms.metallic=this.uniforms.metallic??0,this.uniforms.roughness=this.uniforms.roughness??1,this.uniforms.alphaCutoff=this.uniforms.alphaCutoff??.5,this.uniforms.doNoTiling=this.uniforms.doNoTiling??!1,this.uniforms.normalStrength=this.uniforms.normalStrength??1,this.uniforms.useVertexColor=this.uniforms.useVertexColor??!0,this.uniforms.useTexture=!!this.uniforms.albedoTexture,this.uniforms.useNormalTexture=!!this.uniforms.normalTexture,this.uniforms.useMetallicRoughnessTexture=!!this.uniforms.metallicRoughnessTexture,this.uniforms.useEmissiveTexture=!!this.uniforms.emissiveTexture,this.uniforms.useOcclusionTexture=!!this.uniforms.occlusionTexture,"opaque"in this.uniforms&&(this.opaque=!!this.uniforms.opaque,delete this.uniforms.opaque)}setUniform(e,t){super.setUniform(e,t),"albedoTexture"==e?this.uniforms.useTexture=!!t:"normalTexture"==e?this.uniforms.useNormalTexture=!!t:"metallicRoughnessTexture"==e?this.uniforms.useMetallicRoughnessTexture=!!t:"emissiveTexture"==e?this.uniforms.useEmissiveTexture=!!t:"occlusionTexture"==e&&(this.uniforms.useOcclusionTexture=!!t)}copy(){return ke.call(this,Oe)}}function ke(e){var t={};for(var n in this.uniforms){let e=this.uniforms[n];e instanceof WebGLTexture?t[n]=e:t[n]=void 0===e?e:JSON.parse(JSON.stringify(e))}var r=new e(this.programContainer,t);return r.name=this.name,r.doubleSided=this.doubleSided,r.doubleSidedShadows=this.doubleSidedShadows,r.opaque=this.opaque,r}function Ve(e){this.renderer=null,this.name=e,this.root=new Ne("root"),this.sunDirection=X.normalize({x:-.8,y:1.3,z:-1.2}),this.sunIntensity=X.multiply(new X(1,.9,.85),10),this.skyboxVisible=!0,this.smoothSkybox=!1,this.environmentIntensity=1,this.environmentMinLight=.25,this.ambientColor=[0,0,0],this.skyboxFogIntensity=.8,this.fogDensity=.0035,this.fogColor=[.23,.24,.26,1],this.shadowQuality=2,this.postprocessing=new ze,this.bloom=new Be;var t=[];this.setupUBO=function(){var e=this.renderer.programContainers.lit.uniformBuffers.sharedPerScene;if(e){this.sharedUBO=new this.renderer.UniformBuffer(this.renderer.UBOLocationCounter++,e.blockSize);var t=this.renderer.gl;t.bindBuffer(t.UNIFORM_BUFFER,this.sharedUBO.buffer),t.bufferSubData(t.UNIFORM_BUFFER,e.offsets[3],new Float32Array([this.renderer.shadowCascades.shadowmaps[1].bias]),0),t.bufferSubData(t.UNIFORM_BUFFER,e.offsets[3]+16,new Float32Array([this.renderer.shadowCascades.shadowmaps[0].bias]),0)}},this.updateUniformBuffers=function(e,t,n){if(this.sharedUBO){var r=this.renderer.programContainers.lit.uniformBuffers.sharedPerScene,i=this.renderer.gl;i.bindBuffer(i.UNIFORM_BUFFER,this.sharedUBO.buffer),i.bufferSubData(i.UNIFORM_BUFFER,r.offsets[0],e,0),i.bufferSubData(i.UNIFORM_BUFFER,r.offsets[1],t,0),i.bufferSubData(i.UNIFORM_BUFFER,r.offsets[2],n,0)}},this.loadEnvironment=async function(e={}){if(this.renderer){this.specularCubemap=null;var t=e.res??1024;if(e.hdr)this.skyboxCubemap=await this.renderer.createCubemapFromHDR(e.hdr,t),console.warn("No prebaked diffuse map. Generating one..."),this.diffuseCubemap=await this.renderer.getDiffuseCubemap(this.skyboxCubemap);else if(e.hdrFolder){var n=e.hdrFolder;this.skyboxCubemap=await this.renderer.createCubemapFromHDR(n+"/skybox.hdr",t);try{this.diffuseCubemap=await this.renderer.createCubemapFromHDR(n+"/diffuse.hdr",32)}catch(e){console.warn("No prebaked diffuse map. Generating one..."),this.diffuseCubemap=await this.renderer.getDiffuseCubemap(this.skyboxCubemap)}try{this.renderer.version,this.specularCubemap=await this.renderer.createSpecularCubemapFromHDR(n,t)}catch(e){console.error(e),console.warn("No prebaked specular map. Generating one...")}}else if(e.cubemap)this.skyboxCubemap=e.cubemap,this.diffuseCubemap=await this.renderer.getDiffuseCubemap(this.skyboxCubemap);else{var r=new this.renderer.ProgramContainer(await this.renderer.createProgramFromFile(this.renderer.path+`assets/shaders/built-in/webgl${this.renderer.version}/procedualSkybox`)),i=new Ie(r);this.skyboxCubemap=await this.renderer.createCubemapFromCube(i,t),this.diffuseCubemap=await this.renderer.getDiffuseCubemap(this.skyboxCubemap)}return this.specularCubemap||(this.specularCubemap=await this.renderer.getSpecularCubemap(this.skyboxCubemap)),this.smoothSkybox&&(this.skyboxCubemap=this.diffuseCubemap),!0}return console.error("Add scene to renderer before loading environment"),!1},this.copyEnvironment=function(e){this.skyboxCubemap=e.skyboxCubemap,this.diffuseCubemap=e.diffuseCubemap,this.specularCubemap=e.specularCubemap},this.add=function(e){return Array.isArray(e)?this.root.addChildren(e):this.root.addChild(e)},this.remove=function(e){if(Array.isArray(e))for(var t of e)this.root.removeChild(t);else this.root.removeChild(e)},this.update=function(e){this.updateLights(),this.root.update(e)},this.render=function(){this.renderer.currentBoundLitPrograms=new WeakMap,this.root.render(...arguments)},this.getLights=function(){return t},this.updateLights=function(){return t=[],this.root.traverseCondition((e=>{let n=e.getComponents();for(var r of n)"Light"==r.componentType&&t.push({type:r.type,position:W.getPosition(e.transform.worldMatrix),direction:W.getForward(e.transform.worldMatrix),angle:r.angle,color:r.color})}),(e=>e.active&&e.visible)),!0}}function Ge(){this.componentType="Light",this.gameObject=null,this.angle=Math.PI/3,this.color=[1,.5,.1],this.type=0,this.kelvinToRgb=function(e,t=1){return Ge.kelvinToRgb(e,t)},this.copy=function(){var e=new Ge;return e.angle=this.angle,e.color=Array.from(this.color),e.type=this.type,e}}function Xe(e={}){var t=this;this.frustum=new je,this.transform=new Se(null,e.position,e.rotation),this.layer=e.layer??65535,this.renderTexture=e.renderTexture??null;var n=W.identity();this.prevViewMatrix=W.identity(),this.aspect=1;var r=e.fov??45,i=e.near??.3,a=e.far??100,o=e.size??20;function s(){W.inverse(t.transform.matrix,n),t.updateFrustum()}this.type=e.type??Xe.Type.Perspective,this.type==Xe.Type.Perspective?this.projectionMatrix=W.perspective({fov:r*Math.PI/180,aspect:this.aspect,near:i,far:a}):this.type==Xe.Type.Orthographic&&(this.projectionMatrix=W.orthographic({size:o,near:i,far:a})),this.updateFrustum=function(){if(W.getPosition(this.transform.matrix,We),W.getForward(this.transform.matrix,qe),W.getUp(this.transform.matrix,Ye),W.getRight(this.transform.matrix,Ke),X.set($e,qe),X.multiplyTo($e,a),this.type==Xe.Type.Perspective){const e=a*Math.tan(r*Math.PI/180),t=e*this.aspect;X.set(this.frustum.nearPlane.position,qe),X.multiplyTo(this.frustum.nearPlane.position,i),X.addTo(this.frustum.nearPlane.position,We),X.set(this.frustum.nearPlane.normal,qe),X.set(this.frustum.farPlane.position,$e),X.addTo(this.frustum.farPlane.position,We),X.set(this.frustum.farPlane.normal,qe),X.negateTo(this.frustum.farPlane.normal),X.set(this.frustum.rightPlane.position,We),X.set(Qe,Ke),X.multiplyTo(Qe,t),X.subtractTo(Qe,$e),X.cross(Qe,Ye,this.frustum.rightPlane.normal),X.set(this.frustum.leftPlane.position,We),X.set(Qe,Ke),X.multiplyTo(Qe,t),X.addTo(Qe,$e),X.cross(Qe,Ye,this.frustum.leftPlane.normal),X.set(this.frustum.topPlane.position,We),X.set(Qe,Ye),X.multiplyTo(Qe,e),X.subtractTo(Qe,$e),X.cross(Ke,Qe,this.frustum.topPlane.normal),X.set(this.frustum.bottomPlane.position,We),X.set(Qe,Ye),X.multiplyTo(Qe,e),X.addTo(Qe,$e),X.cross(Ke,Qe,this.frustum.bottomPlane.normal),X.normalizeTo(this.frustum.rightPlane.normal),X.normalizeTo(this.frustum.leftPlane.normal),X.normalizeTo(this.frustum.topPlane.normal),X.normalizeTo(this.frustum.bottomPlane.normal),X.negateTo(this.frustum.leftPlane.normal),X.negateTo(this.frustum.rightPlane.normal),X.negateTo(this.frustum.topPlane.normal),X.negateTo(this.frustum.bottomPlane.normal)}else this.type==Xe.Type.Orthographic&&(X.set(this.frustum.nearPlane.position,qe),X.multiplyTo(this.frustum.nearPlane.position,i),X.addTo(this.frustum.nearPlane.position,We),X.set(this.frustum.nearPlane.normal,qe),X.set(this.frustum.farPlane.position,$e),X.addTo(this.frustum.farPlane.position,We),X.set(this.frustum.farPlane.normal,qe),X.negateTo(this.frustum.farPlane.normal),X.set(Qe,Ke),X.multiplyTo(Qe,o),X.addTo(Qe,We),X.set(this.frustum.rightPlane.position,Qe),X.set(this.frustum.rightPlane.normal,Ke),X.negateTo(this.frustum.rightPlane.normal),X.set(Qe,Ke),X.multiplyTo(Qe,-o),X.addTo(Qe,We),X.set(this.frustum.leftPlane.position,Qe),X.set(this.frustum.leftPlane.normal,Ke),X.set(Qe,Ye),X.multiplyTo(Qe,o),X.addTo(Qe,We),X.set(this.frustum.topPlane.position,Qe),X.set(this.frustum.topPlane.normal,Ye),X.negateTo(this.frustum.topPlane.normal),X.set(Qe,Ye),X.multiplyTo(Qe,-o),X.addTo(Qe,We),X.set(this.frustum.bottomPlane.position,Qe),X.set(this.frustum.bottomPlane.normal,Ye))},Object.defineProperty(this,"cameraMatrix",{get:function(){return t.transform.matrix}}),Object.defineProperty(this,"inverseViewMatrix",{get:function(){return t.transform.matrix}}),Object.defineProperty(this,"viewMatrix",{get:function(){return(t.transform._hasChanged.matrix||t.transform._hasChanged.worldMatrix)&&W.inverse(t.transform.matrix,n),n}}),this.setAspect=function(e){this.type==Xe.Type.Perspective?(this.aspect=e,W.perspective({fov:r*Math.PI/180,aspect:this.aspect,near:i,far:a},this.projectionMatrix),this.updateFrustum()):console.warn("Can't set aspect ratio of orthographic camera")},this.setFOV=function(e){this.type==Xe.Type.Perspective?e!=r&&(r=e,W.setPerspectiveFov(this.projectionMatrix,this.aspect,r*Math.PI/180),this.updateFrustum()):console.warn("Can't set FOV of orthographic camera")},this.getFOV=function(){return this.type==Xe.Type.Orthographic&&console.error("Orthographic camera does not use FOV"),r},this.transform.onUpdateMatrix=s,s()}function je(){this.topPlane=new He,this.bottomPlane=new He,this.rightPlane=new He,this.leftPlane=new He,this.farPlane=new He,this.nearPlane=new He}function He(){this.normal=new X,this.position=new X,this.getSignedDistanceToPlane=function(e){return X.dot(this.normal,X.subtract(e,this.position))}}Ge.kelvinToRgb=function(e,t=1){var n=[0,0,0];if((e=y(e,1e3,4e4)/100)<=66)n[0]=1,n[1]=y(.3900815787690196*Math.log(e)-.6318414437886274,0,1);else{var r=e-60;n[0]=y(1.292936186062745*Math.pow(r,-.1332047592),0,1),n[1]=y(1.129890860895294*Math.pow(r,-.0755148492),0,1)}return n[2]=e>66?1:e<=19?0:y(.543206789110196*Math.log(e-10)-1.19625408914,0,1),n[0]*=t,n[1]*=t,n[2]*=t,n},Xe.Type={Perspective:0,Orthographic:1};const We=new X,qe=new X,Ye=new X,Ke=new X,$e=new X,Qe=new X;function Je(e=[]){this.x=0,this.y=0,this.z=0,this.blendCoords=e,this.getWeight=function(e){var t=this.blendCoords.find((t=>t.animation==e));return t?y(1-X.distance(new X(this.x,this.y,this.z),t.coords),0,1)/this.getWeightSum():0},this.getWeightSum=function(){var e=0;for(var t of this.blendCoords)e+=y(1-X.distance(new X(this.x,this.y,this.z),t.coords),0,1);return e}}function Ze(e="Unnamed animation",t=[],n){if(this.name=e,this.data=t,this.speed=1,null==n)if(this.data.length>0){var r=0;for(var i of this.data){var a=i.inputBuffer[i.inputBuffer.length-1];a>r&&(r=a)}this.length=r}else this.length=4;else this.length=n;this.copy=function(){var e=[];for(var t of this.data)e.push({...t});var n=new Ze(this.name+" (Copy)",e,this.length);return n.speed=this.speed,n},this.transfer=function(e,t){for(var n of this.data)n.target=t.getChild(n.target.name,!0)}}function et(e=[]){function t(e,t,n,r,i="LINEAR"){var a=e.outputBuffer[t],o=e.outputBuffer[n];if("LINEAR"==i)return X.lerp(a,o,r);if("STEP"==i)return X.copy(o);if("CUBICSPLINE"==i&&e.inputTangents&&e.outputTangents){var s=e.inputBuffer[t]-e.inputBuffer[n];return function(e,t,n,r,i){var a=i*i,o=a*i,s=X.multiply(e,2*o-3*a+1),l=X.multiply(t,o-2*a+i),c=X.multiply(n,-2*o+3*a),u=X.multiply(r,o-a);return X.add(X.add(s,l),X.add(c,u))}(o,X.multiply(e.inputTangents[t],s),a,X.multiply(e.outputTangents[t],s),r=1-r)}return X.zero()}function n(e,t,n,r,i="LINEAR"){var a=e.outputBuffer[t],o=e.outputBuffer[n];if("LINEAR"==i)return j.slerp(a,o,r);if("STEP"==i)return j.copy(o);if("CUBICSPLINE"==i&&e.inputTangents&&e.outputTangents){var s=e.inputBuffer[t]-e.inputBuffer[n];return function(e,t,n,r,i){var a=i*i,o=a*i,s=j.multiply(e,2*o-3*a+1),l=j.multiply(t,o-2*a+i),c=j.multiply(n,-2*o+3*a),u=j.multiply(r,o-a);return j.add(j.add(s,l),j.add(c,u))}(o,j.multiply(e.inputTangents[t],s),a,j.multiply(e.outputTangents[t],s),r=1-r)}return j.identity()}this.animations=e,this.speed=1,this.loop=!1,this.animationTimes=new WeakMap,this.weightsHandler=new function(){this.weights=new WeakMap,this.getWeight=function(e){var t=this.weights.get(e);return void 0!==t?t:0}},this.copy=function(){var e=new et;e.speed=this.speed,e.loop=this.loop,this.weightsHandler instanceof Je&&(e.weightsHandler=new Je);for(let t of this.animations){let n=t.copy();e.animationTimes.set(n,this.animationTimes.get(t)),e.animations.push(n),this.weightsHandler.weights&&e.weightsHandler.weights.set(n,this.weightsHandler.weights.get(t)??0),this.weightsHandler instanceof Je&&e.weightsHandler.blendCoords.push({animation:n,coords:this.weightsHandler.blendCoords.find((e=>e.animation==t)).coords})}return e},this.update=function(e){var t=new WeakMap,n=[];for(var r of this.animations){var i=(this.animationTimes.get(r)??0)+e*this.speed*r.speed;this.loop&&(i%=r.length)<0&&(i=r.length+i),this.animationTimes.set(r,i);var a=this.weightsHandler.getWeight(r);if(a>.001&&(i<1.2*r.length||this.loop)){var o=this.getCurrentMatrices(r);for(var s of o){t.get(s.target)||(t.set(s.target,{position:[],rotation:[],scale:[],totalWeight:0}),n.push(s.target));var l=t.get(s.target),c=a;c>.001&&(s.translation&&l.position.push(X.multiply(s.translation,c)),s.rotation&&l.rotation.push(j.multiply(s.rotation,c)),s.scale&&l.scale.push(X.multiply(s.scale,c)))}}}for(var u of n){var h=t.get(u);h.position.length>0&&(u.transform.position=h.position.reduce(((e,t)=>X.add(e,t)),X.zero())),h.rotation.length>0&&(u.transform.rotation=h.rotation.reduce(((e,t)=>j.add(e,t)),j.zero())),h.scale.length>0&&(u.transform.scale=h.scale.reduce(((e,t)=>X.add(e,t)),X.zero()))}},this.play=function(e){if(e instanceof Ze)return this.animationTimes.set(e,0),void this.weightsHandler.weights.set(e,1);var t=e?.toLowerCase();for(var n of this.animations)null!=e&&-1==n.name.toLowerCase().indexOf(t)||(this.animationTimes.set(n,0),this.weightsHandler.weights.set(n,1))},this.getCurrentMatrices=function(e){var t=this.animationTimes.get(e)??0;return this.getStates(e,t)},this.getStates=function(e,r){for(var i=e.data,a=[],o=0;o<i.length;o++){var s=i[o],l={target:s.target},c=this.getClosestIndex(s.inputBuffer,r);"translation"==s.path?l.translation=t(s,c.indices[0],c.indices[1],c.lerpTime,s.interpolation):"rotation"==s.path?l.rotation=n(s,c.indices[0],c.indices[1],c.lerpTime,s.interpolation):"scale"==s.path&&(l.scale=t(s,c.indices[0],c.indices[1],c.lerpTime,s.interpolation)),a.push(l)}return a},this.getClosestIndex=function(e,t){for(var n=0;n<e.length;n++)if(t<e[n])return{indices:[n,Math.max(0,n-1)],lerpTime:w(e[n],e[Math.max(0,n-1)],t)};return{indices:[e.length-1,e.length-1],lerpTime:0}}}var tt="\n#version 300 es\nprecision highp float;\nprecision mediump int;\n",nt="\n#version 300 es\n\nin vec2 position;\n\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n",rt="\nuniform float environmentMinLight;\n\n// const int levels = 2;\n\n// vec4 projectedTexcoords[levels];\n// uniform float biases[levels];\n// uniform sampler2D projectedTextures[levels];\n// uniform mat4 textureMatrices[levels];\n\nuniform int shadowQuality;\nconst bool blurShadows = true;\nconst int shadowSamples = 8 * 2;\nconst float shadowSampleRadius = 3.;\n\nfloat shadowDarkness = 0.;\nconst float shadowKernalSize = 2.;\n// mat3 shadowKernel = mat3(\n//   1, 2, 1,\n//   2, 4, 2,\n//   1, 2, 1\n// );\nvec2 poissonDisk[16] = vec2[]( \n  vec2( -0.94201624, -0.39906216 ), \n  vec2( 0.94558609, -0.76890725 ), \n  vec2( -0.094184101, -0.92938870 ), \n  vec2( 0.34495938, 0.29387760 ), \n  vec2( -0.91588581, 0.45771432 ), \n  vec2( -0.81544232, -0.87912464 ), \n  vec2( -0.38277543, 0.27676845 ), \n  vec2( 0.97484398, 0.75648379 ), \n  vec2( 0.44323325, -0.97511554 ), \n  vec2( 0.53742981, -0.47373420 ), \n  vec2( -0.26496911, -0.41893023 ), \n  vec2( 0.79197514, 0.19090188 ), \n  vec2( -0.24188840, 0.99706507 ), \n  vec2( -0.81409955, 0.91437590 ), \n  vec2( 0.19984126, 0.78641367 ), \n  vec2( 0.14383161, -0.14100790 ) \n);\n\nbool inRange(vec3 projCoord) {\n  return projCoord.x >= 0.0 &&\n         projCoord.x <= 1.0 &&\n         projCoord.y >= 0.0 &&\n         projCoord.y <= 1.0 &&\n         projCoord.z <  1.0;\n}\n\nfloat fadeOutShadow(float visibility, vec3 proj) {\n  return mix(visibility, 1., clamp(pow(length(proj.xy - vec2(0.5, 0.5)) * 2., 5.), 0., 1.));\n}\n\nfloat fadeToNextShadowMap(float v1, float v2, vec3 proj) {\n  return mix(v1, v2, clamp(pow(length(proj.xy - vec2(0.5, 0.5)) * 2., 30.), 0., 1.));\n}\n\n// float random(vec3 seed, int i){\n//   vec4 seed4 = vec4(seed,i);\n//   float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));\n//   return fract(sin(dot_product) * 43758.5453);\n// }\n\nvec2 hash( vec2 p ) { // replace this by something better\n  p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n  return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat getShadowAmount(vec3 worldPosition, float cosTheta) {\n  // for (int i = 0; i < levels; i++) {\n  //   projectedTexcoords[i] = textureMatrices[i] * vec4(worldPosition, 1);\n  // }\n\n  if (shadowQuality == 0) {\n    return 1.;\n  }\n\n  if (shadowQuality == 1) {\n    vec3 proj = projectedTexcoords[0].xyz / projectedTexcoords[0].w;\n    bool inside = inRange(proj);\n    \n    if (inside) {\n      // float bias = 0.005*tan(acos(cosTheta)); // cosTheta is dot( n,l ), clamped between 0 and 1\n      // bias = clamp(bias, 0.0, 0.01);\n\n      float projectedDepth = texture(projectedTextures[0], proj.xy).r;\n      float currentDepth = proj.z + biases[0];\n      return (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n    }\n    \n    proj = projectedTexcoords[1].xyz / projectedTexcoords[1].w;\n    inside = inRange(proj);\n\n    if (inside) {\n      float currentDepth = proj.z + biases[1];\n      float projectedDepth = texture(projectedTextures[1], proj.xy).r;\n      return (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n    }\n\n    return 1.;\n  }\n\n  vec2 shadowStepSize = vec2(1) / vec2(textureSize(projectedTextures[0], 0));\n\n  if (shadowQuality >= 2) {\n    vec4 ShadowCoord = projectedTexcoords[0];\n    vec3 proj = ShadowCoord.xyz / ShadowCoord.w;\n\n    float bias = -biases[0] * (cosTheta > 0. ? 1. : 0.);\n    // float bias = -biases[0];//0.00005 * tan(acos(cosTheta));\n    // bias = clamp(bias, 0., 0.01);\n\n    float currentDepth = proj.z - bias;\n    bool inside = inRange(proj);\n\n    if (inside) {\n      float outShadow = 0.;\n\n      if (blurShadows) {\n        float visibility = 1.;\n        for (int i = 0; i < shadowSamples; i++) {\n          // int index = int(16.0*random(gl_FragCoord.xyy + float(i) * vec3(1, 0.4, -0.5), i))%16;\n          // int index = int(16.0*random(floor(worldPosition.xyz*500.0), i))%16;\n          \n          // if (texture(projectedTextures[0], proj.xy + poissonDisk[index] * shadowStepSize * 4.).r < currentDepth) {\n          //   visibility -= 1. / 64.;\n          // }\n\n          if (texture(projectedTextures[0], proj.xy + hash(worldPosition.xz + worldPosition.zy + float(i) * vec2(1, -.9)) * shadowStepSize * shadowSampleRadius).r < currentDepth) {\n            visibility -= 1. / float(shadowSamples);\n          }\n\n          // visibility -= 0.01*(1.0-textureProj(projectedTextures[0], vec3(ShadowCoord.xy + poissonDisk[index]/700.0, (ShadowCoord.z-bias * 3.) / ShadowCoord.w)).r);\n        }\n\n        outShadow =  visibility;\n      }\n      else {\n        float sum = 0.0;\n        for (float j = -shadowKernalSize / 2. + 0.5; j <= shadowKernalSize / 2. - 0.5; j++) {\n          for (float k = -shadowKernalSize / 2. + 0.5; k <= shadowKernalSize / 2. - 0.5; k++) {\n            // float projectedDepth = texture(projectedTextures[0], proj.xy + shadowStepSize * hash(vec2(j, k) / 1000.)).r;\n            float projectedDepth = texture(projectedTextures[0], proj.xy + shadowStepSize * vec2(j, k)).r;\n\n            sum += 1. - step(projectedDepth, currentDepth);//(projectedDepth <= currentDepth ? shadowDarkness : 1.);// * shadowKernel[j + 1][k + 1];\n          }\n        }\n\n        outShadow = sum / float(shadowKernalSize * shadowKernalSize);\n      }\n\n      // bruh double calc\n      vec3 projNext = projectedTexcoords[1].xyz / projectedTexcoords[1].w;\n      float depthNext = projNext.z + biases[1] * (cosTheta > 0. ? 1. : 0.);\n      float projectedDepthNext = texture(projectedTextures[1], projNext.xy).r;\n      float nextVis = (projectedDepthNext <= depthNext ? shadowDarkness : 1.);\n      return fadeToNextShadowMap(outShadow, nextVis, proj);\n    }\n\n    proj = projectedTexcoords[1].xyz / projectedTexcoords[1].w;\n    inside = inRange(proj);\n\n    if (inside) {\n      currentDepth = proj.z + biases[1] * (cosTheta > 0. ? 1. : 0.);\n      \n      if (shadowQuality == 2) {\n        float projectedDepth = texture(projectedTextures[1], proj.xy).r;\n        return fadeOutShadow((projectedDepth <= currentDepth ? shadowDarkness : 1.), proj);\n      }\n\n      if (shadowQuality == 3) {\n        float sum = 0.0;\n        for (float j = -shadowKernalSize / 2. + 0.5; j <= shadowKernalSize / 2. - 0.5; j++) {\n          for (float k = -shadowKernalSize / 2. + 0.5; k <= shadowKernalSize / 2. - 0.5; k++) {\n            float projectedDepth = texture(projectedTextures[1], proj.xy + shadowStepSize * vec2(j, k)).r;\n            sum += (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n          }\n        }\n\n        return fadeOutShadow(sum / 16., proj);\n      }\n    }\n\n    return 1.;\n  }\n\n  return 1.;\n}\n";function it(e){for(var t in e){var n=e[t];"object"==typeof n?it(n):"string"==typeof n&&(e[t]=e[t].trim())}}var at="\n#version 300 es\nprecision highp float;\nprecision mediump int;\n",ot="\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\n// Attributes\nin vec3 vPosition;\nin vec3 vNormal;\nin vec4 vTangent; // in vec3 vTangent;\nin vec3 vColor;\nin vec2 vUV;\nin mat3 vTBN;\n\n// Motion blur\nin vec4 clipSpace;\nin vec4 prevClipSpace;\n//#in\n\n// Material properties\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform sampler2D normalTexture;\nuniform bool useNormalTexture;\nuniform sampler2D metallicRoughnessTexture;\nuniform bool useMetallicRoughnessTexture;\nuniform sampler2D emissiveTexture;\nuniform bool useEmissiveTexture;\nuniform sampler2D occlusionTexture;\nuniform bool useOcclusionTexture;\n\nuniform vec4 albedo;\nuniform bool useVertexColor;\nuniform float metallic;\nuniform float roughness;\nuniform vec3 emissiveFactor;\nfloat ao = 1.;\nuniform bool opaque;\nuniform float alphaCutoff;\nuniform float normalStrength;\nuniform bool doNoTiling;\n\n// bruh make shared uniform into uniform block\n// Light info\nstruct LightInfo {\n  int type;\n  vec3 position;\n  vec3 direction;\n  float angle;\n  vec3 color;\n};\nconst int maxLights = 16;\nuniform LightInfo lights[maxLights];\nuniform int nrLights;\nuniform vec3 sunDirection;\nuniform vec3 sunIntensity;\n\n// Environment\nuniform vec3 ambientColor;\nuniform float environmentIntensity;\nuniform samplerCube u_diffuseIBL;\nuniform samplerCube u_specularIBL;\nuniform sampler2D u_splitSum;\n\n// Shadows\nconst int levels = 2;\nin vec4 projectedTexcoords[levels];\n// uniform float biases[levels];\nuniform sampler2D projectedTextures[levels];\n\n// uniform mat4 inverseViewMatrix;\nuniform mat4 modelMatrix;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n",st=`\nconst float PI = 3.141592;\n\n// No tiling\nvec4 hash4( vec2 p ) {\n  return fract(sin(vec4(1.0+dot(p,vec2(37.0,17.0)), \n                        2.0+dot(p,vec2(11.0,47.0)),\n                        3.0+dot(p,vec2(41.0,29.0)),\n                        4.0+dot(p,vec2(23.0,31.0))))*103.0);\n}\n\nvec3 textureNoTile( sampler2D samp, in vec2 uv, float v ) {\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n\t\n    // derivatives (for correct mipmapping)\n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n    \n\tvec3 va = vec3(0.0);\n\tfloat w1 = 0.0;\n    float w2 = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec4 o = hash4( p + g );\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n        float w = exp(-5.0*d );\n        vec3 c = textureGrad( samp, uv + v*o.zw, ddx, ddy ).xyz;\n\t\tva += w*c;\n\t\tw1 += w;\n        w2 += w*w;\n    }\n    \n    // normal averaging --\x3e lowers contrasts\n    return va/w1;\n\n    // contrast preserving average\n    float mean = 0.3;// textureGrad( samp, uv, ddx*16.0, ddy*16.0 ).x;\n    vec3 res = mean + (va-w1*mean)/sqrt(w2);\n    return mix( va/w1, res, v );\n}\n\nvec2 noiseHash( vec2 p ) { // replace this by something better\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n  const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n  const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n  vec2  a = p - i + (i.x+i.y)*K2;\n  float m = step(a.y,a.x); \n  vec2  o = vec2(m,1.0-m);\n  vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n  vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,noiseHash(i+0.0)), dot(b,noiseHash(i+o)), dot(c,noiseHash(i+1.0)));\n  return (dot( n, vec3(70.0) ) + 1.) / 2.;\n}\n\nconst int OCTAVES = 4;\nfloat LayeredNoise(vec2 p) {\n  float _noise = 0.;\n  float frequency = 1.;\n  float factor = 1.;\n\n  float persistance = 0.45;\n  float roughness = 3.;\n\n  for (int i = 0; i < OCTAVES; i++) {\n    _noise += noise(p * frequency + float(i) * 0.72354) * factor;\n    factor *= persistance;\n    frequency *= roughness;\n  }\n\n  return _noise;\n}\n\n// Texture sampling\nvec4 sampleTexture(sampler2D samp, vec2 uv) {\n  if (doNoTiling) {\n    return vec4(textureNoTile(samp, uv, 1.), 1);\n  }\n  else {\n    return texture(samp, uv);\n  }\n}\n\n//Normal map\nvec3 setNormalStrength(vec3 normal, float strength) {\n  return vec3(normal.xy * strength, mix(1., normal.z, clamp(strength, 0., 1.)));\n}\n\n// vec3 sampleNormalTexture(sampler2D texture, vec2 uv) {\n//   return sampleTexture(texture, uv).rgb * 2. - 1.\n// }\n\n${rt}\n\n// PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0); // trying this\n  // return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n} \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n  float a      = roughness*roughness;\n  float a2     = a*a;\n  float NdotH  = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH*NdotH;\n\n  float num   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n\n  return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r*r) / 8.0;\n\n  float num   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 F0 = vec3(scalarF0);\n  F0 = mix(F0, albedo, metallic);\n  vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.), F0, roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - metallic;\t  \n    \n  vec3 irradiance = texture(u_diffuseIBL, N).rgb;\n  vec3 diffuse  = irradiance * albedo;\n    \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureLod(u_specularIBL, R, roughness * MAX_REFLECTION_LOD).rgb;\n\n  vec2 uv = vec2(max(dot(N, V), 0.), roughness);\n  uv.y = 1. - uv.y;\n  vec2 envBRDF = texture(u_splitSum, uv).rg;\n\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n  vec3 ambient = (kD * diffuse + specular) * environmentIntensity;\n\n  return ambient;\n}\n\nvec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 L = normalize(lightDir);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;\n  vec3 specular     = nominator / denominator;\n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n\n  kD *= 1.0 - metallic;\n  float NdotL = max(dot(N, L), 0.0);\n\n  vec3 finalColor = (kD * albedo / PI + specular) * radiance * NdotL;\n  return finalColor;\n}\n\nvec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec3 Spotlight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 dir, float angle, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 currentDir = normalize(worldPos - lightPos);\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n\n  float sharpness = 5.;\n  attenuation *= clamp((dot(currentDir, dir) - cos(angle)) * sharpness, 0., 1.);\n\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);\n  \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec4 lit(vec4 _albedo, float _alphaCutoff, vec3 _emission, vec3 _tangentNormal, float _metallic, float _roughness, float _ao) {\n  _roughness = clamp(_roughness, 0.01, 0.99);\n  \n  if (_albedo.a <= _alphaCutoff) {\n    discard;\n  }\n\n  if (opaque) {\n    _albedo.a = 1.;\n  }\n\n  // vec3 N = normalize(mat3(modelMatrix) * vNormal);\n  vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n\n  vec3 N;\n  if (vTangent.xyz != vec3(0)) { //if (vTangent != vec3(0)) {\n    N = normalize(vTBN * _tangentNormal);\n  }\n  else {\n    N = normalize(mat3(modelMatrix) * vNormal);\n  }\n\n  if (!gl_FrontFacing) {\n    N *= -1.;\n  }\n\n  vec3 R = reflect(-V, N);\n\n  float f0 = 0.04;\n\n  float shadowAmount = getShadowAmount(vPosition, dot(sunDirection.xyz, N));\n  // float environmentMinLight = 0.25;\n\n  vec3 col = vec3(0);\n  col += ambientColor;\n  col += IBL(N, V, R, _albedo.rgb, _metallic, _roughness, f0) * _ao * (environmentMinLight + shadowAmount * (1. - environmentMinLight));\n  \n  if (sunIntensity.xyz != vec3(0)) {\n    col += DirectionalLight(vPosition, N, V, sunDirection.xyz, sunIntensity.xyz, _albedo.rgb, _metallic, _roughness, f0) * _ao * shadowAmount;\n  }\n\n  for (int i = 0; i < int(nrLights); i++) {\n    LightInfo light = lights[i];\n    if (light.type == 0) {\n      col += PositionalLight(vPosition, N, V, light.position, light.color, _albedo.rgb, _metallic, _roughness, f0);\n    }\n    else if (light.type == 1) {\n      col += Spotlight(vPosition, N, V, light.position, light.direction, light.angle, light.color, _albedo.rgb, _metallic, _roughness, f0);\n    }\n    else if (light.type == 2) {\n      col += DirectionalLight(vPosition, N, V, light.direction, light.color, _albedo.rgb, _metallic, _roughness, f0);\n    }\n  }\n\n  col += _emission;\n\n  return vec4(col, _albedo.a);\n}\n`,lt="\n#define USEFOG\n\nuniform vec4 fogColor;// = vec4(0.23, 0.24, 0.26, 1);\nuniform float fogDensity;// = 0.0035;\n\nvec4 applyFog(vec4 color) {\n  float distance = length(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n  float fogAmount = exp(-pow(distance * fogDensity, 2.));\n  \n  return mix(fogColor, color, fogAmount);\n}\n",ct="\nvec3 NDCPos = (clipSpace / clipSpace.w).xyz;\nvec3 PrevNDCPos = (prevClipSpace / prevClipSpace.w).xyz;\nmotionVector = (NDCPos - PrevNDCPos).xy * 0.5 + 0.5;\n",ut="\n// Motion blur\nout vec4 clipSpace;\nout vec4 prevClipSpace;\nuniform mat4 prevViewMatrix;\nuniform mat4 prevModelMatrix;\n",ht="\n// Motion blur\nvec4 prevCs = projectionMatrix * prevViewMatrix * prevModelMatrix * vec4(position, 1.0);\nprevClipSpace = prevCs;\nclipSpace = gl_Position;\n",ft=`\n${at}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent; // in vec3 tangent;\nin vec3 color;\nin vec2 uv;\n//#in\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec4 vTangent; // out vec3 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\n//#out\n\nconst int levels = 2;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n// uniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n//Shadows\nuniform mat4 textureMatrices[levels];\nout vec4 projectedTexcoords[levels];\n\n${ut}\n\nvoid main() {\n  //#main\n\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(vNormal, vTangent.xyz) * vTangent.w, 0.0))); // bruh According to comment on stackoverflow (https://blender.stackexchange.com/questions/220756/why-does-blender-output-vec4-tangents-for-gltf), tangents are vec4 and .w is used for bitangent sign (who could have known... :(\n  vec3 _N = normalize(vec3(modelMatrix * vec4(vNormal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  for (int i = 0; i < levels; i++) {\n    projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  }\n\n  vPosition = vec3(worldPosition);\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n\n  ${ht}\n}\n`,dt=`\n${at}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent; //in vec3 tangent;\nin vec3 color;\nin vec2 uv;\nin mat4 modelMatrix;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec4 vTangent; //out vec3 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat4 vModelMatrix;\nout mat3 vTBN;\n\nconst int levels = 2;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n//Shadows\nuniform mat4 textureMatrices[levels];\nout vec4 projectedTexcoords[levels];\n\n${ut}\n\nvoid main() {\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n  vModelMatrix = modelMatrix;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(vNormal, vTangent.xyz) * vTangent.w, 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * vec4(vNormal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  for (int i = 0; i < levels; i++) {\n    projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  }\n\n  vPosition = vec3(worldPosition);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n\n  ${ht}\n}\n`,mt=`\n${at}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent;\nin vec3 color;\nin vec2 uv;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec4 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\nout mat4 vSkin;\n\nconst int levels = 2;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n// uniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n//Skinning\nin vec4 weights;\nin vec4 joints;\n\nuniform sampler2D u_jointTexture;\nuniform float u_numJoints;\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.)\n#define ROW1_U ((0.5 + 1.0) / 4.)\n#define ROW2_U ((0.5 + 2.0) / 4.)\n#define ROW3_U ((0.5 + 3.0) / 4.)\n \nmat4 getBoneMatrix(float jointNdx) {\n  float v = (jointNdx + 0.5) / u_numJoints;\n  return mat4(\n    texture(u_jointTexture, vec2(ROW0_U, v)),\n    texture(u_jointTexture, vec2(ROW1_U, v)),\n    texture(u_jointTexture, vec2(ROW2_U, v)),\n    texture(u_jointTexture, vec2(ROW3_U, v))\n  );\n}\n\n//Shadows\nuniform mat4 textureMatrices[levels];\nout vec4 projectedTexcoords[levels];\n\n${ut}\n\nvoid main() {\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vNormal = normal;\n  // vNormal = mat3(inverse(modelMatrix * skinMatrix)) * normal;\n  // vNormal = mat3(world * inverse(modelMatrix)) * normal;\n\n  mat4 skinMatrix = getBoneMatrix(joints[0]) * weights[0] +\n                    getBoneMatrix(joints[1]) * weights[1] +\n                    getBoneMatrix(joints[2]) * weights[2] +\n                    getBoneMatrix(joints[3]) * weights[3];\n  \n  mat4 world = modelMatrix * skinMatrix;\n  // mat4 world = skinMatrix * modelMatrix;\n  // mat4 world = modelMatrix;\n\n  mat4 TBNWorld = modelMatrix * skinMatrix * modelMatrix;\n  // vec3 _T = normalize(vec3(TBNWorld * vec4(tangent, 0.0)));\n  // vec3 _B = normalize(vec3(TBNWorld * vec4(cross(normal, tangent), 0.0)));\n  // vec3 _N = normalize(vec3(TBNWorld * vec4(normal, 0.0)));\n  vec3 _T = normalize(vec3(TBNWorld * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(TBNWorld * vec4(cross(normal, vTangent.xyz) * vTangent.w, 0.0))); // bruh According to comment on stackoverflow (https://blender.stackexchange.com/questions/220756/why-does-blender-output-vec4-tangents-for-gltf), tangents are vec4 and .w is used for bitangent sign (who could have known... :(\n  vec3 _N = normalize(vec3(TBNWorld * vec4(normal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = world * vec4(position, 1.0);\n  for (int i = 0; i < levels; i++) {\n    projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  }\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n  vPosition = worldPosition.xyz;\n\n  vSkin = skinMatrix;\n\n  // Motion blur\n  vec4 prevCs = projectionMatrix * prevViewMatrix * prevModelMatrix * skinMatrix * vec4(position, 1.0);\n  prevClipSpace = prevCs;\n  clipSpace = gl_Position;\n}\n`,vt=ft;vt=(vt=(vt=vt.replace("//#in","in float alpha;")).replace("//#out","out float vAlpha;")).replace("//#main","vAlpha = alpha;");var gt=`\n${at}\n\n${ot}\n\n${st}\n\n${lt}\n\nvoid main() {\n  ${ct}\n  \n  // fragColor = vec4(1, 0, 0, 1);\n  // return;\n\n  // fragColor = vec4(vNormal, 1);\n  // return;\n\n  vec4 currentAlbedo = useTexture ? sampleTexture(albedoTexture, vUV) : vec4(1);\n  currentAlbedo *= albedo;\n  if (useVertexColor) {\n    currentAlbedo.xyz *= vec3(1) - vColor;\n  }\n  //#currentAlbedo\n\n  // if (doNoTiling) {\n  //   currentAlbedo.rgb *= mix(vec3(1.0), vec3(0.4, 0.7, 0.4), clamp(LayeredNoise(vUV / 40.), 0., 1.));\n  // }\n\n  // fragColor = currentAlbedo + vec4(emissiveFactor, 0.);\n  // return;\n\n  vec3 _emission = emissiveFactor;\n  if (useEmissiveTexture) {\n    _emission *= sampleTexture(emissiveTexture, vUV).rgb;\n  }\n\n  float _ao = ao;\n  if (useOcclusionTexture) {\n    _ao *= sampleTexture(occlusionTexture, vUV).r;\n  }\n\n  float _metallic = metallic;\n  float _roughness = roughness;\n  if (useMetallicRoughnessTexture) {\n    vec4 ts = sampleTexture(metallicRoughnessTexture, vUV);\n    _metallic *= ts.b;\n    _roughness *= ts.g;\n  }\n\n  vec3 _tangentNormal = vec3(0, 0, 1);\n  if (useNormalTexture) {\n    _tangentNormal = sampleTexture(normalTexture, vUV).rgb;\n    \n    // Accoring to GLTF NormalTangentTest, it's correct to flip none of the channels here! Update: yup, should not flip anything here\n    // _tangentNormal.r = 1. - _tangentNormal.r;\n    // _tangentNormal.g = 1. - _tangentNormal.g; // Convert from DirectX to OpenGL normal map format (remove this line if the normal map looks inverted)\n\n    // _tangentNormal.rg = _tangentNormal.gr;\n\n    _tangentNormal = _tangentNormal * 2. - 1.;\n    _tangentNormal = setNormalStrength(_tangentNormal, normalStrength);\n  }\n\n  // fragColor = vec4(_tangentNormal, 1);\n  // return;\n\n  vec4 litColor = lit(currentAlbedo, alphaCutoff, _emission, _tangentNormal, _metallic, _roughness, _ao);\n \n  #ifdef USEFOG\n    litColor = applyFog(litColor);\n  #endif\n\n  fragColor = litColor;\n}\n`,pt=gt;pt=(pt=(pt=pt.replace(/modelMatrix/g,"vModelMatrix")).replace(/uniform mat4 vModelMatrix/g,"in mat4 vModelMatrix")).replace("motionVector = (NDCPos - PrevNDCPos).xy * 0.5 + 0.5;","motionVector = vec2(0.5);");var xt=gt,bt=gt;bt=(bt=bt.replace("//#in","in float vAlpha;")).replace("//#currentAlbedo","currentAlbedo *= vec4(1, 1, 1, vAlpha);");var yt="\n// lit - vertex.glsl\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 tangent;\nattribute vec3 color;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vTangent;\nvarying vec3 vColor;\nvarying vec2 vUV;\nvarying mat3 vTBN;\n\n//Shadows\nconst int levels = 2;\nuniform mat4 textureMatrices[levels];\n// varying vec4 projectedTexcoords[levels];\n\nvoid main() {\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(vNormal, vTangent), 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * vec4(vNormal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  // for (int i = 0; i < levels; i++) {\n  //   projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  // }\n\n  vPosition = vec3(worldPosition);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",Tt="\n#extension GL_EXT_shader_texture_lod : enable\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n\n#ifndef GL_EXT_shader_texture_lod\nvec4 textureCubeLodEXT(samplerCube t, vec3 n, float lod) {\n  return textureCube(t, n);\n}\n#endif\n\nconst float PI = 3.141592;\n\n// Attributes\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vTangent;\nvarying vec3 vColor;\nvarying vec2 vUV;\nvarying mat3 vTBN;\n\nuniform mat4 inverseViewMatrix;\nuniform mat4 modelMatrix;\n\n// Material properties\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform sampler2D normalTexture;\nuniform bool useNormalTexture;\nuniform sampler2D metallicRoughnessTexture;\nuniform bool useMetallicRoughnessTexture;\nuniform sampler2D emissiveTexture;\nuniform bool useEmissiveTexture;\nuniform sampler2D occlusionTexture;\nuniform bool useOcclusionTexture;\n\nuniform vec4 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform vec3 emissiveFactor;\nfloat ao = 1.;\nuniform bool opaque;\nuniform float alphaCutoff;\nuniform float normalStrength;\nuniform bool doNoTiling;\n\n// bruh make shared uniform into uniform block\n// Light info\nstruct LightInfo {\n  int type;\n  vec3 position;\n  vec3 direction;\n  float angle;\n  vec3 color;\n};\nconst int maxLights = 8;\nuniform LightInfo lights[maxLights];\nuniform int nrLights;\nuniform vec3 sunDirection;\nuniform vec3 sunIntensity;\n\n// Environment\nuniform float environmentIntensity;\nuniform samplerCube u_diffuseIBL;\nuniform samplerCube u_specularIBL;\nuniform sampler2D u_splitSum;\n\n// Shadows\nfloat shadowDarkness = 0.;\nvec2 shadowStepSize = 1. / vec2(1024);\nconst int shadowKernalSize = 3;\nmat3 shadowKernel = mat3(\n  1, 2, 1,\n  2, 4, 2,\n  1, 2, 1\n);\n\nconst int levels = 2;\n// in vec4 projectedTexcoords[levels];\nuniform float biases[levels];\nuniform sampler2D projectedTextures[levels];\n\n// Debug\nuniform sampler2D unsued2D;\nuniform samplerCube unsued3D;\n\n// No tiling\nvec4 hash4(vec2 p);\nvec2 hash(vec2 p);\n\n// Texture sampling\nvec4 sampleTexture(sampler2D samp, vec2 uv);\n\n//Normal map\nvec3 setNormalStrength(vec3 normal, float strength);\n\n// Shadow functions\nbool inRange(vec3 projCoord);\nfloat getShadowAmount();\n\n// PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0);\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness);\nfloat DistributionGGX(vec3 N, vec3 H, float roughness);\nfloat GeometrySchlickGGX(float NdotV, float roughness);\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness);\nvec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0);\nvec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0);\nvec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0);\nvec3 Spotlight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 dir, float angle, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0);\nvec4 lit(vec4 _albedo, float _alphaCutoff, vec3 _emission, vec3 _tangentNormal, float _metallic, float _roughness, float _ao);\n\nvoid main() {\n  vec4 currentAlbedo = useTexture ? sampleTexture(albedoTexture, vUV) : vec4(1);\n  currentAlbedo *= albedo;\n  currentAlbedo *= vec4(vec3(1) - vColor, 1);\n\n  vec3 _emission = emissiveFactor;\n  if (useEmissiveTexture) {\n    _emission *= sampleTexture(emissiveTexture, vUV).rgb;\n  }\n\n  float _ao = ao;\n  if (useOcclusionTexture) {\n    _ao *= sampleTexture(occlusionTexture, vUV).r;\n  }\n\n  float _metallic = metallic;\n  float _roughness = roughness;\n  if (useMetallicRoughnessTexture) {\n    vec3 ts = sampleTexture(metallicRoughnessTexture, vUV).rgb;\n    _metallic *= ts.b;\n    _roughness *= ts.g;\n  }\n\n  vec3 _tangentNormal = vec3(0, 0, 1);\n  if (useNormalTexture) {\n    _tangentNormal = sampleTexture(normalTexture, vUV).rgb * 2. - 1.;\n\n    if (normalStrength != 0.) {\n    _tangentNormal = setNormalStrength(_tangentNormal, normalStrength);\n    }\n  }\n\n  gl_FragColor = lit(currentAlbedo, alphaCutoff, _emission, _tangentNormal, _metallic, _roughness, _ao);\n}\n\n// Texture sampling\nvec4 sampleTexture(sampler2D samp, vec2 uv) {\n  return texture2D(samp, uv);\n}\n\n//Normal map\nvec3 setNormalStrength(vec3 normal, float strength) {\n  return vec3(normal.xy * strength, mix(1., normal.z, clamp(strength, 0., 1.)));\n}\n\n// Shadow functions\nbool inRange(vec3 projCoord) {\n  return projCoord.x >= 0.0 &&\n      projCoord.x <= 1.0 &&\n      projCoord.y >= 0.0 &&\n      projCoord.y <= 1.0;\n}\n\nfloat getShadowAmount() {\n  return 1.;\n}\n\n// PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n} \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n  float a      = roughness*roughness;\n  float a2     = a*a;\n  float NdotH  = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH*NdotH;\n\n  float num   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n\n  return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r*r) / 8.0;\n\n  float num   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 F0 = vec3(scalarF0); \n  F0 = mix(F0, albedo, metallic);\n  vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.), F0, roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - metallic;\t  \n    \n  vec3 irradiance = textureCube(u_diffuseIBL, N).rgb;\n  vec3 diffuse  = irradiance * albedo;\n\n    \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureCubeLodEXT(u_specularIBL, R, roughness * MAX_REFLECTION_LOD).rgb;   \n  \n  // vec2 envBRDF = texture2D(u_splitSum, vec2(max(dot(N, V), 0.), roughness)).rg;\n\n  vec2 uv = vec2(max(dot(N, V), 0.), roughness);\n  uv.y = 1. - uv.y;\n  vec2 envBRDF = texture2D(u_splitSum, uv).rg;\n  \n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n  vec3 ambient = (kD * diffuse + specular) * ao;\n\n  return ambient;\n}\n\nvec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 L = normalize(lightDir);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec3 Spotlight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 dir, float angle, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 currentDir = normalize(worldPos - lightPos);\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n\n  float sharpness = 5.;\n  attenuation *= clamp((dot(currentDir, dir) - cos(angle)) * sharpness, 0., 1.);\n\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec4 lit(vec4 _albedo, float _alphaCutoff, vec3 _emission, vec3 _tangentNormal, float _metallic, float _roughness, float _ao) {\n  _roughness = clamp(_roughness, 0.01, 0.99);\n\n  if (_albedo.a <= _alphaCutoff) {\n    discard;\n  }\n\n  if (opaque) {\n    _albedo.a = 1.;\n  }\n\n  // vec3 N = normalize(mat3(modelMatrix) * vNormal);\n  vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n\n  vec3 N = normalize(vTBN * _tangentNormal);\n  if (!gl_FrontFacing) {\n    N *= -1.;\n  }\n\n  vec3 R = reflect(-V, N);\n\n  float f0 = 0.04;\n\n  vec3 col = vec3(0);\n  col += IBL(N, V, R, _albedo.rgb, _metallic, _roughness, f0) * _ao * environmentIntensity;\n  \n  if (sunIntensity != vec3(0)) {\n    col += DirectionalLight(vPosition, N, V, sunDirection, sunIntensity, _albedo.rgb, _metallic, _roughness, f0) * _ao * getShadowAmount();\n  }\n\n  for (int i = 0; i < maxLights; i++) {\n    if (i < nrLights) {\n      LightInfo light = lights[i];\n      if (light.type == 0) {\n        col += PositionalLight(vPosition, N, V, light.position, light.color, _albedo.rgb, _metallic, _roughness, f0);\n      }\n      else if (light.type == 1) {\n        col += Spotlight(vPosition, N, V, light.position, light.direction, light.angle, light.color, _albedo.rgb, _metallic, _roughness, f0);\n      }\n    }\n  }\n\n  // if (nrLights >= 1) {\n  //   const int i = 0;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 2) {\n  //   const int i = 1;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 3) {\n  //   const int i = 2;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 4) {\n  //   const int i = 3;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 5) {\n  //   const int i = 4;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 6) {\n  //   const int i = 5;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 7) {\n  //   const int i = 6;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n  // if (nrLights >= 8) {\n  //   const int i = 7;\n  //   if (lights[i].type == 0)      col += PositionalLight(vPosition, N, V, lights[i].position, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  //   else if (lights[i].type == 1) col += Spotlight(vPosition, N, V, lights[i].position, lights[i].direction, lights[i].angle, lights[i].color, _albedo.rgb, _metallic, _roughness, f0);\n  // }\n\n  col += _emission;\n\n  return vec4(col, _albedo.a);\n}\n\n\n\n\n\n\n\n\n// #extension GL_EXT_shader_texture_lod : enable\n// precision highp float;\n\n// #ifndef GL_EXT_shader_texture_lod\n// vec4 textureCubeLodEXT(samplerCube t, vec3 n, float lod) {\n//   return textureCube(t, n);\n// }\n// #endif\n\n// varying vec3 vPosition;\n// varying vec3 vNormal;\n// varying vec3 vTangent;\n// varying vec3 vColor;\n// varying vec2 vUV;\n// varying mat3 vTBN;\n\n// uniform sampler2D albedoTexture;\n// uniform bool useTexture;\n// uniform sampler2D normalTexture;\n// uniform bool useNormalTexture;\n// uniform sampler2D metallicRoughnessTexture;\n// uniform bool useMetallicRoughnessTexture;\n// uniform sampler2D emissiveTexture;\n// uniform bool useEmissiveTexture;\n// uniform sampler2D occlusionTexture;\n// uniform bool useOcclusionTexture;\n\n// uniform mat4 inverseViewMatrix;\n// uniform mat4 modelMatrix;\n\n// uniform samplerCube u_diffuseIBL;\n// uniform samplerCube u_specularIBL;\n// uniform sampler2D u_splitSum;\n\n// uniform vec3 sunDirection;\n// uniform vec3 sunIntensity;\n\n// float shadowDarkness = 0.;\n\n// uniform vec4 albedo;\n// uniform float metallic;\n// uniform float roughness;\n// uniform vec3 emissiveFactor;\n// float ao = 1.;\n\n// uniform bool opaque;\n// uniform float alphaCutoff;\n\n// uniform bool doNoTiling;\n\n// const float PI = 3.141592;\n\n// vec2 hash( vec2 p ) // replace this by something better\n// {\n// \tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n// \treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n// }\n\n// float noise( in vec2 p )\n// {\n//   const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n//   const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n// \tvec2  i = floor( p + (p.x+p.y)*K1 );\n//   vec2  a = p - i + (i.x+i.y)*K2;\n//   float m = step(a.y,a.x); \n//   vec2  o = vec2(m,1.0-m);\n//   vec2  b = a - o + K2;\n// \tvec2  c = a - 1.0 + 2.0*K2;\n//   vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n// \tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n//   return (dot( n, vec3(70.0) ) + 1.) / 2.;\n// }\n\n// // Texture sampling\n// vec4 sampleTexture(sampler2D samp, vec2 uv) {\n//   return texture2D(samp, uv);\n// }\n\n// //Shadows\n// vec2 shadowStepSize = 1. / vec2(1024);\n// const int shadowKernalSize = 3;\n// mat3 shadowKernel = mat3(\n//   1, 2, 1,\n//   2, 4, 2,\n//   1, 2, 1\n// );\n\n// const int levels = 2;\n// uniform float biases[levels];\n// uniform sampler2D projectedTextures[levels];\n// // varying vec4 projectedTexcoords[levels];\n\n// bool inRange(vec3 projCoord) {\n//   return projCoord.x >= 0.0 &&\n//       projCoord.x <= 1.0 &&\n//       projCoord.y >= 0.0 &&\n//       projCoord.y <= 1.0;\n// }\n\n// float getShadowAmount() {\n//   // vec3 proj = projectedTexcoords[0].xyz / projectedTexcoords[0].w;\n//   // float currentDepth = proj.z + biases[0];\n//   // float projectedDepth = texture2D(projectedTextures[0], proj.xy).r;\n//   // bool inside = inRange(proj);\n  \n//   // if (inside) {\n//   //   return (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n//   // }\n  \n//   // proj = projectedTexcoords[1].xyz / projectedTexcoords[1].w;\n//   // currentDepth = proj.z + biases[1];\n//   // projectedDepth = texture2D(projectedTextures[1], proj.xy).r;\n//   // inside = inRange(proj);\n\n//   // if (inside) {\n//   //   return (projectedDepth <= currentDepth ? shadowDarkness : 1.);\n//   // }\n\n//   return 1.;\n// }\n\n// // PBR\n// vec3 fresnelSchlick(float cosTheta, vec3 F0) {\n//   return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n// }\n\n// vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n//   return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n// } \n\n// float DistributionGGX(vec3 N, vec3 H, float roughness) {\n//   float a      = roughness*roughness;\n//   float a2     = a*a;\n//   float NdotH  = max(dot(N, H), 0.0);\n//   float NdotH2 = NdotH*NdotH;\n\n//   float num   = a2;\n//   float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n//   denom = PI * denom * denom;\n\n//   return num / denom;\n// }\n\n// float GeometrySchlickGGX(float NdotV, float roughness) {\n//   float r = (roughness + 1.0);\n//   float k = (r*r) / 8.0;\n\n//   float num   = NdotV;\n//   float denom = NdotV * (1.0 - k) + k;\n\n//   return num / denom;\n// }\n\n// float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n//   float NdotV = max(dot(N, V), 0.0);\n//   float NdotL = max(dot(N, L), 0.0);\n//   float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n//   float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n//   return ggx1 * ggx2;\n// }\n\n// vec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0) {\n//   vec3 F0 = vec3(scalarF0); \n//   F0 = mix(F0, albedo, metallic);\n//   vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.), F0, roughness);\n\n//   vec3 kS = F;\n//   vec3 kD = 1.0 - kS;\n//   kD *= 1.0 - metallic;\n    \n//   vec3 irradiance = textureCube(u_diffuseIBL, N).rgb;\n//   vec3 diffuse  = irradiance * albedo;\n    \n//   const float MAX_REFLECTION_LOD = 4.0;\n//   vec3 prefilteredColor = textureCubeLodEXT(u_specularIBL, R, roughness * MAX_REFLECTION_LOD).rgb;   \n//   vec2 envBRDF = texture2D(u_splitSum, vec2(max(dot(N, V), 0.), roughness)).rg;\n//   vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n//   vec3 ambient = (kD * diffuse + specular) * ao;\n\n//   return ambient;\n// }\n\n// vec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n//   vec3 L = normalize(lightDir);  \n//   vec3 H = normalize(V + L);  \n//   vec3 radiance     = lightColor;     \n//   vec3 F0 = vec3(scalarF0); \n//   F0      = mix(F0, albedo, metallic);\n//   vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n//   float NDF = DistributionGGX(N, H, roughness);       \n//   float G   = GeometrySmith(N, V, L, roughness);     \n//   vec3 nominator    = NDF * G * F;\n//   float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n//   vec3 specular     = nominator / denominator;       \n//   vec3 kS = F;\n//   vec3 kD = vec3(1.0) - kS;\n    \n//   kD *= 1.0 - metallic;     \n//   float NdotL = max(dot(N, L), 0.0);        \n//   return (kD * albedo / PI + specular) * radiance * NdotL;  \n// }\n\n// void main() {\n//   vec4 currentAlbedo = useTexture ? sampleTexture(albedoTexture, vUV) : vec4(1);\n//   currentAlbedo *= albedo;\n\n//   if (currentAlbedo.a <= alphaCutoff) {\n//     discard;\n//   }\n\n//   if (opaque) {\n//     currentAlbedo.a = 1.;\n//   }\n\n//   float _metallic = metallic;\n//   float _roughness = roughness;\n//   if (useMetallicRoughnessTexture) {\n//     vec3 ts = sampleTexture(metallicRoughnessTexture, vUV).rgb;\n//     _metallic *= ts.b;\n//     _roughness *= ts.g;\n//   }\n\n//   float _ao = ao;\n//   if (useOcclusionTexture) {\n//     _ao *= sampleTexture(occlusionTexture, vUV).r;\n//   }\n\n//   vec3 N = normalize(mat3(modelMatrix) * vNormal);\n//   vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n\n//   if (useNormalTexture && vTangent.xyz != vec3(0)) {\n//     vec3 tangentNormal = sampleTexture(normalTexture, vUV).rgb * 2. - 1.;\n//     N = normalize(vTBN * tangentNormal);\n//   }\n\n//   if (!gl_FrontFacing) {\n//     N *= -1.;\n//   }\n\n//   vec3 R = reflect(-V, N);\n\n//   float f0 = 0.04;\n\n//   vec3 col = vec3(0);\n//   col += IBL(N, V, R, currentAlbedo.rgb, _metallic, _roughness, f0) * _ao;\n//   if (sunIntensity != vec3(0)) {\n//     col += DirectionalLight(vPosition, N, V, sunDirection, sunIntensity, currentAlbedo.rgb, _metallic, _roughness, f0) * _ao * getShadowAmount();\n//   }\n\n//   if (useEmissiveTexture) {\n//     col += sampleTexture(emissiveTexture, vUV).rgb * emissiveFactor;\n//   }\n//   else {\n//     col += emissiveFactor;\n//   }\n\n//   gl_FragColor = vec4(col, currentAlbedo.a);\n//   return;\n// }\n";ft=ft.trim(),dt=dt.trim(),mt=mt.trim(),vt=vt.trim(),gt=gt.trim(),pt=pt.trim(),xt=xt.trim(),bt=bt.trim();var wt={lit:{vertex:yt=yt.trim(),fragment:Tt=Tt.trim()}},Et={lit:{vertex:ft,fragment:gt},litInstanced:{vertex:dt,fragment:pt},litSkinned:{vertex:mt,fragment:xt},litTrail:{vertex:vt,fragment:bt}},_t=Et.lit.vertex,Mt=`\n${at}\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform vec4 albedo;\n\nuniform float alphaCutoff; // uniform alphaCutoff = 0.5;\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec3 vTangent;\nin vec3 vColor;\nin vec2 vUV;\n\nconst int levels = 2;\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n${lt}\n\nvoid main() {\n  motionVector = vec2(0.5);\n\n  vec4 currentAlbedo = useTexture ? texture(albedoTexture, vUV) : vec4(1);\n  currentAlbedo *= albedo;\n  currentAlbedo.xyz *= vec3(1) - vColor.xyz;\n\n  if (currentAlbedo.a < alphaCutoff) {\n    discard;\n  }\n\n  #ifdef USEFOG\n    currentAlbedo = applyFog(currentAlbedo);\n  #endif\n\n  fragColor = currentAlbedo;\n}\n`,Rt=`\n${at}\n\nin vec3 position;\nin vec3 normal;\nin vec3 tangent;\nin vec4 color;\nin vec2 uv;\nin mat4 modelMatrix;\n\n// uniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\n\nconst int levels = 2;\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec3 vTangent;\nout vec4 vColor;\nout vec2 vUV;\n\nvoid main() {\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n  vPosition = vec3(modelMatrix * vec4(position, 1.0));\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n`,Ct=`\n${at}\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform vec4 albedo;\n\nuniform float alphaCutoff; // uniform alphaCutoff = 0.5;\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec3 vTangent;\nin vec4 vColor;\nin vec2 vUV;\n\nconst int levels = 2;\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n${lt}\n\nvoid main() {\n  motionVector = vec2(0.5);\n  \n  vec4 currentAlbedo = useTexture ? texture(albedoTexture, vUV) : vec4(1);\n  currentAlbedo *= albedo;\n  currentAlbedo.xyz *= vec3(1) - vColor.xyz;\n\n  if (currentAlbedo.a < alphaCutoff) {\n    discard;\n  }\n\n  #ifdef USEFOG\n    currentAlbedo = applyFog(currentAlbedo);\n  #endif\n\n  fragColor = currentAlbedo;\n}\n`,Ft="\n",At="\n";_t=_t.trim(),Mt=Mt.trim(),Rt=Rt.trim(),Ct=Ct.trim();var Dt={vertex:Ft=Ft.trim(),fragment:At=At.trim()},Pt={unlit:{vertex:_t,fragment:Mt},unlitInstanced:{vertex:Rt,fragment:Ct}};let St="\n#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec3 tangent;\nin vec3 color;\nin vec2 uv;\nuniform mat4 modelMatrix;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec3 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat4 vModelMatrix;\nout mat3 vTBN;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  // float biases[levels];\n};\n\nvoid main() {\n  vNormal = normal;\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n  vModelMatrix = modelMatrix;\n\n  vec3 center = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);\n  vec3 cameraRight = vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]);\n  vec3 cameraUp = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n  vec4 worldPosition = vec4(center + (cameraRight * position.x + cameraUp * position.y) * 0.5, 1);\n\n  vPosition = vec3(worldPosition); \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n",Nt="\n#version 300 es\nprecision highp float;\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\nuniform sampler2D albedoTexture;\n\nin vec2 vUV;\n\nvoid main() {\n  fragColor = texture(albedoTexture, vUV);\n  motionVector = vec2(0.5);\n}\n";St=St.trim(),Nt=Nt.trim();let Ut={billboard:{vertex:St,fragment:Nt}};var zt={webgl1:{particle:{vertex:"\n        attribute vec3 position;\n        attribute vec3 normal;\n        attribute vec3 tangent;\n        attribute vec4 color;\n        attribute vec2 uv;\n        attribute mat4 modelMatrix;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        varying vec3 vNormal;\n        varying vec3 vTangent;\n        varying vec4 vColor;\n        varying vec2 vUV;\n\n        void main() {\n          vNormal = normal;\n          vTangent = tangent;\n          vUV = uv;\n          vColor = color;\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        uniform sampler2D albedoTexture;\n        uniform bool useTexture;\n        uniform vec4 albedo;\n\n        varying vec3 vNormal;\n        varying vec3 vTangent;\n        varying vec4 vColor;\n        varying vec2 vUV;\n\n        void main() {\n          vec4 currentAlbedo = useTexture ? texture2D(albedoTexture, vUV) : vec4(1);\n          currentAlbedo *= albedo;\n          currentAlbedo *= vColor;\n\n          gl_FragColor = currentAlbedo;\n        }\n      "}},webgl2:{particle:{vertex:"\n        #version 300 es\n\n        in vec3 position;\n        in vec3 normal;\n        in vec3 tangent;\n        in vec4 color;\n        in vec2 uv;\n        in mat4 modelMatrix;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        out vec3 vNormal;\n        out vec3 vTangent;\n        out vec4 vColor;\n        out vec2 vUV;\n\n        void main() {\n          vNormal = normal;\n          vTangent = tangent;\n          vUV = uv;\n          vColor = color;\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        layout (location = 0) out vec4 fragColor;\n        layout (location = 1) out vec2 motionVector;\n\n        uniform sampler2D albedoTexture;\n        uniform bool useTexture;\n        uniform vec4 albedo;\n\n        in vec3 vNormal;\n        in vec3 vTangent;\n        in vec4 vColor;\n        in vec2 vUV;\n\n        void main() {\n          vec4 currentAlbedo = useTexture ? texture(albedoTexture, vUV) : vec4(1);\n          currentAlbedo *= albedo;\n          currentAlbedo *= vColor;\n\n          fragColor = currentAlbedo;\n          motionVector = vec2(0.5);\n        }\n      "}}};it(zt);var Lt=zt.webgl1,Bt=zt.webgl2,It={webgl1:{skybox:{vertex:"\n        attribute vec4 position;\n\n        varying vec4 vPosition;\n        \n        void main() {\n          vPosition = position;\n        \n          gl_Position = position;\n          gl_Position.z = 1.;\n        }\n      ",fragment:"\n        precision mediump float;\n\n        varying vec4 vPosition;\n        \n        uniform samplerCube skybox;\n        uniform mat4 viewDirectionProjectionInverse;\n\n        // #define USEFOG\n        const vec4 fogColor = vec4(0.23, 0.24, 0.26, 1);\n        \n        void main() {\n          vec4 t = viewDirectionProjectionInverse * vPosition;\n          vec3 col = textureCube(skybox, normalize(t.xyz / t.w)).rgb;\n        \n          #ifdef USEFOG\n            gl_FragColor = fogColor;\n          #else\n            gl_FragColor = vec4(col, 1);\n          #endif\n        }\n      "}},webgl2:{skybox:{vertex:"\n        #version 300 es\n        \n        in vec4 position;\n        \n        out vec4 vPosition;\n        \n        void main() {\n          vPosition = position;\n        \n          gl_Position = position;\n          gl_Position.z = 1.;\n        }\n      ",fragment:"\n        #version 300 es\n        precision mediump float;\n        \n        layout (location = 0) out vec4 fragColor;\n        layout (location = 1) out vec2 motionVector;\n        \n        in vec4 vPosition;\n        \n        uniform float environmentIntensity;\n        uniform samplerCube skybox;\n        uniform mat4 viewDirectionProjectionInverse;\n\n        uniform vec4 fogColor;\n        uniform float fogIntensity;\n\n        float _SkyboxSpeed = 0.01;\n        vec3 _SkyboxDirection = vec3(1, -0.3, 0);\n        uniform float iTime;\n\n        vec4 flowUVW(vec3 dir, vec3 curl, float t, bool flowB) {\n          float phaseOffset = flowB ? 0.5f : 0.0f;\n          float progress = t + phaseOffset - floor(t + phaseOffset);\n          vec3 offset = curl * progress;\n\n          vec4 uvw = vec4(dir, 0.0f);\n          uvw.xz -= offset.xy;\n          uvw.w = 1. - abs(1.0f - 2.0f * progress);\n\n          return uvw;\n        }\n        \n        void main() {\n          motionVector = vec2(0.5);\n\n          vec4 proj = viewDirectionProjectionInverse * vPosition;\n          vec3 viewDir = normalize(proj.xyz / proj.w);\n\n          // vec3 col = texture(skybox, viewDir).rgb * environmentIntensity;\n\n          vec3 curl = normalize(_SkyboxDirection);\n          float t = iTime * _SkyboxSpeed;\n          vec4 uvw1 = flowUVW(viewDir, curl, t, false);\n          vec4 uvw2 = flowUVW(viewDir, curl, t, true);\n\n          vec3 sky = texture(skybox, uvw1.xyz).rgb * uvw1.w;\n          vec3 sky2 = texture(skybox, uvw2.xyz).rgb * uvw2.w;\n          vec3 col = (sky + sky2) * environmentIntensity;\n\n          // Fog\n          col = mix(col, fogColor.rgb, fogIntensity * clamp(1. - viewDir.y * 10., 0., 1.));\n\n          fragColor = vec4(col, 1);\n        }\n      "}}};it(It);var Ot=It.webgl1,kt=It.webgl2,Vt={webgl2:{shadow:{vertex:"\n        attribute vec3 position;\n        attribute vec2 uv;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n        uniform mat4 modelMatrix;\n\n        varying vec2 vUV;\n\n        void main() {\n          vUV = uv;\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        varying vec2 vUV;\n\n        uniform sampler2D albedoTexture;\n        uniform bool useTexture;\n        uniform float alphaCutoff;\n\n        void main() {\n          if (useTexture && texture2D(albedoTexture, vUV).a < alphaCutoff) {\n            discard;\n          }\n\n          gl_FragColor = vec4(1, 0, 0, 1);\n        }\n      "},shadowInstanced:{vertex:"\n        attribute vec3 position;\n        attribute vec2 uv;\n        attribute mat4 modelMatrix;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        varying vec2 vUV;\n\n        void main() {\n          vUV = uv;\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n      ",fragment:null},shadowSkinned:{vertex:"\n        attribute vec3 position;\n        attribute vec2 uv;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n        uniform mat4 modelMatrix;\n\n        varying vec2 vUV;\n\n        //Skinning\n        attribute vec4 weights;\n        attribute vec4 joints;\n\n        uniform sampler2D u_jointTexture;\n        uniform float u_numJoints;\n\n        // these offsets assume the texture is 4 pixels across\n        #define ROW0_U ((0.5 + 0.0) / 4.)\n        #define ROW1_U ((0.5 + 1.0) / 4.)\n        #define ROW2_U ((0.5 + 2.0) / 4.)\n        #define ROW3_U ((0.5 + 3.0) / 4.)\n        \n        mat4 getBoneMatrix(float jointNdx) {\n          float v = (jointNdx + 0.5) / u_numJoints;\n          return mat4(\n            texture2D(u_jointTexture, vec2(ROW0_U, v)),\n            texture2D(u_jointTexture, vec2(ROW1_U, v)),\n            texture2D(u_jointTexture, vec2(ROW2_U, v)),\n            texture2D(u_jointTexture, vec2(ROW3_U, v))\n          );\n        }\n\n        void main() {\n          vUV = uv;\n\n          mat4 skinMatrix = getBoneMatrix(joints[0]) * weights[0] +\n                            getBoneMatrix(joints[1]) * weights[1] +\n                            getBoneMatrix(joints[2]) * weights[2] +\n                            getBoneMatrix(joints[3]) * weights[3];\n          \n          gl_Position = projectionMatrix * viewMatrix * modelMatrix * skinMatrix * vec4(position, 1.0);\n        }\n      ",fragment:null}}};Vt.webgl2.shadowInstanced.fragment=Vt.webgl2.shadow.fragment,Vt.webgl2.shadowSkinned.fragment=Vt.webgl2.shadow.fragment,Vt.webgl1={shadow:{vertex:Vt.webgl2.shadow.vertex,fragment:Vt.webgl2.shadow.fragment}},it(Vt);var Gt=Vt.webgl1,Xt=Vt.webgl2,jt={webgl2:{postprocessing:{vertex:"\n        #version 300 es\n\n        in vec2 position;\n\n        void main() {\n          gl_Position = vec4(position, 0.0, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        // #define DEBUG_COLOR\n        \n        out vec4 fragColor;\n\n        // uniform float iTime;\n        uniform vec2 SIZE;\n        uniform sampler2D mainTexture;\n        uniform sampler2D bloomTexture;\n        uniform sampler2D depthTexture;\n        uniform sampler2D motionBlurTexture;\n        uniform sampler2D downscaledTexture;\n        \n        uniform float bloomIntensity;\n        uniform float exposure;\n        uniform float gamma;\n        uniform float saturation;\n        uniform float contrast;\n        uniform float vignetteFalloff;\n        uniform float vignetteAmount;\n        \n        #ifdef ENABLE_MOTIONBLUR\n        uniform float motionBlurStrength;\n        #endif\n\n        uniform sampler2D rainTexture;\n        \n        vec3 godrays(float density, float weight, float decay, float exposure, vec2 screenSpaceLightPos, vec2 uv);\n        vec3 ACESFilm(vec3 x);\n        float getHeight(vec2 uv);\n        vec3 adjustSaturation(vec3 color, float value);\n        vec3 adjustContrast(vec3 color, float value);\n\n        // FXAA\n        #ifndef FXAA_REDUCE_MIN\n            #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n        #endif\n        #ifndef FXAA_REDUCE_MUL\n            #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n        #endif\n        #ifndef FXAA_SPAN_MAX\n            #define FXAA_SPAN_MAX     8.0\n        #endif\n\n        void texcoords(vec2 fragCoord, vec2 resolution,\n                       out vec2 v_rgbNW, out vec2 v_rgbNE,\n                       out vec2 v_rgbSW, out vec2 v_rgbSE,\n                       out vec2 v_rgbM);\n\n        vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n                  vec2 v_rgbNW, vec2 v_rgbNE, \n                  vec2 v_rgbSW, vec2 v_rgbSE, \n                  vec2 v_rgbM);\n\n        vec4 applyFXAA(sampler2D tex, vec2 fragCoord, vec2 resolution);\n\n        // DoF\n        #define MAX_BLUR 10.0\n\n        uniform float uFocusDistance;\n        uniform float uBlurCoefficient;\n        uniform float uPPM;\n        uniform vec2  uDepthRange;\n        uniform vec2 uResolution;\n        uniform vec2 uTexelOffset;\n        uniform sampler2D uDepth;\n\n        vec4 texture2D(sampler2D samp, vec2 uv) {\n          return texture(samp, uv);\n        }\n\n        // Raindrops\n\n        uniform float iTime;\n\n        #define S(x, y, z) smoothstep(x, y, z)\n        #define B(a, b, edge, t) S(a-edge, a+edge, t)*S(b+edge, b-edge, t)\n        #define sat(x) clamp(x,0.,1.)\n\n        #define streetLightCol vec3(1., .7, .3)\n        #define headLightCol vec3(.8, .8, 1.)\n        #define tailLightCol vec3(1., .1, .1)\n\n        #define HIGH_QUALITY\n        #define CAM_SHAKE 1.\n        #define LANE_BIAS .5\n        #define RAIN\n        //#define DROP_DEBUG\n\n        vec3 ro, rd;\n\n        float N(float t) {\n          return fract(sin(t*10234.324)*123423.23512);\n        }\n        vec3 N31(float p) {\n            //  3 out, 1 in... DAVE HOSKINS\n          vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n          p3 += dot(p3, p3.yzx + 19.19);\n          return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n        }\n        float N2(vec2 p)\n        {\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n          vec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n            p3 += dot(p3, p3.yzx + 19.19);\n            return fract((p3.x + p3.y) * p3.z);\n        }\n\n\n        float DistLine(vec3 ro, vec3 rd, vec3 p) {\n          return length(cross(p-ro, rd));\n        }\n        \n        vec3 ClosestPoint(vec3 ro, vec3 rd, vec3 p) {\n            // returns the closest point on ray r to point p\n            return ro + max(0., dot(p-ro, rd))*rd;\n        }\n\n        float Remap(float a, float b, float c, float d, float t) {\n          return ((t-a)/(b-a))*(d-c)+c;\n        }\n\n        float BokehMask(vec3 ro, vec3 rd, vec3 p, float size, float blur) {\n          float d = DistLine(ro, rd, p);\n            float m = S(size, size*(1.-blur), d);\n            \n            #ifdef HIGH_QUALITY\n            m *= mix(.7, 1., S(.8*size, size, d));\n            #endif\n            \n            return m;\n        }\n\n\n\n        float SawTooth(float t) {\n            return cos(t+cos(t))+sin(2.*t)*.2+sin(4.*t)*.02;\n        }\n\n        float DeltaSawTooth(float t) {\n            return 0.4*cos(2.*t)+0.08*cos(4.*t) - (1.-sin(t))*sin(t+cos(t));\n        }  \n\n        vec2 GetDrops(vec2 uv, float seed, float m) {\n            \n            float t = iTime+m*30.;\n            vec2 o = vec2(0.);\n            \n            #ifndef DROP_DEBUG\n            uv.y += t*.05;\n            #endif\n            \n            uv *= vec2(10., 2.5)*2.;\n            vec2 id = floor(uv);\n            vec3 n = N31(id.x + (id.y+seed)*546.3524);\n            vec2 bd = fract(uv);\n            \n            vec2 uv2 = bd;\n            \n            bd -= .5;\n            \n            bd.y*=4.;\n            \n            bd.x += (n.x-.5)*.6;\n            \n            t += n.z * 6.28;\n            float slide = SawTooth(t);\n            \n            float ts = 1.5;\n            vec2 trailPos = vec2(bd.x*ts, (fract(bd.y*ts*2.-t*2.)-.5)*.5);\n            \n            bd.y += slide*2.;\t\t\t\t\t\t\t\t// make drops slide down\n            \n            #ifdef HIGH_QUALITY\n            float dropShape = bd.x*bd.x;\n            dropShape *= DeltaSawTooth(t);\n            bd.y += dropShape;\t\t\t\t\t\t\t\t// change shape of drop when it is falling\n            #endif\n            \n            float d = length(bd);\t\t\t\t\t\t\t// distance to main drop\n            \n            float trailMask = S(-.2, .2, bd.y);\t\t\t\t// mask out drops that are below the main\n            trailMask *= bd.y;\t\t\t\t\t\t\t\t// fade dropsize\n            float td = length(trailPos*max(.5, trailMask));\t// distance to trail drops\n            \n            float mainDrop = S(.2, .1, d);\n            float dropTrail = S(.1, .02, td);\n            \n            dropTrail *= trailMask;\n            o = mix(bd*mainDrop, trailPos, dropTrail);\t\t// mix main drop and drop trail\n            \n            #ifdef DROP_DEBUG\n            if(uv2.x<.02 || uv2.y<.01) o = vec2(1.);\n            #endif\n            \n            return o;\n        }\n\n        vec2 rainEffect(vec2 uv) {\n          // vec3 f = normalize(lookat-ro);\n          // vec3 r = cross(vec3(0., 1., 0.), f);\n          // vec3 u = cross(f, r);\n\n          uv.x *= SIZE.x / SIZE.y;\n\n          float m = 0.;\n          float t = iTime;\n          vec2 offs = vec2(0.);\n\n          #ifdef RAIN\n          vec2 dropUv = uv;\n          \n          #ifdef HIGH_QUALITY\n          // float x = (sin(t*.1)*.5+.5)*.5;\n          // x = -x*x;\n          const float x = 0.2;\n          const float s = sin(x);\n          const float c = cos(x);\n          \n          const mat2 rot = mat2(c, -s, s, c);\n        \n          dropUv = uv*rot;\n          // dropUv.x += -sin(t*.1)*.5;\n          #endif\n          \n          offs = GetDrops(dropUv, 1., m);\n          \n          #ifndef DROP_DEBUG\n          offs += GetDrops(dropUv*1.4, 10., m);\n          #ifdef HIGH_QUALITY\n          // offs += GetDrops(dropUv*2.4, 25., m);\n          //offs += GetDrops(dropUv*3.4, 11.);\n          //offs += GetDrops(dropUv*3., 2.);\n          #endif\n          \n          // float ripple = sin(t+uv.y*3.1415*30.+uv.x*124.)*.5+.5;\n          // ripple *= .005;\n          // offs += vec2(ripple*ripple, ripple);\n          #endif\n          #endif\n\n          uv -= offs;\n          uv.x /= SIZE.x / SIZE.y;\n\n          return uv;\n        }\n        \n        void main() {\n          vec2 uv = gl_FragCoord.xy / SIZE;\n\n          #ifdef DEBUG_COLOR\n          fragColor = texture2D(mainTexture, uv);\n          return;\n          #endif\n        \n          // float stepSize = 0.02;\n          // float size = 2.; //?\n          // float s01 = getHeight(uv + vec2(-stepSize, 0));\n          // float s21 = getHeight(uv + vec2(stepSize, 0));\n          // float s10 = getHeight(uv + vec2(0, -stepSize));\n          // float s12 = getHeight(uv + vec2(0, stepSize));\n          // vec3 va = normalize(vec3(size, 0, s21 - s01));\n          // vec3 vb = normalize(vec3(0, size, s12 - s10));\n          // vec3 normal = cross(va, vb);\n        \n          // gl_FragColor = vec4(normal, 1);\n          // return;\n        \n          // Rain drops\n          // vec3 normal = texture(rainTexture, uv * 3.).rgb * 2. - 1.;\n          // float screenDistance = 0.07 * 0.5;\n          // vec2 uvOffset = normal.xy * screenDistance;\n          // uv += uvOffset;\n\n          // uv = rainEffect(uv);\n        \n          vec4 col = vec4(0);\n\n          // // DoF\n          // ivec2 fragCoord = ivec2(gl_FragCoord.xy);\n          // ivec2 resolution = ivec2(uResolution) - 1;\n\n          // // Convert to linear depth\n          // float ndc = 2.0 * texelFetch(uDepth, fragCoord, 0).r - 1.0;\n          // float depth = -(2.0 * uDepthRange.y * uDepthRange.x) / (ndc * (uDepthRange.y - uDepthRange.x) - uDepthRange.y - uDepthRange.x);\n          // float deltaDepth = abs(uFocusDistance - depth);\n          \n          // // Blur more quickly in the foreground.\n          // float xdd = depth < uFocusDistance ? abs(uFocusDistance - deltaDepth) : abs(uFocusDistance + deltaDepth);\n          // float blurRadius = min(floor(uBlurCoefficient * (deltaDepth / xdd) * uPPM), MAX_BLUR);\n          \n          // if (blurRadius > 1.0) {\n          //     float halfBlur = blurRadius * 0.5;\n\n          //     float count = 0.0;\n\n          //     // for (float i = 0.0; i <= MAX_BLUR; ++i) {\n          //     //     if (i > blurRadius) {\n          //     //         break;\n          //     //     }\n\n          //     //     // texelFetch outside texture gives vec4(0.0) (undefined in ES 3)\n          //     //     ivec2 sampleCoord = clamp(fragCoord + ivec2(((i - halfBlur) * uTexelOffset)), ivec2(0), resolution);\n          //     //     col += texelFetch(mainTexture, sampleCoord, 0);\n\n          //     //     ++count;\n          //     // }\n          //     for (float i = 0.0; i <= MAX_BLUR; ++i) {\n          //       if (i > blurRadius) {\n          //         break;\n          //       }\n\n          //       for (float j = 0.0; j <= MAX_BLUR; ++j) {\n          //         if (j > blurRadius) {\n          //           break;\n          //         }\n\n          //         // texelFetch outside texture gives vec4(0.0) (undefined in ES 3)\n          //         ivec2 sampleCoord = clamp(fragCoord + ivec2(i - halfBlur, j - halfBlur), ivec2(0), resolution);\n          //         col += texelFetch(mainTexture, sampleCoord, 0);\n          //         #ifdef ENABLE_BLOOM\n          //           vec4 bloom = texture2D(bloomTexture, vec2(sampleCoord) / vec2(resolution));\n          //           col.rgb += bloom.rgb * bloomIntensity;\n          //         #endif\n\n          //         ++count;\n          //       }\n          //     }\n\n          //     col /= count;\n          // } else {\n          //     col = texelFetch(mainTexture, fragCoord, 0);\n          // }\n\n          #ifdef ENABLE_MOTIONBLUR\n            const int nSamples = 32;\n            vec2 blurVec = motionBlurStrength * (texture2D(motionBlurTexture, uv).xy * 2. - 1.);\n            vec4 result = texture2D(mainTexture, uv);\n\n            for (int i = 1; i < nSamples; ++i) {\n              vec2 offset = blurVec * (float(i) / float(nSamples - 1) - 0.5);\n              result += texture2D(mainTexture, uv + offset);\n              // result += applyFXAA(mainTexture, (uv + offset) * SIZE, SIZE);\n            }\n            result /= float(nSamples);\n            col += result;\n          #else\n            vec4 samp = texture2D(mainTexture, uv);\n            // vec4 samp = applyFXAA(mainTexture, gl_FragCoord.xy, SIZE);\n            col += samp;\n          #endif\n\n          // Downscaled texture\n          vec4 downscaledCol = texture2D(downscaledTexture, uv);\n          col.rgb += downscaledCol.rgb;\n        \n          // Bloom\n          #ifdef ENABLE_BLOOM\n            vec4 bloom = texture2D(bloomTexture, uv);\n            col.rgb += bloom.rgb * bloomIntensity;\n          #endif\n        \n          // Godrays\n          #ifdef ENABLE_GODRAYS\n            col.rgb += godrays(1., 0.01, 0.97, 0.6, vec2(0.5, 0.5), uv);\n          #endif\n        \n          // Exposure correction\n          col.rgb = col.rgb * pow(2., exposure);\n        \n          // Tonemapping (HDR to LDR)\n          #ifdef TONEMAPPING\n            #if TONEMAPPING == 1\n              col.rgb = ACESFilm(col.rgb);\n            #elif TONEMAPPING == 2\n              col.rgb = col.rgb / (col.rgb + vec3(1.0));\n            #endif\n          #endif\n        \n          // Gamma correction\n          col.rgb = pow(col.rgb, vec3(1. / gamma));\n        \n          // Saturation, contrast\n          // #ifdef ENABLE_COLORGRADING\n          col.rgb = adjustSaturation(col.rgb, saturation);\n          col.rgb = adjustContrast(col.rgb, 1. + contrast);\n          // #endif\n\n          // Vignette\n          float dist = distance(uv, vec2(0.5, 0.5));\n          col.rgb *= smoothstep(0.8, vignetteFalloff * 0.799, dist * (vignetteAmount + vignetteFalloff));\n        \n          fragColor = col;\n        }\n\n        vec4 applyFXAA(sampler2D tex, vec2 fragCoord, vec2 resolution) {\n          mediump vec2 v_rgbNW;\n          mediump vec2 v_rgbNE;\n          mediump vec2 v_rgbSW;\n          mediump vec2 v_rgbSE;\n          mediump vec2 v_rgbM;\n\n          //compute the texture coords\n          texcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n          \n          //compute FXAA\n          return fxaa(tex, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n        }\n\n        vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n                    vec2 v_rgbNW, vec2 v_rgbNE, \n                    vec2 v_rgbSW, vec2 v_rgbSE, \n                    vec2 v_rgbM) {\n            vec4 color;\n            mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n            vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n            vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n            vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n            vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n            vec4 texColor = texture2D(tex, v_rgbM);\n            vec3 rgbM  = texColor.xyz;\n            vec3 luma = vec3(0.299, 0.587, 0.114);\n            float lumaNW = dot(rgbNW, luma);\n            float lumaNE = dot(rgbNE, luma);\n            float lumaSW = dot(rgbSW, luma);\n            float lumaSE = dot(rgbSE, luma);\n            float lumaM  = dot(rgbM,  luma);\n            float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n            float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n            \n            mediump vec2 dir;\n            dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n            dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n            \n            float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                                  (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n            \n            float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n            dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n                      max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                      dir * rcpDirMin)) * inverseVP;\n            \n            vec3 rgbA = 0.5 * (\n                texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n            vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n            float lumaB = dot(rgbB, luma);\n            if ((lumaB < lumaMin) || (lumaB > lumaMax))\n                color = vec4(rgbA, texColor.a);\n            else\n                color = vec4(rgbB, texColor.a);\n            return color;\n        }\n\n        void texcoords(vec2 fragCoord, vec2 resolution,\n              out vec2 v_rgbNW, out vec2 v_rgbNE,\n              out vec2 v_rgbSW, out vec2 v_rgbSE,\n              out vec2 v_rgbM) {\n          vec2 inverseVP = 1.0 / resolution.xy;\n          v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n          v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n          v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n          v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n          v_rgbM = vec2(fragCoord * inverseVP);\n        }\n        \n        vec3 ACESFilm(vec3 x) {\n          float a = 2.51;\n          float b = 0.03;\n          float c = 2.43;\n          float d = 0.59;\n          float e = 0.14;\n          return clamp((x*(a*x+b))/(x*(c*x+d)+e), vec3(0.), vec3(1.));\n        }\n        \n        vec3 godrays(float density, float weight, float decay, float exposure, vec2 screenSpaceLightPos, vec2 uv) {\n          vec3 fragColor = vec3(0);\n        \n          vec2 deltaTextCoord = vec2(uv - screenSpaceLightPos.xy);\n          vec2 textCoo = uv.xy;\n          deltaTextCoord *= (1.0 /  float(100)) * density;\n          float illuminationDecay = 1.0;\n        \n          for (int i = 0; i < 100; i++){\n            textCoo -= deltaTextCoord;\n            vec3 samp = clamp(texture2D(depthTexture, textCoo).xyz, vec3(0.3), vec3(10)) - vec3(0.3);\n            samp *= illuminationDecay * weight;\n            fragColor += samp;\n            illuminationDecay *= decay;\n          }\n        \n          fragColor *= exposure;\n\n          return fragColor;\n        }\n        \n        float getHeight(vec2 uv) {\n          float y = 0.5 + 0.2 * sin(uv.x * 12.);\n          float d = abs(uv.y - y);\n          float falloff = 40.;\n          float thickness = 0.;\n          float height = 1. - clamp(d * falloff - thickness, 0., 1.);\n          return height;\n        }\n\n        vec4 sharpen(in sampler2D tex, in vec2 coords, in vec2 renderSize) {\n          float dx = 1.0 / renderSize.x;\n          float dy = 1.0 / renderSize.y;\n          vec4 sum = vec4(0.0);\n          sum += -1. * texture2D(tex, coords + vec2( -1.0 * dx , 0.0 * dy));\n          sum += -1. * texture2D(tex, coords + vec2( 0.0 * dx , -1.0 * dy));\n          sum += 5. * texture2D(tex, coords + vec2( 0.0 * dx , 0.0 * dy));\n          sum += -1. * texture2D(tex, coords + vec2( 0.0 * dx , 1.0 * dy));\n          sum += -1. * texture2D(tex, coords + vec2( 1.0 * dx , 0.0 * dy));\n          return sum;\n        }\n        \n        vec3 adjustSaturation(vec3 color, float value) {\n          // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance\n          const vec3 luminosityFactor = vec3(0.2126, 0.7152, 0.0722);\n          vec3 grayscale = vec3(dot(color, luminosityFactor));\n        \n          return mix(grayscale, color, 1.0 + value);\n        }\n\n        vec3 adjustContrast(vec3 color, float value) {\n          return 0.5 + value * (color - 0.5);\n        }\n      "}}};jt.webgl1={postprocessing:{vertex:jt.webgl2.postprocessing.vertex,fragment:jt.webgl2.postprocessing.fragment}},it(jt);var Ht=jt.webgl1,Wt=jt.webgl2,qt={webgl1:{bloom:{vertex:"\n        attribute vec2 position;\n\n        void main() {\n          gl_Position = vec4(position, 0.0, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        uniform vec2 screenSize;\n        uniform sampler2D mainTexture;\n        uniform vec2 mainTextureSize;\n        uniform sampler2D secondTexture;\n        uniform int stage;\n\n        #define EPSILON 1.0e-4\n\n        uniform float _SampleScale;\n        uniform float threshold;\n        uniform float knee;\n        uniform float _Clamp;\n\n        float Max3(float a, float b, float c)\n        {\n          return max(max(a, b), c);\n        }\n\n        vec4 QuadraticThreshold(vec4 color, float threshold, vec3 curve)\n        {\n            // Pixel brightness\n            float br = Max3(color.r, color.g, color.b);\n\n            // Under-threshold part: quadratic curve\n            float rq = clamp(br - curve.x, 0.0, curve.y);\n            rq = curve.z * rq * rq;\n\n            // Combine and apply the brightness response curve.\n            color *= max(rq, br - threshold) / max(br, EPSILON);\n\n            return color;\n        }\n\n        vec4 DownsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n        {\n            vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\n            vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\n            vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\n            vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\n            vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\n            vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\n            vec4 G = texture2D(tex, uv                               );\n            vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\n            vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\n            vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\n            vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\n            vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\n            vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\n\n            vec2 div = (1.0 / 4.0) * vec2(0.5, 0.125);\n\n            vec4 o = (D + E + I + J) * div.x;\n            o += (A + B + G + F) * div.y;\n            o += (B + C + H + G) * div.y;\n            o += (F + G + L + K) * div.y;\n            o += (G + H + M + L) * div.y;\n\n            return o;\n        }\n\n        // Standard box filtering\n        vec4 DownsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n        {\n            vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\n\n            vec4 s;\n            s =  (texture2D(tex, uv + d.xy));\n            s += (texture2D(tex, uv + d.zy));\n            s += (texture2D(tex, uv + d.xw));\n            s += (texture2D(tex, uv + d.zw));\n\n            return s * (1.0 / 4.0);\n        }\n\n        // 9-tap bilinear upsampler (tent filter)\n        vec4 UpsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n        {\n            vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\n\n            vec4 s;\n            s =  texture2D(tex, uv - d.xy);\n            s += texture2D(tex, uv - d.wy) * 2.0;\n            s += texture2D(tex, uv - d.zy);\n\n            s += texture2D(tex, uv + d.zw) * 2.0;\n            s += texture2D(tex, uv       ) * 4.0;\n            s += texture2D(tex, uv + d.xw) * 2.0;\n\n            s += texture2D(tex, uv + d.zy);\n            s += texture2D(tex, uv + d.wy) * 2.0;\n            s += texture2D(tex, uv + d.xy);\n\n            return s * (1.0 / 16.0);\n        }\n\n        // Standard box filtering\n        vec4 UpsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n        {\n            vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * (sampleScale * 0.5);\n\n            vec4 s;\n            s =  (texture2D(tex, uv + d.xy));\n            s += (texture2D(tex, uv + d.zy));\n            s += (texture2D(tex, uv + d.xw));\n            s += (texture2D(tex, uv + d.zw));\n\n            return s * (1.0 / 4.0);\n        }\n\n        vec4 SafeHDR(vec4 color) {\n          return color;\n        }\n\n        vec2 getTexelSize(sampler2D tex) {\n          return vec2(1.) / mainTextureSize;\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Prefilter\n\n        vec4 Prefilter(vec4 color, vec2 uv)\n        {\n            vec4 _Threshold = vec4(threshold, threshold - knee, knee * 2., 0.25 / knee); // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\n\n            color = min(vec4(_Clamp), color); // clamp to max\n            color = QuadraticThreshold(color, _Threshold.x, _Threshold.yzw);\n            return color;\n        }\n\n        vec4 FragPrefilter13(vec2 uv)\n        {\n            vec4 color = DownsampleBox13Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return Prefilter(SafeHDR(color), uv);\n        }\n\n        vec4 FragPrefilter4(vec2 uv)\n        {\n            vec4 color = DownsampleBox4Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return Prefilter(SafeHDR(color), uv);\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Downsample\n\n        vec4 FragDownsample13(vec2 uv)\n        {\n            vec4 color = DownsampleBox13Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return color;\n        }\n\n        vec4 FragDownsample4(vec2 uv)\n        {\n            vec4 color = DownsampleBox4Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return color;\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Upsample & combine\n\n        vec4 Combine(vec4 bloom, vec2 uv)\n        {\n            vec4 color = texture2D(secondTexture, uv);\n            return bloom + color;\n        }\n\n        vec4 FragUpsampleTent(vec2 uv)\n        {\n            vec4 bloom = UpsampleTent(mainTexture, uv, getTexelSize(mainTexture), vec4(_SampleScale));\n            return Combine(bloom, uv);\n        }\n\n        vec4 FragUpsampleBox(vec2 uv)\n        {\n            vec4 bloom = UpsampleBox(mainTexture, uv, getTexelSize(mainTexture), vec4(_SampleScale));\n            return Combine(bloom, uv);\n        }\n\n        void main() {\n          vec2 uv = gl_FragCoord.xy / screenSize;\n          vec3 col = texture2D(mainTexture, uv).rgb;\n          vec4 outCol = vec4(1, 0, 1, 1);\n\n          if (stage == 6) {\n            gl_FragColor = vec4(col, 1);\n            return;\n          }\n\n          if (stage == 0) {\n            outCol = FragPrefilter13(uv);\n          }\n          else if (stage == 1) {\n            outCol = FragDownsample13(uv);\n          }\n          else if (stage == 2) {\n            outCol = FragUpsampleTent(uv);\n          }\n\n          gl_FragColor = vec4(outCol.xyz, 1);\n        }\n      "}},webgl2:{bloom:{vertex:"\n        #version 300 es\n\n        in vec2 position;\n\n        void main() {\n          gl_Position = vec4(position, 0.0, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        layout (location = 0) out vec4 fragColor;\n\n        uniform vec2 screenSize;\n        uniform sampler2D mainTexture;\n        uniform sampler2D secondTexture;\n        uniform int stage;\n\n        #define EPSILON 1.0e-4\n\n        uniform float _SampleScale;\n        uniform float threshold;\n        uniform float knee;\n        uniform float _Clamp;\n\n        float Max3(float a, float b, float c)\n        {\n          return max(max(a, b), c);\n        }\n\n        vec4 QuadraticThreshold(vec4 color, float threshold, vec3 curve)\n        {\n            // Pixel brightness\n            float br = Max3(color.r, color.g, color.b);\n\n            // Under-threshold part: quadratic curve\n            float rq = clamp(br - curve.x, 0.0, curve.y);\n            rq = curve.z * rq * rq;\n\n            // Combine and apply the brightness response curve.\n            color *= max(rq, br - threshold) / max(br, EPSILON);\n\n            return color;\n        }\n\n        vec4 DownsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n        {\n            vec4 A = texture(tex, uv + texelSize * vec2(-1.0, -1.0));\n            vec4 B = texture(tex, uv + texelSize * vec2( 0.0, -1.0));\n            vec4 C = texture(tex, uv + texelSize * vec2( 1.0, -1.0));\n            vec4 D = texture(tex, uv + texelSize * vec2(-0.5, -0.5));\n            vec4 E = texture(tex, uv + texelSize * vec2( 0.5, -0.5));\n            vec4 F = texture(tex, uv + texelSize * vec2(-1.0,  0.0));\n            vec4 G = texture(tex, uv                               );\n            vec4 H = texture(tex, uv + texelSize * vec2( 1.0,  0.0));\n            vec4 I = texture(tex, uv + texelSize * vec2(-0.5,  0.5));\n            vec4 J = texture(tex, uv + texelSize * vec2( 0.5,  0.5));\n            vec4 K = texture(tex, uv + texelSize * vec2(-1.0,  1.0));\n            vec4 L = texture(tex, uv + texelSize * vec2( 0.0,  1.0));\n            vec4 M = texture(tex, uv + texelSize * vec2( 1.0,  1.0));\n\n            vec2 div = (1.0 / 4.0) * vec2(0.5, 0.125);\n\n            vec4 o = (D + E + I + J) * div.x;\n            o += (A + B + G + F) * div.y;\n            o += (B + C + H + G) * div.y;\n            o += (F + G + L + K) * div.y;\n            o += (G + H + M + L) * div.y;\n\n            return o;\n        }\n\n        // Standard box filtering\n        vec4 DownsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n        {\n            vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\n\n            vec4 s;\n            s =  (texture(tex, uv + d.xy));\n            s += (texture(tex, uv + d.zy));\n            s += (texture(tex, uv + d.xw));\n            s += (texture(tex, uv + d.zw));\n\n            return s * (1.0 / 4.0);\n        }\n\n        // 9-tap bilinear upsampler (tent filter)\n        vec4 UpsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n        {\n            vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\n\n            vec4 s;\n            s =  texture(tex, uv - d.xy);\n            s += texture(tex, uv - d.wy) * 2.0;\n            s += texture(tex, uv - d.zy);\n\n            s += texture(tex, uv + d.zw) * 2.0;\n            s += texture(tex, uv       ) * 4.0;\n            s += texture(tex, uv + d.xw) * 2.0;\n\n            s += texture(tex, uv + d.zy);\n            s += texture(tex, uv + d.wy) * 2.0;\n            s += texture(tex, uv + d.xy);\n\n            return s * (1.0 / 16.0);\n        }\n\n        // Standard box filtering\n        vec4 UpsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n        {\n            vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * (sampleScale * 0.5);\n\n            vec4 s;\n            s =  (texture(tex, uv + d.xy));\n            s += (texture(tex, uv + d.zy));\n            s += (texture(tex, uv + d.xw));\n            s += (texture(tex, uv + d.zw));\n\n            return s * (1.0 / 4.0);\n        }\n\n        vec4 SafeHDR(vec4 color) {\n          return color;\n        }\n\n        vec2 getTexelSize(sampler2D tex) {\n          return vec2(1.) / vec2(textureSize(tex, 0));\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Prefilter\n\n        vec4 Prefilter(vec4 color, vec2 uv)\n        {\n            vec4 _Threshold = vec4(threshold, threshold - knee, knee * 2., 0.25 / knee); // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\n\n            color = min(vec4(_Clamp), color); // clamp to max\n            color = QuadraticThreshold(color, _Threshold.x, _Threshold.yzw);\n            return color;\n        }\n\n        vec4 FragPrefilter13(vec2 uv)\n        {\n            vec4 color = DownsampleBox13Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return Prefilter(SafeHDR(color), uv);\n        }\n\n        vec4 FragPrefilter4(vec2 uv)\n        {\n            vec4 color = DownsampleBox4Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return Prefilter(SafeHDR(color), uv);\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Downsample\n\n        vec4 FragDownsample13(vec2 uv)\n        {\n            vec4 color = DownsampleBox13Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return color;\n        }\n\n        vec4 FragDownsample4(vec2 uv)\n        {\n            vec4 color = DownsampleBox4Tap(mainTexture, uv, getTexelSize(mainTexture));\n            return color;\n        }\n\n        // ----------------------------------------------------------------------------------------\n        // Upsample & combine\n\n        vec4 Combine(vec4 bloom, vec2 uv)\n        {\n            vec4 color = texture(secondTexture, uv);\n            return bloom + color;\n        }\n\n        vec4 FragUpsampleTent(vec2 uv)\n        {\n            vec4 bloom = UpsampleTent(mainTexture, uv, getTexelSize(mainTexture), vec4(_SampleScale));\n            return Combine(bloom, uv);\n        }\n\n        vec4 FragUpsampleBox(vec2 uv)\n        {\n            vec4 bloom = UpsampleBox(mainTexture, uv, getTexelSize(mainTexture), vec4(_SampleScale));\n            return Combine(bloom, uv);\n        }\n\n        void main() {\n          vec2 uv = gl_FragCoord.xy / screenSize;\n          vec3 col = texture(mainTexture, uv).rgb;\n          vec4 outCol = vec4(1, 0, 1, 1);\n\n          if (stage == 6) {\n            fragColor = vec4(col, 1);\n            return;\n          }\n\n          // if (stage == 0) {\n          //   outCol = vec3(col.r, 0, 0);\n          // }\n          // else if (stage == 1) {\n          //   outCol = vec3(0, col.g, 0);\n          // }\n          // else if (stage == 2) {\n          //   outCol = vec3(0, 0, col.b);\n          // }\n          // else if (stage == 3) {\n          //   outCol = vec3(0, 0, 0);\n          // }\n\n          if (stage == 0) {\n            outCol = FragPrefilter13(uv);\n          }\n          // else if (stage == 1) {\n          //   outCol = FragPrefilter4(uv);\n          // }\n          else if (stage == 1) {\n            outCol = FragDownsample13(uv);\n          }\n          // else if (stage == 3) {\n          //   outCol = FragDownsample4(uv);\n          // }\n\n          else if (stage == 2) {\n            outCol = FragUpsampleTent(uv);\n          }\n          // else if (stage == 5) {\n          //   outCol = FragUpsampleBox(uv);\n          // }\n\n          fragColor = vec4(outCol.xyz, 1);\n        }\n      "}}};it(qt);var Yt=qt.webgl1,Kt=qt.webgl2,$t={webgl1:{equirectangularToCubemap:{vertex:"\n        attribute vec3 position;\n\n        varying vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main() {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        varying vec3 localPos;\n\n        uniform sampler2D equirectangularMap;\n\n        const vec2 invAtan = vec2(0.1591, 0.3183);\n        vec2 SampleSphericalMap(vec3 v) {\n            vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n\n        void main() {\n            vec2 uv = SampleSphericalMap(normalize(localPos)); // make sure to normalize localPos\n            vec3 color = texture2D(equirectangularMap, uv).rgb;\n            \n            gl_FragColor = vec4(color, 1.0);\n        }\n      "}},webgl2:{equirectangularToCubemap:{vertex:"\n        #version 300 es\n        layout (location = 0) in vec3 position;\n\n        out vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main()\n        {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        out vec4 FragColor;\n        in vec3 localPos;\n\n        uniform sampler2D equirectangularMap;\n\n        const vec2 invAtan = vec2(0.1591, 0.3183);\n        vec2 SampleSphericalMap(vec3 v)\n        {\n            vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n\n        void main()\n        {\n            vec2 uv = SampleSphericalMap(normalize(localPos)); // make sure to normalize localPos\n            vec4 color = texture(equirectangularMap, uv);\n            \n            color.rgb *= pow(2., color.a * 255. - (128. + 8.)) * 255.;\n\n            FragColor = vec4(color.rgb, 1.0);\n        }\n      "}}};it($t);var Qt=$t.webgl1,Jt=$t.webgl2,Zt={webgl1:{diffuseCubemap:{vertex:"\n        attribute vec3 position;\n\n        varying vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main() {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        precision highp float;\n\n        varying vec3 localPos;\n\n        uniform samplerCube environmentMap;\n\n        const float PI = 3.14159265359;\n\n        void main() {\t\t\n            // the sample direction equals the hemisphere's orientation \n            vec3 normal = normalize(localPos);\n          \n            vec3 irradiance = vec3(0.0);  \n\n            vec3 up = vec3(0.0, 1.0, 0.0);\n            vec3 right = normalize(cross(up, normal));\n            up = normalize(cross(normal, right));\n\n            const float sampleDelta = 0.025 / 3.;\n            float nrSamples = 0.0; \n            for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {\n                for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta) {\n                    // spherical to cartesian (in tangent space)\n                    vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n                    // tangent space to world\n                    vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal; \n\n                    irradiance += min(textureCube(environmentMap, sampleVec).rgb, vec3(3000)) * cos(theta) * sin(theta);\n                    nrSamples++;\n                }\n            }\n\n            irradiance = PI * irradiance * (1.0 / float(nrSamples));\n          \n            gl_FragColor = vec4(irradiance, 1.0);\n        }\n      "}},webgl2:{diffuseCubemap:{vertex:"\n        #version 300 es\n        layout (location = 0) in vec3 position;\n\n        out vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main()\n        {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        out vec4 FragColor;\n        in vec3 localPos;\n\n        uniform samplerCube environmentMap;\n        const vec3 maxBrightness = vec3(3000000);\n        const float sampleDelta = 0.025 / 3.;\n\n        const float PI = 3.14159265359;\n\n        void main() {\t\t\n            // the sample direction equals the hemisphere's orientation \n            vec3 normal = normalize(localPos);\n          \n            vec3 irradiance = vec3(0.0);  \n\n            vec3 up = vec3(0.0, 1.0, 0.0);\n            vec3 right = normalize(cross(up, normal));\n            up = normalize(cross(normal, right));\n\n            // FragColor = vec4(texture(environmentMap, normal).rgb, 1.0);\n            // return;\n\n            float nrSamples = 0.0; \n            for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {\n                for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta) {\n                    // spherical to cartesian (in tangent space)\n                    vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n                    // tangent space to world\n                    vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal; \n\n                    vec3 sampleColor = texture(environmentMap, sampleVec).rgb;\n                    // sampleColor = pow(sampleColor, vec3(2.2));\n\n                    irradiance += min(sampleColor, maxBrightness) * cos(theta) * sin(theta);\n                    nrSamples++;\n                }\n            }\n\n            irradiance = PI * irradiance * (1.0 / float(nrSamples));\n            // irradiance = pow(irradiance, vec3(1. / 2.2));\n          \n            FragColor = vec4(irradiance, 1.0);\n        }\n      "}}};it(Zt);var en=Zt.webgl1,tn=Zt.webgl2,nn={webgl1:{specularCubemap:{vertex:"\n        attribute vec3 position;\n\n        varying vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main() {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        #extension GL_EXT_shader_texture_lod : enable\n        precision highp float;\n\n        #ifndef GL_EXT_shader_texture_lod\n        vec4 textureCubeLodEXT(samplerCube t, vec3 n, float lod) {\n          return textureCube(t, n);\n        }\n        #endif\n\n        varying vec3 localPos;\n\n        uniform samplerCube environmentMap;\n        uniform float roughness;\n\n        const float PI = 3.14159265359;\n\n        float VanDerCorput(int n, int base);\n        vec2 Hammersley(int i, int N);\n        vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);\n        float DistributionGGX(float NdotH, float roughness);\n        float saturate(float x);\n          \n        void main()\n        {\t\t\n            vec3 N = normalize(localPos);    \n            vec3 R = N;\n            vec3 V = R;\n\n            const int SAMPLE_COUNT = 512;\n            // const int SAMPLE_COUNT = 4096;\n\n            float totalWeight = 0.0;\n            vec3 prefilteredColor = vec3(0.0);\n\n            float resolution = 1024.0; // resolution of source cubemap (per face)\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n\n            for(int i = 0; i < SAMPLE_COUNT; ++i)\n            {\n                vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n                vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n                vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n                float NdotL = max(dot(N, L), 0.0);\n                if(NdotL > 0.0)\n                {\n                    float NdotH = saturate(dot(N, H));\n                    float HdotV = saturate(dot(H, V));\n\n                    float D   = DistributionGGX(NdotH, roughness);\n                    float pdf = (D * NdotH / (4.0 * HdotV)) + 0.0001; \n                    float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n                    float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); \n\n                    prefilteredColor += min(textureCubeLodEXT(environmentMap, L, mipLevel).rgb, vec3(100)) * NdotL;\n                    totalWeight      += NdotL;\n                }\n            }\n            prefilteredColor = prefilteredColor / totalWeight;\n\n            gl_FragColor = vec4(prefilteredColor, 1.0);\n        }\n\n        float VanDerCorput(int n, int base)\n        {\n            float invBase = 1.0 / float(base);\n            float denom   = 1.0;\n            float result  = 0.0;\n\n            for(int i = 0; i < 32; ++i)\n            {\n                if(n > 0)\n                {\n                    denom   = mod(float(n), 2.0);\n                    result += denom * invBase;\n                    invBase = invBase / 2.0;\n                    n       = int(float(n) / 2.0);\n                }\n            }\n\n            return result;\n        }\n        // ----------------------------------------------------------------------------\n        vec2 Hammersley(int i, int N)\n        {\n            return vec2(float(i)/float(N), VanDerCorput(i, 2));\n        }\n\n        vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n        {\n            float a = roughness*roughness;\n          \n            float phi = 2.0 * PI * Xi.x;\n            float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n            float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n          \n            // from spherical coordinates to cartesian coordinates\n            vec3 H;\n            H.x = cos(phi) * sinTheta;\n            H.y = sin(phi) * sinTheta;\n            H.z = cosTheta;\n          \n            // from tangent-space vector to world-space sample vector\n            vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n            vec3 tangent   = normalize(cross(up, N));\n            vec3 bitangent = cross(N, tangent);\n          \n            vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n            return normalize(sampleVec);\n        }\n\n        float DistributionGGX(float NdotH, float roughness)\n        {\n            float a      = roughness*roughness;\n            float a2     = a*a;\n            float NdotH2 = NdotH*NdotH;\n          \n            float nom   = a2;\n            float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n            denom = PI * denom * denom;\n          \n            return nom / denom;\n        }\n\n        float saturate(float x) {\n            return max(0., min(1., x));\n        }\n      "}},webgl2:{specularCubemap:{vertex:"\n        #version 300 es\n        layout (location = 0) in vec3 position;\n\n        out vec3 localPos;\n\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n\n        void main()\n        {\n            localPos = position;\n            gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);\n        }\n      ",fragment:"\n        #version 300 es\n        precision highp float;\n\n        out vec4 FragColor;\n        in vec3 localPos;\n\n        uniform samplerCube environmentMap;\n        uniform float roughness;\n\n        const float PI = 3.14159265359;\n\n        float RadicalInverse_VdC(uint bits);\n        vec2 Hammersley(uint i, uint N);\n        vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);\n        float DistributionGGX(float NdotH, float roughness);\n        float saturate(float x);\n\n        // Settings\n        const uint SAMPLE_COUNT = 1024u;//4096u * 4u;\n        const vec3 maxBrightness = vec3(50);\n        // --------\n          \n        void main()\n        {\t\t\n            vec3 N = normalize(localPos);    \n            vec3 R = N;\n            vec3 V = R;\n\n            float totalWeight = 0.0;\n            vec3 prefilteredColor = vec3(0.0);\n\n            float resolution = float(textureSize(environmentMap, 0).x);//1024.0; // resolution of source cubemap (per face)\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n\n            for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n            {\n                vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n                vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n                vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n                float NdotL = max(dot(N, L), 0.0);\n                if(NdotL > 0.0)\n                {\n                    float NdotH = saturate(dot(N, H));\n                    float HdotV = saturate(dot(H, V));\n\n                    float D   = DistributionGGX(NdotH, roughness);\n                    float pdf = (D * NdotH / (4.0 * HdotV)) + 0.0001; \n                    float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n                    float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); \n\n                    prefilteredColor += min(textureLod(environmentMap, L, mipLevel).rgb, maxBrightness) * NdotL;\n                    totalWeight      += NdotL;\n                }\n            }\n            prefilteredColor = prefilteredColor / totalWeight;\n\n            FragColor = vec4(prefilteredColor, 1.0);\n        }\n\n        float RadicalInverse_VdC(uint bits) \n        {\n            bits = (bits << 16u) | (bits >> 16u);\n            bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n            bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n            bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n            bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n            return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n        }\n        // ----------------------------------------------------------------------------\n        vec2 Hammersley(uint i, uint N)\n        {\n            return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n        }\n\n        vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n        {\n            float a = roughness*roughness;\n          \n            float phi = 2.0 * PI * Xi.x;\n            float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n            float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n          \n            // from spherical coordinates to cartesian coordinates\n            vec3 H;\n            H.x = cos(phi) * sinTheta;\n            H.y = sin(phi) * sinTheta;\n            H.z = cosTheta;\n          \n            // from tangent-space vector to world-space sample vector\n            vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n            vec3 tangent   = normalize(cross(up, N));\n            vec3 bitangent = cross(N, tangent);\n          \n            vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n            return normalize(sampleVec);\n        }\n\n        float DistributionGGX(float NdotH, float roughness)\n        {\n            float a      = roughness*roughness;\n            float a2     = a*a;\n            float NdotH2 = NdotH*NdotH;\n          \n            float nom   = a2;\n            float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n            denom = PI * denom * denom;\n          \n            return nom / denom;\n        }\n\n        float saturate(float x) {\n            return max(0., min(1., x));\n        }\n      "}}};it(nn);var rn=nn.webgl1,an=nn.webgl2,on=`\n${tt}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent;\nin vec3 color;\nin vec2 uv;\n\nout vec4 vPosition;\nout vec3 vNormal;\nout vec4 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvoid main() {\n  vNormal = mat3(modelMatrix) * normal; // in world-space\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(normal, vTangent.xyz) * vTangent.w, 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  vPosition = worldPosition;\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n`,sn=`\n${tt}\n\nlayout (location = 0) out vec4 gPosition;\nlayout (location = 1) out vec3 gNormal;\nlayout (location = 2) out vec3 gAlbedo;\nlayout (location = 3) out vec4 gProperties;\nlayout (location = 4) out vec4 gPositionViewSpace;\n\nin vec4 vPosition;\nin vec3 vNormal;\nin vec4 vTangent;\nin vec3 vColor;\nin vec2 vUV;\nin mat3 vTBN;\n\nuniform float enableMotionBlur;\n\n// Material properties\nuniform sampler2D albedoTexture;\nuniform bool useTexture;\nuniform sampler2D normalTexture;\nuniform bool useNormalTexture;\nuniform sampler2D metallicRoughnessTexture;\nuniform bool useMetallicRoughnessTexture;\nuniform sampler2D emissiveTexture;\nuniform bool useEmissiveTexture;\nuniform sampler2D occlusionTexture;\nuniform bool useOcclusionTexture;\n\nuniform vec4 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform vec3 emissiveFactor;\nfloat ao = 1.;\n\nuniform float alphaCutoff;\nuniform float normalStrength;\n\nuniform mat4 viewMatrix;\n\nvec3 setNormalStrength(vec3 normal, float strength) {\n  return vec3(normal.xy * strength, mix(1., normal.z, clamp(strength, 0., 1.)));\n}\n\nvoid main() {\n  vec4 _albedo = albedo * (useTexture ? texture(albedoTexture, vUV) : vec4(1));\n  if (_albedo.a < alphaCutoff) {\n    discard;\n  }\n\n  gPosition = vec4(vPosition.xyz, 1);\n  gPositionViewSpace = viewMatrix * vPosition;\n\n  if (useNormalTexture) {\n    vec3 _tangentNormal = texture(normalTexture, vUV).rgb;\n    _tangentNormal = _tangentNormal * 2. - 1.;\n    _tangentNormal = setNormalStrength(_tangentNormal, normalStrength);\n    gNormal = normalize(vTBN * _tangentNormal);\n  }\n  else {\n    gNormal = normalize(vNormal);\n  }\n\n  if (!gl_FrontFacing) {\n    gNormal *= -1.;\n  }\n\n  gAlbedo = _albedo.rgb + emissiveFactor;\n\n  float _metallic = metallic;\n  float _roughness = roughness;\n  if (useMetallicRoughnessTexture) {\n    vec3 ts = texture(metallicRoughnessTexture, vUV).rgb;\n    _metallic *= ts.b;\n    _roughness *= ts.g;\n  }\n  gProperties = vec4(_roughness, _metallic, enableMotionBlur, 1);\n}\n`;on=on.trim(),sn=sn.trim();var ln=`\n${tt}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent;\nin vec3 color;\nin vec2 uv;\nin mat4 modelMatrix;\n\nout vec4 vPosition;\nout vec3 vNormal;\nout vec4 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\nout mat4 vModelMatrix;\n\n// const int levels = 2;\n\n// uniform sharedPerScene {\n//   mat4 projectionMatrix;\n//   mat4 viewMatrix;\n//   mat4 inverseViewMatrix;\n//   float biases[levels];\n// };\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\n\n// //Shadows\n// uniform mat4 textureMatrices[levels];\n// out vec4 projectedTexcoords[levels];\n\nvoid main() {\n  vNormal = mat3(modelMatrix) * normal; // in world-space\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n  vModelMatrix = modelMatrix;\n\n  vec3 _T = normalize(vec3(modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * vec4(cross(vNormal, vTangent.xyz) * vTangent.w, 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * vec4(vNormal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  // for (int i = 0; i < levels; i++) {\n  //   projectedTexcoords[i] = textureMatrices[i] * worldPosition;\n  // }\n\n  vPosition = worldPosition;\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n`,cn=sn;cn=(cn=cn.replace(/modelMatrix/g,"vModelMatrix")).replace(/uniform mat4 vModelMatrix/g,"in mat4 vModelMatrix"),ln=ln.trim(),cn=cn.trim();var un=`\n${tt}\n\nin vec3 position;\nin vec3 normal;\nin vec4 tangent;\nin vec3 color;\nin vec2 uv;\n\nout vec4 vPosition;\nout vec3 vNormal;\nout vec4 vTangent;\nout vec3 vColor;\nout vec2 vUV;\nout mat3 vTBN;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n//Skinning\nin vec4 weights;\nin vec4 joints;\n\nuniform sampler2D u_jointTexture;\nuniform float u_numJoints;\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.)\n#define ROW1_U ((0.5 + 1.0) / 4.)\n#define ROW2_U ((0.5 + 2.0) / 4.)\n#define ROW3_U ((0.5 + 3.0) / 4.)\n\nmat4 getBoneMatrix(float jointNdx) {\n  float v = (jointNdx + 0.5) / u_numJoints;\n  return mat4(\n    texture(u_jointTexture, vec2(ROW0_U, v)),\n    texture(u_jointTexture, vec2(ROW1_U, v)),\n    texture(u_jointTexture, vec2(ROW2_U, v)),\n    texture(u_jointTexture, vec2(ROW3_U, v))\n  );\n}\n\nvoid main() {\n  mat4 skinMatrix = getBoneMatrix(joints[0]) * weights[0] +\n                    getBoneMatrix(joints[1]) * weights[1] +\n                    getBoneMatrix(joints[2]) * weights[2] +\n                    getBoneMatrix(joints[3]) * weights[3];\n\n  vNormal = mat3(modelMatrix * skinMatrix) * normal; // in world-space\n  vTangent = tangent;\n  vUV = uv;\n  vColor = color;\n\n  vec3 _T = normalize(vec3(modelMatrix * skinMatrix * modelMatrix * vec4(vTangent.xyz, 0.0)));\n  vec3 _B = normalize(vec3(modelMatrix * skinMatrix * modelMatrix * vec4(cross(normal, vTangent.xyz) * vTangent.w, 0.0)));\n  vec3 _N = normalize(vec3(modelMatrix * skinMatrix * modelMatrix * vec4(normal, 0.0)));\n  vTBN = mat3(_T, _B, _N);\n\n  vec4 worldPosition = modelMatrix * skinMatrix * vec4(position, 1.0);\n  vPosition = worldPosition;\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n`,hn=sn;un=un.trim(),hn=hn.trim();var fn=nt,dn=`\n${tt}\n\n// #define DEBUG_NORMAL\n// #define DEBUG_ALBEDO\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec4 motionVector;\n\nuniform vec2 SIZE;\n\nuniform sampler2D gPosition;\nuniform sampler2D gNormal;\nuniform sampler2D gAlbedo;\nuniform sampler2D gProperties;\n\nstruct LightInfo {\n  int type;\n  vec3 position;\n  vec3 direction;\n  float angle;\n  vec3 color;\n};\nconst int maxLights = 8;\nuniform LightInfo lights[maxLights];\nuniform int nrLights;\n\nuniform vec3 sunDirection;\nuniform vec3 sunIntensity;\nuniform float environmentIntensity;\nuniform vec3 ambientColor;\n\nuniform samplerCube u_diffuseIBL;\nuniform samplerCube u_specularIBL;\nuniform sampler2D u_splitSum;\n\nuniform mat4 inverseViewMatrix;\n\n// Motion blur\nuniform mat4 projectionMatrix;\nuniform mat4 prevViewMatrix;\nuniform mat4 viewMatrix;\n\n// FOG\n\n#define USEFOG\nuniform vec4 fogColor;\nuniform float fogDensity;\n\nvec3 applyFog(vec3 color, vec3 worldPosition) {\n  float distance = length(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - worldPosition);\n  float fogAmount = exp(-pow(distance * fogDensity, 2.));\n  \n  return mix(fogColor.rgb, color, fogAmount);\n}\n\n//\n\n\nbool doNoTiling = false;\n\nconst float PI = 3.141592;\n\n// No tiling\nvec4 hash4( vec2 p ) {\n  return fract(sin(vec4(1.0+dot(p,vec2(37.0,17.0)), \n                        2.0+dot(p,vec2(11.0,47.0)),\n                        3.0+dot(p,vec2(41.0,29.0)),\n                        4.0+dot(p,vec2(23.0,31.0))))*103.0);\n}\n\nvec3 textureNoTile( sampler2D samp, in vec2 uv, float v ) {\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n  \n    // derivatives (for correct mipmapping)\n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n    \n  vec3 va = vec3(0.0);\n  float w1 = 0.0;\n    float w2 = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n    vec4 o = hash4( p + g );\n    vec2 r = g - f + o.xy;\n    float d = dot(r,r);\n        float w = exp(-5.0*d );\n        vec3 c = textureGrad( samp, uv + v*o.zw, ddx, ddy ).xyz;\n    va += w*c;\n    w1 += w;\n        w2 += w*w;\n    }\n    \n    // normal averaging --\x3e lowers contrasts\n    return va/w1;\n\n    // contrast preserving average\n    float mean = 0.3;// textureGrad( samp, uv, ddx*16.0, ddy*16.0 ).x;\n    vec3 res = mean + (va-w1*mean)/sqrt(w2);\n    return mix( va/w1, res, v );\n}\n\n// Texture sampling\nvec4 sampleTexture(sampler2D samp, vec2 uv) {\n  if (doNoTiling) {\n    return vec4(textureNoTile(samp, uv, 1.), 1);\n  }\n  else {\n    return texture(samp, uv);\n  }\n}\n\n//Normal map\nvec3 setNormalStrength(vec3 normal, float strength) {\n  return vec3(normal.xy * strength, mix(1., normal.z, clamp(strength, 0., 1.)));\n}\n\n// vec3 sampleNormalTexture(sampler2D texture, vec2 uv) {\n//   return sampleTexture(texture, uv).rgb * 2. - 1.\n// }\n\n// PBR\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0); // trying this\n  // return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n} \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n  float a      = roughness*roughness;\n  float a2     = a*a;\n  float NdotH  = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH*NdotH;\n\n  float num   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n\n  return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r*r) / 8.0;\n\n  float num   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec3 IBL (vec3 N, vec3 V, vec3 R, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 F0 = vec3(scalarF0);\n  F0 = mix(F0, albedo, metallic);\n  vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.), F0, roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - metallic;\t  \n    \n  vec3 irradiance = texture(u_diffuseIBL, N).rgb;\n  vec3 diffuse  = irradiance * albedo;\n    \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureLod(u_specularIBL, R, roughness * MAX_REFLECTION_LOD).rgb;\n\n  vec2 uv = vec2(max(dot(N, V), 0.), roughness);\n  uv.y = 1. - uv.y;\n  vec2 envBRDF = texture(u_splitSum, uv).rg;\n\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n  vec3 ambient = (kD * diffuse + specular) * environmentIntensity;\n\n  return ambient;\n}\n\nvec3 DirectionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightDir, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 L = normalize(lightDir);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;\n  vec3 specular     = nominator / denominator;\n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n\n  kD *= 1.0 - metallic;\n  float NdotL = max(dot(N, L), 0.0);\n\n  vec3 finalColor = (kD * albedo / PI + specular) * radiance * NdotL;\n  return finalColor;\n}\n\nvec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);        \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nvec3 Spotlight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 dir, float angle, vec3 lightColor, vec3 albedo, float metallic, float roughness, float scalarF0) {\n  vec3 currentDir = normalize(worldPos - lightPos);\n  float distance    = length(lightPos - worldPos);\n  float attenuation = 1.0 / (distance * distance);\n\n  float sharpness = 5.;\n  attenuation *= clamp((dot(currentDir, dir) - cos(angle)) * sharpness, 0., 1.);\n\n  vec3 L = normalize(lightPos - worldPos);  \n  vec3 H = normalize(V + L);  \n  vec3 radiance     = lightColor * attenuation;     \n  vec3 F0 = vec3(scalarF0); \n  F0      = mix(F0, albedo, metallic);\n  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n  float NDF = DistributionGGX(N, H, roughness);       \n  float G   = GeometrySmith(N, V, L, roughness);     \n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n  vec3 specular     = nominator / denominator;       \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n    \n  kD *= 1.0 - metallic;     \n  float NdotL = max(dot(N, L), 0.0);\n  \n  return (kD * albedo / PI + specular) * radiance * NdotL;  \n}\n\nconst int levels = 2;\n\nvec4 projectedTexcoords[levels];\nuniform float biases[levels];\nuniform sampler2D projectedTextures[levels];\nuniform mat4 textureMatrices[levels];\n\n${rt}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / SIZE;\n\n  vec3 position = texture(gPosition, uv).rgb;\n  vec3 normal = texture(gNormal, uv).rgb;\n  vec3 albedo = texture(gAlbedo, uv).rgb;\n  vec4 properties = texture(gProperties, uv);\n\n  float blurFactor = properties.b;\n\n  vec4 prevClipSpace = projectionMatrix * prevViewMatrix * vec4(position, 1.0);\n  vec4 clipSpace = projectionMatrix * viewMatrix * vec4(position, 1.0);\n\n  vec3 NDCPos = (clipSpace / clipSpace.w).xyz;\n  vec3 PrevNDCPos = (prevClipSpace / prevClipSpace.w).xyz;\n  vec2 mv = blurFactor * (NDCPos - PrevNDCPos).xy * 0.5 + 0.5;\n  motionVector = vec4(mv, 0, 1);\n\n  if (normal == vec3(0)) {\n    discard;\n  }\n\n  #ifdef DEBUG_ALBEDO\n  fragColor = vec4(albedo, 1);\n  return;\n  #endif\n\n  #ifdef DEBUG_NORMAL\n  fragColor = vec4(normal, 1);\n  return;\n  #endif\n\n  float _ao = 1.;\n  float _roughness = properties.r;\n  float _metallic = properties.g;\n  vec3 _emission = vec3(0);\n\n  _roughness = clamp(_roughness, 0.01, 0.99);\n\n  vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - position);\n  vec3 N = normal;\n  vec3 R = reflect(-V, N);\n\n  float f0 = 0.04;\n\n  vec3 col = vec3(0);\n  // col += ambientColor;\n\n  for (int i = 0; i < levels; i++) {\n    projectedTexcoords[i] = textureMatrices[i] * vec4(position, 1);\n  }\n  float shadowAmount = getShadowAmount(position, dot(N, sunDirection.xyz));\n\n  col += IBL(N, V, R, albedo, _metallic, _roughness, f0) * _ao * (environmentMinLight + shadowAmount * (1. - environmentMinLight));\n  \n  if (sunIntensity.xyz != vec3(0) && shadowAmount > 0.01) {\n    col += DirectionalLight(position, N, V, sunDirection.xyz, sunIntensity.xyz, albedo, _metallic, _roughness, f0) * _ao * shadowAmount;\n  }\n\n  for (int i = 0; i < int(nrLights); i++) {\n    LightInfo light = lights[i];\n    if (light.type == 0) {\n      col += PositionalLight(position, N, V, light.position, light.color, albedo.rgb, _metallic, _roughness, f0);\n    }\n    else if (light.type == 1) {\n      col += Spotlight(position, N, V, light.position, light.direction, light.angle, light.color, albedo.rgb, _metallic, _roughness, f0);\n    }\n    else if (light.type == 2) {\n      col += DirectionalLight(position, N, V, light.direction, light.color, albedo.rgb, _metallic, _roughness, f0);\n    }\n  }\n\n  col += _emission;\n\n  #ifdef USEFOG\n    col = applyFog(col, position);\n  #endif\n\n  fragColor = vec4(col, 1);\n}\n`;fn=fn.trim(),dn=dn.trim();var mn=nt,vn=`\n${tt}\n\nuniform float scale;\n\nuniform mat4 lensProjection;\nuniform mat4 inverseViewMatrix;\nuniform mat4 viewMatrix;\n\nuniform sampler2D albedoTexture;\nuniform sampler2D positionTexture;\nuniform sampler2D normalTexture;\nuniform sampler2D propertiesTexture;\n\nuniform float maxRoughness;\nuniform float maxDistance;\nuniform float resolution;\nuniform int steps;\nuniform float thickness;\n\n// uniform sampler2D maskTexture;\n// uniform vec2 enabled;\n\nout vec4 fragColor;\n\nvec4 getSceneViewPos(vec2 uv) {\n  vec4 worldPos = texture(positionTexture, uv);\n  if (worldPos.xyz == vec3(0)) {\n    return vec4(0, 0, -1000, 0);\n  }\n\n  // return viewMatrix * vec4(worldPos.rgb, 1);\n  return worldPos;\n}\n\nbool isUVOutside(vec2 uv) {\n  return uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.;\n}\n\nfloat fadeOutUVBorder(vec2 uv, float falloffX, float falloffY) {\n  return smoothstep(0., falloffX, uv.x) * smoothstep(1., 1. - falloffX, uv.x) * smoothstep(0., falloffY, uv.y) * smoothstep(1., 1. - falloffY, uv.y);\n}\n\nfloat random(vec3 seed, int i){\n  vec4 seed4 = vec4(seed,i);\n  float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));\n  return fract(sin(dot_product) * 43758.5453);\n}\n\nvoid main() {\n  // vec2 texSize = vec2(textureSize(positionTexture, 0).xy) * scale;\n  // vec2 texCoord = gl_FragCoord.xy / texSize;\n\n  // if (texture(propertiesTexture, texCoord).r > 0.5) {\n  //   fragColor = vec4(0);\n  //   return;\n  // }\n\n  // vec3 worldNormal = texture(normalTexture, texCoord).xyz;\n  // if (worldNormal == vec3(0)) {\n  //   fragColor = vec4(0);\n  //   return;\n  // }\n\n  // const float maxDistance = 64.;\n\n  // vec3 origin = getSceneViewPos(texCoord).xyz;\n  // vec3 viewNormal = normalize(mat3(viewMatrix) * worldNormal);\n  // vec3 cameraToWorld = normalize(origin);\n  // vec3 rayDirection = normalize(reflect(cameraToWorld, viewNormal));\n  // vec3 end = origin + rayDirection * maxDistance;\n  // // origin += rayDirection * 15.1;\n  // // origin += viewNormal * 0.1;\n\n  // const int initialSteps = 200;\n\n  // // fragColor = vec4(rayDirection, 1);\n  // // return;\n\n  // for (int i = 0; i < initialSteps; i++) {\n  //   vec3 currentView = mix(origin, end, float(i) / float(initialSteps - 1));\n\n  //   vec4 currentScreen = vec4(currentView, 1);\n  //   currentScreen = lensProjection * currentScreen;\n  //   currentScreen.xyz /= currentScreen.w;\n  //   currentScreen.xy = currentScreen.xy * 0.5 + 0.5;\n  //   // currentScreen.xy *= texSize;\n\n  //   if (isUVOutside(currentScreen.xy)) {\n  //     break;\n  //   }\n\n  //   float sceneDepth = getSceneViewPos(currentScreen.xy).z;\n  //   float deltaDepth = (sceneDepth - currentView.z);\n\n  //   if (deltaDepth > 0. && deltaDepth < 10.) {\n  //     fragColor = vec4(texture(albedoTexture, currentScreen.xy).rgb, 1);\n  //     // fragColor = vec4(float(i) / float(initialSteps - 1), 0, 0, 1);\n  //     return;\n  //   }\n  // }\n\n  // fragColor = vec4(0, 0, 1, 1);\n  // return;\n\n\n\n\n\n\n\n\n  vec2 texSize  = vec2(textureSize(positionTexture, 0).xy) * scale;\n  vec2 texCoord = gl_FragCoord.xy / texSize;\n\n  vec4 uv = vec4(0.0);\n\n  vec4 positionFrom = getSceneViewPos(texCoord);\n  // vec4 positionFrom = texture(positionTexture, texCoord);\n  // positionFrom.y *= -1.;\n  // vec4 mask         = texture(maskTexture,     texCoord);\n\n  // fragColor = vec4(getSceneViewPos(texCoord).z * 0.01, 0, 0, 1);\n  // return;\n\n  // fragColor = vec4(texture(albedoTexture, texCoord).rgb, 1);\n  // return;\n\n  // fragColor = texture(positionTexture, texCoord);\n  // // fragColor = viewMatrix * vec4(texture(positionTexture, texCoord).rgb, 1);\n  // return;\n\n  // fragColor = vec4(texCoord, 0, 1);\n  // return;\n\n  // fragColor = vec4(texture(propertiesTexture, texCoord).rgb, 1);\n  // return;\n\n  float roughness = texture(propertiesTexture, texCoord).r;\n  if (\n    // positionFrom.w <= 0.0\n    //  || enabled.x      != 1.0\n    //  || mask.r         <= 0.0\n    roughness > maxRoughness || positionFrom.a == 0.\n  ) {\n    fragColor = vec4(0);\n    return;\n\n    // fragColor = uv;\n    fragColor = vec4(texture(albedoTexture, texCoord).rgb, 1);\n    return;\n  }\n\n  vec3 worldNormal = texture(normalTexture, texCoord).xyz;\n  if (worldNormal == vec3(0)) {\n    fragColor = vec4(0);\n    return;\n\n    fragColor = vec4(texture(albedoTexture, texCoord).rgb, 1);\n    return;\n  }\n\n  vec3 unitPositionFrom = normalize(positionFrom.xyz);\n  vec3 normal           = normalize(mat3(viewMatrix) * worldNormal);\n\n  // fragColor = vec4(normal, 1);\n  // return;\n\n  vec3 pivot            = normalize(reflect(unitPositionFrom, normal));\n  \n  vec4 positionTo = positionFrom;\n\n  vec4 startView = vec4(positionFrom.xyz + (pivot *         (0.01)), 1.0);\n  vec4 endView   = vec4(positionFrom.xyz + (pivot * maxDistance), 1.0);\n\n  // if (endView.z > 0.) {\n  //   fragColor = vec4(1, 0.5, 0, 1);\n  //   return;\n  // }\n\n  vec2 poissonDisk[16] = vec2[]( \n    vec2( -0.94201624, -0.39906216 ), \n    vec2( 0.94558609, -0.76890725 ), \n    vec2( -0.094184101, -0.92938870 ), \n    vec2( 0.34495938, 0.29387760 ), \n    vec2( -0.91588581, 0.45771432 ), \n    vec2( -0.81544232, -0.87912464 ), \n    vec2( -0.38277543, 0.27676845 ), \n    vec2( 0.97484398, 0.75648379 ), \n    vec2( 0.44323325, -0.97511554 ), \n    vec2( 0.53742981, -0.47373420 ), \n    vec2( -0.26496911, -0.41893023 ), \n    vec2( 0.79197514, 0.19090188 ), \n    vec2( -0.24188840, 0.99706507 ), \n    vec2( -0.81409955, 0.91437590 ), \n    vec2( 0.19984126, 0.78641367 ), \n    vec2( 0.14383161, -0.14100790 ) \n  );\n\n  // int index = int(16.0*random(floor(startView.xyz*1000.0), 0))%16;\n  // startView.xy += poissonDisk[index] * 0.05;\n\n  vec4 startFrag      = startView;\n       startFrag      = lensProjection * startFrag;\n       startFrag.xyz /= startFrag.w;\n       startFrag.xy   = startFrag.xy * 0.5 + 0.5;\n       startFrag.xy  *= texSize;\n\n  vec4 endFrag      = endView;\n       endFrag      = lensProjection * endFrag;\n       endFrag.xyz /= endFrag.w;\n       endFrag.xy   = endFrag.xy * 0.5 + 0.5;\n       endFrag.xy  *= texSize;\n\n  vec2 frag  = startFrag.xy;\n       uv.xy = frag / texSize;\n\n  float deltaX    = endFrag.x - startFrag.x;\n  float deltaY    = endFrag.y - startFrag.y;\n  float useX      = abs(deltaX) >= abs(deltaY) ? 1.0 : 0.0;\n  float delta     = mix(abs(deltaY), abs(deltaX), useX) * clamp(resolution, 0.0, 1.0);\n  vec2  increment = vec2(deltaX, deltaY) / max(delta, 0.001);\n\n  float search0 = 0.;\n  float search1 = 0.;\n\n  int hit0 = 0;\n  int hit1 = 0;\n\n  float viewDistance = startView.y;\n  float depth        = thickness;\n\n  int i = 0;\n\n  for (i = 0; i < int(min(delta, 1000.)); ++i) {\n    frag      += increment;\n    uv.xy      = frag / texSize;\n\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) {\n      fragColor = vec4(0);\n      return;\n      \n      fragColor = vec4(texture(albedoTexture, texCoord).rgb, 1);\n      // fragColor = vec4(0, 1, 0, 1);\n      return;\n    }\n\n    // vec4 worldPos = texture(positionTexture, uv.xy);\n    // positionTo = viewMatrix * vec4(worldPos.rgb, 1);\n    // // positionTo = texture(positionTexture, uv.xy);\n    // // positionTo.y *= -1.;\n\n    positionTo = getSceneViewPos(uv.xy);\n\n    search1 =\n      mix\n        ( (frag.y - startFrag.y) / deltaY\n        , (frag.x - startFrag.x) / deltaX\n        , useX\n        );\n\n    search1 = clamp(search1, 0.0, 1.0);\n\n    viewDistance = -sign(endView.z) * (startView.z * endView.z) / mix(endView.z, startView.z, search1);\n    depth        = -(viewDistance - positionTo.z);\n\n    if (viewDistance > 0.) {\n      break;\n    }\n\n    // viewDistance = (startView.y * endView.y) / mix(endView.y, startView.y, search1);\n    // depth        = viewDistance - positionTo.y;\n\n    if (depth > 0. && depth < thickness) {\n      hit0 = 1;\n\n      // // // fragColor = vec4(uv.xy, 0, 1);\n      // fragColor = vec4(0, 0, depth, 1);\n      // // fragColor = vec4(texture(albedoTexture, uv.xy).rgb * vec3(1, 0.5, 0.5), 1);\n      // return;\n\n      break;\n    } else {\n      search0 = search1;\n    }\n  }\n\n  // fragColor = vec4(uv.xy, 0, 1);\n  // return;\n\n  search1 = search0 + ((search1 - search0) / 2.0);\n\n  int currentSteps = steps;\n  currentSteps *= hit0;\n\n  for (i = 0; i < currentSteps; ++i) {\n    frag       = mix(startFrag.xy, endFrag.xy, search1);\n    uv.xy      = frag / texSize;\n\n    // // positionTo = viewMatrix * vec4(texture(positionTexture, uv.xy).rgb, 1);\n    // // // positionTo = texture(positionTexture, uv.xy);\n    // // // positionTo.y *= -1.;\n\n    // vec4 worldPos = texture(positionTexture, uv.xy);\n    // positionTo = viewMatrix * vec4(worldPos.rgb, 1);\n    // // positionTo = texture(positionTexture, uv.xy);\n\n    // if (worldPos.a < 0.01) {\n    //   positionTo = vec4(vec3(1000), 0);\n    // }\n\n    positionTo = getSceneViewPos(uv.xy);\n\n    viewDistance = (startView.z * endView.z) / mix(endView.z, startView.z, search1);\n    depth        = -(viewDistance - positionTo.z);\n\n    // viewDistance = (startView.y * endView.y) / mix(endView.y, startView.y, search1);\n    // depth        = viewDistance - positionTo.y;\n\n    float fineThickness = 0.1;\n    if (depth > -fineThickness * 0.05 && depth < fineThickness) {\n      hit1 = 1;\n      // break;\n    }\n\n    if (depth > 0. && depth < thickness) {\n      search1 = search0 + ((search1 - search0) / 2.);\n    } else {\n      float temp = search1;\n      search1 = search1 + ((search1 - search0) / 2.);\n      search0 = temp;\n    }\n  }\n\n  float visibility =\n    1.\n    * float(hit1)\n    * positionTo.w\n    * ( 1. - max(dot(-unitPositionFrom, pivot), 0.))\n    * ( 1. - clamp(depth / thickness, 0., 1.))\n    * ( 1. - clamp(length(positionTo.xyz - positionFrom.xyz) / maxDistance, 0., 1.))\n    * fadeOutUVBorder(uv.xy, 0.1, 0.1)\n    * (1. - roughness);\n\n  visibility = clamp(visibility, 0., 1.);\n\n  vec3 reflectedColor = texture(albedoTexture, uv.xy).rgb;\n  fragColor = vec4(mix(vec3(0), reflectedColor, visibility), visibility);\n\n  // uv.ba = vec2(visibility);\n  // uv.ba = vec2(1);\n\n  // fragColor = uv;\n\n  // vec3 baseColor = texture(albedoTexture, texCoord.xy).rgb;\n  // vec3 reflectedColor = texture(albedoTexture, uv.xy).rgb;\n\n  // fragColor = vec4(mix(baseColor, reflectedColor, visibility), 1);\n\n  // fragColor = vec4(baseColor, 1);\n}\n`;mn=mn.trim(),vn=vn.trim();var gn=nt,pn=`\n${tt}\n\nuniform sampler2D combinedTexture;\nuniform sampler2D ssrTexture;\nuniform vec2 SIZE;\nuniform float scale;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / SIZE;\n  \n  vec3 combinedColor = texture(combinedTexture, uv).rgb;\n  vec4 ssrColor = texture(ssrTexture, uv * scale);\n\n  fragColor = vec4(mix(combinedColor, ssrColor.rgb, ssrColor.a), 1);\n}\n`;gn=gn.trim(),pn=pn.trim();var xn=nt,bn=`\n${tt}\nout vec4 fragColor;\n\nuniform vec2 SIZE;\nuniform sampler2D imageTexture;\nuniform bool horizontal;\nuniform int radius;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / SIZE;\n  vec2 texelSize = 1. / vec2(textureSize(imageTexture, 0));\n\n  vec4 col = vec4(0);\n\n  for (int i = -radius; i <= radius; i++) {\n    col += texture(imageTexture, uv + texelSize * float(i) * vec2(horizontal, 1 - int(horizontal)));\n  }\n\n  col /= float(radius * 2 + 1);\n\n  fragColor = col;\n  // fragColor = vec4(col.rgb, texture(imageTexture, uv).a);\n}\n`;xn=xn.trim(),bn=bn.trim();let yn=new X,Tn=new X,wn=new X;function En(e,t){function n(t,n){return(n=n||new X).x=e[3*t],n.y=e[3*t+1],n.z=e[3*t+2],n}if(t){var r=new Array(e.length/3);for(let e=0;e<r.length;e++)r[e]=[];var i=t;for(let e=0;e<i.length;e+=3){n(i[e],yn),n(i[e+1],Tn),n(i[e+2],wn);let t=le([yn,Tn,wn]);r[i[e]].push(t),r[i[e+1]].push(t),r[i[e+2]].push(t)}var a=[];for(let e=0;e<r.length;e++){let t=X.divide(r[e].reduce(((e,t)=>X.add(e,t)),X.zero()),r[e].length);a.push(t.x,t.y,t.z)}return new Float32Array(a)}var o=new Float32Array(e.length);for(let t=0;t<e.length/3;t+=3){n(t,yn),n(t+1,Tn),n(t+2,wn);let e=le([yn,Tn,wn]);o[3*t]=e.x,o[3*t+1]=e.y,o[3*t+2]=e.z,o[3*(t+1)]=e.x,o[3*(t+1)+1]=e.y,o[3*(t+1)+2]=e.z,o[3*(t+2)]=e.x,o[3*(t+2)+1]=e.y,o[3*(t+2)+2]=e.z}return o}function _n(e,t,n){function r(t){return[e[3*t],e[3*t+1],e[3*t+2]]}function i(e){return[n[2*e],n[2*e+1]]}function a(e,t){for(var n=new Array(e.length),r=0;r<e.length;r++)n[r]=e[r]-t[r];return n}function o(e,t,n,o){var l,c=r(t),u=r(n),h=r(o),f=i(t),d=i(n),m=i(o),v=a(u,c),g=a(h,c),p=a(d,f),x=a(m,f),b=1/(p[0]*x[1]-p[1]*x[0]);if(isNaN(b)||!isFinite(b)){s++;var y=le([X.fromArray(c),X.fromArray(u),X.fromArray(h)]);l=X.toArray(X.findOrthogonal(y))}else l=[(v[0]*x[1]-g[0]*p[1])*b,(v[1]*x[1]-g[1]*p[1])*b,(v[2]*x[1]-g[2]*p[1])*b];var T=.01;return l[0]+=T,l[1]+=T,l[2]+=T,e[4*t]=l[0],e[4*t+1]=l[1],e[4*t+2]=l[2],e[4*t+3]=1,e[4*n]=l[0],e[4*n+1]=l[1],e[4*n+2]=l[2],e[4*n+3]=1,e[4*o]=l[0],e[4*o+1]=l[1],e[4*o+2]=l[2],e[4*o+3]=1,l}var s=0,l=new Float32Array(e.length/3*4);if(t){var c=t;for(let e=0;e<c.length;e+=3)o(l,c[e],c[e+1],c[e+2])}else for(let t=0;t<e.length/3;t+=3)o(l,t,t+1,t+2);return s.length>0&&console.warn(s+" tangents generated without UVs"),l}function Mn(e,t,n=!1,r=[]){if(t.meshRenderer)for(var i of t.meshRenderer.materials)(!n&&-1!==i.name.indexOf(e)||n&&i.name==e)&&r.push(i);for(var a of t.children)Mn(e,a,n,r);return r}function Rn(e,t,n){var r=document.createElement("canvas");return r.width=t,r.height=n,r.getContext("2d").drawImage(e,0,0,t,n),r}const Cn=function h(f={}){var d,m=this,v=f.renderScale??1;this.debugMode=f.debug??!0,this.catchProgramErrors=f.catchProgramErrors??!!this.debugMode;var x,T=0,w=0;this.startTime=new Date,this.eventHandler=new Pe,this.mouse={x:0,y:0,any:!1,left:!1,right:!1,middle:!1,movement:{x:0,y:0}};var R=[],C=[],F=[];this.currentScene=0,this.scenes=[],this.godrays=null,this.postprocessing=null,this.bloom=null,this.skybox=null,this.shadowCascades=null,this.UBOLocationCounter=0,this.currentBoundLitPrograms=new WeakMap;var N={};this.programContainers={get skybox(){return ae("skybox",i)},get shadow(){return ae("shadow",a)},get shadowInstanced(){return ae("shadowInstanced",a)},get shadowSkinned(){return ae("shadowSkinned",a)},get postprocessing(){return ae("postprocessing",o)},get bloom(){return ae("bloom",s)},get equirectangularToCubemap(){return ae("equirectangularToCubemap",l)},get diffuseCubemap(){return ae("diffuseCubemap",c)},get specularCubemap(){return ae("specularCubemap",u)},get lit(){return ae("lit",e)},get litSkinned(){return ae("litSkinned",e)},get litInstanced(){return ae("litInstanced",e)},get litTrail(){return ae("litTrail",e)},get unlit(){return ae("unlit",t)},get unlitInstanced(){return ae("unlitInstanced",t)},get particle(){return ae("particle",r)},get billboard(){return ae("billboard",n)}};var U,L,B=null,I=!0,O={enableShadows:!0,enableBloom:!0,enablePostProcessing:!0,loadTextures:!0};this.settings={get enableShadows(){return O.enableShadows},set enableShadows(e){O.enableShadows=e,e||m.shadowCascades.clearShadowmaps()},get enableBloom(){return O.enableBloom},set enableBloom(e){O.enableBloom=e,e||m.bloom.clearBloom()},get enablePostProcessing(){return O.enablePostProcessing},set enablePostProcessing(e){O.enablePostProcessing=e},get loadTextures(){return O.loadTextures},set loadTextures(e){O.loadTextures=e}},this.setupSettings=null,this.renderpipeline=null;let k=0;function V(){var e,t,n=(t=((e=performance.now())-x)/1e3,x=e,t);w+=n,k=0,m.eventHandler.fireEvent("renderloop",n,w,T);let r=document.querySelector("#debug_drawCalls");r&&(r.textContent=k),T++,requestAnimationFrame(V)}function G(){H(),m.postprocessing&&m.postprocessing.resizeFramebuffers(),m.bloom&&m.bloom.resizeFramebuffers(),m.eventHandler.fireEvent("resize")}function H(){var e=m.setupSettings,t=v*(window.devicePixelRatio||1);m.canvas.width=(e.width??innerWidth)*t,m.canvas.height=(e.height??innerHeight)*t,m.canvas.style.width=(e.width??innerWidth)+"px",m.canvas.style.height=(e.height??innerHeight)+"px"}function K(e){if(m.catchProgramErrors&&!d.getProgramParameter(e,d.LINK_STATUS)){var t="\nCould not compile WebGL program\n\nLink failed: "+d.getProgramInfoLog(e),n=d.getAttachedShaders(e);for(var r of n){var i=d.getShaderInfoLog(r),a=ie(d.getShaderParameter(r,d.SHADER_TYPE));i&&(t+="\n"+a+":\n"+i),console.log(a,d.getShaderSource(r))}throw new Error(t)}}function $(e,t){var n=d.createShader(t);return d.shaderSource(n,e),d.compileShader(n),n}function Q(){return m.floatTextures?d.FLOAT:m.textureHalfFloatExt?m.textureHalfFloatExt.HALF_FLOAT_OES:d.UNSIGNED_BYTE}function J(e,t,n={}){var r=d.createFramebuffer();d.bindFramebuffer(d.FRAMEBUFFER,r);var i=d.createTexture();d.bindTexture(d.TEXTURE_2D,i),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,e,t,0,d.RGBA,Q(),null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,i,0);var a=d.createRenderbuffer();return d.bindRenderbuffer(d.RENDERBUFFER,a),d.renderbufferStorage(d.RENDERBUFFER,n.depthComponent??d.DEPTH_COMPONENT16,e,t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,a),{framebuffer:r,colorBuffer:i,depthBuffer:a,width:e,height:t}}function Z(e,t=d.ARRAY_BUFFER,n=d.STATIC_DRAW){var r=d.createBuffer();return d.bindBuffer(t,r),d.bufferData(t,e,n),r}function ee(e){return e!==B&&(d.useProgram(e),B=e,!0)}function te(e,t,n,r){U=[e,t,n,r],d.clearColor(e,t,n,r)}function ne(e){if("FLOAT"==e)return"1f";var t=e.match(/FLOAT_VEC([0-9])/);if(t)return t[1]+"f";if("INT"==e||"UNSIGNED_INT"==e||"BOOL"==e||-1!==e.indexOf("SAMPLER"))return"1i";if(t=e.match(/(?:INT|BOOL)_VEC([0-9])/))return t[1]+"i";if(t=e.match(/FLOAT_MAT([0-9]x?[0-9]?)/))return"Matrix"+t[1]+"fv";throw new Error("Invalid uniform type string: "+e)}this.setup=function(e={}){if(this.setupSettings=e,this.path=e.path??"./",this.canvas=e.canvas??document.body.appendChild(document.createElement("canvas")),H(),this.version=e.version??2,1!==this.version&&2!==this.version)throw new Error("Invalid WebGL version: "+this.version);var t="webgl"+(2==this.version?"2":""),n={antialias:!1,premultipliedAlpha:!1};if(d=this.gl=this.canvas.getContext(t,n),!this.gl){if(2!=this.version||"version"in e)throw this.eventHandler.fireEvent("error"),new Error("WebGL "+this.version+" is not supported!");if(this.eventHandler.fireEvent("fallbackVersion"),this.version=1,d=this.gl=this.canvas.getContext("webgl",n),!this.gl)throw this.eventHandler.fireEvent("error"),new Error("WebGL "+this.version+" is not supported!")}console.log("Using Webgl version "+this.version);let r=function(){k++};function i(e,t,n){var r=e[t];return e[t]=function(){return n(...arguments),r.call(e,...arguments)},r}if(i(d,"drawElements",r),i(d,"drawArrays",r),i(d,"drawElementsInstanced",r),i(d,"drawArraysInstanced",r),this.canvas.addEventListener("webglcontextlost",(()=>{console.error("WebGL context lost!"),this.eventHandler.fireEvent("contextlost")})),this.canvas.addEventListener("mousedown",(e=>{this.mouse.any=!0,this.mouse[["left","middle","right"][e.button]]=!0,this.eventHandler.fireEvent("mousedown",e)})),document.addEventListener("mouseup",(e=>{this.mouse.any=0!==e.buttons,this.mouse[["left","middle","right"][e.button]]=!1,this.eventHandler.fireEvent("mouseup",e)})),this.canvas.onmousemove=e=>{var t,n,r,i,a,o=(n=e,r=(t=this.canvas).getBoundingClientRect(),i=t.width/r.width,a=t.height/r.height,{x:(n.clientX-r.left)*i,y:(n.clientY-r.top)*a});this.mouse.x=o.x,this.mouse.y=o.y,this.mouse.movement.x=e.movementX,this.mouse.movement.y=e.movementY,this.eventHandler.fireEvent("mousemove",e)},document.addEventListener("keydown",(e=>{R[e.keyCode]=!0,R[e.code]=!0,this.eventHandler.fireEvent("keydown",e)})),document.addEventListener("keyup",(e=>{R[e.keyCode]=!1,R[e.code]=!1,this.eventHandler.fireEvent("keyup",e)})),window.addEventListener("resize",(()=>{G()})),(L={})[d.NO_ERROR]="No error",L[d.INVALID_ENUM]="Invalid enum",L[d.INVALID_VALUE]="Invalid value",L[d.INVALID_OPERATION]="Invalid operation",L[d.INVALID_FRAMEBUFFER_OPERATION]="Invalid framebuffer operation",L[d.OUT_OF_MEMORY]="Out of memory",L[d.CONTEXT_LOST_WEBGL]="Context lost webgl",this.indexTypeLookup={5121:d.UNSIGNED_BYTE,5123:d.UNSIGNED_SHORT,5125:d.UNSIGNED_INT},d.getParameter(d.MAX_COMBINED_TEXTURE_IMAGE_UNITS)<32&&console.warn("Max texture units: ",d.getParameter(d.MAX_COMBINED_TEXTURE_IMAGE_UNITS)),this.EXT_texture_filter_anisotropic=this.getExtension("EXT_texture_filter_anisotropic")||this.getExtension("MOZ_EXT_texture_filter_anisotropic")||this.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),this.MAX_ANISOTROPY=d.getParameter(this.EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT),2==this.version?(this.getExtension("OES_texture_float_linear"),this.getExtension("EXT_color_buffer_float"),this.getExtension("EXT_float_blend"),this.floatTextures=!0):1==this.version&&(this.getExtension("OES_element_index_uint"),this.getExtension("OES_standard_derivatives"),this.getExtension("EXT_shader_texture_lod"),this.floatTextures=this.getExtension("OES_texture_float"),this.floatTextures=this.floatTextures&&this.getExtension("WEBGL_color_buffer_float"),this.getExtension("OES_texture_float_linear"),this.getExtension("EXT_float_blend"),this.colorBufferHalfFloatExt=this.getExtension("EXT_color_buffer_half_float"),this.textureHalfFloatExt=this.getExtension("OES_texture_half_float"),this.getExtension("WEBGL_depth_texture"),this.sRGBExt=this.getExtension("EXT_sRGB"),this.VAOExt=this.getExtension("OES_vertex_array_object"),this.instanceExt=this.getExtension("ANGLE_instanced_arrays")),this.gl.enable(this.gl.DEPTH_TEST),I=!0,this.gl.enable(this.gl.CULL_FACE),this.gl.cullFace(this.gl.BACK),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),te(...e.clearColor??[0,0,0,1]),d.getError(),null!=e.renderpipeline)if(0==e.renderpipeline)this.renderpipeline=new Ke(this);else{if(1!=e.renderpipeline)throw new Error("Unknown renderpipeline: "+e.renderpipeline);this.renderpipeline=new $e(this)}else this.renderpipeline=new $e(this);this.shadowCascades=new pe({basic:this.programContainers.shadow,instanced:this.programContainers.shadowInstanced,skinned:this.programContainers.shadowSkinned},e.shadowSizes??[4,16],e.shadowBiases??[-3e-4,-5e-4],e.shadowResolution??1024),ue("Shadow cascades"),this.bloom=new ve(this.programContainers.bloom),ue("Bloom"),this.postprocessing=new me,ue("Post processing"),e.enableGodrays&&this.createProgramFromFile(this.path+`assets/shaders/built-in/webgl${this.version}/godrays`).then((e=>{var t=new Te(e);this.godrays=new ge(t),console.log(this.godrays)})),this.gizmos=new he,this.skybox=new ye(this.programContainers.skybox),ue("Skybox"),this.splitsumTexture=this.loadSplitsum(this.path+"assets/pbr/splitsum.png"),ue("Splitsum"),x=performance.now(),requestAnimationFrame(V)},this.setRenderScale=function(e){v=e,G()},this.getRenderScale=function(){return v},this.setCanvasSize=function(e,t){-1===e?delete this.setupSettings.width:this.setupSettings.width=e,-1===t?delete this.setupSettings.height:this.setupSettings.height=t,G()},this.update=function(e){this.getActiveScene().update(e)},this.render=function(e,t=null,n={}){let r=this.getActiveScene();this.postprocessing.exposure.value=r.postprocessing.exposure,this.postprocessing.gamma.value=r.postprocessing.gamma,this.postprocessing.tonemapping.value=r.postprocessing.tonemapping,this.postprocessing.motionBlurStrength.value=r.postprocessing.motionBlurStrength,this.postprocessing.saturation.value=r.postprocessing.saturation,this.postprocessing.contrast.value=r.postprocessing.contrast,this.postprocessing.vignette.amount.value=r.postprocessing.vignette.amount,this.postprocessing.vignette.falloff.value=r.postprocessing.vignette.falloff,this.bloom.setProperties(r.bloom),this.renderpipeline.render(e,t,r,n)},Object.defineProperty(this,"aspect",{get:function(){return d.canvas.clientWidth/d.canvas.clientHeight}}),this.add=function(e){return this.scenes.push(e),e.renderer=this,e.setupUBO(),e},this.on=function(e,t){this.eventHandler.addEvent(e,t)},this.getActiveScene=function(){return this.scenes[this.currentScene]},this.setActiveScene=function(e){if(this.shadowCascades.clearShadowmaps(),"number"==typeof e){if(e<0||e>=this.scenes.length)throw new Error("Scene index outside valid range (0-"+(this.scenes.length-1)+"): "+e);this.currentScene=e}else{if(!(e instanceof Ve))throw new Error("Scene not valid");var t=this.scenes.indexOf(e);if(-1==t)throw console.error(e),new Error("Scene has not been added to renderer");this.currentScene=t}},this.disableContextMenu=function(){m.canvas.addEventListener("contextmenu",(function(e){e.preventDefault()}))},this.disablePinchToZoom=function(){document.addEventListener("touchmove",(function(e){1!==e.scale&&e.preventDefault()}),{passive:!1})},this.isPointerLocked=function(){return document.pointerLockElement===this.canvas||document.mozPointerLockElement===this.canvas},this.lockPointer=function(){this.canvas.requestPointerLock=this.canvas.requestPointerLock||this.canvas.mozRequestPointerLock,this.canvas.requestPointerLock()},this.unlockPointer=function(){document.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock,document.exitPointerLock()},this.getKey=function(e){return!!R[e]},this.getKeyDown=function(e,t=""){if(this.getKey(e)){if(C[e+t])return C[e+t]=!1,!0}else C[e+t]=!0;return!1},this.getKeyUp=function(e,t=""){if(this.getKey(e))F[e+t]=!0;else if(F[e+t])return F[e+t]=!1,!0;return!1},this.saveCanvasAsImage=function(e){z(this.canvas,e)},this.createCubemapFromHDR=async function(e,t=1024,n=1){var r=await Y(e),i=r.data;if(!this.floatTextures)throw new Error("Half float not currently supported");var a=d.createTexture();d.bindTexture(d.TEXTURE_2D,a),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,0),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,r.width,r.height,0,d.RGBA,d.UNSIGNED_BYTE,i),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE);var o=new Ie(this.programContainers.equirectangularToCubemap,{equirectangularMap:a});o.doubleSided=!0;var s=new Ne("Cubemap",{meshRenderer:new Ue([o],[new ze(qe())]),castShadows:!1}),l=W.orthographic({size:1}),c=[W.identity(),W.inverse(W.transform([["ry",Math.PI]])),W.inverse(W.transform([["ry",Math.PI/2],["rx",-Math.PI/2]])),W.inverse(W.transform([["ry",Math.PI/2],["rx",Math.PI/2]])),W.inverse(W.transform([["ry",Math.PI/2]])),W.inverse(W.transform([["ry",-Math.PI/2]]))],u=d.createFramebuffer();d.bindFramebuffer(d.FRAMEBUFFER,u);const h=d.createRenderbuffer();d.bindRenderbuffer(d.RENDERBUFFER,h),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,t,t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,h);var f=d.createTexture();d.bindTexture(d.TEXTURE_CUBE_MAP,f);for(let e=0;e<6;e++)d.bindTexture(d.TEXTURE_CUBE_MAP,f),d.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,1==this.version?d.RGBA:d.RGBA32F,t,t,0,d.RGBA,Q(),null);d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.TEXTURE_WRAP_R&&d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_R,d.CLAMP_TO_EDGE),m.disableCulling(),d.viewport(0,0,t,t);for(let e=0;e<6;e++)d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_CUBE_MAP_POSITIVE_X+e,f,0),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap,s.render({projectionMatrix:l,viewMatrix:c[e],inverseViewMatrix:W.inverse(c[e])});return d.bindTexture(d.TEXTURE_CUBE_MAP,f),d.generateMipmap(d.TEXTURE_CUBE_MAP),m.enableCulling(),f},this.createSpecularCubemapFromHDR=async function(e,t=1024,n=1){var r=[],i=[];for(let t=0;t<5;t++){var a=await Y(e+"/specular_mip_"+t+".hdr"),o=a.data;if(!this.floatTextures)if(m.textureHalfFloatExt)o=M(o);else{o=new Uint8Array(a.data.length);for(let e=0;e<a.data.length;e++)o[e]=Math.min(255,255*Math.pow(a.data[e]/(a.data[e]+1)*2,1/2.2))}var s=d.createTexture();d.bindTexture(d.TEXTURE_2D,s),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,0),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,a.width,a.height,0,d.RGBA,d.UNSIGNED_BYTE,o),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),r.push({hdr:a,pixelData:o,hdrTexture:s})}var l=new Ie(this.programContainers.equirectangularToCubemap,{equirectangularMap:s});l.doubleSided=!0;var c,u,h=new Ne("Cubemap",{meshRenderer:new Ue([l],[new ze(qe())]),castShadows:!1}),f=W.orthographic({size:1}),v=[W.identity(),W.inverse(W.transform([["ry",Math.PI]])),W.inverse(W.transform([["ry",Math.PI/2],["rx",-Math.PI/2]])),W.inverse(W.transform([["ry",Math.PI/2],["rx",Math.PI/2]])),W.inverse(W.transform([["ry",Math.PI/2]])),W.inverse(W.transform([["ry",-Math.PI/2]]))];1!=this.version&&(c=d.createFramebuffer(),d.bindFramebuffer(d.FRAMEBUFFER,c),u=d.createRenderbuffer(),d.bindRenderbuffer(d.RENDERBUFFER,u),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,t,t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,u));var g=d.createTexture();d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_CUBE_MAP,g);for(let e=0;e<6;e++)d.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,1==this.version?d.RGBA:d.RGBA32F,t,t,0,d.RGBA,Q(),null);d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MIN_FILTER,d.LINEAR_MIPMAP_LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.TEXTURE_WRAP_R&&d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_R,d.CLAMP_TO_EDGE),d.generateMipmap(d.TEXTURE_CUBE_MAP),m.disableCulling();for(var p=0;p<5;p++){var x=t*Math.pow(.5,p);1==this.version?i.push(J(x,x)):(d.bindRenderbuffer(d.RENDERBUFFER,u),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,x,x)),d.viewport(0,0,x,x),l.setUniform("equirectangularMap",r[p].hdrTexture);for(var b=0;b<6;b++)1!=this.version&&d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_CUBE_MAP_POSITIVE_X+b,g,p),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap,h.render({projectionMatrix:f,viewMatrix:v[b],inverseViewMatrix:W.inverse(v[b])}),1==this.version&&(d.bindTexture(d.TEXTURE_CUBE_MAP,g),d.copyTexSubImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+b,p,0,0,0,0,x,x))}for(var y of i)d.deleteFramebuffer(y.framebuffer);return m.enableCulling(),g},this.getSpecularCubemap=async function(e,t=128){if(!m.floatTextures&&!m.textureHalfFloatExt)return e;var n=new Ie(this.programContainers.specularCubemap,{environmentMap:e,roughness:0});n.doubleSided=!0;var r,i,a=new Ne("Cubemap",{meshRenderer:new Ue([n],[new ze(qe())]),castShadows:!1}),o=W.orthographic({size:1}),s=[W.inverse(W.transform([["ry",-Math.PI/2],["rz",Math.PI]])),W.inverse(W.transform([["ry",Math.PI/2],["rz",Math.PI]])),W.inverse(W.transform([["rx",Math.PI/2]])),W.inverse(W.transform([["rx",-Math.PI/2]])),W.inverse(W.transform([["ry",Math.PI],["rz",Math.PI]])),W.inverse(W.transform([["rz",Math.PI]]))],l=[];1!=this.version&&(r=d.createFramebuffer(),d.bindFramebuffer(d.FRAMEBUFFER,r),i=d.createRenderbuffer(),d.bindRenderbuffer(d.RENDERBUFFER,i),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,t,t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,i));var c=d.createTexture();d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_CUBE_MAP,c);for(let e=0;e<6;e++)d.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,1==this.version?d.RGBA:d.RGBA16F,t,t,0,d.RGBA,Q(),null);d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MIN_FILTER,d.LINEAR_MIPMAP_LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.TEXTURE_WRAP_R&&d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_R,d.CLAMP_TO_EDGE),d.generateMipmap(d.TEXTURE_CUBE_MAP),m.disableCulling();for(var u=0;u<5;u++){var h=t*Math.pow(.5,u);1==this.version?l.push(J(h,h)):(d.bindRenderbuffer(d.RENDERBUFFER,i),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,h,h)),d.viewport(0,0,h,h);var f=u/4;n.setUniform("roughness",f);for(let e=0;e<6;e++){1!=this.version&&d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_CUBE_MAP_POSITIVE_X+e,c,u),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap;var v=s[e];a.render({projectionMatrix:o,viewMatrix:v,inverseViewMatrix:W.inverse(v)}),1==this.version&&(d.bindTexture(d.TEXTURE_CUBE_MAP,c),d.copyTexSubImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+e,u,0,0,0,0,h,h))}}for(var g of l)d.deleteFramebuffer(g.framebuffer);return m.enableCulling(),c},this.getDiffuseCubemap=async function(e){var t=new Ie(this.programContainers.diffuseCubemap,{environmentMap:e});return await this.createCubemapFromCube(t,32)},this.createCubemapFromCube=async function(e,t){e.doubleSided=!0;var n=new Ne("Cubemap",{meshRenderer:new Ue([e],[new ze(qe())]),castShadows:!1}),r=W.orthographic({size:1}),i=[W.inverse(W.transform([["ry",-Math.PI/2],["rz",Math.PI]])),W.inverse(W.transform([["ry",Math.PI/2],["rz",Math.PI]])),W.inverse(W.transform([["rx",Math.PI/2]])),W.inverse(W.transform([["rx",-Math.PI/2]])),W.inverse(W.transform([["ry",Math.PI],["rz",Math.PI]])),W.inverse(W.transform([["rz",Math.PI]]))],a=d.createFramebuffer();d.bindFramebuffer(d.FRAMEBUFFER,a);const o=d.createRenderbuffer();d.bindRenderbuffer(d.RENDERBUFFER,o),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,t,t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,o);var s=d.createTexture();d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_CUBE_MAP,s);var l=1==this.version?d.RGBA:d.RGBA32F,c=d.RGBA;for(let e=0;e<6;e++)d.bindTexture(d.TEXTURE_CUBE_MAP,s),d.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,l,t,t,0,c,Q(),null);d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.TEXTURE_WRAP_R&&d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_R,d.CLAMP_TO_EDGE),m.disableCulling(),d.viewport(0,0,t,t);for(let e=0;e<6;e++)d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_CUBE_MAP_POSITIVE_X+e,s,0),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap,n.render({projectionMatrix:r,viewMatrix:i[e],inverseViewMatrix:W.inverse(i[e])}),await D(200);return m.enableCulling(),d.deleteFramebuffer(a),s},this.captureReflectionCubemap=function(e=X.zero(),t=512){var n=W.perspective({fov:Math.PI/4,aspect:1,near:.001,far:100}),r=[W.inverse(W.transform([["translate",e],["ry",-Math.PI/2],["rz",Math.PI]])),W.inverse(W.transform([["translate",e],["ry",Math.PI/2],["rz",Math.PI]])),W.inverse(W.transform([["translate",e],["rx",Math.PI/2]])),W.inverse(W.transform([["translate",e],["rx",-Math.PI/2]])),W.inverse(W.transform([["translate",e],["ry",Math.PI],["rz",Math.PI]])),W.inverse(W.transform([["translate",e],["rz",Math.PI]]))],i=d.createFramebuffer();d.bindFramebuffer(d.FRAMEBUFFER,i);const a=d.createRenderbuffer();d.bindRenderbuffer(d.RENDERBUFFER,a),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,t,t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,a);var o=d.createTexture();d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_CUBE_MAP,o);for(let e=0;e<6;e++)d.bindTexture(d.TEXTURE_CUBE_MAP,o),d.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,d.RGBA32F,t,t,0,d.RGBA,Q(),null);d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.TEXTURE_WRAP_R&&d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_R,d.CLAMP_TO_EDGE),d.viewport(0,0,t,t);for(let e=0;e<6;e++){d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_CUBE_MAP_POSITIVE_X+e,o,0),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT);var s={projectionMatrix:n,viewMatrix:r[e],inverseViewMatrix:W.inverse(r[e]),cameraMatrix:W.inverse(r[e])},l=this.scenes[this.currentScene];l.skyboxVisible&&this.skybox.render(s,l.skyboxCubemap),l.updateUniformBuffers(s.projectionMatrix,s.viewMatrix,s.inverseViewMatrix),d.activeTexture(d.TEXTURE0+2),d.bindTexture(d.TEXTURE_CUBE_MAP,l.diffuseCubemap),d.activeTexture(d.TEXTURE0+1),d.bindTexture(d.TEXTURE_CUBE_MAP,l.specularCubemap),d.activeTexture(d.TEXTURE0+0),d.bindTexture(d.TEXTURE_2D,this.splitsumTexture),d.colorMask(!0,!0,!0,!1),d.disable(d.BLEND),l.render(s,{renderPass:g.OPAQUE}),d.enable(d.BLEND),d.depthMask(!1),l.render(s,{renderPass:g.ALPHA}),d.depthMask(!0),d.colorMask(!0,!0,!0,!0),se(null)}return o},this.saveSpecularCubemapAsHDR=async function(e,t=5,n=128){for(var r=0;r<t;r++){var i=n*Math.pow(.5,r);await this.saveCubemapAsHDR(e,i,r,"specular_mip_"+r)}},this.saveCubemapAsHDR=async function(e,t=512,n=0,r="cubemap"){var i=t,a=t/2,o=J(i,a),s=await this.createProgramFromFile(this.path+"assets/shaders/built-in/webgl2/equirectangularFromCubemap"),l=Z(new Float32Array([-1,1,-1,-1,1,1,1,-1])),c=d.getAttribLocation(s,"position"),u=Z(new Float32Array([0,0,0,1,1,0,1,1])),h=d.getAttribLocation(s,"uv");d.bindFramebuffer(d.FRAMEBUFFER,o.framebuffer),m.disableCulling(),d.viewport(0,0,i,a),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),ee(s),se(null),d.bindBuffer(d.ARRAY_BUFFER,l),d.enableVertexAttribArray(c),d.vertexAttribPointer(c,2,d.FLOAT,!1,8,0),d.bindBuffer(d.ARRAY_BUFFER,u),d.enableVertexAttribArray(h),d.vertexAttribPointer(h,2,d.FLOAT,!1,8,0),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_CUBE_MAP,e),d.uniform1i(d.getUniformLocation(s,"cubemap"),0),d.uniform1f(d.getUniformLocation(s,"mipmapLevel"),n),d.drawArrays(d.TRIANGLE_STRIP,0,4);var f=new Float32Array(i*a*4);return d.readPixels(0,0,i,a,d.RGBA,d.FLOAT,f),function(e,t=1024,n=512,r="new"){for(var i=`#?RADIANCE\nFORMAT=32-bit_rle_rgbe\n\n-Y ${n} +X ${t}\n`,a=(new TextEncoder).encode(i),o=[],s=0;s<e.length;s+=4){var l=e[s],c=e[s+1],u=e[s+2];o.push(...q(l,c,u))}var h=new Uint8Array(a.length+o.length);h.set(a,0),h.set(o,a.length),function(e,t,n){const r=new Blob([e],{type:"application/octet-stream"}),i=window.URL.createObjectURL(r);(function(e,t){const n=document.createElement("a");n.href=e,n.download=t,document.body.appendChild(n),n.style.display="none",n.click(),n.remove()})(i,t),setTimeout((()=>window.URL.revokeObjectURL(i)),1e3)}(h,r+".hdr")}(f,i,a,r),!0},this.saveCubemapAsImages=async function(e,t=512){var n=new Te(await this.createProgramFromFile("../assets/shaders/built-in/webgl2/cubemapVis")),r=new Ie(n,{environmentMap:e});r.doubleSided=!0;var i=new Ne("Cubemap",{meshRenderer:new Ue([r],[new ze(qe())]),castShadows:!1}),a=W.orthographic({size:1}),o=[W.inverse(W.transform([["ry",-Math.PI/2],["rz",Math.PI]])),W.inverse(W.transform([["ry",Math.PI/2],["rz",Math.PI]])),W.inverse(W.transform([["rx",Math.PI/2]])),W.inverse(W.transform([["rx",-Math.PI/2]])),W.inverse(W.transform([["ry",Math.PI],["rz",Math.PI]])),W.inverse(W.transform([["rz",Math.PI]]))],s=this.canvas.width,l=this.canvas.height;this.canvas.width=t,this.canvas.height=t,d.bindFramebuffer(d.FRAMEBUFFER,null),m.disableCulling(),d.viewport(0,0,t,t);for(var c=0;c<6;c++)d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),this.currentBoundLitPrograms=new WeakMap,i.render({projectionMatrix:a,viewMatrix:o[c],inverseViewMatrix:W.inverse(o[c])}),z(m.canvas,"cubemap"+c);return m.enableCulling(),this.canvas.width=s,this.canvas.height=l,!0},this.loadSplitsum=function(e){return Le(e,{TEXTURE_MIN_FILTER:d.LINEAR,TEXTURE_WRAP_S:d.CLAMP_TO_EDGE,TEXTURE_WRAP_T:d.CLAMP_TO_EDGE})},this.loadTextFile=async function(e){return await(await fetch(e,{mode:"cors",headers:{"Access-Control-Allow-Origin":"*"}})).text()},this.createProgramFromFile=async function(e,t){var n=e+"/vertex.glsl",r=e+"/fragment.glsl";null!=t&&(n=e,r=t);var i=await this.loadTextFile(n),a=await this.loadTextFile(r);return this.createProgram(i,a)},this.createProgram=function(e,t){var n=$(e,d.VERTEX_SHADER),r=$(t,d.FRAGMENT_SHADER),i=d.createProgram();return d.attachShader(i,n),d.attachShader(i,r),d.linkProgram(i),K(i),i},this.updateVertexShader=function(e,t){var n=d.getAttachedShaders(e.program)[0];this.updateShader(n,e,t)},this.updateFragmentShader=function(e,t){var n=d.getAttachedShaders(e.program)[1];this.updateShader(n,e,t)},this.updateShader=function(e,t,n){d.shaderSource(e,n),d.compileShader(e),d.linkProgram(t.program),K(t.program),t.updateUniformLocations()},this.CustomProgram=class{constructor(e){var t=e["webgl"+m.version]??e;if(t.vertex&&t.fragment){var n=m.createProgram(t.vertex,t.fragment);return new m.ProgramContainer(n)}console.error("Custom program does not have a vertex/fragment shader for version "+m.version)}},this.enableCulling=function(){!0!==I&&(this.gl.enable(this.gl.CULL_FACE),I=!0)},this.disableCulling=function(){!1!==I&&(this.gl.disable(this.gl.CULL_FACE),I=!1)},this.getExtension=function(e){return this.gl.getExtension(e)||(console.error("Could not get extension: "+e),!1)},this.getSRGBFormats=function(){return{internalFormat:1==m.version?m.sRGBExt&&(m.floatTextures||m.textureHalfFloatExt)?m.sRGBExt.SRGB_ALPHA_EXT:d.RGBA:d.SRGB8_ALPHA8,format:1==m.version&&m.sRGBExt&&(m.floatTextures||m.textureHalfFloatExt)?m.sRGBExt.SRGB_ALPHA_EXT:d.RGBA}},this.setClearColor=te;var re={};function ie(e){var t=re[e];if(t)return t;for(const t in d)if(d[t]===e)return re[e]=t,t;return""}function ae(t,n=e){if(!(t in N)){console.log("Loading program:",t);var r=n["webgl"+m.version][t];if(!r||!r.vertex||!r.fragment)return console.error(`Program ${t} not found for version ${m.version}!`),void(N[t]=void 0);var i=m.createProgram(r.vertex,r.fragment);N[t]=new Te(i)}return N[t]}function oe(e){return 1==m.version?m.VAOExt.deleteVertexArrayOES(e):d.deleteVertexArray(e)}function se(e){1==m.version?m.VAOExt.bindVertexArrayOES(e):2==m.version&&d.bindVertexArray(e)}function le(e,t){1==m.version?m.instanceExt.vertexAttribDivisorANGLE(e,t):2==m.version&&d.vertexAttribDivisor(e,t)}function ce(e,t,n,r,i){1==m.version?m.instanceExt.drawElementsInstancedANGLE(e,t,n,r,i):2==m.version&&d.drawElementsInstanced(e,t,n,r,i)}function ue(e="",t=!1){var n=d.getError();t?console[n?"error":"log"]("("+e+") "+L[n]):0!==n&&console.error("("+e+") "+L[n])}function he(){var e;this.gameObject=new Ne("Gizmos");var t=!1,n=()=>{var t=we({},m.programContainers.unlitInstanced),n=function(){const e=new Float32Array([0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1]),t=new Uint32Array([0,1,2,3,4,5]),n=new Float32Array([0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0]);return new ze({indices:{bufferData:t,target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:e,size:3},color:{bufferData:n,size:3}})}();(e=new Se(t,n)).drawMode=d.LINES,this.gameObject.meshRenderer=e};this.visualize=function(r){t||(n(),t=!0);var i=e.addInstance(r.transform.worldMatrix);setInterval((function(){var t=r.transform.worldMatrix;W.setScale(t,X.fill(.3)),e.updateInstance(i,t)}),16)}}function fe(){var e=new Float32Array([-1,1,-1,-1,1,1,1,-1]);this.vertexBuffer=Z(e),this.bindBuffers=function(e){d.bindBuffer(d.ARRAY_BUFFER,this.vertexBuffer),d.enableVertexAttribArray(e),d.vertexAttribPointer(e,2,d.FLOAT,!1,8,0)},this.render=function(){d.drawArrays(d.TRIANGLE_STRIP,0,4)}}function me(){var e=this;function t(e,t=(()=>{})){this.value=e;var n=e;this.onChange=t;var r=!1;this.update=function(){this.value==n&&r||(this.onChange(this.value,n),n=this.value,r=!0)}}this.TONEMAPPING={NONE:0,ACES:1,REINHARD:2},this.exposure=new t(0,(e=>{d.uniform1f(this.programContainer.getUniformLocation("exposure"),e)})),this.gamma=new t(2.2,(e=>{d.uniform1f(this.programContainer.getUniformLocation("gamma"),e)})),this.tonemapping=new t(this.TONEMAPPING.ACES,(e=>{d.uniform1i(this.programContainer.getUniformLocation("tonemapping"),e)})),this.motionBlurStrength=new t(.2,((e,t)=>{i(e,t)||d.uniform1f(this.programContainer.getUniformLocation("motionBlurStrength"),e)})),this.saturation=new t(0,(e=>{d.uniform1f(this.programContainer.getUniformLocation("saturation"),e)})),this.contrast=new t(0,(e=>{d.uniform1f(this.programContainer.getUniformLocation("contrast"),e)})),this.vignette={amount:new t(0,(e=>{d.uniform1f(this.programContainer.getUniformLocation("vignetteAmount"),e)})),falloff:new t(0,(e=>{d.uniform1f(this.programContainer.getUniformLocation("vignetteFalloff"),e)}))};var n,r,i=(e,t)=>{if(e>0&&0==t||0==e&&t>0){for(var n of(m.updateFragmentShader(this.programContainer,g().fragment),a))n.onChange(n.value,n.value);return v(),console.log("Recompiling postprocessing"),!0}return!1},a=[this.exposure,this.gamma,this.tonemapping,this.motionBlurStrength,this.saturation,this.contrast,this.vignette.amount,this.vignette.falloff],s=g(),l=m.createProgram(s.vertex,s.fragment);this.programContainer=new Te(l);var c,u=d.canvas.width,h=d.canvas.height;m.version,this.framebuffer=d.createFramebuffer(),d.bindFramebuffer(d.FRAMEBUFFER,this.framebuffer),this.colorBuffer=d.createTexture(),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,this.colorBuffer),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,u,h,0,d.RGBA,Q(),null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,this.colorBuffer,0),m.version>1&&(this.motionBlurColorBuffer=d.createTexture(),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,this.motionBlurColorBuffer),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,u,h,0,d.RGBA,Q(),null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT1,d.TEXTURE_2D,this.motionBlurColorBuffer,0)),c=d.createRenderbuffer(),d.bindRenderbuffer(d.RENDERBUFFER,c),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,u,h),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,c),this.downscaledFramebuffer=J(u/4,h/4);var f=new fe,v=()=>{ee(this.programContainer.program),d.uniform1i(this.programContainer.getUniformLocation("mainTexture"),0),d.uniform1i(this.programContainer.getUniformLocation("bloomTexture"),1),this.depthTexture||m.godrays?d.uniform1i(this.programContainer.getUniformLocation("depthTexture"),2):d.uniform1i(this.programContainer.getUniformLocation("enableGodrays"),0),d.uniform1i(this.programContainer.getUniformLocation("motionBlurTexture"),3),this.motionBlurColorBuffer&&d.uniform1i(this.programContainer.getUniformLocation("motionBlurTexture"),16),d.uniform2f(this.programContainer.getUniformLocation("SIZE"),d.canvas.width,d.canvas.height)};function g(){var t=o["webgl"+m.version].postprocessing;if(t&&t.vertex&&t.fragment){var n="#version 300 es\n";return m.version>1&&e.motionBlurStrength.value>1e-6&&(n+="#define ENABLE_MOTIONBLUR\n"),n+="#define TONEMAPPING "+e.tonemapping.value+"\n",m.godrays&&(n+="#define ENABLE_GODRAYS\n"),m.bloom.getIntensity()>1e-6&&(n+="#define ENABLE_BLOOM\n"),n+=t.fragment,{vertex:t.vertex,fragment:n}}console.error(`Program postprocessing not found for version ${m.version}!`)}v(),this.getFramebuffer=function(){return this.preFramebuffer?this.preFramebuffer:this.framebuffer},this.bindFramebuffer=function(){d.bindFramebuffer(d.FRAMEBUFFER,this.getFramebuffer())},this.blitAA=function(){this.preFramebuffer&&(d.bindFramebuffer(d.READ_FRAMEBUFFER,this.preFramebuffer),d.bindFramebuffer(d.DRAW_FRAMEBUFFER,this.framebuffer),d.clearBufferfv(d.COLOR,0,[1,1,1,1]),d.blitFramebuffer(0,0,u,h,0,0,u,h,d.COLOR_BUFFER_BIT,d.LINEAR),d.bindFramebuffer(d.FRAMEBUFFER,this.preFramebuffer))},this.resizeFramebuffers=function(){u=d.canvas.width,h=d.canvas.height,d.bindTexture(d.TEXTURE_2D,this.downscaledFramebuffer.colorBuffer),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,u/4,h/4,0,d.RGBA,Q(),null),d.bindTexture(d.TEXTURE_2D,this.colorBuffer),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,d.canvas.width,d.canvas.height,0,d.RGBA,Q(),null),this.motionBlurColorBuffer&&(d.bindTexture(d.TEXTURE_2D,this.motionBlurColorBuffer),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,d.canvas.width,d.canvas.height,0,d.RGBA,Q(),null)),this.depthTexture?(d.bindTexture(d.TEXTURE_2D,this.depthTexture),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.DEPTH_COMPONENT:d.DEPTH_COMPONENT16,d.canvas.width,d.canvas.height,0,d.DEPTH_COMPONENT,d.UNSIGNED_INT,null)):this.preFramebuffer?(d.bindRenderbuffer(d.RENDERBUFFER,c),d.renderbufferStorageMultisample(d.RENDERBUFFER,d.getParameter(d.MAX_SAMPLES),d.DEPTH_COMPONENT16,d.canvas.width,d.canvas.height)):(d.bindRenderbuffer(d.RENDERBUFFER,c),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,d.canvas.width,d.canvas.height)),this.preFramebuffer&&(d.bindRenderbuffer(d.RENDERBUFFER,void 0),d.renderbufferStorageMultisample(d.RENDERBUFFER,d.getParameter(d.MAX_SAMPLES),d.RGBA16F,d.canvas.width,d.canvas.height)),d.bindTexture(d.TEXTURE_2D,null)},this.render=function(){d.bindFramebuffer(d.FRAMEBUFFER,null),d.viewport(0,0,d.canvas.width,d.canvas.height),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),ee(this.programContainer.program),se(null),d.bindBuffer(d.ARRAY_BUFFER,f.vertexBuffer);var e=this.programContainer.getAttribLocation("position");for(var t of(d.enableVertexAttribArray(e),d.vertexAttribPointer(e,2,d.FLOAT,!1,8,0),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,this.colorBuffer),d.activeTexture(d.TEXTURE1),d.bindTexture(d.TEXTURE_2D,m.bloom.upsampleFramebuffers[m.bloom.upsampleFramebuffers.length-1].colorBuffer),this.depthTexture?(d.activeTexture(d.TEXTURE2),d.bindTexture(d.TEXTURE_2D,this.depthTexture)):m.godrays&&(d.activeTexture(d.TEXTURE2),d.bindTexture(d.TEXTURE_2D,m.godrays.framebufferData.colorBuffer)),this.motionBlurColorBuffer&&(d.activeTexture(d.TEXTURE25),d.bindTexture(d.TEXTURE_2D,this.motionBlurColorBuffer),d.uniform1i(this.programContainer.getUniformLocation("motionBlurTexture"),25)),this.rainTexture&&(d.activeTexture(d.TEXTURE17),d.bindTexture(d.TEXTURE_2D,this.rainTexture),d.uniform1i(this.programContainer.getUniformLocation("rainTexture"),17)),d.activeTexture(d.TEXTURE18),d.bindTexture(d.TEXTURE_2D,this.downscaledFramebuffer.colorBuffer),d.uniform1i(this.programContainer.getUniformLocation("downscaledTexture"),18),d.uniform1f(this.programContainer.getUniformLocation("iTime"),(new Date-m.startTime)/1e3),d.canvas.width===n&&d.canvas.height===r||(n=d.canvas.width,r=d.canvas.height,d.uniform2f(this.programContainer.getUniformLocation("SIZE"),d.canvas.width,d.canvas.height)),d.uniform1f(this.programContainer.getUniformLocation("bloomIntensity"),m.bloom.getIntensity()),a))t.update();f.render()}}function ve(e){this.programContainer=e;var t=!0,n=1,r=1,i=.5,a=10,o=.05,s={enabled:t};this.downsampleFramebuffers=[],this.upsampleFramebuffers=[];var l=Z(new Float32Array([-1,1,-1,-1,1,1,1,-1]));ee(this.programContainer.program),d.uniform1i(this.programContainer.getUniformLocation("mainTexture"),0),d.uniform1i(this.programContainer.getUniformLocation("secondTexture"),1),this.resizeFramebuffers=function(){for(let e=0;e<this.downsampleFramebuffers.length;e++)d.deleteFramebuffer(this.downsampleFramebuffers[e].framebuffer);for(let e=0;e<this.upsampleFramebuffers.length;e++)d.deleteFramebuffer(this.upsampleFramebuffers[e].framebuffer);this.downsampleFramebuffers=[],this.upsampleFramebuffers=[];let e=(()=>{let e=Math.min(d.canvas.width,d.canvas.height),t=Math.floor(Math.log(e)/Math.log(2));return Math.min(7,t)})();for(let t=0;t<e;t++){let e=Math.pow(.5,t+1);this.downsampleFramebuffers.push(J(Math.floor(d.canvas.width*e),Math.floor(d.canvas.height*e)))}for(let t=0;t<e-1;t++){let n=Math.pow(.5,e-1-t);this.upsampleFramebuffers.push(J(Math.floor(d.canvas.width*n),Math.floor(d.canvas.height*n)))}},this.resizeFramebuffers(),this.render=function(){if(!t&&s.enabled&&this.clearBloom(),s.enabled=t,!t)return;ee(this.programContainer.program),d.uniform1f(this.programContainer.getUniformLocation("_SampleScale"),n),d.uniform1f(this.programContainer.getUniformLocation("threshold"),r),d.uniform1f(this.programContainer.getUniformLocation("knee"),i),d.uniform1f(this.programContainer.getUniformLocation("_Clamp"),a);let e=this.programContainer.getAttribLocation("position");d.bindBuffer(d.ARRAY_BUFFER,l),d.enableVertexAttribArray(e),d.vertexAttribPointer(e,2,d.FLOAT,!1,8,0),d.activeTexture(d.TEXTURE0);for(var o=0;o<this.downsampleFramebuffers.length;o++){var c=this.downsampleFramebuffers[o];d.bindFramebuffer(d.FRAMEBUFFER,c.framebuffer),d.viewport(0,0,c.width,c.height),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),d.bindTexture(d.TEXTURE_2D,o<1?m.postprocessing.colorBuffer:this.downsampleFramebuffers[o-1].colorBuffer),this.programContainer.getUniformLocation("mainTextureSize")&&d.uniform2fv(this.programContainer.getUniformLocation("mainTextureSize"),o<1?[d.canvas.width,d.canvas.height]:[this.downsampleFramebuffers[o-1].width,this.downsampleFramebuffers[o-1].height]),d.uniform2f(this.programContainer.getUniformLocation("screenSize"),c.width,c.height),d.uniform1i(this.programContainer.getUniformLocation("stage"),0==o?0:1),d.drawArrays(d.TRIANGLE_STRIP,0,4)}d.uniform1i(this.programContainer.getUniformLocation("stage"),2);for(let e=0;e<this.upsampleFramebuffers.length;e++){let t=this.upsampleFramebuffers[e];if(d.bindFramebuffer(d.FRAMEBUFFER,t.framebuffer),d.viewport(0,0,t.width,t.height),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,e<1?this.downsampleFramebuffers[this.downsampleFramebuffers.length-1].colorBuffer:this.upsampleFramebuffers[e-1].colorBuffer),d.activeTexture(d.TEXTURE1),d.bindTexture(d.TEXTURE_2D,this.downsampleFramebuffers[this.downsampleFramebuffers.length-2-e].colorBuffer),this.programContainer.getUniformLocation("mainTextureSize")){let t=e<1?this.downsampleFramebuffers[this.downsampleFramebuffers.length-1]:this.upsampleFramebuffers[e-1];d.uniform2f(this.programContainer.getUniformLocation("mainTextureSize"),t.width,t.height)}d.uniform2f(this.programContainer.getUniformLocation("screenSize"),t.width,t.height),d.drawArrays(d.TRIANGLE_STRIP,0,4)}},this.clearBloom=function(){d.bindFramebuffer(d.FRAMEBUFFER,this.upsampleFramebuffers[this.upsampleFramebuffers.length-1].framebuffer);var e=U;te(0,0,0,1),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),te(...e)},this.setProperties=function(e){t=e.enabled,n=e.sampleScale,r=e.threshold,i=e.knee,a=e.clamp,o=e.intensity},this.getIntensity=function(){return o}}function ge(e){this.material=new Ie(e);var t=.2;this.framebufferData=J(d.canvas.width*t,d.canvas.height*t);var n=d.createRenderbuffer();d.bindRenderbuffer(d.RENDERBUFFER,n),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,d.canvas.width*t,d.canvas.height*t),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,n),this.render=function(e,t){d.bindFramebuffer(d.FRAMEBUFFER,this.framebufferData.framebuffer),d.viewport(0,0,this.framebufferData.width,this.framebufferData.height),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),e.render(t,{renderPass:g.OPAQUE,materialOverride:this.material}),m.skybox.render(t,e.skyboxCubemap)}}function pe(e,t=[50,8],n=[-.0025,-5e-4],r=1024){var i=this;t.reverse(),n.reverse(),this.levels=t.length,this.programContainers=e,this.programContainer=e.basic,Object.defineProperty(this,"program",{get:function(){return i.programContainer.program},set:e=>{i.programContainer.setProgram(e)}}),this.material=new Ie(this.programContainer),this.materialInstanced=new Ie(this.programContainers.instanced),this.materialSkinned=new Ie(this.programContainers.skinned);var a=new Float32Array(16*this.levels);this.shadowmaps=[];for(let e=0;e<this.levels;e++){var o=new be(r,t[e],n[e],[d["TEXTURE"+(30-2*e)],d["TEXTURE"+(31-2*e)]]);o.textureMatrix=new Float32Array(a.buffer,16*Float32Array.BYTES_PER_ELEMENT*(1-e),16),this.shadowmaps.push(o)}var s=new Array(this.levels),l=new Array(this.levels);for(let e=0;e<this.levels;e++){var c=this.levels-1-e;s[e]=30-2*c,l[e]=this.shadowmaps[c].bias}this.clearShadowmaps=function(){for(var e=0;e<this.levels;e++)this.shadowmaps[e].clearShadowmap()};var u=0;this.refreshRate=0,this.renderShadowmaps=function(e){u++;let t=m.scenes[m.currentScene];t.root.traverseCondition((e=>{e.isCulled=!1}),(e=>e.active&&e.visible));for(let n=0;n<this.levels;n++){if(this.refreshRate>=1&&u%this.refreshRate!==Math.floor(n*this.refreshRate/this.levels))continue;let r=this.shadowmaps[n];r.updateModelMatrix(e),r.bind();let i={projectionMatrix:r.shadowPerspeciveMatrix,viewMatrix:r.shadowViewMatrix,inverseViewMatrix:r.shadowInverseViewMatrix,frustum:r.camera.frustum};t.updateUniformBuffers(i.projectionMatrix,i.viewMatrix,i.inverseViewMatrix),t.root.traverseCondition((e=>{e.isCulled||!e.meshRenderer||i.frustum&&e.getAABB()&&!e.getAABB().isInsideFrustum(i.frustum)?e.isCulled=!0:e.isCulled=!1}),(e=>e.active&&e.visible)),t.render(i,{materialOverride:this.material,materialOverrideInstanced:this.materialInstanced,materialOverrideSkinned:this.materialSkinned,renderPass:g.OPAQUE|g.SHADOWS})}},this.setUniforms=function(e){var t=e.getUniformLocation("textureMatrices[0]");null!=t&&(d.uniformMatrix4fv(t,!1,a),d.uniform1iv(e.getUniformLocation("projectedTextures[0]"),s),d.uniform1fv(e.getUniformLocation("biases[0]"),l))}}function be(e=512,t=20,n=-.006,r=[d.TEXTURE31,d.TEXTURE30]){this.bias=n,this.textureNumbers=r,this.camera=new Xe({type:Xe.Type.Orthographic,size:t,near:1,far:300}),this.shadowPerspeciveMatrix=W.orthographic({size:t,near:1,far:300}),this.shadowModelMatrix=W.identity(),this.shadowViewMatrix=W.identity(),this.shadowInverseViewMatrix=W.identity(),this.textureMatrix=null,this.textureMatrixBase=W.transform([["translate",{x:.5,y:.5,z:.5}],["scale",X.fill(.5)]]),this.depthTexture=d.createTexture(),this.depthTextureSize=e,d.activeTexture(r[0]),d.bindTexture(d.TEXTURE_2D,this.depthTexture),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.DEPTH_COMPONENT:d.DEPTH_COMPONENT16,this.depthTextureSize,this.depthTextureSize,0,d.DEPTH_COMPONENT,d.UNSIGNED_INT,null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),this.depthFramebuffer=d.createFramebuffer(),d.bindFramebuffer(d.FRAMEBUFFER,this.depthFramebuffer),d.framebufferTexture2D(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.TEXTURE_2D,this.depthTexture,0),d.activeTexture(d.TEXTURE0),this.updateModelMatrix=function(n){var r=m.scenes[m.currentScene],i=t/e*2;W.lookAt(X.zero(),X.negate(r.sunDirection),X.up(),this.shadowModelMatrix);var a=W.transformVector(W.inverse(this.shadowModelMatrix),n);W.transform([["translate",new X(E(a.x,i),E(a.y,i),a.z+100)]],this.shadowModelMatrix),this.camera.transform.matrix=this.shadowModelMatrix,W.inverse(this.shadowModelMatrix,this.shadowViewMatrix),W.copy(this.shadowModelMatrix,this.shadowInverseViewMatrix),W.copy(this.textureMatrixBase,this.textureMatrix),W.multiply(this.textureMatrix,this.shadowPerspeciveMatrix,this.textureMatrix),W.multiply(this.textureMatrix,this.shadowViewMatrix,this.textureMatrix)},this.bind=function(){d.bindFramebuffer(d.FRAMEBUFFER,this.depthFramebuffer),d.viewport(0,0,this.depthTextureSize,this.depthTextureSize),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT)},this.clearShadowmap=function(){d.bindFramebuffer(d.FRAMEBUFFER,this.depthFramebuffer),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT)}}function ye(e){this.programContainer=e;var t=this;Object.defineProperty(this,"program",{get:function(){return t.programContainer.program},set:e=>{t.programContainer.setProgram(e)}}),this.meshData=new ze({position:{bufferData:new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),size:2}}),this.uniformLocations={viewDirectionProjectionInverse:d.getUniformLocation(this.program,"viewDirectionProjectionInverse"),environmentIntensity:d.getUniformLocation(this.program,"environmentIntensity"),skybox:d.getUniformLocation(this.program,"skybox")};var n=W.identity();this.render=function(e,t){if(!t)return;ee(this.program),this.meshData.bindBuffers(this.programContainer),W.copy(e.viewMatrix,n),W.removeTranslation(n),W.multiply(e.projectionMatrix,n,n),W.inverse(n,n);const r=m.getActiveScene();d.uniform1f(this.uniformLocations.environmentIntensity,r.environmentIntensity),d.uniformMatrix4fv(this.uniformLocations.viewDirectionProjectionInverse,!1,n),this.programContainer.setUniform("fogColor",r.fogColor),this.programContainer.setUniform("fogIntensity",r.skyboxFogIntensity),this.programContainer.setUniform("iTime",(new Date-1690402835811)/1e3),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_CUBE_MAP,t),d.uniform1i(this.uniformLocations.skybox,0),d.depthFunc(d.LEQUAL),d.drawArrays(d.TRIANGLES,0,6),d.depthFunc(d.LESS)}}function Te(e){var t,n=this;this.activeAttributes={},this.activeUniforms={},this.uniformBuffers={},Object.defineProperty(this,"program",{get:function(){return t},set:function(e){n.setProgram(e)}}),this.setProgram=function(e){!function(e){e instanceof WebGLProgram||console.error("Not a program:",e)}(e),t=e,this.updateUniformLocations()},this.getUniformLocation=function(e){var t=this.activeUniforms[e];return t?t.location:null},this.setUniform=function(e,t,n=!0){var r=this.activeUniforms[e];if(r)if(-1===r.setType.toLowerCase().indexOf("matrix"))Array.isArray(t)?d["uniform"+r.setType+"v"](r.location,t):d["uniform"+r.setType](r.location,t);else{if(!ArrayBuffer.isView(t))throw console.error(t),new Error(`Cannot set matrix uniform: ${e}. Matrix must be Float32Array`);d["uniform"+r.setType](r.location,!1,t)}else n&&console.warn(`Cannot set uniform: ${e}. Uniform does not exist`)},this.bindTexture=function(e,t,n=0){d.activeTexture(d.TEXTURE0+n),d.bindTexture(d.TEXTURE_2D,e),d.uniform1i(this.getUniformLocation(t),n)},this.getAttribLocation=function(e){var t=this.activeAttributes[e];if(t)return t.location},this.updateUniformLocations=function(){this.activeAttributes={},this.activeUniforms={},this.uniformBuffers={};const e=d.getProgramParameter(t,d.ACTIVE_ATTRIBUTES);for(let n=0;n<e;n++){const e=d.getActiveAttrib(t,n),r=d.getAttribLocation(t,e.name),i=ie(e.type);this.activeAttributes[e.name]={location:r,size:e.size,type:e.type,typeString:i}}const n=d.getProgramParameter(t,d.ACTIVE_UNIFORMS);for(let e=0;e<n;e++){const n=d.getActiveUniform(t,e),r=d.getUniformLocation(t,n.name),i=ie(n.type),a=ne(i);this.activeUniforms[n.name]={location:r,size:n.size,type:n.type,typeString:i,setType:a}}if(m.version>1){const e=[...Array(n).keys()];var r=Math.max(...d.getActiveUniforms(t,e,d.UNIFORM_BLOCK_INDEX))+1;if(-1!=r)for(let e=0;e<r;e++){var i=d.getActiveUniformBlockName(t,e);if(null!=i){for(var a=d.getActiveUniformBlockParameter(t,e,d.UNIFORM_BLOCK_DATA_SIZE),o=d.getActiveUniformBlockParameter(t,e,d.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),s=new Array(o.length),l=0;l<s.length;l++)s[l]=d.getActiveUniform(t,o[l]).name;var c=d.getUniformIndices(t,s),u=d.getActiveUniforms(t,c,d.UNIFORM_OFFSET);this.uniformBuffers[i]={name:i,blockIndex:e,blockSize:a,subnames:s,offsets:u}}}}},this.setProgram(e)}function we(e={},t=m.programContainers.lit){return new Oe(t,e)}this.logGLError=ue,this.TrailRenderer=function(){this.gameObject=null;var e=X.up();Object.defineProperty(this,"emitNormal",{get:function(){return e},set:function(t){X.set(e,t)}});var t=X.zero(),n=!1;Object.defineProperty(this,"emitPosition",{get:function(){return t},set:function(e){X.set(t,e),n=!0}}),this.emit=!0,this.width=.13,this.maxVertices=500,this.minDistance=.05,this.uvOriginAtStart=!0;var r=0,i=new Array(this.maxVertices);for(let e=0;e<i.length;e++)i[e]={position:X.zero(),normal:X.up(),distance:0,alpha:1};var a=0,o=0,s=new Float32Array(2*this.maxVertices*3),l=new Float32Array(2*this.maxVertices*2),c=new Float32Array(2*this.maxVertices*1),u=new ze({position:{bufferData:s,size:3},uv:{bufferData:l,size:2},alpha:{bufferData:c,size:1}}),h=we({metallic:1,albedo:[.003,.003,.003,1],albedoTexture:Le(m.path+"assets/textures/skidmarksSoft2.png"),alphaCutoff:0},m.programContainers.litTrail);h.opaque=!1,new Ue(h,u).drawMode=d.TRIANGLE_STRIP;var f=W.identity(),v=new X,g=new j,p=X.zero(),x=()=>{n?X.set(p,t):W.getPosition(this.gameObject.transform.worldMatrix,p);var s=a<=0?i[i.length-1]:i[a-1],l=X.distanceSqr(s.position,p);if(l<this.minDistance*this.minDistance)return!1;var c=Math.sqrt(l);X.set(v,s.position),X.subtractTo(v,p),X.divideTo(v,c);var u=i[a],h=u.normal;return j.angleAxis(Math.PI/2,v,g),j.QxV(g,e,h),X.multiplyTo(h,this.width),X.set(u.position,p),u.distance=s.distance+c,u.alpha=this.emit,r+=c,++a>=i.length&&(a=0),o++,o=Math.min(o,this.maxVertices),!0};const T=(e,t=1)=>(e.set(e.subarray(t)),e.fill(0,-t),e);this.update=function(){if(x()){T(s,6),T(l,4),T(c,2);let e=b(a-1,i.length),t=i[e],n=t.position,o=t.normal,u=this.maxVertices-1;s[6*u+0]=n.x+o.x,s[6*u+1]=n.y+o.y,s[6*u+2]=n.z+o.z,s[6*u+3]=n.x-o.x,s[6*u+4]=n.y-o.y,s[6*u+5]=n.z-o.z;let h=t.distance,f=this.uvOriginAtStart?h:r-h;l[4*u+0]=f,l[4*u+1]=1,l[4*u+2]=f,l[4*u+3]=0;for(let e=this.maxVertices-1;e>=0;e--){let t=b(a-this.maxVertices+e,i.length),n=i[t].alpha;n=y(n,0,1),n*=e/(this.maxVertices-1);let r=e;c[2*r+0]=n,c[2*r+1]=n}}let e=d.STREAM_DRAW;d.bindBuffer(d.ARRAY_BUFFER,u.buffers[0].buffer),d.bufferData(d.ARRAY_BUFFER,s,e,6*(this.maxVertices-o)),d.bindBuffer(d.ARRAY_BUFFER,u.buffers[1].buffer),d.bufferData(d.ARRAY_BUFFER,l,e,4*(this.maxVertices-o)),d.bindBuffer(d.ARRAY_BUFFER,u.buffers[2].buffer),d.bufferData(d.ARRAY_BUFFER,c,e,2*(this.maxVertices-o))},this.render=function(e,t,n=!1,r=!0){if(!n){if(null===h.programContainer)return;if(h.isOpaque()!=r)return;ee(h.programContainer.program),u.bindBuffers(h.programContainer),_e(h,{camera:e,modelMatrix:f,prevViewMatrix:e.prevViewMatrix,shadowPass:n}),!n&&m.shadowCascades&&m.shadowCascades.setUniforms(h),Ee(h,n),d.drawArrays(d.TRIANGLE_STRIP,0,2*o)}}},this.ParticleSystem=function(e=200,t){var n=this;this.maxParticles=e,this.drawOnDownscaledFramebuffer=!1,this.drawMode=d.TRIANGLES,this.material=we({albedoTexture:Le(m.path+"assets/textures/bulletTrail.png"),albedo:[40,10,5,1]},m.programContainers.particle),this.material.doubleSided=!0,this.meshData=t??Ye(),this.particles=new Array(this.maxParticles);for(let e=0;e<this.particles.length;e++)this.particles[e]=new o(new X(0,-1e3,0));var r=[];this.matrixData=new Float32Array(16*this.maxParticles);for(let e=0;e<this.maxParticles;e++)this.matrixData.set(this.particles[e].matrix,16*e);this.colorData=new Float32Array(4*this.maxParticles);for(let e=0;e<this.colorData.length;e++)this.colorData[e]=1;this.matrixBuffer=d.createBuffer(),d.bindBuffer(d.ARRAY_BUFFER,this.matrixBuffer),d.bufferData(d.ARRAY_BUFFER,this.matrixData,d.DYNAMIC_DRAW),this.colorBuffer=d.createBuffer(),d.bindBuffer(d.ARRAY_BUFFER,this.colorBuffer),d.bufferData(d.ARRAY_BUFFER,this.colorData,d.DYNAMIC_DRAW);var i=X.zero();this.orientation="faceVelocity",this.localParticles=!0,this.alpha=1,this.startSize=e=>(e.x=.6*(.8*Math.random()+.2),e.y=.15*(.4*Math.random()+.6),e.z=1,e),this.endSize=e=>X.zero(e),this.emitPosition=e=>X.zero(e),this.emitVelocity=e=>X.zero(e),this.emitHealth=.5,this.alphaCurve=new de,this.alphaCurve.addStage(0,1),this.alphaCurve.addStage(.8,1),this.alphaCurve.addStage(1,0),this.wind=e=>(e.x=10*(Math.random()-.45),e.y=0,e.z=10*(Math.random()-.45),e),this.drag=1,this.gravityScale=1;var a=new X;function o(e){this.position=e,this.matrix=W.translate(this.position),this.velocity=X.zero(),this.startSize=X.one(),this.endSize=X.one(),this.health=.5,this.maxHealth=.5,this.alpha=n.alpha,this.active=!0;var t=X.up(),a=X.zero(),o=W.identity(),s=X.zero(),l=new X;this.matrix=W.identity(),this.getAlpha=function(){return this.alpha*n.alphaCurve.getValue(1-this.health/this.maxHealth)},this.getMatrix=function(){if(i){var e,r;if(n.localParticles?(W.copy(n.gameObject.transform.matrix,o),e=W.transformVector(o,this.position),r=W.transformDirection(o,this.velocity)):(e=this.position,r=this.velocity),"faceVelocity"==n.orientation){var l=X.normalize(r),c=X.projectOnPlane(X.subtract(i,e),l);W.lookInDirection(e,c,l,this.matrix)}else{if("faceCamera"!=n.orientation)throw new Error("Unknown orientation mode: "+n.orientation);X.set(a,i),X.subtractTo(a,e),W.lookInDirection(e,a,t,this.matrix)}X.lerp(this.endSize,this.startSize,this.health/this.maxHealth,s),W.scaleWithVector(this.matrix,s)}return this.matrix},this.update=function(e){this.active&&(n.wind(l),X.multiplyTo(l,e),X.addTo(this.velocity,l),this.velocity.x-=n.drag*Math.abs(this.velocity.x)*this.velocity.x*e,this.velocity.y-=n.drag*Math.abs(this.velocity.y)*this.velocity.y*e,this.velocity.z-=n.drag*Math.abs(this.velocity.z)*this.velocity.z*e,this.velocity.y-=9.82*n.gravityScale*e,this.position.x+=this.velocity.x*e,this.position.y+=this.velocity.y*e,this.position.z+=this.velocity.z*e,this.health-=e,this.health<=0&&(this.active=!1,r.push(this)))}}this.emit=function(e=1){for(var t=0;t<e&&r.length>0;t++){var i=r.shift();i.active=!0,i.health=i.maxHealth=this.emitHealth,i.alpha=this.alpha,n.emitPosition(a),X.set(i.position,a),n.emitVelocity(a),X.set(i.velocity,a),n.startSize(a),X.set(i.startSize,a),n.endSize(a),X.set(i.endSize,a)}},this.update=function(e){for(var t of this.particles)t.update(e);for(var n=0;n<this.maxParticles;n++){var r=this.particles[n];r.active?(this.matrixData.set(r.getMatrix(),16*n),this.colorData[4*n+3]=r.getAlpha()):this.colorData[4*n+3]=0}d.bindBuffer(d.ARRAY_BUFFER,this.matrixBuffer),d.bufferData(d.ARRAY_BUFFER,this.matrixData,d.DYNAMIC_DRAW),d.bindBuffer(d.ARRAY_BUFFER,this.colorBuffer),d.bufferData(d.ARRAY_BUFFER,this.colorData,d.DYNAMIC_DRAW)},this.render=function(e,t,n=!1,r=!0,a,o={}){if(o.downscaledPass==this.drawOnDownscaledFramebuffer&&!r){W.getPosition(e.cameraMatrix,i),ee(this.material.programContainer.program),this.meshData.bindBuffers(this.material.programContainer),d.bindBuffer(d.ARRAY_BUFFER,this.matrixBuffer);const t=this.material.programContainer.getAttribLocation("modelMatrix");for(var s=0;s<4;s++){const e=t+s;d.enableVertexAttribArray(e),d.vertexAttribPointer(e,4,d.FLOAT,!1,64,16*s),le(e,1)}d.bindBuffer(d.ARRAY_BUFFER,this.colorBuffer);const r=this.material.programContainer.getAttribLocation("color");d.enableVertexAttribArray(r),d.vertexAttribPointer(r,4,d.FLOAT,!1,0,0),le(r,1),this.material instanceof Ie?_e(this.material,{camera:e,prevViewMatrix:e.prevViewMatrix,shadowPass:n}):this.material.bindUniforms(e),Ee(this.material,n),ce(this.drawMode,this.meshData.indices.length,this.meshData.indexType,0,this.maxParticles)}}},this.RenderTexture=function(e=512,t=512,n={}){this.width=e,this.height=t,this.clearFlags=n.clearFlags??d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT,this.framebuffer=d.createFramebuffer(),d.bindFramebuffer(d.FRAMEBUFFER,this.framebuffer),this.colorTexture=d.createTexture(),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,this.colorTexture),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,this.width,this.height,0,d.RGBA,Q(),null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,this.colorTexture,0),this.depthTexture=d.createTexture(),d.bindTexture(d.TEXTURE_2D,this.depthTexture),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.DEPTH_COMPONENT:d.DEPTH_COMPONENT16,this.width,this.height,0,d.DEPTH_COMPONENT,d.UNSIGNED_INT,null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.framebufferTexture2D(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.TEXTURE_2D,this.depthTexture,0),this.bind=function(){d.bindFramebuffer(d.FRAMEBUFFER,this.framebuffer)},this.resize=function(e,t){this.width=e,this.height=t,d.bindTexture(d.TEXTURE_2D,this.colorTexture),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.RGBA:d.RGBA16F,this.width,this.height,0,d.RGBA,Q(),null),d.bindTexture(d.TEXTURE_2D,this.depthTexture),d.texImage2D(d.TEXTURE_2D,0,1==m.version?d.DEPTH_COMPONENT:d.DEPTH_COMPONENT16,this.width,this.height,0,d.DEPTH_COMPONENT,d.UNSIGNED_INT,null)}},this.UniformBuffer=function(e,t){this.data=new Float32Array,this.location=e,this.buffer=d.createBuffer(),d.bindBuffer(d.UNIFORM_BUFFER,this.buffer),d.bufferData(d.UNIFORM_BUFFER,t,d.DYNAMIC_DRAW),d.bindBuffer(d.UNIFORM_BUFFER,null),d.bindBufferBase(d.UNIFORM_BUFFER,this.location,this.buffer),this.update=function(e){this.data=e,d.bindBuffer(d.UNIFORM_BUFFER,this.buffer),d.bufferData(d.UNIFORM_BUFFER,this.data,d.DYNAMIC_DRAW),d.bindBuffer(d.UNIFORM_BUFFER,null),d.bindBufferBase(d.UNIFORM_BUFFER,this.location,this.buffer)}},h.ProgramContainer=Te,this.ProgramContainer=Te,this.LitMaterial=class{constructor(e={},t=m.programContainers.lit){return m.CreateLitMaterial(e,t)}},this.CreateLitMaterial=we;let Ee=(e,t=!1)=>{t?e.doubleSidedShadows?m.disableCulling():m.enableCulling():e.doubleSided?m.disableCulling():m.enableCulling()},_e=(e,t={})=>{Ce(e,e.programContainer,t)},Me=[0,0,0],Re=[0,0,0],Ce=(e,t,n={})=>{let r=m.getActiveScene(),i=0,a=(e,n)=>{if(!t.activeUniforms[n])return;let r=(e=>{let t=null;if(-1!==(e=e.toUpperCase()).indexOf("SAMPLER_2D_ARRAY"))t=d.TEXTURE_2D_ARRAY;else if(-1!==e.indexOf("SAMPLER_CUBE"))t=d.TEXTURE_CUBE_MAP;else if(-1!==e.indexOf("SAMPLER_3D"))t=d.TEXTURE_3D;else{if(-1===e.indexOf("SAMPLER_2D"))throw new Error("Unknown texture target: ",e);t=d.TEXTURE_2D}return t})(t.activeUniforms[n].typeString);if(Array.isArray(e)){var a=Array.from({length:e.length},((e,t)=>i+t));d.uniform1iv(t.getUniformLocation(n),a);for(var o=0;o<e.length;o++)d.activeTexture(d.TEXTURE0+i),d.bindTexture(r,e[o]),i++}else d.activeTexture(d.TEXTURE0+i),d.bindTexture(r,e),d.uniform1i(t.getUniformLocation(n),i),i++},o=e=>t.getUniformLocation(e);if(n.modelMatrix&&t.setUniform("modelMatrix",n.modelMatrix,!1),n.prevModelMatrix&&t.setUniform("prevModelMatrix",n.prevModelMatrix,!1),e.isLit&&!n.shadowPass&&(a(m.splitsumTexture,"u_splitSum"),a(r.diffuseCubemap,"u_diffuseIBL"),a(r.specularCubemap,"u_specularIBL")),!this.currentBoundLitPrograms.has(t)){((e,t)=>{let n=e=>t.getUniformLocation(e);n("iTime")&&d.uniform1f(n("iTime"),w);var r=e.getLights();n("nrLights")&&d.uniform1i(n("nrLights"),r.length);for(let e=0;e<r.length;e++){let t=r[e];n(`lights[${e}].type`)&&d.uniform1i(n(`lights[${e}].type`),t.type),n(`lights[${e}].position`)&&d.uniform3f(n(`lights[${e}].position`),t.position.x,t.position.y,t.position.z),n(`lights[${e}].direction`)&&t.direction&&d.uniform3f(n(`lights[${e}].direction`),t.direction.x,t.direction.y,t.direction.z),n(`lights[${e}].angle`)&&"angle"in t&&d.uniform1f(n(`lights[${e}].angle`),t.angle),n(`lights[${e}].color`)&&d.uniform3f(n(`lights[${e}].color`),t.color[0],t.color[1],t.color[2])}null!=n("sunDirection")&&d.uniform3fv(n("sunDirection"),X.toArray(e.sunDirection,Me)),null!=n("sunIntensity")&&d.uniform3fv(n("sunIntensity"),X.toArray(e.sunIntensity,Re)),null!=n("environmentIntensity")&&d.uniform1f(n("environmentIntensity"),e.environmentIntensity),null!=n("environmentMinLight")&&d.uniform1f(n("environmentMinLight"),e.environmentMinLight),null!=n("ambientColor")&&d.uniform3fv(n("ambientColor"),e.ambientColor),null!=n("fogDensity")&&d.uniform1f(n("fogDensity"),e.fogDensity),null!=n("fogColor")&&d.uniform4fv(n("fogColor"),e.fogColor)})(r,t);let i=t.uniformBuffers.sharedPerScene;if(i&&r.sharedUBO)d.uniformBlockBinding(t.program,i.blockIndex,r.sharedUBO.location);else{let e=n.camera;e&&(null!=o("projectionMatrix")&&d.uniformMatrix4fv(o("projectionMatrix"),!1,e.projectionMatrix),null!=o("inverseViewMatrix")&&d.uniformMatrix4fv(o("inverseViewMatrix"),!1,e.inverseViewMatrix),null!=o("viewMatrix")&&d.uniformMatrix4fv(o("viewMatrix"),!1,e.viewMatrix))}n.prevViewMatrix&&t.setUniform("prevViewMatrix",n.prevViewMatrix,!1),n.shadowPass||(d.uniform1i(t.getUniformLocation("shadowQuality"),n.shadowQuality??0),m.shadowCascades&&m.shadowCascades.setUniforms(e)),this.currentBoundLitPrograms.set(t,1)}t.setUniform("opaque",e.opaque,!1);for(let n in e.uniforms)t.activeUniforms[n]&&((s=e.uniforms[n])instanceof WebGLTexture||Array.isArray(s)&&s.every((e=>e instanceof WebGLTexture))?a(e.uniforms[n],n):t.setUniform(n,e.uniforms[n]));var s};function Fe(e,t){this.joints=e,this.inverseBindMatrixData=t,this.inverseBindMatrices=[],this.jointMatrices=[],this.jointData=new Float32Array(16*e.length),this.textureIndex=25,this.parentNode=null;for(var n=0;n<e.length;n++)this.inverseBindMatrices.push(new Float32Array(t.buffer,t.byteOffset+16*Float32Array.BYTES_PER_ELEMENT*n,16)),this.jointMatrices.push(new Float32Array(this.jointData.buffer,16*Float32Array.BYTES_PER_ELEMENT*n,16));this.jointTexture=d.createTexture(),d.activeTexture(d.TEXTURE0+this.textureIndex),d.bindTexture(d.TEXTURE_2D,this.jointTexture),d.texImage2D(d.TEXTURE_2D,0,d.RGBA32F,4,this.joints.length,0,d.RGBA,Q(),null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),this.copy=function(){var e=new Fe([...this.joints],new Float32Array(t));return e.parentNode=this.parentNode,e},this.update=function(){this.updateMatrixTexture()},this.bindTexture=function(e){d.uniform1i(e.programContainer.getUniformLocation("u_jointTexture"),this.textureIndex),d.uniform1f(e.programContainer.getUniformLocation("u_numJoints"),this.joints.length),d.activeTexture(d.TEXTURE0+this.textureIndex),d.bindTexture(d.TEXTURE_2D,this.jointTexture)},this.updateMatrixTexture=function(){for(let e=0;e<this.joints.length;e++)W.copy(W.multiply(this.joints[e].transform.getWorldMatrix(this.parentNode),this.inverseBindMatrices[e]),this.jointMatrices[e]);d.activeTexture(d.TEXTURE0+this.textureIndex),d.bindTexture(d.TEXTURE_2D,this.jointTexture),d.texSubImage2D(d.TEXTURE_2D,0,0,0,4,this.joints.length,d.RGBA,Q(),this.jointData)}}this.Skin=Fe;class Ae{drawOnDownscaledFramebuffer=!1;constructor(){this.eventHandler=new Pe,this.on=this.eventHandler.on.bind(this.eventHandler),this.off=this.eventHandler.off.bind(this.eventHandler)}cleanup(){for(let e of this.meshData)e.cleanup()}setShadowQuality(e,t=!1){for(var n of this.materials)n.isOpaque()==t&&null!==n.programContainer&&(ee(n.programContainer.program),d.uniform1i(n.programContainer.getUniformLocation("shadowQuality"),e))}isFullyOpaque(){for(let e of this.materials)if(!e.isOpaque())return!1;return!0}}class De extends Ae{constructor(e,t,n,r={}){super(),this.materials=Array.isArray(t)?t:[t],this.meshData=Array.isArray(n)?n:[n],this.drawMode=r.drawMode??d.TRIANGLES,this.skin=e}update(){this.skin.update()}render(e,t,n=!1,r=!0,i,a={}){if((a.downscaledPass??!1)==this.drawOnDownscaledFramebuffer)for(var o=0;o<this.meshData.length;o++){var s=this.meshData[o],l=this.materials[o];null!==l.programContainer&&(a.submeshCondition&&!a.submeshCondition(s,l)||l.isOpaque()==r&&(ee(l.programContainer.program),s.bindBuffers(l.programContainer),l instanceof Ie?_e(l,{camera:e,modelMatrix:t,prevModelMatrix:i,prevViewMatrix:e.prevViewMatrix,shadowPass:n}):(l.bindModelMatrixUniform(t,i,e.prevViewMatrix),l.bindUniforms(e)),this.skin.bindTexture(l),n&&d.uniform1iv(l.programContainer.getUniformLocation("projectedTextures[0]"),[0,0]),Ee(l,n),s.drawCall(this.drawMode)))}}copy(){var e=[];for(var t of this.materials)e.push(t.copy());var n=[];for(var r of this.meshData)n.push(r.copy());var i=new De(this.skin.copy(),e,n);return i.drawMode=this.drawMode,i}}h.SkinnedMeshRenderer=De;class Se extends Ae{constructor(e,t,n={}){super(),this.materials=Array.isArray(e)?e:[e],this.meshData=Array.isArray(t)?t:[t],this.drawMode=n.drawMode??d.TRIANGLES,this.matrixBuffer=d.createBuffer(),this.needsBufferUpdate=!1,this.matrices=[]}getAABB(e){(e=e||new xe).isEmpty=!0,X.zero(e.bl),X.zero(e.tr);const t=new xe;for(let n of this.meshData)for(let r of this.matrices)n.aabb.copy(t).approxTransform(r),e.extend(t);return e}addInstance(e){var t=W.copy(e);return this.matrices.push(t),this.needsBufferUpdate=!0,t}addInstanceDontCopy(e){return this.matrices.push(e),this.needsBufferUpdate=!0,e}updateInstance(e,t,n=!0){this.needsBufferUpdate&&(this.updateMatrixData(),this.needsBufferUpdate=!1),W.copy(t,e),this.matrixData.set(e,16*this.matrices.indexOf(e)),n&&(d.bindBuffer(d.ARRAY_BUFFER,this.matrixBuffer),d.bufferSubData(d.ARRAY_BUFFER,0,this.matrixData))}removeInstance(e){var t=this.matrices.indexOf(e);-1!=t&&(this.matrices.splice(t,1),this.needsBufferUpdate=!0)}removeAllInstances(){this.matrices=[],this.needsBufferUpdate=!0}updateMatrixData(){this.matrixData=new Float32Array(16*this.matrices.length);for(var e=0;e<this.matrices.length;e++)this.matrixData.set(this.matrices[e],16*e);d.bindBuffer(d.ARRAY_BUFFER,this.matrixBuffer),d.bufferData(d.ARRAY_BUFFER,this.matrixData,d.DYNAMIC_DRAW)}render(e,t,n=!1,r=!0,i,a={}){if((a.downscaledPass??!1)==this.drawOnDownscaledFramebuffer&&(this.needsBufferUpdate&&(this.updateMatrixData(),this.needsBufferUpdate=!1),this.matrices.length>0))for(var o=0;o<this.meshData.length;o++){var s=this.meshData[o],l=this.materials[o];if(null!==l.programContainer&&(!a.submeshCondition||a.submeshCondition(s,l))&&l.isOpaque()==r){ee(l.programContainer.program),s.bindBuffers(l.programContainer),d.bindBuffer(d.ARRAY_BUFFER,this.matrixBuffer);for(var c=l.programContainer.getAttribLocation("modelMatrix"),u=0;u<4;u++){const e=c+u;d.enableVertexAttribArray(e),d.vertexAttribPointer(e,4,d.FLOAT,!1,64,16*u),le(e,1)}l instanceof Ie?_e(l,{camera:e,prevModelMatrix:i,prevViewMatrix:e.prevViewMatrix,shadowPass:n}):l.bindUniforms(e),Ee(l,n),ce(this.drawMode,s.indices.length,s.indexType,0,this.matrices.length)}}}copy(){var e=[];for(var t of this.materials)e.push(t.copy());var n=[];for(var r of this.meshData)n.push(r.copy());var i=new Se(e,n);return i.drawMode=this.drawMode,i}}h.MeshInstanceRenderer=Se,this.MeshInstanceRenderer=Se;class Ue extends Ae{constructor(e,t,n={}){if(super(),this.materials=Array.isArray(e)?e:[e],this.meshData=Array.isArray(t)?t:[t],this.drawMode=n.drawMode??d.TRIANGLES,this.materials.some((e=>!(e instanceof Ie))))throw console.error(this.materials),new Error("Not a valid Material!");if(this.meshData.some((e=>!(e instanceof ze))))throw console.error(this.meshData),new Error("Not a valid MeshData!");for(let e of this.meshData)e.on("updateAABB",(()=>{this.eventHandler.fireEvent("updateAABB")}))}getAABB(e){for(var t of((e=e||new xe).isEmpty=!0,X.zero(e.bl),X.zero(e.tr),this.meshData))e.extend(t.aabb);return e}render(e,t,n=!1,r=!0,i,a={}){if((a.downscaledPass??!1)==this.drawOnDownscaledFramebuffer)for(var o=0;o<this.meshData.length;o++){var s=this.meshData[o],l=this.materials[o];if(null!==l.programContainer&&(!a.submeshCondition||a.submeshCondition(s,l))&&l.isOpaque()==r){if(ee(l.programContainer.program),s.bindBuffers(l.programContainer),l instanceof Ie?_e(l,{camera:e,modelMatrix:t,prevModelMatrix:i,prevViewMatrix:e.prevViewMatrix,shadowPass:n,shadowQuality:a.shadowQuality}):(l.bindModelMatrixUniform(t,i,e.prevViewMatrix),l.bindUniforms(e)),n){let e=l.programContainer.getUniformLocation("projectedTextures[0]");e&&d.uniform1iv(e,[0,0])}Ee(l,n),s.drawCall(this.drawMode)}}}getInstanceMeshRenderer(e=m.programContainers.litInstanced){var t=[];for(var n of this.materials){var r=n.copy();r.programContainer=e,t.push(r)}return new Se(t,this.meshData,{drawMode:this.drawMode})}copy(){var e=this.materials.map((e=>e.copy())),t=this.meshData.map((e=>e.copy())),n=new Ue(e,t);return n.drawMode=this.drawMode,n}}function ze(e){for(var t of(this.eventHandler=new Pe,this.on=this.eventHandler.on.bind(this.eventHandler),this.data=e,Object.defineProperty(this,"indices",{get:()=>this.data?.indices?.bufferData}),Object.defineProperty(this,"indexType",{get:()=>this.data?.indices?.type??d.UNSIGNED_INT}),this.buffers=[],Object.keys(this.data))){var n=this.data[t];this.buffers.push({attribute:t,buffer:Z(n.bufferData,n.target??d.ARRAY_BUFFER),size:n.size,target:n.target??d.ARRAY_BUFFER,type:n.type??d.FLOAT,stride:n.stride??0})}var r=[];this.vaos=new WeakMap;const i=new xe,a=new X;let o=()=>{if(i.isEmpty=!0,X.zero(i.bl),X.zero(i.tr),this.data.position)for(var e=0;e<this.data.position.bufferData.length;e+=3)a.x=this.data.position.bufferData[e],a.y=this.data.position.bufferData[e+1],a.z=this.data.position.bufferData[e+2],i.extend(a);this.eventHandler.fireEvent("updateAABB")};o(),Object.defineProperty(this,"aabb",{get:()=>i,set:()=>{throw new Error("Set MeshData aabb")}}),this.updateData=function(e,t=d.DYNAMIC_DRAW){this.data=e;for(let r of Object.keys(e)){var n=this.buffers.find((e=>e.attribute==r));n&&n.size==e[r].size&&n.target==(e[r].target??d.ARRAY_BUFFER)&&n.type==(e[r].type??d.FLOAT)&&n.stride==(e[r].stride??0)?(d.bindBuffer(n.target,n.buffer),d.bufferData(n.target,e[r].bufferData,t)):console.warn("New attribute or missmatching size, target, type or stride: "+r)}o()},this.setAttribute=function(e,t,n=d.DYNAMIC_DRAW){var r=this.buffers.find((t=>t.attribute==e));r?(d.bindBuffer(r.target,r.buffer),d.bufferData(r.target,t.bufferData,n),"size"in t&&(r.size=t.size),"target"in t&&(r.target=t.target),"type"in t&&(r.type=t.type),"stride"in t&&(r.stride=t.stride),this.data[e]=t):this.buffers.push({attribute:e,buffer:Z(t.bufferData,t.target??d.ARRAY_BUFFER),size:t.size,target:t.target??d.ARRAY_BUFFER,type:t.type??d.FLOAT,stride:t.stride??0}),"position"===e&&o()},this.recalculateNormals=function(){if(!this.data.position||!this.data.indices)throw new Error("Can't generate normals! Missing positions or indicies");var e=En(this.data.position.bufferData,this.data.indices.bufferData);this.setAttribute("normal",{bufferData:e,size:3})},this.recalculateTangents=function(){if(!(this.data.position&&this.data.indices&&this.data.uv))throw new Error("Can't generate tangents! Missing positions, indicies or uvs");var e=_n(this.data.position.bufferData,this.data.indices.bufferData,this.data.uv.bufferData);this.setAttribute("tangent",{bufferData:e,size:4})},this.applyTransform=function(e){if(!(this.data&&this.data.position&&this.data.indices))throw new Error("Can't transform MeshData. MeshData is missing 'position' or 'indices' attribute");for(let t=0;t<this.data.position.bufferData.length;t+=3){let n={x:this.data.position.bufferData[t+0],y:this.data.position.bufferData[t+1],z:this.data.position.bufferData[t+2]};n=W.transformVector(e,n),this.data.position.bufferData[t+0]=n.x,this.data.position.bufferData[t+1]=n.y,this.data.position.bufferData[t+2]=n.z}this.setAttribute("position",this.data.position)},this.getSubdivision=function(e=1,t=!1){let n=this.data.position.bufferData,r=this.data.indices.bufferData;function i(e,t,n,r){this.a=e,this.b=t,this.v=n,this.last=r}let a=(e,t)=>((t=t||new X).x=n[3*e+0],t.y=n[3*e+1],t.z=n[3*e+2],t),o=[],s=[];o=[...n];let l=new Map,c=e=>l.get(`${e[0]}-${e[1]}`),u=e=>{let t=[];for(let n=0;n<r.length;n+=3){let i=r[n+0],a=r[n+1],o=r[n+2],s=[[i,a],[a,o],[o,i]],l=[o,i,a];for(let n=0;n<s.length;n++){let r=s[n];(r[0]==e[0]&&r[1]==e[1]||r[0]==e[1]&&r[1]==e[0])&&t.push({a:e[0],b:e[1],last:l[n]})}}return t},h=new Array(n.length/3);for(let e=0;e<h.length;e++)h[e]=[];for(let e=0;e<r.length;e+=3){let t=r[e+0],n=r[e+1],i=r[e+2],a=[[t,n],[n,i],[i,t]],o=[i,t,n];for(let e=0;e<o.length;e++)h[o[e]].push(...a[e])}for(let e=0;e<h.length;e++)h[e]=Array.from(new Set(h[e]));for(let e=0;e<n.length/3;e++){let t=h[e],n=t.length,r=2==n?1/8:3==n?3/16:3/8/n,i=n>=3?1-n*r:3/4,s=X.zero();for(let e of t)X.addTo(s,X.multiply(a(e),r));X.addTo(s,X.multiply(a(e),i)),o[3*e+0]=s.x,o[3*e+1]=s.y,o[3*e+2]=s.z}for(let e=0;e<r.length;e+=3){let n=r[e+0],h=r[e+1],f=r[e+2],d=[[n,h],[h,f],[f,n]],m=[f,n,h],v=[];for(let e=0;e<d.length;e++){let n=d[e];if(t){let t=c(n);if(t){let n=X.multiply(a(m[e]),1/8);o[3*t.v+0]+=n.x,o[3*t.v+1]+=n.y,o[3*t.v+2]+=n.z,v.push(t.v)}else{let r=a(n[0]),s=a(n[1]),c=X.add(X.multiply(r,3/8),X.multiply(s,3/8));X.addTo(c,X.multiply(a(m[e]),1/8)),o.push(c.x,c.y,c.z),v.push(o.length/3-1),t=new i(n[0],n[1],o.length/3-1,m[e]),l.set(`${n[0]}-${n[1]}`,t),l.set(`${n[1]}-${n[0]}`,t)}}else{let e=c(n);if(e)v.push(e.v);else{let e=u(n);if(2==e.length){let t=X.zero();X.addTo(t,X.multiply(a(e[0].a),3/8)),X.addTo(t,X.multiply(a(e[0].b),3/8)),X.addTo(t,X.multiply(a(e[0].last),1/8)),X.addTo(t,X.multiply(a(e[1].last),1/8)),o.push(t.x,t.y,t.z),v.push(o.length/3-1)}else if(1==e.length){let t=X.zero();X.addTo(t,X.multiply(a(e[0].a),.5)),X.addTo(t,X.multiply(a(e[0].b),.5)),o.push(t.x,t.y,t.z),v.push(o.length/3-1)}else console.warn(e.length);let t=new i(n[0],n[1],o.length/3-1,null);l.set(`${n[0]}-${n[1]}`,t),l.set(`${n[1]}-${n[0]}`,t)}}}s.push(n,v[0],v[2]),s.push(v[0],h,v[1]),s.push(v[1],f,v[2]),s.push(v[0],v[1],v[2])}return{indices:{bufferData:new Uint32Array(s),type:5125,target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(o),size:3}}},this.subdivide=function(e=1){let t=this.getSubdivision(e);this.setAttribute("indices",t.indices),this.setAttribute("position",t.position),this.recalculateNormals()},this.copy=function(){return this},this.bindBuffers=function(e){var t=e.program,n=this.vaos.get(t);if(null==n){n=1==m.version?m.VAOExt.createVertexArrayOES():2==m.version?d.createVertexArray():void 0,r.push(n),this.vaos.set(t,n),se(n);for(var i=e.activeAttributes,a=0;a<this.buffers.length;a++){var o=this.buffers[a];if(o.target==d.ELEMENT_ARRAY_BUFFER)d.bindBuffer(d.ELEMENT_ARRAY_BUFFER,o.buffer);else{var s=i[o.attribute];void 0!==s&&-1!=(s=s.location)&&(d.bindBuffer(o.target,o.buffer),d.enableVertexAttribArray(s),le(s,0),d.vertexAttribPointer(s,o.size,o.type,!1,o.stride,0))}}}else se(n)},this.drawCall=function(e){this.indices?d.drawElements(e,this.indices.length,this.indexType,0):this.data.position?e==d.TRIANGLE_STRIP?d.drawArrays(e,0,this.data.position.bufferData.length/3):d.drawArrays(e,0,this.data.position.bufferData.length):console.warn("Can't render meshData")},this.cleanup=function(){for(var e of r)oe(e);for(var t of this.buffers)d.deleteBuffer(t.buffer)}}function Le(e,t={}){var n=d.createTexture();if(d.bindTexture(d.TEXTURE_2D,n),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,1,1,0,d.RGBA,d.UNSIGNED_BYTE,new Uint8Array([0,0,255,255])),"string"==typeof e){var r=new Image;r.crossOrigin="Anonymous",r.src=e,r.onload=function(){ke(n,r,t)}}else ke(n,e,t);return n}async function Be(e,t={}){var n;return n="string"==typeof e?await P(e):e,ke(d.createTexture(),n,t)}function ke(e,t,n){if(Object.prototype.hasOwnProperty.call(n,"anisotropicFiltering")||(n.anisotropicFiltering=!0),Object.prototype.hasOwnProperty.call(n,"generateMipmap")||(n.generateMipmap=!0),Object.prototype.hasOwnProperty.call(n,"maxTextureSize")&&t.width>n.maxTextureSize){var r=t.width/t.height;t=Rn(t,n.maxTextureSize,n.maxTextureSize/r)}if(1==m.version){var i=Math.pow(2,Math.floor(Math.log2(t.width)));t=Rn(t,i,i)}if(d.bindTexture(d.TEXTURE_2D,e),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,0),d.texImage2D(d.TEXTURE_2D,n.level??0,n.internalFormat??d.RGBA,n.format??d.RGBA,d.UNSIGNED_BYTE,t),n.generateMipmap&&(1!=m.version||1==m.version&&_(t.width)&&_(t.height))&&35906!=n.format?d.generateMipmap(d.TEXTURE_2D):d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),n.TEXTURE_WRAP_R&&d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_R,n.TEXTURE_WRAP_R),n.TEXTURE_WRAP_S&&d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,n.TEXTURE_WRAP_S),n.TEXTURE_WRAP_T&&d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,n.TEXTURE_WRAP_T),n.TEXTURE_MIN_FILTER&&d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,n.TEXTURE_MIN_FILTER),n.TEXTURE_MAG_FILTER&&d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,n.TEXTURE_MAG_FILTER),n.anisotropicFiltering&&m.EXT_texture_filter_anisotropic){const e=m.EXT_texture_filter_anisotropic,t=m.MAX_ANISOTROPY;d.texParameterf(d.TEXTURE_2D,e.TEXTURE_MAX_ANISOTROPY_EXT,t)}return e}this.MeshRenderer=Ue,this.MeshData=ze,this.loadMetalRoughness=function(e,t){var n=d.createTexture();return d.bindTexture(d.TEXTURE_2D,n),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,1,1,0,d.RGBA,d.UNSIGNED_BYTE,new Uint8Array([0,255,0,255])),Promise.all([P(e),P(t)]).then((([e,t])=>{if(e.width!=t.width||e.height!=t.height)throw new Error("Dimension mismatch!");for(var r=S(e),i=S(t),a=new Uint8Array(e.width*e.height*4),o=0;o<a.length;o+=4)a[o]=0,a[o+1]=i[o+1],a[o+2]=r[o+2],a[o+3]=255;d.bindTexture(d.TEXTURE_2D,n),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,e.width,e.height,0,d.RGBA,d.UNSIGNED_BYTE,a),d.generateMipmap(d.TEXTURE_2D)})).catch((e=>{throw e})),n},this.loadTexture=Le,this.loadTextureAsync=Be,this.loadGLTF=async function(e,t={}){console.groupCollapsed("Load GLTF: "+e);var n=await this.getGLTFData(e),r=await this.createGameObjectFromGLTFData(n,t);return console.groupEnd(),r},this.getGLTFData=async function(e){return new Promise(((t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=async function(){if(200==r.status){var i=r.response;if(i){let n=new TextDecoder;for(var a,o=new Uint8Array(i),s=[],l=12;l<o.byteLength;){var c=A(o.slice(l,l+4)),u=A(o.slice(l+4,l+8)),h=o.slice(l+8,l+8+c);if(1313821514==u){var f=n.decode(h);a=JSON.parse(f)}else{if(5130562!=u)throw new Error("Invalid chunk type: "+u.toString(16));s.push(h)}l+=c+8}t({json:a,buffers:s,path:e})}}else n("Could not load GLTF model: "+r.statusText)},r.send(null)}))};var je={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},He={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},We={5120:8,5121:8,5122:16,5123:16,5125:32,5126:32};function qe(){var e=new Float32Array([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1]),t=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),n=new Uint32Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),r=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0]),i=_n(e,n,r);return{indices:{bufferData:n,target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:e,size:3},normal:{bufferData:t,size:3},tangent:{bufferData:i,size:4},uv:{bufferData:r,size:2}}}function Ye(e=1){var t=new Float32Array([e,e,0,-e,e,0,-e,-e,0,e,-e,0]),n=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1]),r=new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0]),i=new Uint32Array([0,1,2,0,2,3]),a=new Float32Array([1,1,0,1,0,0,1,0]);return new ze({indices:{bufferData:i,target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:t,size:3},normal:{bufferData:n,size:3},tangent:{bufferData:r,size:3},uv:{bufferData:a,size:2}})}function Ke(e){if(!(e instanceof h))throw new Error("Renderer is not of class 'Renderer'");console.log("Using %cforward%c renderpipeline","color: green; text-transform: uppercase; font-weight: bold;",""),this.renderer=e;var t=this.renderer.gl;this.render=function(n,r,i,a){if(this.renderer.shadowCascades&&O.enableShadows&&(0!=i.sunIntensity.x||0!=i.sunIntensity.y||0!=i.sunIntensity.z)&&!1!==a.shadows&&this.renderer.shadowCascades.renderShadowmaps(n.transform.position),i.updateUniformBuffers(n.projectionMatrix,n.viewMatrix,n.inverseViewMatrix),this.renderer.postprocessing&&O.enablePostProcessing?this.renderer.postprocessing.bindFramebuffer():t.bindFramebuffer(t.FRAMEBUFFER,null),e.version>1&&t.drawBuffers([t.COLOR_ATTACHMENT0,t.COLOR_ATTACHMENT1]),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),t.disable(t.BLEND),i.skyboxVisible&&this.renderer.skybox.render(n,i.skyboxCubemap),i.root.traverseCondition((e=>{!e.meshRenderer||n.frustum&&e.getAABB()&&!e.getAABB().isInsideFrustum(n.frustum)?e.isCulled=!0:e.isCulled=!1}),(e=>e.active&&e.visible)),1==U[3]&&t.colorMask(!0,!0,!0,!1),t.disable(t.BLEND),i.render(n,{renderPass:g.OPAQUE}),this.renderer.gizmos.gameObject.render(n),t.enable(t.BLEND),t.depthMask(!1),i.render(n,{renderPass:g.ALPHA}),t.depthMask(!0),e.version>1&&t.drawBuffers([t.COLOR_ATTACHMENT0]),r)for(var o of r)i.updateUniformBuffers(o.projectionMatrix,o.viewMatrix,o.inverseViewMatrix),o.renderTexture?(o.renderTexture.bind(),t.viewport(0,0,o.renderTexture.width,o.renderTexture.height),t.clear(o.renderTexture.clearFlags)):(this.renderer.postprocessing&&O.enablePostProcessing?this.renderer.postprocessing.bindFramebuffer():t.bindFramebuffer(t.FRAMEBUFFER,null),t.clear(t.DEPTH_BUFFER_BIT)),i.render(o,{renderPass:g.OPAQUE}),t.depthMask(!1),i.render(o,{renderPass:g.ALPHA}),t.depthMask(!0);t.colorMask(!0,!0,!0,!0),this.renderer.godrays&&this.renderer.godrays.render(i,n),se(null),this.renderer.postprocessing&&O.enablePostProcessing&&this.renderer.postprocessing.blitAA(),this.renderer.bloom&&O.enableBloom&&this.renderer.bloom.render(),this.renderer.postprocessing&&O.enablePostProcessing&&this.renderer.postprocessing.render(),W.copy(n.viewMatrix,n.prevViewMatrix)}}function $e(e){if(!(e instanceof h))throw new Error("Renderer is not of class 'Renderer'");if(e.version<2)throw new Error("Deferred rendering is only available with WebGL2");console.log("Using %cdeferred%c renderpipeline","color: red; text-transform: uppercase; font-weight: bold;",""),this.renderer=e;var t=this.renderer.gl,n=t.canvas.width,r=t.canvas.height;const i=Q();for(var a={basic:new Te(this.renderer.createProgram(on,sn)),instanced:new Te(this.renderer.createProgram(ln,cn)),skinned:new Te(this.renderer.createProgram(un,hn))},o=new Te(this.renderer.createProgram(fn,dn)),s=new fe,l=_(n,r),c=E(n,r),u=[],f=0;f<Object.keys(l.colorBuffers).length;f++)u.push(t.COLOR_ATTACHMENT0+f);var d=new function(){this.scale=.5,this.blur=5,this.blurHMultiplier=1,this.blurVMultiplier=1,this.maxRoughness=.5,this.maxDistance=64,this.stepResolution=.1,this.refinementSteps=10,this.thickness=10;var i=new fe,a=new Te(e.createProgram(mn,vn)),o=new Te(e.createProgram(gn,pn));this.framebuffer=J(n,r),this.resizeFramebuffers=function(){t.deleteFramebuffer(this.framebuffer.framebuffer),this.framebuffer=J(t.canvas.width,t.canvas.height)},this.pass=function(e,n,r,o){t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer.framebuffer),t.viewport(0,0,t.canvas.width*this.scale,t.canvas.height*this.scale),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),ee(a.program),se(null),i.bindBuffers(a.getAttribLocation("position")),a.setUniform("scale",this.scale),a.setUniform("maxRoughness",this.maxRoughness),a.setUniform("maxDistance",this.maxDistance),a.setUniform("resolution",this.stepResolution),a.setUniform("steps",this.refinementSteps),a.setUniform("thickness",this.thickness),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.positionViewSpace),t.uniform1i(a.getUniformLocation("positionTexture"),0),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.normal),t.uniform1i(a.getUniformLocation("normalTexture"),1),t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.properties),t.uniform1i(a.getUniformLocation("propertiesTexture"),2),t.activeTexture(t.TEXTURE3),t.bindTexture(t.TEXTURE_2D,c.colorBuffer),t.uniform1i(a.getUniformLocation("albedoTexture"),3),t.uniformMatrix4fv(a.getUniformLocation("lensProjection"),!1,e.projectionMatrix),t.uniformMatrix4fv(a.getUniformLocation("inverseViewMatrix"),!1,e.inverseViewMatrix),t.uniformMatrix4fv(a.getUniformLocation("viewMatrix"),!1,e.viewMatrix),i.render()},this.combinePass=function(e){t.bindFramebuffer(t.FRAMEBUFFER,e),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),ee(o.program),se(null),i.bindBuffers(o.getAttribLocation("position")),t.uniform2f(o.getUniformLocation("SIZE"),t.canvas.width,t.canvas.height),t.uniform1f(o.getUniformLocation("scale"),this.scale),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,c.colorBuffer),t.uniform1i(o.getUniformLocation("combinedTexture"),0),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,this.framebuffer.colorBuffer),t.uniform1i(o.getUniformLocation("ssrTexture"),1),i.render()}};this.ssr=d;var m=new function(){var n=new fe,r=new Te(e.createProgram(xn,bn)),i=J(t.canvas.width,t.canvas.height);this.resizeFramebuffers=function(){t.deleteFramebuffer(i.framebuffer),i=J(t.canvas.width,t.canvas.height)},this.pass=function(e,a=null,o=20,s=1,l=1){ee(r.program),se(null),n.bindBuffers(r.getAttribLocation("position")),t.uniform2f(r.getUniformLocation("SIZE"),t.canvas.width,t.canvas.height),t.bindFramebuffer(t.FRAMEBUFFER,i.framebuffer),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e),t.uniform1i(r.getUniformLocation("imageTexture"),0),t.uniform1i(r.getUniformLocation("horizontal"),0),t.uniform1i(r.getUniformLocation("radius"),o*s),n.render(),t.bindFramebuffer(t.FRAMEBUFFER,a),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,i.colorBuffer),t.uniform1i(r.getUniformLocation("imageTexture"),0),t.uniform1i(r.getUniformLocation("horizontal"),1),t.uniform1i(r.getUniformLocation("radius"),o*l),n.render()}};this.enableSSR=!1,this.renderer.on("resize",(()=>{this.resizeFramebuffers(),d.resizeFramebuffers(),m.resizeFramebuffers()})),this.resizeFramebuffers=function(){t.deleteFramebuffer(l.framebuffer),l=_(t.canvas.width,t.canvas.height),t.deleteFramebuffer(c.framebuffer),c=E(t.canvas.width,t.canvas.height)},this.render=function(e,i,a,o){n=t.canvas.width,r=t.canvas.height,t.viewport(0,0,t.canvas.width,t.canvas.height),g(e,i,a,o),v(e,i,a,o);var s=this.enableSSR?c.framebuffer:this.renderer.postprocessing.getFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),se(null),this.renderer.skybox.render(e,a.skyboxCubemap),se(null),b(e,i,a,o),se(null),x(s,e,i,a,o),se(null),M(e,i,a,o),se(null),p(),se(null),this.renderer.postprocessing.render(),W.copy(e.viewMatrix,e.prevViewMatrix)};var v=(e,n,r,i)=>{t.bindFramebuffer(t.FRAMEBUFFER,l.framebuffer),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),t.drawBuffers(u);for(var o=0;o<32;o++)t.activeTexture(t.TEXTURE0+o),t.bindTexture(t.TEXTURE_2D,null);for(let n in a){let r=a[n];ee(r.program),t.uniformMatrix4fv(r.getUniformLocation("projectionMatrix"),!1,e.projectionMatrix),t.uniformMatrix4fv(r.getUniformLocation("inverseViewMatrix"),!1,e.inverseViewMatrix),t.uniformMatrix4fv(r.getUniformLocation("viewMatrix"),!1,e.viewMatrix)}se(null),r.root.traverseCondition((n=>{if(n.meshRenderer){if(e.frustum&&n.getAABB()&&!n.getAABB().isInsideFrustum(e.frustum))return;var r=n.meshRenderer;if(r instanceof Se){let e=a.instanced;if(ee(e.program),r.needsBufferUpdate&&(r.updateMatrixData(),r.needsBufferUpdate=!1),r.matrices.length>0)for(let i=0;i<r.meshData.length;i++){let a=r.meshData[i],o=r.materials[i];if(null!==o.programContainer&&o.programContainer!=this.renderer.programContainers.litInstanced)continue;if(!o.isOpaque())continue;a.bindBuffers(e),t.bindBuffer(t.ARRAY_BUFFER,r.matrixBuffer);let s=e.getAttribLocation("modelMatrix");for(let e=0;e<4;e++){const n=s+e;t.enableVertexAttribArray(n),t.vertexAttribPointer(n,4,t.FLOAT,!1,64,16*e),le(n,1)}T(e,o,n.transform.worldMatrix),ce(r.drawMode,a.indices.length,a.indexType,0,r.matrices.length)}}else if(r instanceof Ue){let e=a.basic;ee(e.program);for(let t=0;t<r.meshData.length;t++){let i=r.meshData[t],a=r.materials[t];null!==a.programContainer&&a.programContainer!=this.renderer.programContainers.lit||a.isOpaque()&&(i.bindBuffers(e),T(e,a,n.transform.worldMatrix),i.drawCall(r.drawMode))}}else if(r instanceof De){let e=a.skinned;ee(e.program);for(var i=0;i<r.meshData.length;i++){var o=r.meshData[i],s=r.materials[i];null!==s.programContainer&&s.programContainer!=this.renderer.programContainers.litSkinned||s.isOpaque()&&(o.bindBuffers(e),T(e,s,n.transform.worldMatrix),r.skin.bindTexture({programContainer:e}),o.drawCall(r.drawMode))}}}}),(e=>e.active&&e.visible))},g=(e,t,n,r)=>{se(null),this.renderer.shadowCascades&&O.enableShadows&&(0!=n.sunIntensity.x||0!=n.sunIntensity.y||0!=n.sunIntensity.z)&&!1!==r.shadows&&n.shadowQuality>0&&this.renderer.shadowCascades.renderShadowmaps(e.transform.position)},p=()=>{this.renderer.bloom?.render()},x=(e,i,a,o,s)=>{t.bindFramebuffer(t.DRAW_FRAMEBUFFER,e),t.bindFramebuffer(t.READ_FRAMEBUFFER,l.framebuffer),t.blitFramebuffer(0,0,n,r,0,0,n,r,t.DEPTH_BUFFER_BIT,t.NEAREST),t.bindFramebuffer(t.FRAMEBUFFER,e),o.updateUniformBuffers(i.projectionMatrix,i.viewMatrix,i.inverseViewMatrix),t.activeTexture(t.TEXTURE0+2),t.bindTexture(t.TEXTURE_CUBE_MAP,o.diffuseCubemap),t.activeTexture(t.TEXTURE0+1),t.bindTexture(t.TEXTURE_CUBE_MAP,o.specularCubemap),t.activeTexture(t.TEXTURE0+0),t.bindTexture(t.TEXTURE_2D,this.renderer.splitsumTexture),1==U[3]&&t.colorMask(!0,!0,!0,!1),t.disable(t.BLEND),o.root.traverseCondition((e=>{let t=!0;if(e.meshRenderer){let n=e.transform.worldMatrix;e.meshRenderer.setShadowQuality?.(e.receiveShadows?2:0,t),e.meshRenderer.render(i,n,!1,t,e.prevModelMatrix,{submeshCondition:(e,t)=>null!==t.programContainer&&!(N.lit&&t.programContainer==this.renderer.programContainers.lit||N.litInstanced&&t.programContainer==this.renderer.programContainers.litInstanced||N.litSkinned&&t.programContainer==this.renderer.programContainers.litSkinned)}),e.updatePrevModelMatrix()}for(var n of e.getComponents())if("function"==typeof n.render){let r=e.transform.worldMatrix;n.render(i,r,!1,t)}}),(e=>e.active&&e.visible)),t.enable(t.BLEND),t.depthMask(!1),o.root.traverseCondition((e=>{let t=!1;if(e.meshRenderer){let n=e.transform.worldMatrix;e.meshRenderer.setShadowQuality?.(e.receiveShadows?2:0,t),e.meshRenderer.render(i,n,!1,t,e.prevModelMatrix)}for(var n of e.getComponents())if("function"==typeof n.render){let r=e.transform.worldMatrix;n.render(i,r,!1,t)}}),(e=>e.active&&e.visible)),t.disable(t.BLEND),t.depthMask(!0),t.colorMask(!0,!0,!0,!0)},b=(e,n,r,i)=>{ee(o.program),t.drawBuffers([t.COLOR_ATTACHMENT0,t.COLOR_ATTACHMENT1]),t.bindBuffer(t.ARRAY_BUFFER,s.vertexBuffer);var a=o.getAttribLocation("position");t.enableVertexAttribArray(a),t.vertexAttribPointer(a,2,t.FLOAT,!1,8,0),t.uniform2f(o.getUniformLocation("SIZE"),t.canvas.width,t.canvas.height),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.position),t.uniform1i(o.getUniformLocation("gPosition"),0),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.normal),t.uniform1i(o.getUniformLocation("gNormal"),1),t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.albedo),t.uniform1i(o.getUniformLocation("gAlbedo"),2),t.activeTexture(t.TEXTURE6),t.bindTexture(t.TEXTURE_2D,l.colorBuffers.properties),t.uniform1i(o.getUniformLocation("gProperties"),6),t.activeTexture(t.TEXTURE3),t.bindTexture(t.TEXTURE_CUBE_MAP,r.diffuseCubemap),t.uniform1i(o.getUniformLocation("u_diffuseIBL"),3),t.activeTexture(t.TEXTURE4),t.bindTexture(t.TEXTURE_CUBE_MAP,r.specularCubemap),t.uniform1i(o.getUniformLocation("u_specularIBL"),4),t.activeTexture(t.TEXTURE5),t.bindTexture(t.TEXTURE_2D,this.renderer.splitsumTexture),t.uniform1i(o.getUniformLocation("u_splitSum"),5);var c=r.getLights();t.uniform1i(o.getUniformLocation("nrLights"),c.length);for(let e=0;e<c.length;e++){let n=c[e];t.uniform1i(o.getUniformLocation(`lights[${e}].type`),n.type),t.uniform3f(o.getUniformLocation(`lights[${e}].position`),n.position.x,n.position.y,n.position.z),n.direction&&t.uniform3f(o.getUniformLocation(`lights[${e}].direction`),n.direction.x,n.direction.y,n.direction.z),"angle"in n&&t.uniform1f(o.getUniformLocation(`lights[${e}].angle`),n.angle),t.uniform3f(o.getUniformLocation(`lights[${e}].color`),n.color[0],n.color[1],n.color[2])}t.uniformMatrix4fv(o.getUniformLocation("projectionMatrix"),!1,e.projectionMatrix),t.uniformMatrix4fv(o.getUniformLocation("viewMatrix"),!1,e.viewMatrix),t.uniformMatrix4fv(o.getUniformLocation("prevViewMatrix"),!1,e.prevViewMatrix),t.uniformMatrix4fv(o.getUniformLocation("inverseViewMatrix"),!1,e.inverseViewMatrix),t.uniform3fv(o.getUniformLocation("sunDirection"),X.toArray(r.sunDirection)),t.uniform3fv(o.getUniformLocation("sunIntensity"),X.toArray(r.sunIntensity)),t.uniform3fv(o.getUniformLocation("ambientColor"),X.toArray(r.ambientColor)),t.uniform1f(o.getUniformLocation("environmentIntensity"),r.environmentIntensity),t.uniform1f(o.getUniformLocation("environmentMinLight"),r.environmentMinLight),null!=o.getUniformLocation("fogDensity")&&t.uniform1f(o.getUniformLocation("fogDensity"),r.fogDensity),o.setUniform("fogColor",r.fogColor),t.uniform1i(o.getUniformLocation("shadowQuality"),r.shadowQuality),w(o),s.render()},y={modelMatrix:null,shadowPass:!1},T=(e,n,r)=>{y.modelMatrix=r,Ce(n,e,y),e.setUniform("enableMotionBlur",n.uniforms.enableMotionBlur??1),t.uniformMatrix4fv(e.getUniformLocation("modelMatrix"),!1,r),Ee(n,!1)},w=n=>{var r=e.shadowCascades;r.setUniforms(n);var i=Array.from({length:r.levels},((e,t)=>30-2*t)).reverse();t.uniform1iv(n.getUniformLocation("projectedTextures[0]"),i);for(let e=0;e<r.levels;e++){let n=30-2*e;t.activeTexture(t.TEXTURE0+n),t.bindTexture(t.TEXTURE_2D,r.shadowmaps[e].depthTexture)}};function E(n,r){var a=J(n,r);return a.motionBlurColorBuffer=t.createTexture(),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,a.motionBlurColorBuffer),t.texImage2D(t.TEXTURE_2D,0,1==e.version?t.RGBA:t.RGBA16F,n,r,0,t.RGBA,i,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT1,t.TEXTURE_2D,a.motionBlurColorBuffer,0),a}function _(e,n){var r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r);var a={position:{internalFormat:t.RGBA32F,type:i,filter:t.NEAREST},albedo:{internalFormat:t.RGBA16F,type:i,filter:t.LINEAR},normal:{internalFormat:t.RGBA16F,type:i,filter:t.LINEAR},properties:{internalFormat:t.RGBA,type:t.UNSIGNED_BYTE,filter:t.LINEAR},positionViewSpace:{internalFormat:t.RGBA32F,type:i,filter:t.NEAREST}},o={position:null,normal:null,albedo:null,properties:null,positionViewSpace:null};t.activeTexture(t.TEXTURE0);var s=0;for(var l in o){var c=t.createTexture();t.bindTexture(t.TEXTURE_2D,c);var u=a[l],h=u?.internalFormat??t.RGBA32F,f=u?.type??i;t.texImage2D(t.TEXTURE_2D,0,h,e,n,0,t.RGBA,f,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,u?.filter??t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,u?.filter??t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+s,t.TEXTURE_2D,c,0),o[l]=c,s++}var d=t.createRenderbuffer();return t.bindRenderbuffer(t.RENDERBUFFER,d),t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_COMPONENT16,e,n),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.RENDERBUFFER,d),{framebuffer:r,colorBuffers:o,depthBuffer:d}}var M=(e,t,n,r)=>{this.enableSSR&&(d.pass(e,t,n,r),d.blur>0&&m.pass(d.framebuffer.colorBuffer,d.framebuffer.framebuffer,d.blur,d.blurVMultiplier,d.blurHMultiplier),d.combinePass(this.renderer.postprocessing.getFramebuffer()))}}this.createGameObjectFromGLTFData=async function(e,t={}){var{json:n,buffers:r,path:i}=e,a=[],o=[];console.time("Loading "+i),console.log(n);var s,l=i.indexOf(".glb")+4,c=i.lastIndexOf("/",l)+1,u=new Ne(i.slice(c,l)),h=[],f=[],v=[],g=n.scene??0,p=n.scenes[g];for(let e=0;e<p.nodes.length;e++)f=f.concat(await D(p.nodes[e]));if(u.addChildren(f),!t.disableAnimations&&(s=n.animations)&&0!==Object.keys(s).length)for(var x of(u.animationController=new et,n.animations)){var b=[];for(var y of x.channels){var T,w,E=x.samplers[y.sampler],_=N(E.input).buffer,M=N(E.output),R=M.accessor,C=M.buffer,F=C;if("VEC3"==R.type){let e=[];for(let t=0;t<C.byteLength/4;t+=3)e.push({x:C[t],y:C[t+1],z:C[t+2]});F=e}else if("VEC4"==R.type){let e=[];for(let t=0;t<C.byteLength/4;t+=4)e.push({x:C[t],y:C[t+1],z:C[t+2],w:C[t+3]});F=e}"CUBICSPLINE"==E.interpolation&&(T=F.filter(((e,t)=>t%3==0)),w=F.filter(((e,t)=>t%3==0)),F=F.filter(((e,t)=>t%3==1))),b.push({target:h[y.target.node],path:y.target.path,interpolation:E.interpolation,inputBuffer:_,outputBuffer:F,inputTangents:T,outputTangents:w})}var A=new Ze(x.name,b);u.animationController.animations.push(A)}for(let e=0;e<v.length;e++){let t=v[e],n=[];for(let e=0;e<t.joints.length;e++){let r=h[t.joints[e]];r?n[e]=r:console.warn("Invalid joint index!")}let r=[];for(let e=0;e<t.obj.meshRenderer.materials.length;e++){let n=null;m.renderpipeline instanceof Ke&&(n=m.programContainers.litSkinned);let i=t.obj.meshRenderer.materials[e],a=new Oe(n,i.uniforms);r.push(a)}t.obj.meshRenderer=new De(new Fe(n,t.inverseBindMatrixData),r,t.obj.meshRenderer.meshData),t.obj.meshRenderer.skin.parentNode=t.obj.parent}return u.traverse((e=>{e.transform.matrix=e.transform.matrix})),console.timeEnd("Loading "+i),u;async function D(e,r=0){var i=n.nodes[e],a=W.identity();i.matrix?W.copy(i.matrix,a):(i.translation&&W.translate(X.fromArray(i.translation),a),i.rotation&&W.multiply(a,W.fromQuaternion(X.fromArray(i.rotation)),a),i.scale&&W.transform([["scale",X.fromArray(i.scale)]],a));var s=new Ne(i.name,{matrix:a,...t.gameObjectOptions});if(s.nodeIndex=e,h[e]=s,i.extensions&&i.extensions.KHR_lights_punctual){var l=n.extensions.KHR_lights_punctual.lights[i.extensions.KHR_lights_punctual.light],c=l.intensity??1,u=l.color??[1,1,1],f=l.type,g=s.addComponent(new Ge);g.color=[u[0]*c,u[1]*c,u[2]*c],g.type={point:0,spot:1,directional:2}[f],l.spot&&"spot"==f&&(g.angle=l.spot.outerConeAngle)}var p=i.extras;if(p&&(console.log("Custom data:",p),s.customData={...p}),null!=i.mesh){var x=n.meshes[i.mesh],b=x.extras;b&&(console.log("Custom mesh data:",b),s.customData={...s.customData,...b});for(var y=t.loadNormals??!0,T=t.loadTangents??!0,w=[],E=[],_=0;_<x.primitives.length;_++){var M=x.primitives[_],R={},C=N(M.attributes.POSITION);R.position={bufferData:C.buffer,size:C.size,stride:C.stride};var F=N(M.indices);F&&(R.indices={bufferData:F.buffer,type:m.indexTypeLookup[F.type],target:d.ELEMENT_ARRAY_BUFFER,stride:F.stride});var A=N(M.attributes.COLOR_0);A&&(R.color={bufferData:P(A.buffer),size:A.size,stride:A.stride});var U=N(M.attributes.TEXCOORD_0);if(U&&(R.uv={bufferData:U.buffer,size:U.size,stride:U.stride}),y){var z=N(M.attributes.NORMAL);z?R.normal={bufferData:z.buffer,size:z.size,stride:z.stride}:(console.warn("Generating normals"),R.normal={bufferData:En(C.buffer,F.buffer),size:3})}if(T){var L=N(M.attributes.TANGENT);L?R.tangent={bufferData:L.buffer,size:L.size,stride:L.stride}:U&&(console.warn("Generating tangents"),R.tangent={bufferData:_n(C.buffer,F.buffer,U.buffer),size:4})}if(M.attributes.JOINTS_0){let e=N(M.attributes.JOINTS_0);R.joints={bufferData:e.buffer,size:e.size,type:e.type,stride:e.stride}}if(M.attributes.WEIGHTS_0){let e=N(M.attributes.WEIGHTS_0);R.weights={bufferData:e.buffer,size:e.size,type:e.type,stride:e.stride}}var B=t.loadMaterials??!0,I=void 0,k=M.material;if(B&&null!=k)if(null!=o[k])I=o[k];else{var V=[0,0,0],G=[1,1,1,1],j=void 0,H=void 0,q=void 0,Y=void 0,K=void 0,$=1,Q=1,J=.5,Z=1,ee=!1,te=n.materials[k],ne=te.pbrMetallicRoughness;if(te.doubleSided&&(ee=!0),"BLEND"==te.alphaMode?(J=0,Z=0):"MASK"==te.alphaMode?(J=te.alphaCutoff??.5,Z=1):"OPAQUE"!=te.alphaMode&&"alphaMode"in te||(J=-1,Z=1),null!=ne){if(G=ne.baseColorFactor??[1,1,1,1],ne.metallicRoughnessTexture||($=0,Q=1),O.loadTextures){var re=1==m.version?m.sRGBExt&&(m.floatTextures||m.textureHalfFloatExt)?m.sRGBExt.SRGB_ALPHA_EXT:d.RGBA:d.SRGB8_ALPHA8,ie=1==m.version&&m.sRGBExt&&(m.floatTextures||m.textureHalfFloatExt)?m.sRGBExt.SRGB_ALPHA_EXT:d.RGBA;ne.baseColorTexture&&(j=await S(ne.baseColorTexture.index,{internalFormat:re,format:ie})),ne.metallicRoughnessTexture&&(q=await S(ne.metallicRoughnessTexture.index)),te.normalTexture&&(H=await S(te.normalTexture.index,t.sRGBNormalMap?{internalFormat:re,format:ie}:{})),null!=te.emissiveTexture&&(Y=await S(te.emissiveTexture.index,{internalFormat:re,format:ie})),null!=te.occlusionTexture&&(K=await S(te.occlusionTexture.index))}null!=te.emissiveFactor&&(V=te.emissiveFactor),null!=ne.metallicFactor&&($=ne.metallicFactor),null!=ne.roughnessFactor&&(Q=ne.roughnessFactor)}(I=we({alphaCutoff:J,albedo:G,albedoTexture:j,normalTexture:H,metallicRoughnessTexture:q,roughness:Q,metallic:$,emissiveFactor:V,emissiveTexture:Y,occlusionTexture:K})).opaque=!!Z,I.doubleSided=ee,I.name=te.name||"No name!",o[k]=I}w.push(I??we()),E.push(new ze(R))}s.meshRenderer=new Ue(w,E)}if(null!=i.skin){var ae=n.skins[i.skin],oe=N(ae.inverseBindMatrices).buffer;0!=N(ae.inverseBindMatrices).stride&&console.warn("Stride in skin ibm data");var se=ae.joints;v.push({obj:s,joints:se,inverseBindMatrixData:oe})}var le=[];if(null!=i.children)for(var ce=0;ce<i.children.length;ce++)le=le.concat(await D(i.children[ce],r+1));return s.addChildren(le),[s]}function P(e){for(var t=0;t<e.length;t++)e[t]=1-e[t];return e}async function S(e,i){if(null==a[e]){var o=await async function(e,i={}){var a=n.textures[e],o=a.source,s=n.bufferViews[n.images[o].bufferView],l=r[s.buffer].slice(s.byteOffset??0,(s.byteOffset??0)+s.byteLength);const c=new Blob([l],{type:n.images[o].mimeType});var u=URL.createObjectURL(c);if(t.downloadTextures&&function(e,t="download"){var n=document.createElement("a");n.download=t+".png",n.href=e,n.click()}(u,"texture"),Object.prototype.hasOwnProperty.call(t,"maxTextureSize")&&(i.maxTextureSize=t.maxTextureSize),a.sampler){var h=n.samplers[a.sampler];i.TEXTURE_WRAP_S=h.wrapS,i.TEXTURE_WRAP_T=h.wrapT,i.TEXTURE_MIN_FILTER=h.minFilter,i.TEXTURE_MAG_FILTER=h.magFilter}return await Be(u,i)}(e,i);return a[e]=o,o}return a[e]}function N(e){if(null!=e&&e>=0){var t=n.accessors[e],i=n.bufferViews[t.bufferView],a=i.byteStride??0,o=a?a/(We[t.componentType]/8)/He[t.type]:1,s=(i.byteOffset??0)+(t.byteOffset??0),l=r[i.buffer].slice(s,s+t.count*He[t.type]*We[t.componentType]/8*o);return{buffer:new je[t.componentType](l.buffer),size:He[t.type],type:t.componentType,stride:a,accessor:t}}}},this.getLineCubeData=function(){const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]);return{indices:{bufferData:new Uint32Array([0,1,1,3,3,2,2,0,4,5,5,7,7,6,6,4,0,4,1,5,3,7,2,6]),target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:e,size:3}}},this.getCubeData=qe,this.getPlaneData=function(){var e=new Float32Array([1,1,0,-1,1,0,-1,-1,0,1,-1,0]),t=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1]),n=new Float32Array([1,0,0,-1,1,0,0,-1,1,0,0,-1,1,0,0,-1]),r=new Uint32Array([0,1,2,0,2,3]),i=new Float32Array([1,1,0,1,0,0,1,0]);return{indices:{bufferData:r,target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:e,size:3},normal:{bufferData:t,size:3},tangent:{bufferData:n,size:4},uv:{bufferData:i,size:2}}},this.getSphereData=function(e=3){var t=.5257311121191336,n=.8506508083520399,r=[-t,0,n,t,0,n,-t,0,-n,t,0,-n,0,n,t,0,n,-t,0,-n,t,0,-n,-t,n,t,0,-n,t,0,n,-t,0,-n,-t,0],i=[0,1,4,0,4,9,9,4,5,4,8,5,4,1,8,8,1,10,8,10,3,5,8,3,5,3,2,2,3,7,7,3,10,7,10,6,7,6,11,11,6,0,0,6,1,6,10,1,9,11,0,9,2,11,9,5,2,7,11,2];for(let t=0;t<e;t++){let e=[],t=[];for(let n=0;n<i.length;n+=3){let a=[];for(let e=0;e<3;e++){let o=i[n+e],l=i[n+(e+1)%3],c=s(t,o,l);if(c)a.push(c);else{let e=X.fromArray(r.slice(3*o,3*o+3)),n=X.fromArray(r.slice(3*l,3*l+3)),i=X.normalize(X.lerp(e,n,.5));r.push(i.x,i.y,i.z),a.push(r.length/3-1),t.push({edge:[o,l],index:a[a.length-1]})}}e.push(i[n],a[0],a[2]),e.push(i[n+1],a[1],a[0]),e.push(i[n+2],a[2],a[1]),e.push(a[0],a[1],a[2])}i=e}var a=[];for(let e=0;e<r.length;e+=3){let t=X.normalize(X.fromArray(r.slice(e,e+3)));a.push(t.x,t.y,t.z)}let o=[];for(let e=0;e<r.length;e+=3){let t=X.normalize(X.fromArray(r.slice(e,e+3))),n=Math.atan2(t.x,t.z)/(2*Math.PI)+.5,i=Math.asin(t.y)/Math.PI+.5;o.push(n,i)}return new this.MeshData({indices:{bufferData:new Uint32Array(i),target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(r),size:3},normal:{bufferData:new Float32Array(a),size:3},uv:{bufferData:new Float32Array(o),size:2}});function s(e,t,n){return e.find((e=>e.edge[0]==t&&e.edge[1]==n||e.edge[0]==n&&e.edge[1]==t))?.index}},this.getParticleMeshData=Ye,this.loadObj=async function(e,t=!1){var n="No name",r={},i=[],a=[],o=[],s=(await(await fetch(e)).text()).split("\n");for(let e=0;e<s.length;e++){let t=s[e].split(" ");switch(t[0]){case"o":r[n=t[1]+" #"+Math.floor(1e4*Math.random())]=[[],[],[]];break;case"v":i.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]));break;case"vn":a.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]));break;case"vt":o.push(parseFloat(t[1]),parseFloat(t[2]));break;case"f":if(4==t.length)for(let e=0;e<3;e++)r[n][e].push(parseInt(t[1].split("/")[e])-1,parseInt(t[2].split("/")[e])-1,parseInt(t[3].split("/")[e])-1);else if(5==t.length)for(let e=0;e<3;e++)r[n][e].push(parseInt(t[1].split("/")[e])-1,parseInt(t[2].split("/")[e])-1,parseInt(t[3].split("/")[e])-1,parseInt(t[1].split("/")[e])-1,parseInt(t[3].split("/")[e])-1,parseInt(t[4].split("/")[e])-1)}}var l={},c=[],u=[],h=[],f=[c,h,u],m=[i,o,a],v=0;for(let e in r){let t=r[e];l[e]=[];for(let n=0;n<t[0].length;n++){for(let e=0;e<3;e+=2)f[e].push(m[e][3*t[e][n]],m[e][3*t[e][n]+1],m[e][3*t[e][n]+2]);l[e].push(v),v++}l[e]=new Uint32Array(l[e]);for(let e=0;e<t[0].length;e++){let n=1;f[n].push(m[n][2*t[n][e]],m[n][2*t[n][e]+1])}}let g=l;if(!t){g=[];for(let e in l)g=g.concat(Array.from(l[e]));g=new Uint32Array(g)}return new ze({indices:{bufferData:g,target:d.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(c),size:3},normal:{bufferData:new Float32Array(u),size:3},uv:{bufferData:new Float32Array(h),size:2}})},this.CreateShape=function(e=p,t=null,n=3){var r;if("plane"==(e=e.toLowerCase()))r=new this.MeshData(this.getPlaneData());else if(e==p)r=new this.MeshData(this.getCubeData());else{if("sphere"!=e)throw new Error("Invalid shape: "+e);r=this.getSphereData(n)}t=t??this.CreateLitMaterial();var i=new Ue(t,r),a=new Ne("Shape");return a.meshRenderer=i,a},this.CreatePBRGrid=async function(e,t=10,n=10,r="sphere"){for(var i="cube"==r?(await this.loadGLTF(this.path+"assets/models/primitives/cube.glb")).children[0].meshRenderer.meshData[0]:(await this.loadGLTF(this.path+"assets/models/primitives/uvSphere.glb")).children[0].meshRenderer.meshData[0],a=0;a<n;a++)for(var o=0;o<t;o++){var s=we({roughness:o/(t-1),metallic:a/(n-1)}),l=new Ue(s,i),c=new Ne;c.transform.position=new X(2.1*(o-(t-1)/2),2.1*(a-(n-1)/2),0),c.meshRenderer=l,"cube"==r&&(c.transform.scale=new X(.5,.5,100)),e.add(c)}},this.BatchGameObject=function(e){var t=new Ne(e.name+" (Batched)"),n=[];e.traverse((e=>{var r=e.findComponents("Light");if(r.length>0){var i=new Ne(e.name+" (Copy)");for(var a of(i.transform.matrix=e.transform.worldMatrix,r))i.addComponent(a.copy());t.addChild(i)}if(e.meshRenderer){var o=W.copy(e.transform.worldMatrix);W.removeTranslation(o);for(let t=0;t<e.meshRenderer.meshData.length;t++){let r=e.meshRenderer.materials[t],i=e.meshRenderer.meshData[t],a=n.find((e=>e.material==r));if(a||(a={material:r,vertices:[],indices:[],tangent:[],normal:[],uv:[],indexOffset:0},n.push(a)),i.data.position&&i.data.indices){let t=function(e,t=3){if(i.data[e])for(var n=i.data[e].bufferData,r=i.data[e].size,s=0,l=0;l<n.length;l+=r){var c=X.fromArray(n,l,1,3);c=X.normalize(W.transformVector(o,c)),a[e][a.indexOffset*t+s]=c.x,a[e][a.indexOffset*t+s+1]=c.y,a[e][a.indexOffset*t+s+2]=c.z,4==t&&(a[e][a.indexOffset*t+s+3]=4==r?n[l+3]:1),s+=t}};for(let t=0;t<i.data.position.bufferData.length;t+=3){let n={x:i.data.position.bufferData[t],y:i.data.position.bufferData[t+1],z:i.data.position.bufferData[t+2]};n=W.transformVector(e.transform.worldMatrix,n),a.vertices.push(n.x,n.y,n.z)}for(let e=0;e<i.data.indices.bufferData.length;e++)a.indices.push(i.data.indices.bufferData[e]+a.indexOffset);if(i.data.uv)for(let e=0;e<i.data.uv.bufferData.length;e++)a.uv[2*a.indexOffset+e]=i.data.uv.bufferData[e];t("normal"),t("tangent",4),a.indexOffset+=i.data.position.bufferData.length/3}i.cleanup()}}}));var r=[],i=[];for(var a of n){for(let e=0;e<a.uv.length;e++)void 0===a.uv[e]&&(a.uv[e]=0);for(let e=0;e<a.normal.length;e++)void 0===a.normal[e]&&(a.normal[e]=0);for(let e=0;e<a.tangent.length;e++)void 0===a.tangent[e]&&(a.tangent[e]=0);r.push(a.material),i.push(new ze({position:{bufferData:new Float32Array(a.vertices),size:3},indices:{bufferData:new Uint32Array(a.indices),target:m.gl.ELEMENT_ARRAY_BUFFER},tangent:{bufferData:new Float32Array(a.tangent),size:4},normal:{bufferData:new Float32Array(a.normal),size:3},uv:{bufferData:new Float32Array(a.uv),size:2}}))}return t.meshRenderer=new Ue(r,i),t},f.dontCallSetup||this.setup(f),this.DeferredPBRRenderpipeline=$e},Fn=function(){this.p=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],this.noise=function(e=0,t=0,n=0){var r,i,a,o,s,l,c,u,h,f,d,m,v=255&Math.floor(e),g=255&Math.floor(t),p=255&Math.floor(n),x=e-Math.floor(e),b=t-Math.floor(t),y=n-Math.floor(n),T=this.fade(x),w=this.fade(b),E=this.fade(y);return r=this.p[this.p[this.p[v]+g]+p],i=this.p[this.p[this.p[v]+g+1]+p],a=this.p[this.p[this.p[v]+g]+p+1],o=this.p[this.p[this.p[v]+g]+p+1],s=this.p[this.p[this.p[v+1]+g]+p],l=this.p[this.p[this.p[v+1]+g+1]+p],c=this.p[this.p[this.p[v+1]+g]+p+1],u=this.p[this.p[this.p[v+1]+g+1]+p+1],h=this.lerp(this.grad(r,x,b,y),this.grad(s,x-1,b,y),T),f=this.lerp(this.grad(i,x,b-1,y),this.grad(l,x-1,b-1,y),T),d=this.lerp(h,f,w),h=this.lerp(this.grad(a,x,b,y-1),this.grad(c,x-1,b,y-1),T),f=this.lerp(this.grad(o,x,b-1,y-1),this.grad(u,x-1,b-1,y-1),T),m=this.lerp(h,f,w),this.lerp(d,m,E)},this.fade=function(e){return e*e*e*(e*(6*e-15)+10)},this.grad=function(e,t,n,r){var i=15&e,a=i<8?t:n,o=i<4?n:12==i||14==i?t:r;return(0==(1&i)?a:-a)+(0==(2&i)?o:-o)},this.lerp=function(e,t,n){return e+n*(t-e)}},An=function(e,t,n={vertical:{keyboard:["KeyW","KeyS"],controller:"LSVertical"},horizontal:{keyboard:["KeyA","KeyD"],controller:"LSHorizontal"}}){this.gamepadManager=t;var r="none";this.setBindings=function(e={}){n=e},this.setBinding=function(e,t={}){n[e]=t},this.getInput=function(t){if(n[t]){var r=0;if(Array.isArray(n[t].keyboard)){var i=e.getKey(n[t].keyboard[0])?1:0;r=(e.getKey(n[t].keyboard[1])?1:0)-i}else r=e.getKey(n[t].keyboard)?1:0;var a=this.gamepadManager.getButton(n[t].controller)??this.gamepadManager.getAxis(n[t].controller)??0;return Math.abs(r)>Math.abs(a)?r:a}},this.getInputAndInputMethod=function(t){var i="none",a=0;if(n[t]){var o=0;if(Array.isArray(n[t].keyboard)){var s=e.getKey(n[t].keyboard[0])?1:0;o=(e.getKey(n[t].keyboard[1])?1:0)-s}else o=e.getKey(n[t].keyboard)?1:0;var l=this.gamepadManager.getButton(n[t].controller)??this.gamepadManager.getAxis(n[t].controller)??0;Math.abs(o)>Math.abs(l)?(i="keyboard",a=o):(i="controller",a=l),r=i}return{value:a,method:r}},this.getInputDown=function(t){if(n[t]){var r=0;if(Array.isArray(n[t].keyboard)){var i=e.getKeyDown(n[t].keyboard[0],t)?1:0;r=(e.getKeyDown(n[t].keyboard[1],t)?1:0)-i}else r=e.getKeyDown(n[t].keyboard)?1:0;var a=this.gamepadManager.getButtonDown(n[t].controller,void 0)??this.gamepadManager.getAxis(n[t].controller)??0;return Math.abs(r)>Math.abs(a)?r:a}},this.getInputUp=function(t){if(n[t]){var r=0;if(Array.isArray(n[t].keyboard)){var i=e.getKeyUp(n[t].keyboard[0],t)?1:0;r=(e.getKeyUp(n[t].keyboard[1],t)?1:0)-i}else r=e.getKeyUp(n[t].keyboard)?1:0;var a=this.gamepadManager.getButtonUp(n[t].controller,void 0)??this.gamepadManager.getAxis(n[t].controller)??0;return Math.abs(r)>Math.abs(a)?r:a}}};function Dn(e,t=.1){return Math.abs(e)<t?0:e}function Pn(e){return Math.abs(e)*e}const Sn=function(){this.gamepads={};var e=[],t=[];this.buttonNames={A:0,B:1,X:2,Y:3,LB:4,RB:5,LT:6,RT:7,Back:8,Menu:9,LS:10,RS:11,DPUp:12,DPDown:13,DPLeft:14,DPRight:15},this.axesNames={LSHorizontal:0,LSVertical:1,RSHorizontal:2,RSVertical:3},window.addEventListener("gamepadconnected",(e=>{console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",e.gamepad.index,e.gamepad.id,e.gamepad.buttons.length,e.gamepad.axes.length,e.gamepad),this.gamepads[e.gamepad.index]=e.gamepad})),window.addEventListener("gamepaddisconnected",(e=>{console.log("Gamepad disconnected from index %d: %s",e.gamepad.index,e.gamepad.id),delete this.gamepads[e.gamepad.index]})),this.getGamepad=function(e){var t=e??this.gamepads[Object.keys(this.gamepads)[0]]?.index;return null!=t&&navigator.getGamepads()[t]},this.nameToIndex=function(e,t){return t[e]??e},this.getButtonName=function(e){return Object.keys(this.buttonNames).find((t=>this.buttonNames[t]===e))},this.getButton=function(e,t){var n=this.getGamepad(t);if(n){var r=this.nameToIndex(e,this.buttonNames);return n.buttons[r]?.value}return null},this.getButtons=function(e){var t=this.getGamepad(e);if(t){for(var n=[],r=0;r<t.buttons.length;r++)t.buttons[r].value&&n.push(r);return n}return[]},this.getButtonDown=function(t,n,r=""){var i=this.getButton(t,n),a=this.nameToIndex(t,this.buttonNames);if(i){if(e[a+r])return e[a+r]=!1,i}else e[a+r]=!0},this.getButtonUp=function(e,n,r=""){var i=this.getButton(e,n),a=this.nameToIndex(e,this.buttonNames);if(i)t[a+r]=!0;else if(t[a+r])return t[a+r]=!1,1-i},this.getAxis=function(e,t){var n=this.getGamepad(t);if(n){var r=this.nameToIndex(e,this.axesNames);return n.axes[r]}return null},this.vibrate=function(e,t=.5,n=.5,r){var i=this.getGamepad(r);i&&i.vibrationActuator?.playEffect?.("dual-rumble",{duration:e,strongMagnitude:n,weakMagnitude:t}).then((()=>{})).catch((e=>console.log(e)))}},Nn=30/Math.PI;function Un(e,t,n={}){if(!(e instanceof Ve))throw new Error("Scene is not of class 'Scene'");if(!(t instanceof ye))throw new Error("physicsEngine is not of class 'PhysicsEngine'");var r=this,i=e.renderer;this.path=n.path??i.path??"./",this.renderer=i,this.physicsEngine=t;var a=new Fn,o=this.keybindings=n.keybindings??new An(i,new Sn,{resetGame:{keyboard:"Escape",controller:"Menu"},resetCar:{keyboard:"KeyR",controller:"Menu"},drive:{keyboard:"KeyW",controller:"RT"},brake:{keyboard:"KeyS",controller:"LT"},ebrake:{keyboard:"Space",controller:"A"},clutch:{keyboard:"KeyC",controller:"Y"},steer:{keyboard:["KeyA","KeyD"],controller:"LSHorizontal"},gearDown:{keyboard:"KeyQ",controller:"X"},gearUp:{keyboard:"KeyE",controller:"B"},cameraMode:{keyboard:"KeyC",controller:"RB"},turnCamera:{keyboard:["ArrowLeft","ArrowRight"],controller:"RSHorizontal"}});this.canMove=!0,this.frozen=!1,this.simulateFriction=!0,this.resetPosition=X.zero(),this.resetRotation=j.identity(),this.bottomOffset=X.zero(),this.mainCamera=new Xe({position:new X(0,0,-3),near:.1,far:1e3,fov:35});var s=()=>{this.mainCamera.setAspect(i.aspect)};i.on("resize",s),s();var l=n.camera??{};this.followCamera=new kn(this),this.followCamera.followDistance=l.followDistance??5,this.followCamera.followHeight=l.followHeight??.4,this.followCamera.followSpeed=l.followSpeed??.05,this.followCamera.pitch=l.pitch??.15,this.followCamera.accelerationSpeed=l.accelerationSpeed??.05,this.followCamera.accelerationEffect=l.accelerationEffect??.3;var c=[this.followCamera,new jn(this),new Vn(this),new Gn(this),new Xn(this)],u=0;this.engine=new function(e={}){this.torque=e.torque??300,this.minRPM=800,this.maxRPM=8e3,this.rpmLimiterDelay=50,this.angularVelocity=this.minRPM/Nn,this.inertia=.15,this.friction=50,this.canThrottle=!0;var t=null,n=1,i=r.path+"cargame/engineSound/i6/",a=1.4,o=[{baseRPM:750,from:-5e3,to:1e3,on:i+"idle.wav",off:i+"idle.wav",interior_on:i+"int_idle.wav",interior_off:i+"int_idle.wav"},{baseRPM:1125,from:1e3,to:2500,on:i+"low_on.wav",off:i+"low_off.wav",interior_on:i+"int_low_on.wav",interior_off:i+"int_low_off.wav"},{baseRPM:1900,from:2500,to:5e3,on:i+"med_on.wav",off:i+"med_off.wav",interior_on:i+"int_med_on.wav",interior_off:i+"int_med_off.wav"},{baseRPM:3500,from:1e3,to:15e3,on:i+"high_on.wav",off:i+"high_off.wav",interior_on:i+"int_high_on.wav",interior_off:i+"int_high_off.wav"}];this.setupAudio=async function(e,t){for(let n of o)n.on&&Bn(e,n.on).then((r=>{let{source:i,gainNode:a}=In(e,r);n.onSource=i,n.onGain=a,a.connect(t),a.gain.value=0})),n.off&&Bn(e,n.off).then((r=>{let{source:i,gainNode:a}=In(e,r);n.offSource=i,n.offGain=a,a.connect(t),a.gain.value=0})),n.interior_on&&Bn(e,n.interior_on).then((r=>{let{source:i,gainNode:a}=In(e,r);n.interiorOnSource=i,n.interiorOnGain=a,a.connect(t),a.gain.value=0})),n.interior_off&&Bn(e,n.interior_off).then((r=>{let{source:i,gainNode:a}=In(e,r);n.interiorOffSource=i,n.interiorOffGain=a,a.connect(t),a.gain.value=0}))},this.update=function(){this.getRPM()>=this.maxRPM&&(this.canThrottle=!1,clearTimeout(t),t=setTimeout((()=>{this.canThrottle=!0}),this.rpmLimiterDelay)),this.handleAudio()},this.fixedUpdate=function(e,t=!1){var r=this.torqueLookup(this.getRPM())*this.torque;if(this.canThrottle){var i=g;this.getRPM()<this.minRPM&&(i=y(y((this.minRPM-this.getRPM())/100,0,.4)+i,0,1)),t&&(i*=.2),this.angularVelocity+=i*r/this.inertia*e,i&&this.getRPM()>this.maxRPM&&(this.angularVelocity=this.maxRPM/Nn+10),n-=.11*(n-i)}else n-=.11*(n-0);this.angularVelocity+=Math.min(Math.abs(this.angularVelocity),this.friction/this.inertia*e)*-Math.sign(this.angularVelocity)},this.handleAudio=function(){var e=y(this.getRPM(),0,this.maxRPM);for(let f of o){var t=e,i=f.from,s=f.to,l=(s-i)/2,c=(i+s)/2,u=Math.max(0,Math.min(1,l/2250-Math.abs((t-c)/2250)+.5)),h=e/(f.baseRPM*a);isFinite(u)&&isFinite(h)&&(r.getCurrentCameraController()instanceof Gn?(f.interiorOnGain&&(f.interiorOnGain.gain.value=.3*u*n,f.interiorOnSource.playbackRate.value=e/(f.baseRPM*a)),f.interiorOffGain&&(f.interiorOffGain.gain.value=.4*u*(1-n),f.interiorOffSource.playbackRate.value=e/(f.baseRPM*a)),f.onGain&&(f.onGain.gain.value=0),f.offGain&&(f.offGain.gain.value=0)):(f.onGain&&(f.onGain.gain.value=.3*u*n,f.onSource.playbackRate.value=e/(f.baseRPM*a)),f.offGain&&(f.offGain.gain.value=.4*u*(1-n),f.offSource.playbackRate.value=e/(f.baseRPM*a)),f.interiorOnGain&&(f.interiorOnGain.gain.value=0),f.interiorOffGain&&(f.interiorOffGain.gain.value=0)))}},this.getRPM=function(){return this.angularVelocity*Nn},this.torqueLookup=function(e){return(309-Math.pow(Math.abs((e-4600)/145),1.4))/309}}({torque:n.torque}),this.clutch=new function(){this.angularVelocity=0,this.inertia=.05,this.impulseCapacity=50},this.frontDiffConnector=new H,this.rearDiffConnector=new H,this.wheels=[],this.wings=n.wings??[],this.drivetrain=n.drivetrain??"RWD";var h,f=!1;this.canDriveWhenChangingGear=n.canDriveWhenChangingGear??!1,this.gearChangeTime=n.gearChangeTime??.35,this.currentGear=1,this.gearRatios=n.gearRatios??[2.66,1.78,1.3,1,.74],this.reverseGearRatio=n.reverseGearRatio??2.9,this.allGearRatios=[this.reverseGearRatio,...this.gearRatios],this.differentialRatio=n.differentialRatio??3.42,this.differentialType=n.differential??Un.ENUMS.DIFFERENTIAL.OPEN,this.LSDFactor=n.LSDFactor??.05,this.activateAutoCountersteer=n.activateAutoCountersteer??!0,this.autoCountersteerMinVel=2,this.autoCountersteer=.6,this.autoCountersteerVelocityMultiplier=.2,this.steerSpeed=.05,this.steerVelocity=n.steerVelocity??50,this.steerGamma=2,this.ackermannSteering=n.ackermannSteering??!0,this.maxSteerAngle=n.maxSteerAngle??35,this.steeringWheelModelMaxRotation=1.5*Math.PI;var d=n.ebrakeTorque??4e3;this.brakeTorque=n.brakeTorque??1500,this.ABS=n.ABS??!0,this.TCS=n.TCS??!1,this.antiRoll=n.antiRoll??7e3;var m=n.rideHeightOffset??0;this.controlScheme=n.controlScheme??Un.ControlScheme.Keyboard;var v=0,g=0,p=1,b=0,w=1,E=1;let _=1,M=0,R=!1;var C=W.identity(),F=W.identity(),A=new X,D=new X,P=new X,S=new W,N=new X,U=new X;let z=new j,L=new X;this.smokeTexture=this.path+"assets/textures/smoke.png",this.skidAudioSource=this.path+"cargame/skid.wav",this.offroadAudioSource=this.path+"assets/sound/gravelRoad.wav",this.bottomOutAudioSource=this.path+"assets/sound/bottomOut.wav";var B=!1,I=()=>{this.audioContext.suspend()},O=()=>{this.audioContext.resume()};(()=>{const e=window.AudioContext||window.webkitAudioContext;this.audioContext=new e,this.mainGainNode=this.audioContext.createGain(),this.mainGainNode.connect(this.audioContext.destination),Bn(this.audioContext,this.skidAudioSource).then((e=>{var{source:t,gainNode:n}=In(this.audioContext,e);this.skidSource=t,this.skidGain=n,this.skidGain.connect(this.mainGainNode),n.gain.value=0})),Bn(this.audioContext,this.offroadAudioSource).then((e=>{var{source:t,gainNode:n}=In(this.audioContext,e);this.offroadSource=t,this.offroadGain=n,this.offroadGain.connect(this.mainGainNode),n.gain.value=0})),Bn(this.audioContext,this.bottomOutAudioSource).then((e=>{this.bottomOutSample=e})),this.engine.setupAudio(this.audioContext,this.mainGainNode),this.horn=new Hn(this.audioContext)})(),window.addEventListener("click",O,{once:!0});var k={},V=!1;this.brakeLightTurnonTime=.1;var G=0;function H(){this.angularVelocity=0,this.inertia=.05}function q(e,n,r,i=1,a=1,o=1/0){var s=[1/i,-1/a],l=[e.angularVelocity,n.angularVelocity],c=[e.inertia,n.inertia],u=0/r*0,h=t.getEffectiveMass(s,c),f=t.getLambda(h,s,l,u);f=y(f,-o,o);for(var d=[],m=0;m<s.length;m++)d[m]=s[m]*f;e.angularVelocity+=d[0]/e.inertia,n.angularVelocity+=d[1]/n.inertia}function Y(e,n,r,i=1,a=1,o=1/0){var s=e.angle/i-n.angle/a,l=[1/i,-1/a],c=[e.angularVelocity,n.angularVelocity],u=[e.inertia,n.inertia],{impulses:h}=t.getConstraintImpulse(l,c,u,s,r,0);e.angularVelocity+=h[0]/e.inertia,n.angularVelocity+=h[1]/n.inertia}function K(e,n,r,i,a,o=0){var s=(n.angularVelocity-r.angularVelocity)*o,l=[.5,.5,-1/a],c=[n.angularVelocity,r.angularVelocity,e.angularVelocity],u=[n.inertia,r.inertia,e.inertia],{impulses:h}=t.getConstraintImpulse(l,c,u,0,i,0);h[0]-=s,h[1]+=s,n.angularVelocity+=h[0]/n.inertia,r.angularVelocity+=h[1]/r.inertia,e.angularVelocity+=h[2]/e.inertia}this.fixedUpdateFunction=e=>{this.fixedUpdate(e)},t.on("fixedUpdate",this.fixedUpdateFunction),this.freeze=function(){this.frozen=!0,this.rb.frozen=!0,I()},this.unfreeze=function(){this.frozen=!1,this.rb.frozen=!1,O()},this.getWheel=function(e){return"rr"==e.toLowerCase()?this.wheels[0]:"rl"==e.toLowerCase()?this.wheels[1]:"fr"==e.toLowerCase()?this.wheels[2]:"fl"==e.toLowerCase()?this.wheels[3]:void 0},this.getCurrentCameraController=function(){return c[u]},this.setup=async function(t){"string"==typeof t?this.gameObject=e.add(await i.loadGLTF(t)):t instanceof Ne&&(this.gameObject=t);var r,a=[(r=this.gameObject).getChild(/(wheel_*rr)|(rr_*wheel)|(^rr$)/gim,!0)||r.getChild("RearRightWheel",!0),r.getChild(/(wheel_*rl)|(rl_*wheel)|(^rl$)/gim,!0)||r.getChild("RearLeftWheel",!0),r.getChild(/(wheel_*fr)|(fr_*wheel)|(^fr$)/gim,!0)||r.getChild("FrontRightWheel",!0),r.getChild(/(wheel_*fl)|(fl_*wheel)|(^fl$)/gim,!0)||r.getChild("FrontLeftWheel",!0)];if(4!=a.length||a.some((e=>null==e)))throw console.log(a),new Error("Vehicle does not have 4 wheels");var o=be(this.gameObject,0,a),s=o.getCenter(),l=X.subtract(o.getSize(),X.fill(.2));for(var f of this.gameObject.children)if(!a.includes(f)){var d=f.transform;d.position=X.subtract(d.position,s)}this.rb=new Re,this.rb.position=X.copy(this.resetPosition),this.rb.mass=n.mass??1500,X.addTo(this.rb.COMOffset,n.COMOffset??X.zero()),this.rb.inertia=new X(this.rb.mass/12*(l.y**2+l.z**2),this.rb.mass/12*(l.x**2+l.z**2),this.rb.mass/12*(l.y**2+l.x**2)),this.gameObject.addComponent(this.rb),this.gameObject.addComponent(new Ee(new xe(X.divide(l,-2),X.divide(l,2)),-1e3));for(var v=0;v<a.length;v++){var g=a[v],p=be(g),x=p.getCenter();(x=X.subtract(x,s)).y+=m;var b=Math.max(...X.toArray(p.getSize()))/2,y=g.addComponent(new i.TrailRenderer);y.width=.5*Math.min(...X.toArray(p.getSize()));var T=this.gameObject.addChild(new Ne(g.name+"-Parent"));T.transform.position=x;var w=T.addChild(new Ne("WheelModel"));g.setParent(w),g.transform.position=X.subtract(g.transform.position,p.getCenter()),this.wheels[v]=new zn(this,x,T,{...n,radius:b}),this.wheels[v].wheelModel=w,this.wheels[v].skidmarks=y,this.bottomOffset.y=x.y-b-this.wheels[v].suspensionTravel-this.gameObject.transform.position.y}this.track=X.distance(this.wheels[0].position,this.wheels[1].position),this.wheelBase=X.distance(this.wheels[0].position,this.wheels[2].position),this.wheels[0].turn=!1,this.wheels[1].turn=!1,this.wheels[2].drive=!1,this.wheels[3].drive=!1,this.wheels[2].ebrake=!1,this.wheels[3].ebrake=!1,this.wheels[1].side=-1,this.wheels[3].side=-1;let E=n.rearCamber??0;this.wheels[0].camberAngle=E*-this.wheels[0].side,this.wheels[1].camberAngle=E*-this.wheels[1].side;let _=n.frontCamber??0;this.wheels[2].camberAngle=_*-this.wheels[2].side,this.wheels[3].camberAngle=_*-this.wheels[3].side,this.rollbars=[{a:this.wheels[0],b:this.wheels[1]},{a:this.wheels[2],b:this.wheels[3]}],k.mainFront=Mn("LampWhite",this.gameObject,!0)[0],k.mainRear=Mn("LampRedLight",this.gameObject,!0)[0],k.brake=Mn("LampRed",this.gameObject,!0)[0],k.turnSignal=Mn("LampOrange",this.gameObject,!0)[0],k.reverseRear=Mn("Reverse",this.gameObject,!0)[0],this.setLightEmission("mainRear",[1,0,0]);var M=!1;setInterval((()=>{M=!M,this.setLightEmission("turnSignal",M?[50,5,0]:[0,0,0])}),400),this.lamps={brightsLeft:this.gameObject.getChild("BrightsLeft",!0)?.children[0]?.getComponent("Light"),brightsRight:this.gameObject.getChild("BrightsRight",!0)?.children[0]?.getComponent("Light")},this.lamps.brightsLeft&&(this.lamps.brightsLeft.color=[0,0,0]),this.lamps.brightsRight&&(this.lamps.brightsRight.color=[0,0,0]);var R=new Ne("Smoke");this.gameObject.addChild(R);var C=R.addComponent(new i.ParticleSystem(300));C.material=i.CreateLitMaterial({albedoTexture:i.loadTexture(this.smokeTexture),albedo:[2,2,2,1]},i.programContainers.particle),C.material.doubleSided=!0,C.emitPosition=e=>{e.x=0,e.y=2,e.z=0},C.emitVelocity=e=>{e.x=Math.random()-.5,e.y=Math.random()-.5+.5,e.z=-2},C.startSize=e=>{X.fill(.4*Math.random()+.2,e)},C.endSize=e=>X.fill(3,e),C.emitHealth=2.5,C.gravityScale=0,C.drag=.1,C.orientation="faceCamera",C.localParticles=!1,this.smoke=C,this.steeringWheelModel=this.gameObject.getChild("SteeringWheel",!0),this.steeringWheelModel&&(h=W.copy(this.steeringWheelModel.transform.matrix));var F=new Ne("InteriorCamera");F.transform.position=new X(-.3,.35,-.5),F.transform.rotation=j.euler(0,Math.PI,0),this.gameObject.addChild(F);var A=new Ne("HoodCamera");A.transform.position=new X(0,.5,.8),A.transform.rotation=j.euler(0,Math.PI,0),this.gameObject.addChild(A),c[u].onReset()},this.destroy=function(){this.audioContext.close(),window.removeEventListener("click",O),t.eventHandler.removeEvent("fixedUpdate",this.fixedUpdateFunction),this.gameObject.delete()},this.reset=function(){for(var e of(this.rb.position.y+=2,this.rb.rotation=j.euler(0,0*Math.PI/2,0),this.gameObject.transform.position=this.rb.position,this.gameObject.transform.rotation=this.rb.rotation,this.rb.velocity=X.zero(),this.rb.angularVelocity=X.zero(),this.rb.rotation=j.identity(),this.rb.inverseWorldInertia=W.identity(),this.rb._worldCOMOffset=X.zero(),this.rb.torque=X.zero(),this.currentGear=1,this.engine.angularVelocity=0,this.clutch.angularVelocity=0,this.wheels))e.angle=0,e.angularVelocity=0,e.normalForce=0,e.isGrounded=!1;v=0,this.mainCamera.transform.matrix=W.identity(),c[u].onReset()},this.resetGame=function(){this.reset(),this.rb.position=X.copy(this.resetPosition),this.rb.rotation=j.copy(this.resetRotation),this.gameObject.transform.position=this.rb.position,this.gameObject.transform.rotation=this.rb.rotation,c[u].onReset(this.mainCamera)},this.renderUI=function(e){var t=this.engine.getRPM(),n={x:e.width-140,y:e.height-120};!function(e,t,n,r,i,a,o=100){t=y(t,n-100,r+100);var s=2.1*Math.PI;e.beginPath(),e.arc(i,a,o-.125*o/2,.75*Math.PI,s),e.lineWidth(.125*o),e.strokeStyle("rgba(0, 0, 0, 0.25)"),e.stroke(),e.beginPath(),e.arc(i,a,o-.125*o/2,s,2.25*Math.PI),e.lineWidth(.125*o),e.strokeStyle("rgba(255, 0, 0, 0.25)"),e.stroke(),e.beginPath(),e.arc(i,a,o-.125*o/2,.75*Math.PI,e.mapValue(t,n,r,.75*Math.PI,2.25*Math.PI)),e.lineWidth(.125*o),e.strokeStyle("white"),e.stroke()}(e,t,0,this.engine.maxRPM,n.x,n.y,100),e.setTextXAlign("center"),e.setTextYAlign("middle"),e.text(Math.floor(t),n.x,n.y-60,20,"white"),e.roundedRectangle(n.x-25,n.y-10-30,50,55,"rgba(0, 0, 0, 0.25)",10);var r=.9*this.engine.maxRPM;e.text(f?"N":0==this.currentGear?"R":this.currentGear,n.x,n.y-10,50,t>r?"red":"white"),e.text(Math.abs(Math.floor(3.6*this.forwardVelocity)),n.x,n.y+40,35,"white"),e.text("km/h",n.x,n.y+65,15,"white"),this.ABS&&e.text("ABS",n.x-50,n.y-22,15,"red"),this.TCS&&e.text("TCS",n.x-50,n.y+2,15,"blue"),e.resetTextXAlign(),e.resetTextYAlign();var i=15;e.rectangle(50,n.y-30,i,100,"rgba(0, 0, 0, 0.5)"),e.rectangle(50,n.y-30+100*(1-g),i,100*g,"white"),e.rectangle(75,n.y-30,i,100,"rgba(0, 0, 0, 0.5)"),e.rectangle(75,n.y-30+100*(1-p),i,100*p,"red"),e.rectangle(100,n.y-30,i,100,"rgba(0, 0, 0, 0.5)"),e.rectangle(100,n.y-30+100*(1-b),i,100*b,"orange"),e.rectangle(125,n.y-30,i,100,"rgba(0, 0, 0, 0.5)"),e.rectangle(125,n.y-30+100*(1-w),i,100*w,"lime")},this.update=function(e){if(!this.frozen){if(this.horn&&(o.getInputDown("horn")&&this.horn.start(),o.getInputUp("horn")&&this.horn.stop()),o.getInputDown("brights")&&(V=!V,this.lamps.brightsLeft&&(this.lamps.brightsLeft.color=V?[3e3,3e3,3e3]:[200,200,200]),this.lamps.brightsRight&&(this.lamps.brightsRight.color=V?[3e3,3e3,3e3]:[200,200,200]),this.setLightEmission("mainFront",V?[200,200,200]:[1,1,1])),o.getInputDown("cameraMode")&&(c[u].onDeactivate(this.mainCamera),u++,u%=c.length,c[u].onActivate(this.mainCamera)),o.getInputDown("resetGame")&&this.resetGame(),this.canMove){var t=X.negate(W.getForward(C)),n=X.dot(this.rb.velocity,t);if(this.controlScheme==Un.ControlScheme.Controller){let e=o.getInputAndInputMethod("drive"),t=y(e.value,0,1);if("keyboard"==e.method?g+=.1*(t-g):"controller"==e.method&&(g=t),X.lengthSqr(this.rb.velocity)<.1&&p>.1&&g<.01)p=1;else{let e=o.getInputAndInputMethod("brake"),t=Math.pow(e.value,3);"keyboard"==e.method?p+=.1*(t-p):"controller"==e.method&&(p=t)}}else if(this.controlScheme==Un.ControlScheme.Keyboard){var r=y(o.getInput("drive"),0,1)-o.getInput("brake"),i=y(Math.abs(r),0,1);g=i,p=0,(n>1&&r<-.1||n<-1&&r>.1)&&(p=1,g=0),r>.1&&n>-1.1&&0==this.currentGear&&(this.currentGear=1),r<-.1&&n<1.1&&(this.currentGear=0)}b+=.2*(o.getInput("ebrake")-b);var a=(e=1)=>{this.currentGear+=e,this.currentGear=y(this.currentGear,0,this.allGearRatios.length-1)};f||(o.getInputDown("gearDown")&&this.currentGear>0&&(f=!0,setTimeout((()=>{a(-1),f=!1}),1e3*this.gearChangeTime)),o.getInputDown("gearUp")&&this.currentGear<this.allGearRatios.length-1&&(f=!0,setTimeout((()=>{a(1),f=!1}),1e3*this.gearChangeTime))),f&&!this.canDriveWhenChangingGear&&o.getInput("clutch")<.05&&(g=0),o.getInputDown("resetCar")&&this.reset()}else g=0,p=0,b=1,w=1;G=y(G+=Math.sign((p>1e-6?1:0)-G)/this.brakeLightTurnonTime*e,0,1),this.setLightEmission("reverseRear",0==this.currentGear?[50,50,50]:[0,0,0]),this.setLightEmission("brake",[50*Math.pow(G,5),0,0]),this.engine.update()}},this.fixedUpdate=function(e){if(this.frozen)return;this.cameraControls(e),W.copy(this.gameObject.transform.worldMatrix,C),W.inverse(C,F),W.removeTranslation(F),W.transformVector(F,this.rb.angularVelocity,A),W.getForward(C,D),X.negate(D,D),W.getRight(C,P);var n=X.dot(this.rb.velocity,D);this.forwardVelocity=n;var r=X.dot(this.rb.velocity,P),i=-Math.atan2(r,Math.abs(n));!isNaN(i)&&isFinite(i)||(i=0);var s=-Dn(this.canMove?o.getInput("steer"):0,.1);s=y(s=Math.pow(Math.abs(s),this.steerGamma)*Math.sign(s),-1,1),s*=Math.exp(-Math.abs(n)/this.steerVelocity),v+=(s-v)*this.steerSpeed;var l=this.activateAutoCountersteer&&(Math.abs(r)>.5||n>this.autoCountersteerMinVel)?-i/(this.maxSteerAngle/180*Math.PI)*this.autoCountersteer-A.y*this.autoCountersteerVelocityMultiplier*Math.sign(n):0,c=y(v+l,-1,1);this.steeringWheelModel&&(W.copy(h,S),W.transform([["rz",-c*this.steeringWheelModelMaxRotation]],S),this.steeringWheelModel.transform.matrix=S);for(let n=0;n<this.wheels.length;n++){let r=this.wheels[n],i=r.turn?c*this.maxSteerAngle*Math.PI/180:0;this.ackermannSteering&&(2==n&&c>0||3==n&&c<0)&&(i=Math.sign(c)*Math.atan(this.wheelBase/(this.track+this.wheelBase/Math.tan(Math.abs(i))))),W.identity(S),W.transform([["translate",r.position],["ry",i]],S),r.model.transform.matrix=S;let o=r.model.transform.worldMatrix;W.getUp(o,r.up);let s=r.up;X.negate(s,U),W.transformVector(C,r.position,r.worldPos);let l=r.worldPos;this.rb.GetPointVelocity(l,N),X.multiplyTo(N,e);let u={origin:l,direction:U},h=t.Raycast(u.origin,u.direction)?.firstHit;if(h&&h.gameObject?.customData.bumpiness){let e=h.gameObject?.customData.bumpinessNoiseScale??3;if(isNaN(e))throw console.error(e),new Error("Bumpiness noise scale is NaN");let t=h.gameObject?.customData.bumpiness;if(isNaN(t))throw console.error(t),new Error("Bumpiness value is NaN");h.distance-=.5*(a.noise(h.point.x*e,h.point.z*e)+1)*t}if(r.isGrounded=h&&h.distance<r.suspensionTravel+r.radius,r.wheelModel){let e=r.wheelModel.transform;e.position.x=r.camberAngle/100,e.position.y=-(r.isGrounded?h.distance-r.radius:r.suspensionTravel),e.position.z=0,e.rotation=j.euler(r.angle,0,r.camberAngle*Math.PI/180)}if(r.staticWheelModel){let e=r.staticWheelModel.transform;e.position.x=r.camberAngle/100,e.position.y=-(r.isGrounded?h.distance-r.radius:r.suspensionTravel),e.position.z=0,e.rotation=j.euler(0,1==r.side?Math.PI:0,r.camberAngle*Math.PI/180)}r.skidmarks&&(r.isGrounded?(r.skidmarks.emitPosition=X.add(X.add(h.point,new X(0,.01,0)),N),r.skidmarks.emitNormal=h.normal):r.skidmarks.emitPosition=X.add(X.add(l,X.multiply(s,-r.radius)),N)),r.ray=u,r.worldPos=l,r.isGrounded&&(r.groundHit=h,r.contactPoint=h.point)}_=1,M=0,R=!1;var u=this.engine.getRPM();let d=o.getInput("clutch");var m=new Array(this.wheels.length).fill(0),g=e/20;for(let t=0;t<20;t++){var p=(this.engine.getRPM()-u)*g;E=y(E=Math.max(b,d,w-.002*(this.engine.getRPM()-(this.engine.minRPM+800))-20*p),0,1),w+=.3*(E-w),f&&(w=1,E=1),u=this.engine.getRPM(),this.engine.fixedUpdate(g,R),R=!1,q(this.engine,this.clutch,g,1,1,Math.pow(1-w,4)*this.clutch.impulseCapacity);let t=(0==this.currentGear?-1:1)*this.allGearRatios[this.currentGear]*this.differentialRatio;if(this.differentialType==Un.ENUMS.DIFFERENTIAL.OPEN||this.differentialType==Un.ENUMS.DIFFERENTIAL.LSD){let e=this.differentialType==Un.ENUMS.DIFFERENTIAL.LSD?this.LSDFactor:0;"RWD"==this.drivetrain?K(this.clutch,this.wheels[0],this.wheels[1],g,t,e):"FWD"==this.drivetrain?K(this.clutch,this.wheels[2],this.wheels[3],g,t,e):"AWD"==this.drivetrain&&(K(this.rearDiffConnector,this.wheels[0],this.wheels[1],g,t,e),K(this.frontDiffConnector,this.wheels[2],this.wheels[3],g,t,e),K(this.clutch,this.rearDiffConnector,this.frontDiffConnector,g,1))}else this.differentialType==Un.ENUMS.DIFFERENTIAL.LOCKED&&("RWD"!=this.drivetrain&&"AWD"!=this.drivetrain||(Y(this.clutch,this.wheels[0],g,1,1/t),Y(this.clutch,this.wheels[1],g,1,1/t)),"FWD"!=this.drivetrain&&"AWD"!=this.drivetrain||(Y(this.clutch,this.wheels[2],g,1,1/t),Y(this.clutch,this.wheels[3],g,1,1/t)));for(var x of this.wheels)x.normalForce=0;$(e,m),Q(g),J(g),this.simulateFriction&&Z(g,r)}for(let t of this.wheels)if(t.angle+=t.angularVelocity*e,t.isGrounded&&!t.groundHit.gameObject?.customData.offroad){let e=t.model.transform.worldMatrix,n=X.negate(W.getForward(e)),r=X.dot(this.rb.velocity,n),i=t.angularVelocity*t.radius-r;if(i*=t.roadFriction*t.forwardFriction*t.friction,Math.abs(i)>5){let n=W.getUp(e),r=W.transformVector(C,t.position);X.addTo(r,X.multiply(n,-t.radius)),this.smoke.emitPosition=e=>X.set(e,r);let a=W.getRight(e),o=j.QxV(j.angleAxis(-Math.PI/2,a),t.groundHit.normal),s=W.basis(a,X.cross(a,o),o);this.smoke.emitVelocity=e=>{new X(Math.random()-.5,.5*Math.random(),3.5,e),W.transformVector(s,e,e)},this.smoke.alpha=.1*y((Math.abs(i)-5)/10,0,1),this.smoke.emit()}}for(let e of this.wings)e.applyForce(this.rb,n);if(this.rb.angularVelocity.x*=.995,this.rb.angularVelocity.y*=.995,this.rb.angularVelocity.z*=.995,this.skidSource&&this.skidGain&&(this.skidGain.gain.value+=.1*(.5*M-this.skidGain.gain.value),this.skidSource.playbackRate.value=_),this.offroadSource&&this.offroadGain)if(this.wheels.some((e=>e.isGrounded&&e.groundHit.gameObject?.customData.offroad))){let e=y(X.length(this.rb.velocity)/3,0,.7);isFinite(e)&&(this.offroadGain.gain.value=e);let t=y(.8+X.length(this.rb.velocity)/15,1,1.4);isFinite(t)&&(this.offroadSource.playbackRate.value=t)}else this.offroadGain.gain.value=0;let T=Math.max(...this.wheels.map((e=>e.bottomOutStrength)));if(T>0&&this.bottomOutSample&&!B){let{source:e,gainNode:t}=In(this.audioContext,this.bottomOutSample);e.loop=!1,e.playbackRate.value=.9+.2*Math.random(),t.gain.value=y(T/3e3,0,1.5),t.connect(this.mainGainNode),B=!0,setTimeout((()=>{B=!1}),100)}},this.setLightEmission=function(e,t=[0,0,0]){var n=k[e];n&&(Array.isArray(t)||(t=[t,t,t]),n.setUniform("emissiveFactor",t))},this.cameraControls=function(e){c[u].update(this.mainCamera,e)};{let e=new X,t=new X;var $=(n,r)=>{let i=0;for(let a of this.wheels){a.bottomOutStrength=0;let o=a.ray,s=a.groundHit;if(a.isGrounded&&s&&s.distance<a.suspensionTravel+a.radius){X.multiply(o.direction,a.radius+a.stopLength,L),X.add(o.origin,L,t),X.subtract(s.point,t,L);let l=-X.dot(L,s.normal);if(l<0){a.isGrounded=!0,X.subtract(t,this.rb.position,L),X.cross(L,s.normal,e);let o=[s.normal.x,s.normal.y,s.normal.z,e.x,e.y,e.z],c=this.rb.inverseWorldInertia,u=.15/n*l,h=Kn([o[0]/this.rb.mass,o[1]/this.rb.mass,o[2]/this.rb.mass,o[3]*c[0],o[4]*c[5],o[5]*c[10]],o),f=-(Kn(o,[this.rb.velocity.x,this.rb.velocity.y,this.rb.velocity.z,this.rb.angularVelocity.x,this.rb.angularVelocity.y,this.rb.angularVelocity.z])+u)/h;r[i]+f<0&&(f=-r[i]),r[i]+=f,X.addTo(this.rb.velocity,X.multiply(new X(o[0],o[1],o[2]),f/this.rb.mass)),X.addTo(this.rb.angularVelocity,W.transformVector(this.rb.inverseWorldInertia,X.multiply(new X(o[3],o[4],o[5]),f))),a.normalForce=Math.abs(r[i]/n),a.bottomOutStrength=Math.max(a.bottomOutStrength,Math.abs(r[i]))}}i++}}}{let e=new X,t=new X,n=new X,r=new X;var Q=i=>{for(let a of this.wheels){let o=a.ray,s=a.groundHit,l=a.worldPos,c=a.up;if(this.rb.GetPointVelocity(l,e),a.isGrounded){let u=s.distance,h=a.suspensionTravel-(u-a.radius);X.multiply(o.direction,h*-a.suspensionForce,t),X.projectOnPlane(this.rb.velocity,s.normal,L),X.subtract(e,L,L),X.project(L,c,L),X.multiply(L,-a.suspensionDamping,n),X.add(t,n,r),X.multiply(r,i,L),this.rb.AddImpulseAtPosition(L,l),a.normalForce+=X.length(r),a.compressionAmount=y(h/a.suspensionTravel,0,1)}}}}var J=e=>{for(let t of this.rollbars){let n=((t.a.compressionAmount??0)-(t.b.compressionAmount??0))*this.antiRoll;t.a.isGrounded&&(X.multiply(t.a.up,(t.b.isGrounded?1:2)*n*e,L),this.rb.AddImpulseAtPosition(L,t.a.worldPos)),t.b.isGrounded&&(X.multiply(t.b.up,(t.a.isGrounded?1:2)*-n*e,L),this.rb.AddImpulseAtPosition(L,t.b.worldPos))}};{let e=new X,t=new X,n=new X,r=new X,i=new X,a=new X;var Z=(o,s)=>{for(let F of this.wheels){let A=0,D=0,P=F.model.transform.worldMatrix;if(W.getForward(P,e),W.getRight(P,t),W.transformVector(C,F.position,n),this.rb.GetPointVelocity(n,r),b>.1&&F.ebrake&&(F.angularVelocity+=-Math.sign(F.angularVelocity)*Math.min(b*d,Math.abs(F.angularVelocity)/o)*o),F.isGrounded){D=X.dot(r,e);let n=X.dot(r,t);if(0!=p)if(this.ABS){let e=F.lastA??0,t=F.slipRatioPeak*Math.sqrt(Math.max(.01,1-e*e))*Math.sign(D),n=T(-D/F.radius,(t*Math.abs(D)-D)/F.radius,p);F.angularVelocity=Math.abs(D)<1?0:n}else F.angularVelocity+=-Math.sign(F.angularVelocity)*Math.min(p*this.brakeTorque/F.inertia,Math.abs(F.angularVelocity)/o)*o;const s=F.groundHit.gameObject?.customData?.offroad,d=s?F.offroadFriction:F.friction;let x=F.groundHit.gameObject?.customData?.friction??1;F.roadFriction=x,A=-Math.atan(n/Math.abs(D)),!isNaN(A)&&isFinite(A)||(A=0);let b=A/F.slipAnglePeak;F.lastA=b;var l=-(F.angularVelocity*F.radius+D)/Math.abs(D)*Math.min(Math.abs(D)/2,1);isNaN(l)&&(l=0),isFinite(l)||(l=Math.sign(l));var c=l/F.slipRatioPeak;this.TCS&&Math.abs(F.angularVelocity*F.radius+D)>1&&(R=!0);var u=Math.sqrt(c*c+b*b),h=c/u*(Yn(u*F.slipRatioPeak,F.slipRatioCoeffs)*x*d*F.forwardFriction)*F.normalForce,f=b/u*(qn(u*F.slipAnglePeak*180/Math.PI,F.normalForce,F.camberAngle,F.advancedSlipAngleCoeffs)*x*d*F.sidewaysFriction);if(!isNaN(h)){var m=F.angularVelocity*F.radius+D,v=Math.abs(m/(F.radius*F.radius)*F.inertia/o),g=Math.abs(h),w=Math.min(g,v)*-Math.sign(h);F.angularVelocity-=w*F.radius/F.inertia*o}X.projectOnPlane(t,F.groundHit.normal,i),j.angleAxis(-Math.PI/2,i,z),j.QxV(z,F.groundHit.normal,a),isNaN(h)||(X.multiply(a,h*o,L),this.rb.AddImpulseAtPosition(L,F.contactPoint)),isNaN(f)||(X.multiply(i,f*o,L),this.rb.AddImpulseAtPosition(L,F.contactPoint))}else 0==p||this.ABS||(F.angularVelocity+=-Math.sign(F.angularVelocity)*Math.min(p*this.brakeTorque,Math.abs(F.angularVelocity)/o)*o);var E=.8+y(.7*(Math.abs(l)-.2),0,.8);E>_&&(_=E);let S=0;F.isGrounded&&!F.groundHit.gameObject?.customData.offroad&&(S=x(u,1,1.1),S*=x((F.angularVelocity*F.radius+D)**2+s**2,0,2),S>M&&(M=S)),F.skidmarks&&(F.skidmarks.emit=y(y(20*S*(F.isGrounded?1:0),0,.7)*(F.isGrounded?y(F.normalForce/5e3,0,1)*F.friction*F.forwardFriction*F.roadFriction:0),0,1)),F.slipRatio=l}}}}function zn(e,t=X.zero(),n,r={}){this.position=t,this.model=n,this.side=1,this.offroadFriction=r.offroadFriction??.5,this.friction=r.friction??1,this.forwardFriction=r.forwardFriction??1,this.sidewaysFriction=r.sidewaysFriction??1,this.radius=r.radius??.35,this.camberAngle=0,this.camberAngleCoeff=r.camberAngleCoeff??1,this.stopLength=r.stopLength??.01,this.suspensionTravel=r.suspensionTravel??.15,this.suspensionDamping=r.suspensionDamping??2500,this.suspensionForce=r.suspensionForce??5e4,this.angle=0,this.angularVelocity=0,this.mass=r.wheelMass??20,this.inertia=this.mass*this.radius*this.radius/2,this.slipRatioCoeffs=r.slipRatioCoeffs??[16,1.5,1.1,-1.4],this.slipAngleCoeffs=r.slipAngleCoeffs??[.2,1.5,1.1,-1.4],this.advancedSlipAngleCoeffs=[1.799,0,1688,1e3,6.026,0,-.3589,1,.8,-.006111,-3.224/100,0,0,0,0],this.slipRatioPeak=Wn((e=>Yn(e,this.slipRatioCoeffs))),this.slipAnglePeak=Wn((t=>qn(180*t/Math.PI,9.82*e.rb.mass/4,this.camberAngle,this.advancedSlipAngleCoeffs))),this.drive=!0,this.turn=!0,this.ebrake=!0,this.isGrounded=!1,this.normalForce=0,this.up=new X,this.worldPos=new X}function Ln(e,t=.1){this.position=e,this.liftCoeff=t,this.applyForce=function(e,t){var n=X.multiply(X.down(),this.liftCoeff*t*t),r=W.transformVector(e.gameObject.transform.worldMatrix,this.position);e.AddForceAtPosition(n,r)}}function Bn(e,t){return fetch(t).then((e=>e.arrayBuffer())).then((t=>e.decodeAudioData(t)))}function In(e,t){var n=e.createGain();const r=e.createBufferSource();return r.buffer=t,r.loop=!0,r.connect(n),r.start(0),{source:r,gainNode:n}}Un.ENUMS={DIFFERENTIAL:{OPEN:0,LOCKED:1,LSD:2}},Un.ControlScheme={Keyboard:0,Controller:1};class On{update(){}onActivate(){}onDeactivate(){}onReset(){}}class kn extends On{#r=new X;#o=0;#s=0;#l=0;#c=5;#u=X.zero();#h=0;#f=X.zero();#d=X.zero();CAMERA_FOLLOW_MODES={FOLLOW_VELOCITY:1,FOLLOW_DIRECTION:2,FOLLOW_INVERSE_DIRECTION:3};followMode=this.CAMERA_FOLLOW_MODES.FOLLOW_VELOCITY;followDistance=5;followHeight=.4;followSpeed=.05;pitch=.15;accelerationSpeed=.05;accelerationEffect=.3;constructor(e){super(),this.car=e}resetForward(){this.#u=W.getForward(this.car.gameObject.transform.worldMatrix),this.#s=0,this.#o=this.car.rb.position.y+.15+this.followHeight/Math.sqrt(1+this.followHeight**2)*this.followDistance}onReset(){this.resetForward()}onActivate(){this.resetForward()}update(e,t){var n=this.car.gameObject.transform.worldMatrix,r=W.getUp(n),i=X.negate(W.getForward(n)),a=(X.dot(this.car.rb.acceleration,r),X.dot(this.car.rb.acceleration,i));isNaN(a)||(this.#c-=(this.#c-this.followDistance*(1+a/t*this.accelerationEffect))*this.accelerationSpeed);var o=this.#c,s=this.followHeight,l=this.followSpeed,c=this.pitch,u=Dn(this.car.keybindings.getInput("turnCamera")||0,.09)*Math.PI/2*2;this.#l+=.27*(u-this.#l);var h,f=X.projectOnPlane(this.car.rb.velocity,X.up());this.followMode==this.CAMERA_FOLLOW_MODES.FOLLOW_VELOCITY?h=X.length(f)>1?X.negate(X.normalize(f)):X.negate(i):this.followMode==this.CAMERA_FOLLOW_MODES.FOLLOW_DIRECTION?h=X.negate(i):this.followMode==this.CAMERA_FOLLOW_MODES.FOLLOW_INVERSE_DIRECTION&&(h=X.slerp(this.car.gameObject.transform.forward,X.normalize(X.projectOnPlane(X.negate(this.car.rb.velocity),this.car.gameObject.transform.up)),-.5)),this.#u=X.slerp(this.#u,h,l);var d=X.copy(this.#u);d=j.QxV(j.angleAxis(this.#l,this.car.gameObject.transform.up),d);var m=null,v=X.add(this.car.rb.position,new X(0,.15,0));X.set(this.#r,this.car.rb.velocity),X.multiplyTo(this.#r,t),X.addTo(v,this.#r);var g=X.normalize(X.add(d,new X(0,s,0))),p=this.car.physicsEngine.Raycast(v,g);if(p&&p.firstHit&&p.firstHit.distance<o){var x=p.firstHit.distance,b=Math.sqrt(o*o-x*x+(s*x)**2)/x,T=X.normalize(X.add(d,new X(0,b,0)));m=(p=this.car.physicsEngine.Raycast(v,T))&&p.firstHit&&p.firstHit.distance<o?X.multiply(T,p.firstHit.distance-.5):X.multiply(T,o)}else m=X.multiply(g,o);var w=70*(v.y+m.y-this.#o);this.#s+=w*t,this.#s+=7*-this.#s*t,this.#s+=-9.82*t,this.#o+=this.#s*t,e.transform.position=X.add(v,m),e.transform.position.y=this.#o,e.transform.matrix=W.lookAt(e.transform.position,v),W.rotateX(e.transform.matrix,c,e.transform.matrix);var E=Math.abs(X.dot(this.car.rb.velocity,i));if(this.#h%3==0){var _=.02*y(.02*(E-100/3.6),0,1);this.#f=new X(2*(Math.random()-.5)*_,2*(Math.random()-.5)*_,0)}this.#d=X.lerp(this.#d,this.#f,.15),W.rotateX(e.transform.matrix,this.#d.x,e.transform.matrix),W.rotateY(e.transform.matrix,this.#d.y,e.transform.matrix),this.#h++,e.updateFrustum()}}class Vn extends On{#m=new X;constructor(e){super(),this.car=e}onActivate(e){e.setFOV(30)}update(e,t){var n=this.car.gameObject.getChild("HoodCamera",!0);n&&(e.transform.matrix=n.transform.worldMatrix,X.set(this.#m,this.car.rb.velocity),X.multiplyTo(this.#m,t),X.addTo(e.transform.position,this.#m))}}class Gn extends On{#u=X.zero();#v=45;velocityBias=.3;followSpeed=.15;constructor(e){super(),this.car=e}resetForward(){this.#u=W.getForward(this.car.gameObject.transform.worldMatrix)}onReset(){this.resetForward()}onActivate(){this.#v=this.car.mainCamera.getFOV(),this.car.mainCamera.setFOV(25),this.resetForward()}onDeactivate(){this.car.mainCamera.setFOV(this.#v)}update(e,t){var n=this.car.gameObject.getChild("InteriorCamera",!0);if(n){var r=-X.dot(this.car.gameObject.transform.forward,this.car.rb.velocity),i=0===this.car.currentGear?X.negate(this.car.gameObject.transform.forward):r<.2?this.car.gameObject.transform.forward:X.slerp(this.car.gameObject.transform.forward,X.normalize(X.projectOnPlane(X.negate(this.car.rb.velocity),this.car.gameObject.transform.up)),this.velocityBias);this.#u=X.slerp(this.#u,i,this.followSpeed),e.transform.matrix=W.lookInDirection(X.add(n.transform.worldPosition,X.multiply(this.car.rb.velocity,t)),this.#u,this.car.gameObject.transform.up)}}}class Xn extends On{#g=X.zero();#p=45;constructor(e){super(),this.car=e,this.#p=this.car.mainCamera.getFOV()}onReset(){}onActivate(){this.car.rb.frozen=!0}onDeactivate(){this.car.mainCamera.setFOV(this.#p),this.car.rb.frozen=!1}update(e,t){var n=e.getFOV(),r=Pn(Dn(this.car.keybindings.gamepadManager.getAxis("RSHorizontal"),.08)),i=Pn(Dn(this.car.keybindings.gamepadManager.getAxis("RSVertical"),.08));this.#g.x-=.07*i*y(n/45,0,1),this.#g.y-=.07*r*y(n/45,0,1);var a=Pn(Dn(this.car.keybindings.gamepadManager.getAxis("LSVertical"))),o=Pn(Dn(this.car.keybindings.gamepadManager.getAxis("LSHorizontal"))),s=Math.cos(this.#g.x);e.transform.position.x-=a*Math.cos(this.#g.y+Math.PI/2)*15*t*s,e.transform.position.z-=a*-Math.sin(this.#g.y+Math.PI/2)*15*t*s,e.transform.position.y-=a*Math.sin(this.#g.x)*15*t,e.transform.position.x+=o*Math.cos(this.#g.y)*15*t,e.transform.position.z+=o*-Math.sin(this.#g.y)*15*t,function(e,t,n,r=1){var i=15;if(e.getKey([87])){let e=Math.cos(n.x);t.transform.position.x+=Math.cos(n.y+Math.PI/2)*i*r*e,t.transform.position.z+=-Math.sin(n.y+Math.PI/2)*i*r*e,t.transform.position.y+=Math.sin(n.x)*i*r}if(e.getKey([83])){let e=Math.cos(n.x);t.transform.position.x-=Math.cos(n.y+Math.PI/2)*i*r*e,t.transform.position.z-=-Math.sin(n.y+Math.PI/2)*i*r*e,t.transform.position.y-=Math.sin(n.x)*i*r}e.getKey([65])&&(t.transform.position.x-=Math.cos(n.y)*i*r,t.transform.position.z-=-Math.sin(n.y)*i*r),e.getKey([68])&&(t.transform.position.x+=Math.cos(n.y)*i*r,t.transform.position.z+=-Math.sin(n.y)*i*r),e.getKey([37])&&(n.y+=3*r),e.getKey([39])&&(n.y-=3*r),e.getKey([38])&&(n.x+=3*r),e.getKey([40])&&(n.x-=3*r)}(this.car.renderer,e,this.#g,t);var l=n*(1+.03*(this.car.keybindings.gamepadManager.getButton("LS")-this.car.keybindings.gamepadManager.getButton("RS")));l=y(l,.1,89),e.setFOV(l),e.transform.rotation=j.eulerVector(this.#g)}}class jn extends On{#x=new X;constructor(e){super(),this.car=e}onActivate(e){X.set(this.#x,e.transform.worldPosition)}update(e,t){let n=X.distance(this.#x,this.car.rb.position),r=100/Math.max(0,n-5)**.7;r=y(r,6,35),e.setFOV(r),e.transform.matrix=W.lookAt(this.#x,this.car.rb.position)}}function Hn(e){let t=t=>{let n=e.createOscillator();return n.type="square",n.frequency.value=t,n.connect(e.destination),n},n=null,r=null;this.start=function(){n=t(500),r=t(405),n.start(),r.start()},this.stop=function(){n?.stop(),r?.stop()}}function Wn(e,t=10,n=.001){for(var r=0;r<t;r+=n){var i=e(r);if(i>e(r-n)&&i>e(r+n))return r}throw new Error("No peak found!")}function qn(e,t,n,r){var i=n/180*Math.PI,a=t/1e3,o=(r[1]*a+r[2])*a,s=e+r[8]*n+r[9]*a+r[10],l=r[3]*Math.sin(2*Math.atan(a/r[4]))*(1-r[5]*Math.abs(i))/(r[0]*(r[1]*a+r[2])*a),c=r[6]*a+r[7],u=((r[11]*a+r[12])*n+r[13])*a+r[14];return o*Math.sin(r[0]*Math.atan(s*l+c*(Math.atan(s*l)-s*l)))+u}function Yn(e,t){var n=t[0],r=t[1],i=t[2],a=t[3];return i*Math.sin(r*Math.atan(n*e-a*(n*e-Math.atan(n*e))))}function Kn(e,t){if(e.length!=t.length)throw new Error("Matrices have to be the same length!");for(var n=0,r=0;r<e.length;r++)n+=e[r]*t[r];return n}const $n={name:"Lamborghini Aventador",model:"../assets/models/aventador.glb",settings:{drivetrain:"RWD",torque:700,gearChangeTime:.15,friction:1.2,forwardFriction:1,sidewaysFriction:1.05,maxSteerAngle:40,steerVelocity:100,suspensionForce:9e4,suspensionDamping:3e3,suspensionTravel:.1,rideHeightOffset:.08,ABS:!0,differential:Un.ENUMS.DIFFERENTIAL.LSD,wings:[new Ln(new X(0,.5,-2.3),.4),new Ln(new X(0,-.4,2.2),.42)],camera:{followDistance:4,followHeight:.25,pitch:.1}}},Qn={name:"Toyota ae86",model:"../assets/models/toyota_ae86.glb",settings:{mass:1e3,drivetrain:"RWD",friction:.9,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:70,torque:400,suspensionForce:9e4,suspensionDamping:3e3,suspensionTravel:.1,rideHeightOffset:.08,antiRoll:16e3,ABS:!1,TCS:!1,differential:Un.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},Jn=JSON.parse(JSON.stringify(Qn));Jn.settings.maxSteerAngle=85,Jn.model="../assets/models/FocE.glb";const Zn=JSON.parse(JSON.stringify(Qn));Zn.model="../assets/models/nissanGTR.glb";const er={name:"Ford Ranger",model:"../assets/models/ford_ranger_police.glb",settings:{mass:1900,drivetrain:"RWD",differentialRatio:7,friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:40,torque:500,suspensionForce:45e3,suspensionDamping:4e3,suspensionTravel:.3,rideHeightOffset:.3,antiRoll:15e3,TCS:!0,ABS:!0,camera:{followDistance:4,followHeight:.25,pitch:.1}}},tr={name:"Nissan Skyline R32 GT-R",model:"../assets/models/skyline.glb",settings:{mass:1400,gearRatios:[2.66,1.78,1.3,1,.74,.6],drivetrain:"RWD",friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:45,torque:600,suspensionForce:9e4,suspensionDamping:2e3,suspensionTravel:.1,rideHeightOffset:.08,antiRoll:1e4,ABS:!1,TCS:!1,differential:Un.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},nr={name:"BMW M3 Coupe (E30) 1986",model:"../assets/models/M3_E30.glb",settings:{mass:1e3,drivetrain:"RWD",friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:50,torque:600,suspensionForce:9e4,suspensionDamping:4e3,suspensionTravel:.1,rideHeightOffset:.08,antiRoll:1e4,ABS:!1,TCS:!1,differential:Un.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},rr={name:"Police car",model:"../assets/models/crownvic.glb",settings:{mass:1700,drivetrain:"RWD",friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:45,torque:600,suspensionForce:6e4,suspensionDamping:4e3,suspensionTravel:.15,rideHeightOffset:.1,antiRoll:9e3,ABS:!1,TCS:!1,differential:Un.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},ir={name:"Nagoya City Bus",model:"../assets/models/bus.glb",settings:{mass:7e3,drivetrain:"RWD",maxSteerAngle:45,torque:3500,friction:.5,forwardFriction:1,sidewaysFriction:1,suspensionForce:2e5,suspensionDamping:8e3,suspensionTravel:.2,rideHeightOffset:.08,antiRoll:5e4,ABS:!0,TCS:!1,differential:Un.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:7,followHeight:.25,pitch:.1}}},ar={name:"Audi RS6",model:"../assets/models/audi_rs6.glb",settings:{mass:2e3,drivetrain:"AWD",friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:45,torque:550,suspensionForce:13e4,suspensionDamping:5e3,suspensionTravel:.1,rideHeightOffset:.08,antiRoll:1e4,ABS:!0,TCS:!1,differential:Un.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},or={name:"Lowpoly Sports Car",model:"../assets/models/cars/lowpolySportsCar.glb",settings:{mass:1400,gearRatios:[2.66,1.78,1.3,1,.74,.6],drivetrain:"RWD",friction:1,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:40,torque:350,suspensionForce:12e4,suspensionDamping:4e3,suspensionTravel:.1,rideHeightOffset:.08,antiRoll:1e4,ABS:!1,TCS:!1,differential:Un.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}},sr={name:"Lowpoly Jeep",model:"../assets/models/cars/lowpolyJeep.glb",settings:{mass:1700,drivetrain:"RWD",offroadFriction:1,friction:.8,forwardFriction:1,sidewaysFriction:1,maxSteerAngle:45,torque:400,COMOffset:new X(0,-.5,0),suspensionForce:6e4,suspensionDamping:4e3,suspensionTravel:.15,rideHeightOffset:.1,antiRoll:9e3,ABS:!1,TCS:!1,differential:Un.ENUMS.DIFFERENTIAL.LSD,camera:{followDistance:4,followHeight:.25,pitch:.1}}};function lr(e,t,n={}){var r=this;{let e=new X,t=new X,n=new j;var i=function(){j.eulerVector(h,n),r.camera.transform.rotation=n,W.getForward(r.camera.transform.worldMatrix,e),X.multiplyTo(e,-r.distance),X.set(t,u),X.addTo(t,e),r.camera.transform.position=t}}var a=n.rotate??!0,o=n.translate??!0,s=n.scale??!0,l=n.stylePointer??!0,c=5;Object.defineProperty(this,"distance",{get:function(){return c},set:function(e){c=e,i()}});var u=X.zero();Object.defineProperty(this,"center",{get:function(){return u},set:function(e){u=e,i()}});var h=X.zero();Object.defineProperty(this,"rotation",{get:function(){return h},set:function(e){h=e,i()}});var f=W.identity();b(),this.camera=new Xe(t),this.camera.setAspect(e.aspect),i(),l&&(e.canvas.style.cursor="grab",e.canvas.addEventListener("mousedown",(function(){e.canvas.style.cursor="grabbing"})),document.addEventListener("mouseup",(function(){e.canvas.style.cursor="grab"}))),e.canvas.addEventListener("contextmenu",(function(e){e.preventDefault()})),window.addEventListener("mousemove",(function(t){e.mouse.left&&a?(h.x+=.005*-t.movementY,h.y+=.005*-t.movementX,b()):e.mouse.right&&o&&x(t.movementX,t.movementY),i()}));var d={x:0,y:0},m=!0;e.canvas.addEventListener("touchstart",(function(e){d.x=e.touches[0].clientX,d.y=e.touches[0].clientY,m=!(e.touches.length>1),2==e.touches.length&&(d.x=(e.touches[0].clientX+e.touches[1].clientX)/2,d.y=(e.touches[0].clientY+e.touches[1].clientY)/2),i(),e.preventDefault()})),e.canvas.addEventListener("touchmove",(function(e){if(m){let t=e.touches[0].clientX-d.x,n=e.touches[0].clientY-d.y,r=.005;h.x+=-n*r,h.y+=-t*r,b(),d.x=e.touches[0].clientX,d.y=e.touches[0].clientY}if(2==e.touches.length){let t=(e.touches[0].clientX+e.touches[1].clientX)/2,n=(e.touches[0].clientY+e.touches[1].clientY)/2;x(t-d.x,n-d.y),d.x=t,d.y=n}i(),e.preventDefault()})),document.addEventListener("touchmove",(function(e){1!==e.scale&&e.preventDefault()}),{passive:!1}),e.canvas.addEventListener("wheel",(function(e){s&&(r.distance+=.001*e.deltaY*r.distance,r.distance=Math.max(0,r.distance),i(),e.preventDefault())}));var v=1;e.canvas.addEventListener("gesturestart",(function(e){v=e.scale}),!1),e.canvas.addEventListener("gesturechange",(function(e){var t=v/e.scale;v=e.scale,r.distance*=t,r.distance=Math.max(0,r.distance),i(),e.preventDefault()}),!1),e.on("resize",(function(){r.camera.setAspect(e.aspect)})),this.setCenter=function(e){u=e,i()};let g=new X,p=new X;function x(e,t){var n=6e-4*r.distance;p.x=-e*n,p.y=t*n,p.z=0,W.transformVector(f,p,g),X.addTo(u,g)}function b(){W.identity(f),W.transform([["ry",h.y],["rx",h.x]],f)}}__webpack_require__(388),new Fn;var cr={vertex:Et.lit.vertex,fragment:`\n${at}\n\nlayout (location = 0) out vec4 fragColor;\nlayout (location = 1) out vec2 motionVector;\n\n// Attributes\nin vec3 vPosition;\nin vec3 vNormal;\nin vec4 vTangent; //in vec3 vTangent;\nin vec3 vColor;\nin vec2 vUV;\nin mat3 vTBN;\n\n// Motion blur\nin vec4 clipSpace;\nin vec4 prevClipSpace;\n//#in\n\n// Custom\nuniform bool twoTone;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform bool useFlakes;\nuniform sampler2D flakesNormalTexture;\nuniform float flakeScale;\nuniform float clearcoatFactor;\nuniform float clearcoatRoughness;\n//\n\nuniform sampler2D albedoTexture;\nuniform sampler2D normalTexture;\n\nuniform vec4 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform vec3 emissiveFactor;\nfloat ao = 1.;\nuniform bool opaque;\nuniform float alphaCutoff;\nuniform float normalStrength;\nuniform bool doNoTiling;\n\n// bruh make shared uniform into uniform block\n// Light info\nstruct LightInfo {\n  int type;\n  vec3 position;\n  vec3 direction;\n  float angle;\n  vec3 color;\n};\nconst int maxLights = 16;\nuniform LightInfo lights[maxLights];\nuniform int nrLights;\nuniform vec3 sunDirection;\nuniform vec3 sunIntensity;\n\n// Environment\nuniform vec3 ambientColor;\nuniform float environmentIntensity;\nuniform samplerCube u_diffuseIBL;\nuniform samplerCube u_specularIBL;\nuniform sampler2D u_splitSum;\n\n// Shadows\nconst int levels = 2;\nin vec4 projectedTexcoords[levels];\n// uniform float biases[levels];\nuniform sampler2D projectedTextures[levels];\n\n// uniform mat4 inverseViewMatrix;\nuniform mat4 modelMatrix;\n\nuniform sharedPerScene {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  mat4 inverseViewMatrix;\n  float biases[levels];\n};\n\n${st}\n\nvec3 getN(vec3 tangentNormal) {\n  vec3 N;\n  if (vTangent.xyz != vec3(0)) {\n    N = normalize(vTBN * tangentNormal);\n  }\n  else {\n    N = normalize(mat3(modelMatrix) * vNormal);\n  }\n\n  if (!gl_FrontFacing) {\n    N *= -1.;\n  }\n\n  return N;\n}\n\nvoid main() {\n  ${ct}\n\n  // vec4 baseAlbedo = vec4(0, 0, 1, 1);\n  float baseAO = 1.;\n\n  vec3 baseTangentNormal = vec3(0, 0, 1);\n  if (useFlakes) {\n    baseTangentNormal = textureNoTile(flakesNormalTexture, vUV * flakeScale, 1.).rgb * 2. - 1.;\n  }\n\n  float baseScalarF0 = 0.04;\n\n  vec3 clearcoatTangentNormal = vec3(0, 0, 1);\n  float clearcoatScalarF0 = 0.04;\n  //\n\n  float ccRough = clearcoatRoughness;\n  ccRough = clamp(ccRough, 0.01, 0.99);\n  float rough = roughness;\n  rough = clamp(rough, 0.01, 0.99);\n\n  // V, N, R\n  vec3 V = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition);\n  \n  vec3 baseN = getN(baseTangentNormal);\n  vec3 clearcoatN = getN(clearcoatTangentNormal);\n\n  vec3 baseR = reflect(-V, baseN);\n  vec3 clearcoatR = reflect(-V, clearcoatN);\n  //\n\n  vec4 baseAlbedo = vec4(color1, 1);\n  if (twoTone) {\n    float fresnelTerm = dot(V, baseN);\n    fresnelTerm = clamp(1.0 - fresnelTerm, 0., 1.);\n\n    baseAlbedo = vec4(mix(color1, color2, fresnelTerm), 1);\n    // baseAlbedo = vec4(fresnelTerm * color1 + pow(fresnelTerm, 2.) * color2, 1);\n  }\n\n  // Clear coat\n  // vec3 F0 = vec3(clearcoatScalarF0);\n  // F0 = mix(F0, clearcoatAlbedo, /*clearcoatMetallic = */0.);\n  // vec3 F = fresnelSchlickRoughness(max(dot(clearcoatN, V), 0.), F0, clearcoatRoughness);\n\n  // vec3 kS = F;\n  // vec3 kD = 1.0 - kS;\n  // kD *= 1.0 - /*clearcoatMetallic = */0.;\n    \n  // vec3 irradiance = texture(u_diffuseIBL, clearcoatN).rgb;\n  // vec3 diffuse  = irradiance * clearcoatAlbedo;\n    \n  // const float MAX_REFLECTION_LOD = 4.0;\n  // vec3 prefilteredColor = textureLod(u_specularIBL, clearcoatR, clearcoatRoughness * MAX_REFLECTION_LOD).rgb;\n\n  // vec2 uv = vec2(max(dot(clearcoatN, V), 0.), clearcoatRoughness);\n  // uv.y = 1. - uv.y;\n  // vec2 envBRDF = texture(u_splitSum, uv).rg;\n\n  // vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n  // vec3 clearcoatColor = (kD * diffuse * 0. + specular) * environmentIntensity;\n\n  vec3 F0 = vec3(clearcoatScalarF0);\n  vec3 F = fresnelSchlickRoughness(max(dot(clearcoatN, V), 0.), F0, ccRough);\n    \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureLod(u_specularIBL, clearcoatR, ccRough * MAX_REFLECTION_LOD).rgb;\n\n  vec2 uv = vec2(max(dot(clearcoatN, V), 0.), ccRough);\n  uv.y = 1. - uv.y;\n  vec2 envBRDF = texture(u_splitSum, uv).rg;\n\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n  vec3 clearcoatColor = specular * environmentIntensity;\n\n  // Base\n  vec3 baseIBL = IBL(baseN, V, baseR, baseAlbedo.rgb, metallic, rough, baseScalarF0) * baseAO;\n  vec3 baseSun = DirectionalLight(vPosition, baseN, V, sunDirection.xyz, sunIntensity.xyz, baseAlbedo.rgb, metallic, rough, baseScalarF0) * baseAO * getShadowAmount(vPosition, dot(sunDirection.xyz, baseN));\n  vec3 baseColor = baseIBL + baseSun;\n\n  // Final\n  vec3 finalColor = baseColor * (1. - F * clearcoatFactor) + clearcoatColor * clearcoatFactor;\n  fragColor = vec4(finalColor, 1);\n}\n`};it(cr);var ur={vertex:Et.lit.vertex,fragment:`\n${at}\n\n${ot}\n\nconst int nrTextures = 2;\nuniform sampler2D albedoTextures[nrTextures];\nuniform sampler2D normalTextures[nrTextures];\nuniform sampler2D metallicRoughnessTextures[nrTextures];\n\n${st}\n\n${lt}\n\nvoid main() {\n  ${ct}\n\n  vec4 grassAlbedo = vec4(textureNoTile(albedoTextures[0], vUV, 1.), 1);\n  vec4 stoneAlbedo = vec4(textureNoTile(albedoTextures[1], vUV, 1.), 1);\n\n  vec3 grassNormal = textureNoTile(normalTextures[0], vUV, 1.) * 2. - 1.;\n  vec3 stoneNormal = textureNoTile(normalTextures[1], vUV, 1.) * 2. - 1.;\n\n  float mixFactor = clamp(noise(vUV / 40.), 0., 1.);\n\n  vec4 currentAlbedo = mix(grassAlbedo, stoneAlbedo, mixFactor);\n  currentAlbedo *= albedo;\n  currentAlbedo.rgb *= mix(vec3(0.3, 0.5, 0.1), vec3(0.5, 0.5, 0.3), mixFactor);\n  // currentAlbedo.rgb *= 0.7;\n\n  // vec4 currentAlbedo = vec4(textureNoTile(albedoTextures[0], vUV, 1.), 1);\n  // currentAlbedo *= albedo;\n  // currentAlbedo.rgb *= mix(vec3(1.0), vec3(0.5, 0.5, 0.6), clamp(LayeredNoise(vUV / 40.), 0., 1.));\n\n  vec3 _emission = vec3(0);\n  float _metallic = 0.;\n  float _roughness = 1.;\n  float _ao = 1.;\n\n  vec3 _tangentNormal = mix(grassNormal, stoneNormal, mixFactor);\n  _tangentNormal = setNormalStrength(_tangentNormal, 3.);\n\n  // vec3 _tangentNormal = textureNoTile(normalTextures[0], vUV, 1.) * 2. - 1.;\n  // _tangentNormal = setNormalStrength(_tangentNormal, 2.);\n\n  vec4 litColor = lit(currentAlbedo, 0.5, _emission, _tangentNormal, _metallic, _roughness, _ao);\n\n  #ifdef USEFOG\n    litColor = applyFog(litColor);\n  #endif\n\n  fragColor = litColor;\n}\n`};it(ur);var hr=Et.litInstanced.vertex,fr=`\n${at}\n\n${ot}\n\n${st}\n\nvoid main() {\n  ${ct}\n\n  vec4 albedo = texture(albedoTexture, vUV);\n  if (albedo.a < 0.5) {\n    discard;\n  }\n\n  vec3 tangentNormal = texture(normalTexture, vUV).rgb * 2. - 1.;\n  vec3 worldNormal = normalize(vTBN * tangentNormal);\n  // if (!gl_FrontFacing) {\n  //   worldNormal *= -1.;\n  // }\n  worldNormal *= float(gl_FrontFacing) * 2. - 1.;\n\n  worldNormal = mix(worldNormal, normalize(vPosition - (modelMatrix * vec4(0, 4., 0, 1)).xyz), 0.6);\n  // worldNormal = normalize(vPosition - vec3(0, 4, 0));\n\n  vec3 irradiance = texture(u_diffuseIBL, worldNormal).rgb;\n  vec3 iblDiffuse = irradiance * albedo.rgb * environmentIntensity;\n  iblDiffuse *= 1. - 0.04;\n  vec3 diffuse = albedo.rgb * sunIntensity * max(dot(sunDirection, worldNormal), 0.) * 0.5;\n  vec3 ambient = vec3(0.1, 0.03, 0.);\n\n  fragColor = vec4(diffuse + iblDiffuse + ambient, 1);\n}\n`;it({vertex:hr,fragment:fr=(fr=(fr=fr.replace(/modelMatrix/g,"vModelMatrix")).replace(/uniform mat4 vModelMatrix/g,"in mat4 vModelMatrix")).replace("motionVector = (NDCPos - PrevNDCPos).xy * 0.5 + 0.5;","motionVector = vec2(0.5);")});class dr{#b="../assets/sound/menu tick.wav";#y=new Audio(this.#b);constructor(e){this.keybindings=e,this.selectedElement=null}update(){this.keybindings.getInputDown("UIup")?this.#T(0):this.keybindings.getInputDown("UIright")?this.#T(1):this.keybindings.getInputDown("UIdown")?this.#T(2):this.keybindings.getInputDown("UIleft")?this.#T(3):this.keybindings.getInputDown("UIselect")&&this.#w()}#w(){this.selectedElement&&null!==this.selectedElement.offsetParent&&(this.selectedElement.click(),this.#E())}#T(e){var t=document.querySelectorAll(".isSelectable:not([disabled]):not(.hidden):not(.selected)");if(0!=(t=[...t].filter((e=>null!==e.offsetParent))).length)if(this.selectedElement&&null==this.selectedElement.offsetParent&&this.deselectElement(),this.selectedElement){var n=this.selectedElement.getBoundingClientRect(),r=e*Math.PI/2-Math.PI/2,i=function(e){var t,r,i,a,o=e.getBoundingClientRect();return t=n.x,r=n.y,i=t-o.x,a=r-o.y,Math.sqrt(i*i+a*a)},a=t.reduce(((e,t)=>{return c=t.getBoundingClientRect(),a=n.x,o=n.y,s=c.x,l=c.y,u=Math.atan2(l-o,s-a)-r,Math.abs(Math.atan2(Math.sin(u),Math.cos(u)))<.4*Math.PI&&(!e||i(t)<i(e))?t:e;var a,o,s,l,c,u}),null);a&&this.selectElement(a)}else this.selectFirstElement(t);else this.deselectElement()}deselectElement(){this.selectedElement&&(this.selectedElement.classList.remove("selected"),this.selectedElement=null)}selectFirstElement(e){var t=e;e||(t=document.querySelectorAll(".isSelectable:not([disabled]):not(.hidden):not(.selected)"),t=[...t].filter((e=>null!==e.offsetParent)));var n=t.reduce(((e,t)=>e.getBoundingClientRect().y-t.getBoundingClientRect().y+.1*(e.getBoundingClientRect().x-t.getBoundingClientRect().x)>0?t:e));this.selectElement(n)}selectElement(e){this.selectedElement&&this.selectedElement.classList.remove("selected"),e.classList.contains("isSelectable")?(this.selectedElement=e,this.selectedElement.classList.add("selected"),this.selectedElement.scrollIntoView({behavior:"smooth"}),this.#E()):(console.warn("Element is not selectable"),console.log(e))}#E(){this.#y.currentTime=0,this.#y.play()}}class mr{constructor(e,t,n={}){var r=new e.LitMaterial;return r.programContainer=t,n.flakesNormalTexture&&(r.setUniform("flakesNormalTexture",n.flakesNormalTexture),r.setUniform("useFlakes",1)),r.setUniform("metallic",n.metallic??1),r.setUniform("roughness",n.roughness??.4),r.setUniform("twoTone",n.twoTone??0),r.setUniform("color1",n.color1??[0,.3,1]),r.setUniform("color2",n.color2??[.4,.3,1]),r.setUniform("flakeScale",n.flakeScale??500),r.setUniform("clearcoatRoughness",n.clearcoatRoughness??.1),r.setUniform("clearcoatFactor",n.clearcoatFactor??1),r}}class vr{constructor(e=512,t=512){const n=document.createElement("canvas");n.width=e,n.height=t;const r=n.getContext("2d");r.fillStyle="rgb(127,127,255)",r.fillRect(0,0,e,t);for(let n=0;n<4e3;n++){const n=Math.random()*e,i=Math.random()*t,a=3*Math.random()+3;let o=2*Math.random()-1,s=2*Math.random()-1,l=7.5;const c=Math.sqrt(o*o+s*s+l*l);o/=c,s/=c,l/=c,r.fillStyle="rgb("+(127*o+127)+","+(127*s+127)+","+255*l+")",r.beginPath(),r.arc(n,i,a,0,2*Math.PI),r.fill()}return n}}document.addEventListener("DOMContentLoaded",(async function(){const e=document.querySelector(".pauseOverlay"),t=document.querySelector(".garage"),n=document.querySelector(".loading"),r=document.querySelector(".settings"),i=t.querySelector(".selectCar"),a=n.querySelector(".progressBar"),o=n.querySelector(".progressStatus");let s;const l=document.querySelector(".messages"),c=new Fn;let u;const d=new v({publicMethods:!1});d.canvas.classList.add("ingameUICanvas"),d.canvas.style.zIndex=2;var g=!1,p=!1;const x=new X(0,2,0),b=j.identity(),T=["lowpolySportsCar"];let w=0,E=0,_=0;const M=new Sn;var R,C,F;let A=0,D=10+T.length;le(A++,D,"Initializing renderer");const S=new Cn({path:"../",renderScale:1,debug:!0,renderpipeline:0,shadowResolution:1024,shadowSizes:[6,64]});S.disableContextMenu(),S.canvas.style.position="fixed",window.isDay=se;const z=new function(){const e="com.tc5550.cardemo.settings";class t{constructor(e){this.name=e}}class n{constructor(e="Setting",t=0,n=(()=>{}),r=0,i=1,a=.1,o=!1){this.name=e,this.value=t,this.defaultValue=t,this.onValueChange=n,this.min=r,this.max=i,this.step=a,this.displayAsPercent=o}formatValue(e){return this.displayAsPercent?`${Math.round(100*e)}%`:e.toString()}createDOM(){var e=document.createElement("div");return this.valueSpan=e.appendChild(document.createElement("span")),this.valueSpan.style.marginRight="2em",this.valueSpan.textContent=this.formatValue(this.value),e.appendChild(document.createElement("span")).textContent=this.min,this.slider=e.appendChild(document.createElement("input")),this.slider.type="range",this.slider.min=this.min,this.slider.max=this.max,this.slider.step=this.step,this.slider.value=this.value,e.appendChild(document.createElement("span")).textContent=this.max,this.slider.addEventListener("input",(()=>{this.value=this.slider.value,this.valueSpan.textContent=this.formatValue(this.value),this.onValueChange(this.value)})),e}setValue(e){this.value=e,this.onValueChange(this.value),this.slider.value=this.value,this.valueSpan.textContent=this.formatValue(this.value)}}class r{constructor(e="Setting",t=!1,n=(()=>{})){this.name=e,this.value=t,this.defaultValue=t,this.onValueChange=n}createDOM(){var e=document.createElement("div");return this.checkbox=e.appendChild(document.createElement("input")),this.checkbox.type="checkbox",this.checkbox.checked=this.value,this.checkbox.addEventListener("click",(()=>{this.value=this.checkbox.checked,this.onValueChange(this.value)})),e}setValue(e){this.value=e,this.onValueChange(this.value),this.checkbox.checked=e}onClick(){this.setValue(!this.value)}}var i={_soundGroup:new t("Sound"),masterVolume:new n("Master volume",1,(e=>{ie&&(ie.mainGainNode.gain.value=e),h()}),0,2,.01,!0),_displayGroup:new t("Graphics"),fps:new r("Show FPS",!1,(e=>{!u&&e&&(u=new m),e?document.body.appendChild(u.dom):u?.dom.remove(),h()})),renderScale:new n("Render scale",1,(e=>{S.setRenderScale(e),h()}),.2,2,.05),motionBlur:new n("Motion blur",.15,(e=>{L.postprocessing.motionBlurStrength=e,h()}),0,.5,.01),bloom:new r("Bloom",!0,(e=>{L.bloom.enabled=e,h()})),_gameplayGroup:new t("Gameplay"),day:new r("Daytime",!0,(e=>{window.isDay(e),h()})),cameraFollowMode:new class{constructor(e="Setting",t=0,n=(()=>{}),r,i){if(this.name=e,this.value=t,this.defaultValue=t,this.onValueChange=n,this.labels=r,this.values=i,this.labels.length!=this.values.length)throw console.error(this.labels,this.values),new Error("Labels and values must have same length!")}createDOM(){var e=document.createElement("div");this.select=e.appendChild(document.createElement("select"));for(var t=0;t<this.labels.length;t++){var n=this.labels[t],r=this.values[t],i=this.select.appendChild(document.createElement("option"));i.value=r,i.textContent=n}return this.select.addEventListener("input",(()=>{this.value=this.select.value,this.onValueChange(this.value)})),e}setValue(e){this.value=e,this.onValueChange(this.value),this.select.selectedIndex=[...this.select.options].findIndex((t=>t.value==e))}onClick(){let e=this.select.options.length;this.select.setAttribute("size",e);let t=this.select.selectedIndex;t++,t%=this.select.options.length,this.setValue(this.select.options[t].value)}}("Camera follow mode",1,(e=>{ie&&(ie.followCamera.followMode=e),h()}),["Follow velocity","Follow direction","Follow inverse direction"],[1,2,3]),_assistGroup:new t("Assists"),abs:new r("ABS",!0,(e=>{ie&&(ie.ABS=e),h()})),tcs:new r("TCS",!1,(e=>{ie&&(ie.TCS=e),h()})),steeringAssist:new r("Steering assist",!0,(e=>{ie&&(ie.activateAutoCountersteer=e),h()})),autoCountersteer:new n("Auto countersteer",.25,(e=>{ie&&(ie.autoCountersteer=e),h()}),0,1,.05),autoCountersteerVelocityMultiplier:new n("Auto countersteer velocity",.15,(e=>{ie&&(ie.autoCountersteerVelocityMultiplier=e),h()}),0,1,.05)},a=document.querySelector(".settings > .settingsContainer > .items"),o=document.createElement("div");o.classList.add("group");var s=o;for(let e in i){let n=i[e];if(n instanceof t){var l=a.appendChild(document.createElement("div"));l.classList.add("group");var c=l.appendChild(document.createElement("span"));c.classList.add("title"),c.textContent=n.name,s=l}else{let e=s.appendChild(document.createElement("div"));e.classList.add("item"),e.classList.add("isSelectable"),e.addEventListener("click",(function(){n.onClick?.()})),e.appendChild(document.createElement("span")).textContent=n.name,e.appendChild(n.createDOM()),s!=o||a.contains(o)||a.appendChild(o)}}function h(){var t={};for(let e in i)t[e]=i[e].value;localStorage.setItem(e,JSON.stringify(t))}this.getSettingValue=function(e){if(e in i)return i[e].value;console.warn("Setting not defined: "+e)},this.setSettingValue=function(e,t){e in i?i[e].setValue(t):console.warn("Setting not defined: "+e)},this.loadSaveData=function(){var t=function(){var t=localStorage.getItem(e);if(null==t)return{};try{var n=JSON.parse(t);for(let e in n)Object.prototype.hasOwnProperty.call(i,e)||delete n[e];return n}catch(e){console.warn("Could not load settings"),console.error(e)}return{}}();for(let e in t)i[e].setValue(t[e])}};R=new An(S,M,{brights:{keyboard:"KeyX",controller:"LB"},drive:{keyboard:"KeyW",controller:"RT"},brake:{keyboard:"KeyS",controller:"LT"},ebrake:{keyboard:"Space",controller:"A"},clutch:{keyboard:"KeyC",controller:"Y"},steer:{keyboard:["KeyA","KeyD"],controller:"LSHorizontal"},gearDown:{keyboard:"KeyQ",controller:"X"},gearUp:{keyboard:"KeyE",controller:"B"},cameraMode:{keyboard:"KeyC",controller:"RB"},turnCamera:{keyboard:["ArrowLeft","ArrowRight"],controller:"RSHorizontal"},horn:{keyboard:"KeyT",controller:"RS"},pause:{keyboard:"Escape",controller:"Menu"},back:{keyboard:"Escape",controller:"B"},menuDown:{keyboard:"ArrowDown",controller:"DPDown"},menuUp:{keyboard:"ArrowUp",controller:"DPUp"},menuSelect:{keyboard:"Enter",controller:"A"},garagePrev:{keyboard:"ArrowLeft",controller:"DPLeft"},garageNext:{keyboard:"ArrowRight",controller:"DPRight"},UIup:{keyboard:"ArrowUp",controller:"DPUp"},UIright:{keyboard:"ArrowRight",controller:"DPRight"},UIdown:{keyboard:"ArrowDown",controller:"DPDown"},UIleft:{keyboard:"ArrowLeft",controller:"DPLeft"},UIselect:{keyboard:"Enter",controller:"A"}}),C=new dr(R),le(A++,D,"Loading scene");const L=new Ve("Playground");S.add(L),L.fogColor=[.4,.4,.5,1],L.fogDensity=.001,L.skyboxFogIntensity=1,L.environmentMinLight=.5,L.postprocessing.exposure=-1,L.postprocessing.vignette.amount=.3,L.postprocessing.vignette.falloff=.3,S.shadowCascades.refreshRate=0,se(!0),await L.loadEnvironment({hdrFolder:"cubemaps/infiniteForestCapture"}),le(A++,D,"Generating garage"),console.time("Garage");const B=new Ve("Garage");S.add(B),B.sunIntensity=X.zero(),B.environmentIntensity=.2,await B.loadEnvironment({hdrFolder:"../assets/hdri/studio_small_09_1k_precomputed"}),console.timeEnd("Garage"),B.add(await S.loadGLTF("./garage.glb"));const I=new Xe({fov:30});I.transform.matrix=W.lookAt(new X(0,1.5,6),new X(0,.5,0),X.up());var O=()=>{I.setAspect(S.aspect)};S.on("resize",O),O(),le(A++,D,"Initializing physics engine");const k=new ye(L,{octreeLevels:7,multipleTimestepsPerFrame:!1});le(A++,D,"Initializing car paint material");const V=await S.loadTextureAsync(new vr),G=new S.CustomProgram(f),H={purple:new mr(S,G,{flakesNormalTexture:V}),simplyRed:new mr(S,G,{metallic:0,clearcoatRoughness:0,twoTone:0,color1:[1,0,0]}),darkgray:new mr(S,G,{flakesNormalTexture:V,flakeScale:1e3,metallic:1,roughness:.5,clearcoatRoughness:0,clearcoatFactor:.5,twoTone:0,color1:[.05,.05,.05]})};le(A++,D,"Loading map");const{terrain:q,checkChunks:Y}=await async function(){const{checkChunks:e}=await async function(){var e=300;const[t,n,r,i,a,o]=await Promise.all([P("leaves5.png"),P("../assets/textures/brown_mud_leaves_01_512_jpg/brown_mud_leaves_01_diff_2k.jpg"),P("../assets/textures/brown_mud_leaves_01_512_jpg/brown_mud_leaves_01_Nor_2k.jpg"),P("../assets/textures/road512/albedo.png"),P("../assets/textures/road512/normal.png"),P("../assets/textures/road512/metallicRoughness.png")]),s=S.CreateLitMaterial({albedo:[.3,.3,.3,1],albedoTexture:S.loadTexture(i,{...S.getSRGBFormats(),anisotropicFiltering:!0}),normalTexture:S.loadTexture(a,{anisotropicFiltering:!0}),metallicRoughnessTexture:S.loadTexture(o,{anisotropicFiltering:!0}),metallic:.5}),l=S.CreateLitMaterial({albedoTexture:S.loadTexture(n,{...S.getSRGBFormats()}),normalTexture:S.loadTexture(r)});l.setUniform("doNoTiling",!0);const u=S.CreateLitMaterial({albedoTexture:S.loadTexture(t,{...S.getSRGBFormats()})}),h=S.CreateShape("plane",u),f=await S.loadGLTF("../assets/models/trees/wideTreeBillboard.glb");var d={rally:{width:4,material:null,flipUV:!0,uvScale:.75},asphalt:{width:10,material:s,flipUV:!1,uvScale:1}},m="asphalt",v=d[m].width,g=d[m].material,p=d[m].flipUV,x=d[m].uvScale,b=5,y=[],T=0,w=0;y.push(new X(0,T,-210)),y.push(new X(0,T,-150));for(var E=1;E<9;E++)y.push(new X(0,T,E*e/3-150));var _=[await R(y.slice(0,7)),await R(y.slice(3,10),new X(0,0,100))];const M=async function(){if(void 0!==ie&&ie&&ie.rb){for(let t=0;t<_.length;t++)_[t].active=Math.abs(t*e-ie.rb.position.z)<600;if(ie.rb.position.z>(_.length-2)*e){for(let t=0;t<3;t++)w+=3.5*(Math.random()-(.5+.02*w)),T+=w,y.push(new X((Math.random()-.5)*e*.3,T,(y.length-1)*e/3-150));_.push(await R(y.slice(3*_.length,3*_.length+7),new X(0,0,_.length*e)))}}};return setInterval(M,400),{checkChunks:M};async function R(e,t=X.zero()){var n=new me(e.map((e=>X.subtract(e,t))));return await async function(e,t,n=12,r=100){var i=new Ne("Chunk");i.transform.position=e;var a=!0,o=i.add(f.copy());o.children[0].meshRenderer=o.children[0].meshRenderer.getInstanceMeshRenderer(S.programContainers.unlitInstanced),o.setReceiveShadows(!1);var s=[];function u(e){s.push(e)}i.addChild(new Ne("Tree container")).visible=!1;var d=i.add(h.copy());d.castShadows=!1,d.meshRenderer=d.meshRenderer.getInstanceMeshRenderer(S.programContainers.unlitInstanced);var m=d.meshRenderer;function v(t){m.addInstance(W.transform([["translate",X.add(e,t)],["scale",X.fill(.25+.5*Math.random())],["ry",2*Math.random()*Math.PI],["rx",-Math.PI/2]]))}m.castShadows=!1,m.materials[0].setUniform("alphaCutoff",.7);var y=new Ne("Road"),T=0,w=[],E=[],_=[],M=[],R=[],C=[],F=0,A=1/r;for(let i=0;i<r;i++){let a=i/(r-1)*.75,o=t.getPoint(a),s=X.subtract(t.getPoint(a+A),o),l=X.normalize(s),h=j.QxV(j.angleAxis(Math.PI/2,l),X.up());var D=X.multiply(h,n/2),P=X.multiply(h,n/2*1.4),N=X.add(o,D),U=X.add(o,P);U.y-=.06*n;var z=X.subtract(o,D),B=X.subtract(o,P);B.y-=.06*n,E.push(U.x,U.y,U.z),E.push(N.x,N.y,N.z),E.push(N.x,N.y,N.z),E.push(z.x,z.y,z.z),E.push(z.x,z.y,z.z),E.push(B.x,B.y,B.z);var I=T/n;p?(_.push(I*x,-.4*x),_.push(I*x,0*x),_.push(I*x,0*x),_.push(I*x,1*x),_.push(I*x,1*x),_.push(I*x,1.4*x)):(_.push(-.4*x,I*x),_.push(0*x,I*x),_.push(0*x,I*x),_.push(1*x,I*x),_.push(1*x,I*x),_.push(1.4*x,I*x));var O=(c.noise(0,0,.01*(e.z+o.z))+1)/2,V=1.6,G=X.add(N,new X(-n*V,.4*n*O,0)),H=X.add(N,new X(8*-n,.55*n*O,0)),q=X.add(z,new X(n*V,.4*n*O,0)),Y=X.add(z,new X(8*n,.55*n*5*O,0));F%3==0&&(R.push(H.x,H.y,H.z),R.push(G.x,G.y,G.z),R.push(N.x,N.y,N.z),R.push(z.x,z.y,z.z),R.push(q.x,q.y,q.z),R.push(Y.x,Y.y,Y.z),C.push(-32,4*I),C.push(-16,4*I),C.push(0,4*I),C.push(4,4*I),C.push(12,4*I),C.push(36,4*I)),F++,T+=X.length(s);let f=()=>{let e=100*Math.random();u(X.add(X.add(o,X.multiply(h,.6*n+e)),new X(0,Math.min(5,.15*e)-Math.max(0,.1*(e-50)),0))),e=100*Math.random(),u(X.add(X.subtract(o,X.multiply(h,.6*n+e)),new X(0,Math.min(5,.15*e)-Math.max(0,.1*(e-50)),0)))};if(b>=1)for(let e=0;e<b;e++)f();else Math.random()<b&&f();v(X.add(X.add(o,X.multiply(h,n/2-2*Math.random())),new X(0,.05+.02*Math.random(),0))),v(X.add(X.subtract(o,X.multiply(h,n/2-2*Math.random())),new X(0,.05+.02*Math.random(),0)))}for(var K=0;K<6*(E.length/3/6-1);K+=6){var $=1e10;w.push((K+0)%$,(K+6)%$,(K+1)%$,(K+1)%$,(K+6)%$,(K+7)%$,(K+2)%$,(K+8)%$,(K+3)%$,(K+3)%$,(K+8)%$,(K+9)%$,(K+4)%$,(K+10)%$,(K+5)%$,(K+5)%$,(K+10)%$,(K+11)%$)}for(let e=0;e<6*(R.length/3/6-1);e+=6){let t=6;for(let n=0;n<5;n++)2!=n&&M.push(e+0+n,e+t+n,e+1+n,e+1+n,e+t+n,e+t+1+n)}var Q=new S.MeshData({indices:{bufferData:new Uint32Array(w),target:S.gl.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(E),size:3},uv:{bufferData:new Float32Array(_),size:2}});Q.recalculateNormals(),Q.recalculateTangents(),y.meshRenderer=new S.MeshRenderer(g,Q),y.addComponent(new we),y.transform.position.y=.04,i.addChild(y);var J=new S.MeshData({indices:{bufferData:new Uint32Array(M),target:S.gl.ELEMENT_ARRAY_BUFFER},position:{bufferData:new Float32Array(R),size:3},uv:{bufferData:new Float32Array(C),size:2}});J.recalculateNormals(),J.recalculateTangents();var Z=new Ne("Terrain");if(Z.meshRenderer=new S.MeshRenderer(l,J),Z.addComponent(new we),Z.transform.position.y=0,Z.customData.bumpiness=.08,Z.customData.friction=.9,Z.customData.offroad=1,i.addChild(Z),L.add(i),a)for(let t of s){const n=X.add(e,t),r=k.Raycast(new X(n.x,n.y+50,n.z),X.down());r&&r.firstHit&&X.set(n,r.firstHit.point);const i=3,a=6;let s=W.transform([["translate",X.add(n,new X(0,2*-Math.random()*-.1,0))],["scale",X.fill(i+Math.random()*(a-i))],["ry",2*Math.random()*Math.PI],["rx",.07*(Math.random()-.5)],["rz",.07*(Math.random()-.5)]]),l=W.copy(s);W.transform([["ry",Math.PI/2]],l),o.children[0].meshRenderer.addInstance(s),o.children[0].meshRenderer.addInstance(l)}return i}(t,n,v,100)}}(),t=L.add(await S.loadGLTF("tutorialSign.glb"));return t.transform.position=new X(-2.7,0,3),t.transform.rotation=j.euler(0,.65*Math.PI,0),new X(0,0,0,x),{checkChunks:e,terrain:null}}();le(A++,D,"Loading car models");var K={},$={},Q=0;for(var J of T){le(A++,D,`Loading car number ${Q+1}: ${J}`);var Z=h[J],ee=await S.loadGLTF(Z.model);K[J]=ee;var te=be(ee);$[J]=X.add(X.negate(te.getCenter()),new X(0,te.getSize().y/2,0)),ee.transform.position=X.add(new X(5*Q,.1,0),$[J]),B.add(ee),Q++}le(A++,D,"Setting up car");var ne=T[0],re=L.add(K[ne].copy());let ie;if(ie=await de(h[ne].settings,re),le(A++,D,"Finalizing physics colliders"),k.setupMeshCollider(),!ie)var ae=new lr(S,{far:1e4});var oe={};function se(e){e?(L.fogDensity=.001,L.environmentIntensity=1.25,L.sunIntensity={x:30,y:24,z:18}):(L.fogDensity=.005,L.environmentIntensity=.01,L.sunIntensity=X.fill(.25))}function le(e,t,n){s&&console.timeEnd(s),e<t&&console.time(n),s=n,a&&(a.querySelector(".progress").style.width=e/t*100+"%"),o.textContent=`${n} (${Math.floor(e/t*100)}%)`}function ce(e=1){w+=e,w=y(w,0,Object.keys(K).length-1),i.disabled=E==w,fe()}function ue(){p?(ie.freeze(),U(e),C.deselectElement(),C.selectFirstElement()):(ie.unfreeze(),N(e),ie.mainGainNode&&(S.getActiveScene()!=L?ie.mainGainNode.gain.value=0:ie.mainGainNode.gain.value=z.getSettingValue("masterVolume")))}function he(e){S.setActiveScene(e),document.querySelectorAll(".menu > div").forEach((e=>N(e))),U(document.querySelector(".menu > ."+e.name)),e==B?(U(t),fe()):N(t)}function fe(){let e=h[Object.keys(K)[w]],n=e.settings;t.querySelector(".carName").textContent=e.name,t.querySelectorAll(".stats .value")[0].textContent=`${n.torque} Nm`??0,t.querySelectorAll(".stats .value")[1].textContent=`${n.mass} kg`??0,t.querySelectorAll(".stats .value")[2].textContent=n.drivetrain??"UNKNOWN",t.querySelectorAll(".stats .value")[3].textContent=Object.keys(Un.ENUMS.DIFFERENTIAL).find((e=>Un.ENUMS.DIFFERENTIAL[e]===n.differential))??"UNKNOWN",t.querySelectorAll(".stats .value")[4].textContent=n.friction??"UNKNOWN"}async function de(e,t){var n=new Un(L,k,{path:S.path,keybindings:R,controlScheme:Un.ControlScheme.Controller,...e});t.transform.matrix=W.identity(),await n.setup(t),n.gameObject.traverse((e=>{if(e.meshRenderer){var t=e.meshRenderer.materials;for(var n of t){if("carpaint"==n.name.toLowerCase()){var r=t.indexOf(n);t[r]=H.darkgray,t[r].setUniform("flakeScale",50)}n.uniforms.enableMotionBlur=0,n.doubleSided=!1,n.doubleSidedShadows=!1}}})),n.wheels.map((e=>{e.model.setLayer(2,!0)})),X.set(n.resetPosition,x),n.resetPosition.y-=n.bottomOffset.y;const r=Math.max(...n.wheels.map((e=>e.suspensionTravel)));return n.resetPosition.y+=.5*r,X.set(n.rb.position,n.resetPosition),n.gameObject.transform.position=X.copy(n.rb.position),j.set(n.resetRotation,b),j.set(n.rb.rotation,n.resetRotation),n.gameObject.transform.rotation=j.copy(n.rb.rotation),n.resetGame(),n.mainCamera=new Xe({near:.1,far:15e3,fov:35}),n.mainCamera.setAspect(S.aspect),n.ABS=z.getSettingValue("abs"),n.TCS=z.getSettingValue("tcs"),n.activateAutoCountersteer=z.getSettingValue("steeringAssist"),n.autoCountersteer=z.getSettingValue("autoCountersteer"),n.autoCountersteerVelocityMultiplier=z.getSettingValue("autoCountersteerVelocityMultiplier"),n.followCamera.followMode=z.getSettingValue("cameraFollowMode"),n.mainGainNode.gain.value=z.getSettingValue("masterVolume"),n}function ve(e,t=null){(function(e){return e&&e.readyState==e.OPEN})(F)&&F.send(JSON.stringify({type:e,data:t,clientSendTime:new Date}))}function ge(e){var t=document.createElement("div");t.classList.add("message"),t.textContent=e,l.prepend(t)}(F=new WebSocket(`wss://${location.hostname}:8080`)).onerror=function(){ge("Disconnected")},F.onopen=function(){console.log("Connected to server!"),ge("Connected"),setInterval((function(){ie&&ie.rb&&(ve("updatePlayer",{position:ie.rb.position,rotation:ie.rb.rotation,velocity:ie.rb.velocity,angularVelocity:ie.rb.angularVelocity}),ve("getAllPlayers"))}),100)},F.onmessage=async function(e){var t;try{t=JSON.parse(e.data)}catch(e){return void console.warn(e)}if(Object.prototype.hasOwnProperty.call(t,"type")&&Object.prototype.hasOwnProperty.call(t,"data"))if("ping"==t.type)console.log(t.data);else if("playerAction"==t.type)switch(t.data.action){case"join":console.log("Player has joined!",t.data.clientID),ge(`${t.data.clientID} has joined`);break;case"leave":console.log("Player has left!",t.data.clientID),ge(`${t.data.clientID} has left`)}else if("getAllPlayers"==t.type)for(let e of t.data){let t=oe[e.clientID];if(!t){let n=L.add(K.skyline.copy()),r=await de(tr.settings,n);r.activateAutoCountersteer=!1,r.simulateFriction=!1,oe[e.clientID]=t={model:n,car:r}}let n=t.car.rb,r=e.data;n.position=r.position,n.rotation=r.rotation,n.velocity=r.velocity,n.angularVelocity=r.angularVelocity}},document.addEventListener("visibilitychange",(function(){document.hidden&&(p=!0),ue()}),!1),le(A++,D,"Done!"),z.loadSaveData(),N(n),z.getSettingValue("Show FPS")&&(u=new m,document.body.appendChild(u.dom)),S.on("renderloop",(function(t,n){if(d.clearScreen(),function(t){g&&R.getInputDown("back")?(N(r),U(e),C.selectFirstElement(),g=!1):p&&R.getInputDown("back")?(p=!1,ue()):R.getInputDown("pause")&&!g?(p=!p,ue()):(p||S.getActiveScene()!=B||(R.getInputDown("back")&&window.gotoPlayground(),R.getInputDown("garagePrev")&&ce(-1),R.getInputDown("garageNext")&&ce(1),R.getInputDown("menuSelect")&&window.selectCar(),_+=-Pn(Dn(M.getAxis("RSHorizontal"),.08))*t*5),C.update(t))}(t),S.getActiveScene()==L){if(!p){let e=ie?ie.mainCamera:ae.camera;q?.update(e.transform),k.update(),ie&&(ie.rb.position.y<-300&&ie.resetGame(),ie.update(t),ie.renderUI(d)),S.update(t),S.render(e)}}else{var i=j.euler(0,_,0);B.root.getChild("spin",!0).transform.rotation=i;var a=0;for(var o in K){var s=K[o],l=X.add(new X(20*(a-w),.1,0),$[o]);X.addTo(s.transform.position,X.multiply(X.subtract(l,s.transform.position),.3)),s.transform.rotation=i,s.visible=w==a,a++}_+=.1*t,S.update(t),p||S.render(I)}u?.update()})),window.renderer=S,window.scene=L,window.physicsEngine=k,window.car=ie,window.selectCar=async function(){if(E!==w){X.copy(ie.rb.position).y=0,ie.destroy();var e=Object.keys(K)[w],t=h[e],n=L.add(K[e].copy());ie=await de(t.settings,n),E=w}i.disabled=E==w},window.gotoPlayground=function(){he(L),window.resume()},window.gotoGarage=function(){he(B),window.resume()},window.resetCar=function(){ie.resetGame(),Y(),window.resume()},window.resume=function(){p=!1,ue()},window.openSettings=function(){g=!0,N(e),U(r),C.selectFirstElement()},window.goBack=function(){return g?(N(r),U(e),C.selectFirstElement(),void(g=!1)):p?(p=!1,void ue()):void 0}}))})()})();