  // // vec4 baseColor = texture(albedoTexture, vUV);
  // vec4 baseColor = useTexture ? texture(albedoTexture, vUV) : vec4(1);
  // if (baseColor.a < 0.1) {
  //   discard;
  // }

  // vec3 viewDirection = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition); 
  // vec3 H = normalize(sunDirection + viewDirection);

  // vec3 worldNormal = normalize(mat3(modelMatrix) * vNormal);
  // if (useNormalMap) {
  //   // vec3 worldTangent = normalize(mat3(modelMatrix) * vTangent);

  //   // float normalMapStrength = 0.3;
  //   // vec3 normalMap = tangentToObject(worldNormal, worldTangent, normalStrength(vec3(texture(normalTexture, vUV)) * 2. - 1., normalMapStrength));
  //   // worldNormal = normalMap;

  //   worldNormal = perturb_normal(worldNormal, viewDirection, vUV);
  // }

  // float shadowAmount = getShadowAmount();

  // float reflectionSharpness = 0.;//10.
  // vec3 reflection = textureLod(u_specularIBL, reflect(-viewDirection, worldNormal), reflectionSharpness).xyz;
  // vec3 specular = vec3(specularIntensity) * pow(clamp(dot(worldNormal, H), 0., 1.), specularSharpness) * 1.5;

  // float shade = (dot(worldNormal, sunDirection) * 0.5 + 0.5) * 1.2;
  // // float shade = clamp(dot(worldNormal, sunDirection), 0.3, 1.) * 1.7;
  // vec3 shadowColor = vec3(39, 38, 43) / 255.;
  // vec3 color = (float(shadowAmount == 1.) * specular + albedo * baseColor.rgb * shade * 1.5) * mix(shadowColor, vec3(1), shadowAmount);

  // vec3 outputColor = color + reflection * 0.1;
  // fragColor = vec4(outputColor, 1);











  // mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv) {
//     // get edge vectors of the pixel triangle
//     vec3 dp1 = dFdx( p );
//     vec3 dp2 = dFdy( p );
//     vec2 duv1 = dFdx( uv );
//     vec2 duv2 = dFdy( uv );
 
//     // solve the linear system
//     vec3 dp2perp = cross( dp2, N );
//     vec3 dp1perp = cross( N, dp1 );
//     vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
//     vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
//     // construct a scale-invariant frame 
//     float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
//     return mat3( T * invmax, B * invmax, N );
// }

// vec3 perturb_normal( vec3 N, vec3 V, vec2 texcoord, float strength ) {
//   // assume N, the interpolated vertex normal and 
//   // V, the view vector (vertex to eye)
//   vec3 map = sampleTexture(normalTexture, texcoord).xyz;
//   map = map * 255./127. - 128./127.;
//   map = normalStrength(map, strength);

//   mat3 TBN = cotangent_frame(N, V, texcoord);
//   return normalize(TBN * map);
// }