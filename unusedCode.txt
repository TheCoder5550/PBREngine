  // // vec4 baseColor = texture(albedoTexture, vUV);
  // vec4 baseColor = useTexture ? texture(albedoTexture, vUV) : vec4(1);
  // if (baseColor.a < 0.1) {
  //   discard;
  // }

  // vec3 viewDirection = normalize(vec3(inverseViewMatrix * vec4(0, 0, 0, 1)) - vPosition); 
  // vec3 H = normalize(sunDirection + viewDirection);

  // vec3 worldNormal = normalize(mat3(modelMatrix) * vNormal);
  // if (useNormalTexture) {
  //   // vec3 worldTangent = normalize(mat3(modelMatrix) * vTangent);

  //   // float normalMapStrength = 0.3;
  //   // vec3 normalMap = tangentToObject(worldNormal, worldTangent, normalStrength(vec3(texture(normalTexture, vUV)) * 2. - 1., normalMapStrength));
  //   // worldNormal = normalMap;

  //   worldNormal = perturb_normal(worldNormal, viewDirection, vUV);
  // }

  // float shadowAmount = getShadowAmount();

  // float reflectionSharpness = 0.;//10.
  // vec3 reflection = textureLod(u_specularIBL, reflect(-viewDirection, worldNormal), reflectionSharpness).xyz;
  // vec3 specular = vec3(specularIntensity) * pow(clamp(dot(worldNormal, H), 0., 1.), specularSharpness) * 1.5;

  // float shade = (dot(worldNormal, sunDirection) * 0.5 + 0.5) * 1.2;
  // // float shade = clamp(dot(worldNormal, sunDirection), 0.3, 1.) * 1.7;
  // vec3 shadowColor = vec3(39, 38, 43) / 255.;
  // vec3 color = (float(shadowAmount == 1.) * specular + albedo * baseColor.rgb * shade * 1.5) * mix(shadowColor, vec3(1), shadowAmount);

  // vec3 outputColor = color + reflection * 0.1;
  // fragColor = vec4(outputColor, 1);











  // mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv) {
//     // get edge vectors of the pixel triangle
//     vec3 dp1 = dFdx( p );
//     vec3 dp2 = dFdy( p );
//     vec2 duv1 = dFdx( uv );
//     vec2 duv2 = dFdy( uv );
 
//     // solve the linear system
//     vec3 dp2perp = cross( dp2, N );
//     vec3 dp1perp = cross( N, dp1 );
//     vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
//     vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
//     // construct a scale-invariant frame 
//     float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
//     return mat3( T * invmax, B * invmax, N );
// }

// vec3 perturb_normal( vec3 N, vec3 V, vec2 texcoord, float strength ) {
//   // assume N, the interpolated vertex normal and 
//   // V, the view vector (vertex to eye)
//   vec3 map = sampleTexture(normalTexture, texcoord).xyz;
//   map = map * 255./127. - 128./127.;
//   map = normalStrength(map, strength);

//   mat3 TBN = cotangent_frame(N, V, texcoord);
//   return normalize(TBN * map);
// }










// AABB
    for (var j = 0; j < 3; j++) {
      for (var i = 0; i < colliders.length; i++) {
        var aabb = colliders[i];
  
        if (aabb.pointInside(this.position)) {
          var data = aabb.getNormal(this.position);

          if (Vector.dot(data.normal, {x: 0, y: 1, z: 0}) > 0.6) {
            realGroundNormal = {...data.normal};
            data.normal = {x: 0, y: 1, z: 0};
            this.grounded = true;
          }

          this.position = Vector.add(this.position, Vector.multiply(data.normal, data.distance / 2));
          this.velocity = Vector.projectOnPlane(this.velocity, data.normal);
        }
      }
    }

    // Ray - Mesh
    // var hit = Raycast(Vector.add(this.position, {x: 0, y: 1, z: 0}), {x: 0, y: -1, z: 0}).firstHit;
    // if (hit && hit.point && hit.distance < 1.1) {
    //   this.position.y = hit.point.y;
    //   this.velocity.y = 0;
    //   this.grounded = true;
    // }

    // var hit = Raycast(Vector.add(this.position, {x: 0, y: 1.5, z: 0}), {x: 0, y: -1, z: 0}).firstHit;
    // if (hit && hit.point && hit.distance < 0.3) {
    //   this.position.y = hit.point.y - 1.8;
    //   this.velocity.y = 0;
    // }

    // var hw = 0.2;
    // var directions = [{x: -1, y: 0, z: 0}, {x: 1, y: 0, z: 0}, {x: 0, y: 0, z: -1}, {x: 0, y: 0, z: 1}]
    // for (var i = 0; i < 4; i++) {
    //   var hit = Raycast(Vector.add(this.position, {x: 0, y: 1.1, z: 0}), directions[i]).firstHit;
    //   if (hit && hit.point && hit.distance < hw) {
    //     var p = Vector.add(this.position, Vector.add(Vector.multiply(directions[i], hw), {x: 0, y: 1.1, z: 0}));
    //     this.position = Vector.add(this.position, Vector.multiply(hit.normal, Math.abs(Vector.dot(hit.normal, Vector.subtract(hit.point, p)))));
    //     this.velocity = Vector.projectOnPlane(this.velocity, hit.normal);
    //   }
    // }








    function Car() {
  var _this = this;

  var radPerSecToRPM = 30 / Math.PI;

  this.engine = new Engine();
  this.wheels = [];

  this.currentGear = 1;
  this.gearRatios = [2.66, 1.78, 1.3, 1, 0.74];
  this.reverseGearRatio = 2.9;
  this.allGearRatios = [this.reverseGearRatio, ...this.gearRatios];

  this.differentialRatio = 3.42;

  var activateAutoCountersteer = true;
  var autoCountersteerMinVel = 2;
  var autoCountersteer = 0.7;
  var autoCountersteerVelocityMultiplier = 0.3;
  
  this.setup = async function() {
    this.gameObject = scene.add(await renderer.loadGLTF("./assets/models/mustang.glb"));
    this.rb = new Rigidbody();
    this.rb.position = new Vector(4, 4, 0);
    this.rb.mass = 1500;
    this.rb.inertia = Vector.fill(1500);
    this.gameObject.addComponent(this.rb);

    this.wheels[0] = new Wheel(new Vector(1.1, -0.25, 1.7), scene.add(await renderer.loadGLTF("./assets/models/wheel.glb")));
    this.wheels[1] = new Wheel(new Vector(-1.1, -0.25, 1.7), scene.add(await renderer.loadGLTF("./assets/models/wheel.glb")));
    this.wheels[2] = new Wheel(new Vector(1.1, -0.25, -1.85), scene.add(await renderer.loadGLTF("./assets/models/wheel.glb")));
    this.wheels[3] = new Wheel(new Vector(-1.1, -0.25, -1.85), scene.add(await renderer.loadGLTF("./assets/models/wheel.glb")));
  
    this.wheels[0].turn = false;
    this.wheels[1].turn = false;
    this.wheels[2].drive = false;
    this.wheels[3].drive = false;
    this.wheels[2].ebrake = false;
    this.wheels[3].ebrake = false;

    this.wheels[0].modelAngleOffset = Math.PI;
    this.wheels[2].modelAngleOffset = Math.PI;
  }

  this.reset = function() {
    this.rb.position = new Vector(0, 4, 0);
    this.rb.velocity = Vector.zero();
    this.rb.angles = Vector.zero();
    this.rb.angularVelocity = Vector.zero();
  }

  this.update = function(dt) {
    var worldMatrix = this.gameObject.getWorldMatrix();
    var inverseWorldMatrix = Matrix.inverse(worldMatrix);
    var localVelocity = Matrix.transformVector(inverseWorldMatrix, this.rb.velocity);
    var localAngularVelocity = Matrix.transformVector(inverseWorldMatrix, this.rb.angularVelocity);

    var forward = Matrix.getForward(worldMatrix);
    var sideways = Matrix.getRight(worldMatrix);

    var forwardVelocity = Vector.dot(this.rb.velocity, forward);
    var sidewaysVelocity = Vector.dot(this.rb.velocity, sideways);

    var slipAngle = -Math.atan2(sidewaysVelocity, forwardVelocity);
    if (isNaN(slipAngle) || !isFinite(slipAngle)) slipAngle = 0;

    if (gamepadManager.getButtonDown("X")) {
      this.currentGear--;
    }
    if (gamepadManager.getButtonDown("Y")) {
      this.currentGear++;
    }
    this.currentGear = clamp(this.currentGear, 0, this.allGearRatios.length - 1);

    var driveInput = Math.abs(this.engine.rpm) < 8000 ? gamepadManager.getButton("RT") : 0;
    var brakeInput = gamepadManager.getButton("LT");
    var ebrakeInput = gamepadManager.getButton("A");

    var maxSteerAngle = 45;
    var steerInput = -gamepadManager.getAxis("LSHorizontal");
    var acs = activateAutoCountersteer /*&& Vector.length(Vector.projectOnPlane(localVelocity, Vector.up)) >= autoCountersteerMinVel*/ && forwardVelocity > 0.1 ? (-slipAngle) / (maxSteerAngle / 180 * Math.PI) * autoCountersteer : 0;

    steerInput = clamp(steerInput - acs, -1, 1);

    var driveTorque = driveInput * (this.currentGear == 0 ? 1 : -1) * this.engine.torqueLookup(this.engine.rpm) * this.engine.torque / 2 * this.allGearRatios[this.currentGear] * this.differentialRatio;

    for (var wheel of this.wheels) {
      var steerAngle = wheel.turn ? steerInput * maxSteerAngle * Math.PI / 180 : 0;

      var worldMatrix = this.gameObject.getWorldMatrix();
      var up = Matrix.getUp(worldMatrix);
      var forward = Matrix.getForward(worldMatrix);
      var sideways = Matrix.getRight(worldMatrix);

      var worldPos = Matrix.transformVector(worldMatrix, wheel.position);
      var wheelVelocity = this.rb.GetPointVelocity(worldPos);

      var ray = {origin: worldPos, direction: Vector.negate(up)};
      var hit = physicsEngine.Raycast(ray.origin, ray.direction).firstHit;
      var wheelIsGrounded = hit && hit.distance < wheel.suspensionTravel + wheel.radius;

      wheel.model.matrix = Matrix.transform([
        ["translate", Vector.add(ray.origin, Vector.multiply(ray.direction, wheelIsGrounded ? hit.distance - wheel.radius : wheel.suspensionTravel))],
        ["rx", this.gameObject.rotation.x],
        ["rz", this.gameObject.rotation.z],
        ["ry", this.gameObject.rotation.y],
        ["ry", steerAngle + wheel.modelAngleOffset],
        ["rx", wheel.angle * (wheel.modelAngleOffset == Math.PI ? -1 : 1)]
      ]);

      if (wheelIsGrounded) {
        var rayDist = hit.distance;
        var contactPoint = hit.point;

        var normalForce = 0;
        var compressionAmount = 0;

        // Suspension
        var springError = wheel.suspensionTravel - (rayDist - wheel.radius);
        var currentSpringForce = Vector.multiply(ray.direction, springError * -wheel.suspensionForce);
        var currentDampingForce = Vector.multiply(Vector.project(Vector.subtract(wheelVelocity, Vector.projectOnPlane(this.rb.velocity, hit.normal)), up), -wheel.suspensionDamping);
        var totalForce = Vector.add(currentSpringForce, currentDampingForce);
        this.rb.AddForceAtPosition(totalForce, worldPos);

        wheel.normalForce = normalForce = Vector.length(totalForce);
        compressionAmount = clamp(springError / wheel.suspensionTravel, 0, 1);

        // Bottom out
        var furthestPoint = Vector.add(ray.origin, Vector.multiply(ray.direction, wheel.radius + wheel.stopLength));
        var C = -Vector.dot(Vector.subtract(contactPoint, furthestPoint), hit.normal);

        if (C < 0) {
          var r = Vector.cross(Vector.subtract(furthestPoint, this.rb.position), hit.normal);

          var jacobian = [
            hit.normal.x,
            hit.normal.y,
            hit.normal.z,
            r.x,
            r.y,
            r.z
          ];

          var JM = [
            jacobian[0] / this.rb.mass,
            jacobian[1] / this.rb.mass,
            jacobian[2] / this.rb.mass,
            jacobian[3] / this.rb.inertia.x,
            jacobian[4] / this.rb.inertia.y,
            jacobian[5] / this.rb.inertia.z
          ];

          var beta = 0.15;
          var bias = beta / dt * (C + 0.01);
          var JMJ = multiply1DMatrices(JM, jacobian);

          var lambdaAccumulated = 0;

          for (var i = 0; i < 5; i++) {
            var velocityMatrix = [
              this.rb.velocity.x,
              this.rb.velocity.y,
              this.rb.velocity.z,
              this.rb.angularVelocity.x,
              this.rb.angularVelocity.y,
              this.rb.angularVelocity.z
            ];

            var JV = multiply1DMatrices(jacobian, velocityMatrix);
            var lambda = -(JV + bias) / JMJ;

            if (lambdaAccumulated + lambda < 0) {
              lambda = -lambdaAccumulated;
            }
            lambdaAccumulated += lambda;

            this.rb.velocity = Vector.add(this.rb.velocity, Vector.multiply(new Vector(jacobian[0], jacobian[1], jacobian[2]), lambda / this.rb.mass));
            this.rb.angularVelocity = Vector.add(this.rb.angularVelocity, divideVectorAndVector(Vector.multiply(new Vector(jacobian[3], jacobian[4], jacobian[5]), lambda), this.rb.inertia));
          }
        }

        // Friction

        var torqueInput = wheel.drive ? driveTorque : 0;

        var iters = 5;
        var _dt = dt / iters;
        for (var count = 0; count < iters; count++) {
          wheelVelocity = this.rb.GetPointVelocity(worldPos);

          var forwardVelocity = Vector.dot(wheelVelocity, forward);
          var sidewaysVelocity = Vector.dot(wheelVelocity, sideways);

          var roadFriction = 1;

          wheel.angularVelocity += torqueInput / wheel.inertia * _dt;

          var slipAngle = -Math.atan(sidewaysVelocity / Math.abs(forwardVelocity)) - steerAngle * Math.sign(forwardVelocity);
          if (isNaN(slipAngle) || !isFinite(slipAngle)) slipAngle = 0;
          var a = slipAngle / wheel.slipAnglePeak;

          if (brakeInput != 0) {
            wheel.angularVelocity = -forwardVelocity / wheel.radius * (1 - brakeInput);
          }

          if (ebrakeInput != 0 && wheel.ebrake) {
            wheel.angularVelocity = -forwardVelocity / wheel.radius * (1 - ebrakeInput);
          }

          var driveForwardVector = forward;//Quaternion.AngleAxis(-90, sideways) * groundHit.normal;

          var slipRatio = -(wheel.angularVelocity * wheel.radius + forwardVelocity) / Math.abs(forwardVelocity) * Math.min(Math.abs(forwardVelocity) / 3, 1);
          if (isNaN(slipRatio)) slipRatio = 0;
          if (!isFinite(slipRatio)) slipRatio = Math.sign(slipRatio);
          var s = slipRatio / wheel.slipRatioPeak;

          var rho = Math.sqrt(s * s + a * a);

          var Fx = (_slipRatio) => {
            return magicFormula(_slipRatio, wheel.slipRatioCoeffs) * roadFriction * wheel.friction;
          }
          var Fy = ( _slipAngle) => {
            return magicFormula(_slipAngle * 180 / Math.PI - wheel.camberAngle * wheel.camberAngleCoeff, wheel.slipAngleCoeffs) * roadFriction * wheel.friction;
          }

          var finalForceX = s / rho * Fx(rho * wheel.slipRatioPeak) * normalForce;
          var finalForceY = a / rho * Fy(rho * wheel.slipAnglePeak) * normalForce;

          // if (!count) console.log(slipRatio);

          if (!isNaN(finalForceX)) {
            var contactVelocity = (wheel.angularVelocity * wheel.radius + forwardVelocity);
            var maxForceToResolveFriction = Math.abs(contactVelocity / (wheel.radius * wheel.radius) * wheel.inertia / _dt);
            var maxFriction = Math.abs(finalForceX);
            var frictionForce = Math.min(maxFriction, maxForceToResolveFriction) * -Math.sign(finalForceX);
            wheel.angularVelocity -= (frictionForce * wheel.radius) / wheel.inertia * _dt;
          }
          
          if (!isNaN(finalForceX)) this.rb.AddImpulseAtPosition(Vector.multiply(driveForwardVector, finalForceX * _dt), contactPoint);
          if (!isNaN(finalForceY)) this.rb.AddImpulseAtPosition(Vector.multiply(sideways, finalForceY * _dt), contactPoint);
        }
      }

      wheel.angle += wheel.angularVelocity * dt;
    }

    updateEngineRPM();
  }

  function updateEngineRPM() {
    var angularVelocities = 0;
    for (var wheel of _this.wheels) {
      if (wheel.drive) {
        angularVelocities += Math.abs(wheel.angularVelocity);
      }
    }

    var driveWheels = 2;
    _this.engine.rpm = angularVelocities / driveWheels * _this.allGearRatios[_this.currentGear] * _this.differentialRatio * radPerSecToRPM;
    // _this.engine.rpm = clamp(_this.engine.rpm, _this.engine.minRPM, _this.engine.maxRPM);
  }

  function Engine() {
    this.torque = 700;
    this.rpm = 0;
    this.minRPM = 0;
    this.maxRPM = 8000;

    this.torqueLookup = function(rpm) {
      return (-Math.pow(Math.abs((rpm - 4600) / 145), 1.4) + 309) / 309;
    }
  }

  function Wheel(position = Vector.zero(), model) {
    this.position = position;
    this.model = model;
    this.modelAngleOffset = 0;

    this.friction = 1;
    this.radius = 0.47;
    this.camberAngle = 0;
    this.camberAngleCoeff = 1;

    this.stopLength = 0.05;
    this.suspensionTravel = 0.35;
    this.suspensionDamping = 3500;
    this.suspensionForce = 50000;

    this.angle = 0;
    this.angularVelocity = 0;
    this.mass = 20;
    this.inertia = this.mass * this.radius * this.radius / 2;

    this.slipRatioCoeffs = [16, 1.5, 1.1, -1.4];
    this.slipAngleCoeffs = [0.1, 1.5, 1.1, -1.4];

    this.slipRatioPeak = findPeak(x => {
      return magicFormula(x, this.slipRatioCoeffs);
    });

    this.slipAnglePeak = findPeak(x => {
      return magicFormula(x * 180 / Math.PI - this.camberAngle * this.camberAngleCoeff, this.slipAngleCoeffs);
    });

    this.drive = true;
    this.turn = true;
    this.ebrake = true;

    this.wheelIsGrounded = false;
    this.normalForce = 0;
  }

  function divideVectorAndVector(a, b) {
    return new Vector(a.x / b.x, a.y / b.y, a.z / b.z);
  }

  function multiply1DMatrices(m1, m2) {
    if (m1.length != m2.length) {
      throw new Error("Matrices have to be the same length!");
    }

    var sum = 0;
    for (var i = 0; i < m1.length; i++) {
      sum += m1[i] * m2[i];
    }

    return sum;
  }

  function magicFormula(x, coeffs) {
    var b = coeffs[0];
    var c = coeffs[1];
    var d = coeffs[2];
    var e = coeffs[3];
    return d * Math.sin(c * Math.atan(b * x - e * (b * x - Math.atan(b * x))));
  }

  function findPeak(f, maxX = 10, stepsize = 0.001) {
    for (var x = 0; x < maxX; x += stepsize) {
      var fx = f(x);
      if (fx > f(x - stepsize) && fx > f(x + stepsize)) {
        return x;
      }
    }

    throw new Error("No peak found!");
  }
}
































// const terrain = new Terrain(scene, {
  //   terrainSize: 10_000,
  //   colliderDepthThreshold: 6,
  //   // enableCollision: false,
  // });
  // terrain.chunkRes = 25;

  // terrain.getHeight = function(i, j) {
  //   return 0;

  //   var power = 2.5;
  //   var noiseLayers = 2;
  //   var noiseScale = 0.001;
  //   const amplitude = 20;

  //   var heightFalloff = 1;//1 - clamp((Vector.length(new Vector(i, j)) - 400) * 0.005, 0, 1);
  //   var elevation = Math.pow(Math.abs(LayeredNoise(i * noiseScale, j * noiseScale, noiseLayers)), power) * amplitude * heightFalloff;

  //   // elevation *= smoothstep(Math.abs(i), 10, 50);

  //   return elevation;
  // };

  // var litTerrain = new renderer.ProgramContainer(await renderer.createProgramFromFile(renderer.path + "assets/shaders/custom/webgl2/litTerrain"));

  // // var grassAlbedo = await renderer.loadTextureAsync(renderer.path + "assets/textures/aerial_rocks_02_1k/textures/aerial_rocks_02_diff_1k.jpg", { ...renderer.getSRGBFormats() });
  // // var grassNormal = await renderer.loadTextureAsync(renderer.path + "assets/textures/aerial_rocks_02_1k/textures/aerial_rocks_02_nor_gl_1k.png");
  // // var grassAlbedo = await renderer.loadTextureAsync(renderer.path + "assets/textures/Grass_001_SD/Grass_001_COLOR.jpg", { ...SRGBFormat });
  // // var grassNormal = await renderer.loadTextureAsync(renderer.path + "assets/textures/Grass_001_SD/Grass_001_NORM.jpg");
  // // var grassAlbedo = await renderer.loadTextureAsync(renderer.path + "assets/textures/brown_mud_leaves_01_2k_jpg/brown_mud_leaves_01_diff_2k.jpg", { ...SRGBFormat });
  // // var grassNormal = await renderer.loadTextureAsync(renderer.path + "assets/textures/brown_mud_leaves_01_2k_jpg/brown_mud_leaves_01_Nor_2k.jpg");

  // // var stoneAlbedo = await renderer.loadTextureAsync(renderer.path + "assets/textures/rocks_ground_06/diffuse.jpg", { ...SRGBFormat });
  // // var stoneNormal = await renderer.loadTextureAsync(renderer.path + "assets/textures/rocks_ground_06/normal.png");

  // let [
  //   grassAlbedoImage,
  //   grassNormalImage,
  //   stoneAlbedoImage,
  //   stoneNormalImage,
  //   snowAlbedoImage,
  //   snowNormalImage
  // ] = await Promise.all([
  //   loadImage(renderer.path + "assets/textures/GroundForest003/GroundForest003_COL_VAR1_3K.jpg"),
  //   loadImage(renderer.path + "assets/textures/GroundForest003/GroundForest003_NRM_3K.jpg"),
  //   loadImage(renderer.path + "assets/textures/aerial_rocks_02_1k/textures/aerial_rocks_02_diff_1k.jpg"),
  //   loadImage(renderer.path + "assets/textures/aerial_rocks_02_1k/textures/aerial_rocks_02_nor_gl_1k.png"),
  //   loadImage(renderer.path + "assets/textures/Snow/albedo.jpg"),
  //   loadImage(renderer.path + "assets/textures/Snow/normal.jpg")
  // ]);
  
  // let SRGBFormat = renderer.getSRGBFormats();

  // let grassAlbedo = renderer.loadTexture(grassAlbedoImage, { ...SRGBFormat });
  // let grassNormal = renderer.loadTexture(grassNormalImage);
  // let stoneAlbedo = renderer.loadTexture(stoneAlbedoImage, { ...SRGBFormat });
  // let stoneNormal = renderer.loadTexture(stoneNormalImage);
  // let snowAlbedo = renderer.loadTexture(snowAlbedoImage, { ...SRGBFormat });
  // let snowNormal = renderer.loadTexture(snowNormalImage);

  // let terrainMat = renderer.CreateLitMaterial({}, litTerrain);
  // terrainMat.setUniform("roughness", 1);
  // terrainMat.setUniform("albedoTextures[0]", [ grassAlbedo, stoneAlbedo, snowAlbedo ]);
  // terrainMat.setUniform("normalTextures[0]", [ grassNormal, stoneNormal, snowNormal ]);

  // await terrain.loadMaterials(terrainMat);

  // const { roadMaterial, asphaltMaterial } = await createRoadMaterials();

  // const house = scene.add(await renderer.loadGLTF("./house.glb"));
  // house.children[0].meshRenderer = house.children[0].meshRenderer.getInstanceMeshRenderer();

  // const cityData = [
  //   1, 1, 1, 1, 1, 1, 1, 1,
  //   1, 2, 1, 0, 2, 0, 2, 1,
  //   1, 2, 1, 0, 0, 0, 0, 1,
  //   1, 1, 1, 1, 1, 1, 0, 1,
  //   1, 0, 1, 0, 2, 1, 2, 1,
  //   1, 0, 1, 0, 0, 1, 1, 1,
  //   1, 0, 1, 0, 2, 0, 0, 1,
  //   1, 1, 1, 1, 1, 1, 1, 1,
  // ];
  // const city = new City(scene, house.children[0].meshRenderer);
  // city.generate(cityData, 8, 8, { material: roadMaterial, asphaltMaterial });

  // const getTreeDensity = (position) => {
  //   let i = Math.floor(position.x / 25 + 0.5);
  //   let j = Math.floor(position.z / 25 + 0.5);

  //   if (i < 0 || j < 0 || i >= 8 || j >= 8) {
  //     return 1;
  //   }

  //   if (cityData[i * 8 + j] !== 0) {
  //     return 0;
  //   }

  //   return 0.1;
  // };

  // // let track = await generateTrack({
  // //   material: roadMaterial
  // // });

  // // let grass = await renderer.loadGLTF("grass1.glb");
  // // grass.castShadows = false;
  // // // grass.children[0].meshRenderer.materials[0].setUniform("albedo", [15, 15, 15, 1]);
  // // grass.children[0].meshRenderer.materials[0].setUniform("albedo", [6, 8, 6, 1]);
  // // let grassScatter = terrain.addScatter(grass);
  // // grass.children[0].meshRenderer.materials[0].programContainer = renderer.programContainers.unlitInstanced;
  // // grassScatter.spawnProbability = (origin) => {
  // //   if (Vector.lengthSqr(new Vector(origin.x, 0, origin.z)) <= 162 ** 2 && track.curve.distanceSqrToPoint(origin).distance < (track.width / 2) ** 2) {
  // //     return 0;
  // //   }

  // //   let p = 1 - smoothstep(origin.y, 80, 100);
  // //   return p;
  // // };
  // let tree = await renderer.loadGLTF("../assets/models/trees/wideTreeBillboard.glb");
  // tree.children[0].meshRenderer.materials[0].setUniform("alphaCutoff", 0.5);
  // let treeScatter = terrain.addScatter(tree, 2, 100, 10 * 10 * 5);
  // tree.children[0].meshRenderer.materials[0].programContainer = renderer.programContainers.unlitInstanced;
  // treeScatter.minScale = 1 * 3;
  // treeScatter.maxScale = 1.8 * 3;
  // treeScatter.cross = true;
  // treeScatter.spawnProbability = getTreeDensity;

  // // // let tree = await renderer.loadGLTF("../assets/models/trees/stylizedAutumnBillboard.glb");
  // // // let tree = await renderer.loadGLTF("../assets/models/treePbrBillboard.glb");
  // // let tree = await renderer.loadGLTF("../assets/models/trees/wideTreeBillboard.glb");
  // // tree.children[0].meshRenderer.materials[0].setUniform("alphaCutoff", 0.5);
  // // // tree.children[0].meshRenderer.materials[0].programContainer = simpleFoliageProgram;
  // // let treeScatter = terrain.addScatter(tree, 4, 100, 10 * 10 * 50);
  // // tree.children[0].meshRenderer.materials[0].programContainer = renderer.programContainers.unlitInstanced;
  // // treeScatter.minScale = 1 * 4;
  // // treeScatter.maxScale = 1.8 * 4;
  // // treeScatter.cross = true;
  // // treeScatter.spawnProbability = (origin) => {
  // //   if (Vector.lengthSqr(new Vector(origin.x, 0, origin.z)) <= 162 ** 2 && track.curve.distanceSqrToPoint(origin).distance < (track.width / 2) ** 2) {
  // //     return 0;
  // //   }

  // //   let p = 1 - clamp(mapValue(origin.y, 10, 50, 1, 0), 0, 0.95);
  // //   p *= 1 - smoothstep(origin.y, 60, 100);
  // //   return p;
  // // };

  // // let pebbles = await renderer.loadGLTF("../assets/models/rock.glb");
  // // pebbles.castShadows = false;
  // // let pebblesScatter = terrain.addScatter(pebbles, 2, 20);
  // // pebblesScatter.minScale = 0.1;
  // // pebblesScatter.maxScale = 0.15;
  // // pebbles.children[0].meshRenderer.materials[0].doubleSided = false;
  // // // pebbles.children[0].meshRenderer.materials[0].programContainer = renderer.programContainers.unlitInstanced;
  // // pebblesScatter.spawnProbability = (origin) => {
  // //   if (Vector.lengthSqr(new Vector(origin.x, 0, origin.z)) <= 162 ** 2 && track.curve.distanceSqrToPoint(origin).distance < (track.width / 2) ** 2) {
  // //     return 0;
  // //   }

  // //   return smoothstep(origin.y, 10, 20);
  // // };

  // // let rocks = await renderer.loadGLTF("../assets/models/rock.glb");
  // // let rocksScatter = terrain.addScatter(rocks, 2, 220, 10);
  // // rocksScatter.minScale = 2;
  // // rocksScatter.maxScale = 6;
  // // rocks.children[0].meshRenderer.materials[0].doubleSided = false;
  // // rocksScatter.spawnProbability = (origin) => {
  // //   if (Vector.lengthSqr(new Vector(origin.x, 0, origin.z)) <= 162 ** 2 && track.curve.distanceSqrToPoint(origin).distance < (track.width / 2) ** 2) {
  // //     return 0;
  // //   }

  // //   return 1;
  // // };
  // // // rocks.children[0].meshRenderer.materials[0].programContainer = renderer.programContainers.unlitInstanced;

  // // Spawn in everything all at once
  // terrain.chunkUpdatesPerFrame = 1e6;
  // terrain.update();
  // await sleep(5000);
  // terrain.chunkUpdatesPerFrame = 1;

  // // let m = scene.add(renderer.CreateShape("sphere")).meshRenderer.materials[0];
  // // m.setUniform("roughness", 0);
  // // m.setUniform("metallic", 1);

  // // await createChunks();

  // // await loadMap();

  // // Set spawn point
  // new Vector(0, 0.8, 50, spawnPosition);
  // Quaternion.euler(0, Math.PI / 2, 0, spawnRotation);

  // var controlPoints = JSON.parse('[{"x":238.9905803198908,"y":11.010891524613218,"z":0},{"x":248.35707929750777,"y":12.723226116925797,"z":180.44198024083917},{"x":86.43430472565373,"y":2.3016814664524694,"z":266.0174367013337},{"x":-68.42980023211553,"y":0.19100462446428695,"z":210.60526962657337},{"x":-291.0143147923255,"y":11.280076252913517,"z":211.43427595496414},{"x":-367.37847338756524,"y":44.89847560608845,"z":4.4990887150972286e-14},{"x":-244.37662920532279,"y":21.023621965313925,"z":-177.55001396826387},{"x":-88.49153796618087,"y":6.502505256081859,"z":-272.34894957783365},{"x":75.79755225098485,"y":0.26559658178005546,"z":-233.28087872103728},{"x":209.2681935881474,"y":11.838977337235947,"z":-152.04224240064795}]');
  // var crCurve = new CatmullRomCurve(controlPoints, 0.5);
  // initRoad(crCurve);

  // // Grass
  // setProgress(10, totalTasks, "Planting trees");
  // await loadGrass();

  // // Cubemap
  // setProgress(currentTask++, totalTasks, "Generating cubemap");
  // const cubemap = renderer.captureReflectionCubemap(new Vector(0, 2.5, 0));
  // const oldSkybox = scene.skyboxCubemap;
  // setProgress(currentTask++, totalTasks, "Loading cubemap");
  // await scene.loadEnvironment({ cubemap });
  // scene.skyboxCubemap = oldSkybox;
  // scene.environmentIntensity = 1;